
Show_03_MP3_Player.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000144c8  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00003478  08014650  08014650  00024650  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000124  20000000  08017ac8  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .co_stack     00002000  20000124  08017bec  00030124  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .ccmram       00000000  10000000  10000000  00032124  2**0
                  CONTENTS
  6 .bss          0000ebfc  20002124  20002124  00032124  2**2
                  ALLOC
  7 ._user_heap_stack 00000400  20010d20  20010d20  00032124  2**0
                  ALLOC
  8 .ARM.attributes 00000037  00000000  00000000  00032124  2**0
                  CONTENTS, READONLY
  9 .debug_info   000444fa  00000000  00000000  0003215b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00007870  00000000  00000000  00076655  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000628  00000000  00000000  0007dec5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000fc53  00000000  00000000  0007e4ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00007164  00000000  00000000  0008e140  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .comment      0000007c  00000000  00000000  000952a4  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00003368  00000000  00000000  00095320  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0002fbca  00000000  00000000  00098688  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000055a8  00000000  00000000  000c8252  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <ADC_IRQHandler>:
  *         preserving the system state for examination by a debugger.
  * @param  None
  * @retval None
  */
static void Default_Handler(void)
{
 8000188:	e7fe      	b.n	8000188 <ADC_IRQHandler>
 800018a:	bf00      	nop

0800018c <Default_Reset_Handler>:
{
 800018c:	b508      	push	{r3, lr}
  for(pulDest = &_sdata; pulDest < &_edata; )
 800018e:	480c      	ldr	r0, [pc, #48]	; (80001c0 <zero_loop+0x12>)
 8000190:	4b0c      	ldr	r3, [pc, #48]	; (80001c4 <zero_loop+0x16>)
 8000192:	4298      	cmp	r0, r3
 8000194:	d207      	bcs.n	80001a6 <Default_Reset_Handler+0x1a>
    *(pulDest++) = *(pulSrc++);
 8000196:	43c2      	mvns	r2, r0
 8000198:	441a      	add	r2, r3
 800019a:	f022 0203 	bic.w	r2, r2, #3
 800019e:	3204      	adds	r2, #4
 80001a0:	4909      	ldr	r1, [pc, #36]	; (80001c8 <zero_loop+0x1a>)
 80001a2:	f014 fa07 	bl	80145b4 <memcpy>
  __asm("  ldr     r0, =_sbss\n"
 80001a6:	4809      	ldr	r0, [pc, #36]	; (80001cc <zero_loop+0x1e>)
 80001a8:	4909      	ldr	r1, [pc, #36]	; (80001d0 <zero_loop+0x22>)
 80001aa:	f04f 0200 	mov.w	r2, #0

080001ae <zero_loop>:
 80001ae:	4288      	cmp	r0, r1
 80001b0:	bfb8      	it	lt
 80001b2:	f840 2b04 	strlt.w	r2, [r0], #4
 80001b6:	dbfa      	blt.n	80001ae <zero_loop>
}
 80001b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  main();
 80001bc:	f014 b9d8 	b.w	8014570 <main>
 80001c0:	20000000 	.word	0x20000000
 80001c4:	20000124 	.word	0x20000124
 80001c8:	08017ac8 	.word	0x08017ac8
 80001cc:	20002124 	.word	0x20002124
 80001d0:	20010d20 	.word	0x20010d20

080001d4 <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80001d4:	4b35      	ldr	r3, [pc, #212]	; (80002ac <SystemInit+0xd8>)

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80001d6:	4836      	ldr	r0, [pc, #216]	; (80002b0 <SystemInit+0xdc>)
  RCC->CR |= (uint32_t)0x00000001;
 80001d8:	681a      	ldr	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 80001da:	2100      	movs	r1, #0
  RCC->CR |= (uint32_t)0x00000001;
 80001dc:	f042 0201 	orr.w	r2, r2, #1
 80001e0:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 80001e2:	6099      	str	r1, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80001e4:	681a      	ldr	r2, [r3, #0]
 80001e6:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80001ea:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80001ee:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 80001f0:	6058      	str	r0, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80001f2:	681a      	ldr	r2, [r3, #0]
{
 80001f4:	b082      	sub	sp, #8
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80001f6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80001fa:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80001fc:	60d9      	str	r1, [r3, #12]
static void SetSysClock(void)
{
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80001fe:	9100      	str	r1, [sp, #0]
 8000200:	9101      	str	r1, [sp, #4]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000202:	681a      	ldr	r2, [r3, #0]
 8000204:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000208:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800020a:	461a      	mov	r2, r3
 800020c:	e003      	b.n	8000216 <SystemInit+0x42>
    StartUpCounter++;
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 800020e:	9b00      	ldr	r3, [sp, #0]
 8000210:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8000214:	d009      	beq.n	800022a <SystemInit+0x56>
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000216:	6813      	ldr	r3, [r2, #0]
 8000218:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800021c:	9301      	str	r3, [sp, #4]
    StartUpCounter++;
 800021e:	9b00      	ldr	r3, [sp, #0]
 8000220:	3301      	adds	r3, #1
 8000222:	9300      	str	r3, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000224:	9b01      	ldr	r3, [sp, #4]
 8000226:	2b00      	cmp	r3, #0
 8000228:	d0f1      	beq.n	800020e <SystemInit+0x3a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 800022a:	4b20      	ldr	r3, [pc, #128]	; (80002ac <SystemInit+0xd8>)
 800022c:	681b      	ldr	r3, [r3, #0]
 800022e:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8000232:	bf18      	it	ne
 8000234:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8000236:	9301      	str	r3, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 8000238:	9b01      	ldr	r3, [sp, #4]
 800023a:	2b01      	cmp	r3, #1
 800023c:	d005      	beq.n	800024a <SystemInit+0x76>
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800023e:	4b1d      	ldr	r3, [pc, #116]	; (80002b4 <SystemInit+0xe0>)
 8000240:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000244:	609a      	str	r2, [r3, #8]
}
 8000246:	b002      	add	sp, #8
 8000248:	4770      	bx	lr
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 800024a:	4b18      	ldr	r3, [pc, #96]	; (80002ac <SystemInit+0xd8>)
    PWR->CR |= PWR_CR_PMODE;  
 800024c:	491a      	ldr	r1, [pc, #104]	; (80002b8 <SystemInit+0xe4>)
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 800024e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000250:	481a      	ldr	r0, [pc, #104]	; (80002bc <SystemInit+0xe8>)
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8000252:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000256:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 8000258:	680a      	ldr	r2, [r1, #0]
 800025a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800025e:	600a      	str	r2, [r1, #0]
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8000260:	689a      	ldr	r2, [r3, #8]
 8000262:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000264:	689a      	ldr	r2, [r3, #8]
 8000266:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800026a:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 800026c:	689a      	ldr	r2, [r3, #8]
 800026e:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8000272:	609a      	str	r2, [r3, #8]
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000274:	6058      	str	r0, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000276:	681a      	ldr	r2, [r3, #0]
 8000278:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800027c:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800027e:	681a      	ldr	r2, [r3, #0]
 8000280:	0192      	lsls	r2, r2, #6
 8000282:	d5fc      	bpl.n	800027e <SystemInit+0xaa>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000284:	490e      	ldr	r1, [pc, #56]	; (80002c0 <SystemInit+0xec>)
    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    RCC->CFGR |= RCC_CFGR_SW_PLL;

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8000286:	4a09      	ldr	r2, [pc, #36]	; (80002ac <SystemInit+0xd8>)
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8000288:	f240 6005 	movw	r0, #1541	; 0x605
 800028c:	6008      	str	r0, [r1, #0]
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800028e:	6899      	ldr	r1, [r3, #8]
 8000290:	f021 0103 	bic.w	r1, r1, #3
 8000294:	6099      	str	r1, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 8000296:	6899      	ldr	r1, [r3, #8]
 8000298:	f041 0102 	orr.w	r1, r1, #2
 800029c:	6099      	str	r1, [r3, #8]
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 800029e:	6893      	ldr	r3, [r2, #8]
 80002a0:	f003 030c 	and.w	r3, r3, #12
 80002a4:	2b08      	cmp	r3, #8
 80002a6:	d1fa      	bne.n	800029e <SystemInit+0xca>
 80002a8:	e7c9      	b.n	800023e <SystemInit+0x6a>
 80002aa:	bf00      	nop
 80002ac:	40023800 	.word	0x40023800
 80002b0:	24003010 	.word	0x24003010
 80002b4:	e000ed00 	.word	0xe000ed00
 80002b8:	40007000 	.word	0x40007000
 80002bc:	07405408 	.word	0x07405408
 80002c0:	40023c00 	.word	0x40023c00

080002c4 <SystemCoreClockUpdate>:
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80002c4:	4a15      	ldr	r2, [pc, #84]	; (800031c <SystemCoreClockUpdate+0x58>)
 80002c6:	6893      	ldr	r3, [r2, #8]
 80002c8:	f003 030c 	and.w	r3, r3, #12
  switch (tmp)
 80002cc:	2b04      	cmp	r3, #4
 80002ce:	d023      	beq.n	8000318 <SystemCoreClockUpdate+0x54>
 80002d0:	2b08      	cmp	r3, #8
 80002d2:	d009      	beq.n	80002e8 <SystemCoreClockUpdate+0x24>
 80002d4:	4b12      	ldr	r3, [pc, #72]	; (8000320 <SystemCoreClockUpdate+0x5c>)
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002d6:	4a11      	ldr	r2, [pc, #68]	; (800031c <SystemCoreClockUpdate+0x58>)
 80002d8:	4912      	ldr	r1, [pc, #72]	; (8000324 <SystemCoreClockUpdate+0x60>)
 80002da:	6892      	ldr	r2, [r2, #8]
 80002dc:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80002e0:	5c8a      	ldrb	r2, [r1, r2]
  SystemCoreClock >>= tmp;
 80002e2:	40d3      	lsrs	r3, r2
 80002e4:	610b      	str	r3, [r1, #16]
 80002e6:	4770      	bx	lr
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 80002e8:	6850      	ldr	r0, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80002ea:	6851      	ldr	r1, [r2, #4]
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 80002ec:	6852      	ldr	r2, [r2, #4]
      if (pllsource != 0)
 80002ee:	0243      	lsls	r3, r0, #9
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80002f0:	f3c2 1288 	ubfx	r2, r2, #6, #9
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80002f4:	f001 013f 	and.w	r1, r1, #63	; 0x3f
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 80002f8:	bf4c      	ite	mi
 80002fa:	4b0b      	ldrmi	r3, [pc, #44]	; (8000328 <SystemCoreClockUpdate+0x64>)
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80002fc:	4b08      	ldrpl	r3, [pc, #32]	; (8000320 <SystemCoreClockUpdate+0x5c>)
 80002fe:	fbb3 f3f1 	udiv	r3, r3, r1
 8000302:	fb03 f302 	mul.w	r3, r3, r2
      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000306:	4a05      	ldr	r2, [pc, #20]	; (800031c <SystemCoreClockUpdate+0x58>)
 8000308:	6852      	ldr	r2, [r2, #4]
 800030a:	f3c2 4201 	ubfx	r2, r2, #16, #2
 800030e:	3201      	adds	r2, #1
 8000310:	0052      	lsls	r2, r2, #1
      SystemCoreClock = pllvco/pllp;
 8000312:	fbb3 f3f2 	udiv	r3, r3, r2
      break;
 8000316:	e7de      	b.n	80002d6 <SystemCoreClockUpdate+0x12>
  switch (tmp)
 8000318:	4b03      	ldr	r3, [pc, #12]	; (8000328 <SystemCoreClockUpdate+0x64>)
 800031a:	e7dc      	b.n	80002d6 <SystemCoreClockUpdate+0x12>
 800031c:	40023800 	.word	0x40023800
 8000320:	00f42400 	.word	0x00f42400
 8000324:	20000000 	.word	0x20000000
 8000328:	007a1200 	.word	0x007a1200

0800032c <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 800032c:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000330:	4b02      	ldr	r3, [pc, #8]	; (800033c <NVIC_PriorityGroupConfig+0x10>)
 8000332:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8000336:	60d8      	str	r0, [r3, #12]
 8000338:	4770      	bx	lr
 800033a:	bf00      	nop
 800033c:	e000ed00 	.word	0xe000ed00

08000340 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8000340:	78c3      	ldrb	r3, [r0, #3]
 8000342:	b95b      	cbnz	r3, 800035c <NVIC_Init+0x1c>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000344:	7803      	ldrb	r3, [r0, #0]
 8000346:	4816      	ldr	r0, [pc, #88]	; (80003a0 <NVIC_Init+0x60>)
 8000348:	095a      	lsrs	r2, r3, #5
 800034a:	3220      	adds	r2, #32
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800034c:	f003 031f 	and.w	r3, r3, #31
 8000350:	2101      	movs	r1, #1
 8000352:	fa01 f303 	lsl.w	r3, r1, r3
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000356:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
  }
}
 800035a:	4770      	bx	lr
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 800035c:	4a11      	ldr	r2, [pc, #68]	; (80003a4 <NVIC_Init+0x64>)
{
 800035e:	b470      	push	{r4, r5, r6}
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8000360:	68d2      	ldr	r2, [r2, #12]
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000362:	7843      	ldrb	r3, [r0, #1]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8000364:	7886      	ldrb	r6, [r0, #2]
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000366:	7801      	ldrb	r1, [r0, #0]
 8000368:	480d      	ldr	r0, [pc, #52]	; (80003a0 <NVIC_Init+0x60>)
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 800036a:	43d2      	mvns	r2, r2
 800036c:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 8000370:	f1c2 0504 	rsb	r5, r2, #4
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000374:	b2ed      	uxtb	r5, r5
    tmpsub = tmpsub >> tmppriority;
 8000376:	240f      	movs	r4, #15
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000378:	40ab      	lsls	r3, r5
    tmpsub = tmpsub >> tmppriority;
 800037a:	fa44 f202 	asr.w	r2, r4, r2
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 800037e:	4032      	ands	r2, r6
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000380:	b2db      	uxtb	r3, r3
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8000382:	4313      	orrs	r3, r2
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000384:	1844      	adds	r4, r0, r1
    tmppriority = tmppriority << 0x04;
 8000386:	011b      	lsls	r3, r3, #4
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000388:	f001 051f 	and.w	r5, r1, #31
 800038c:	2201      	movs	r2, #1
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800038e:	0949      	lsrs	r1, r1, #5
    tmppriority = tmppriority << 0x04;
 8000390:	b2db      	uxtb	r3, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000392:	40aa      	lsls	r2, r5
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000394:	f884 3300 	strb.w	r3, [r4, #768]	; 0x300
}
 8000398:	bc70      	pop	{r4, r5, r6}
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800039a:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
}
 800039e:	4770      	bx	lr
 80003a0:	e000e100 	.word	0xe000e100
 80003a4:	e000ed00 	.word	0xe000ed00

080003a8 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80003a8:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 80003ac:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 80003b0:	4b01      	ldr	r3, [pc, #4]	; (80003b8 <NVIC_SetVectorTable+0x10>)
 80003b2:	4301      	orrs	r1, r0
 80003b4:	6099      	str	r1, [r3, #8]
 80003b6:	4770      	bx	lr
 80003b8:	e000ed00 	.word	0xe000ed00

080003bc <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 80003bc:	b929      	cbnz	r1, 80003ca <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 80003be:	4a05      	ldr	r2, [pc, #20]	; (80003d4 <NVIC_SystemLPConfig+0x18>)
 80003c0:	6913      	ldr	r3, [r2, #16]
 80003c2:	ea23 0000 	bic.w	r0, r3, r0
 80003c6:	6110      	str	r0, [r2, #16]
 80003c8:	4770      	bx	lr
    SCB->SCR |= LowPowerMode;
 80003ca:	4b02      	ldr	r3, [pc, #8]	; (80003d4 <NVIC_SystemLPConfig+0x18>)
 80003cc:	691a      	ldr	r2, [r3, #16]
 80003ce:	4310      	orrs	r0, r2
 80003d0:	6118      	str	r0, [r3, #16]
 80003d2:	4770      	bx	lr
 80003d4:	e000ed00 	.word	0xe000ed00

080003d8 <SysTick_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80003d8:	4a04      	ldr	r2, [pc, #16]	; (80003ec <SysTick_CLKSourceConfig+0x14>)
 80003da:	6813      	ldr	r3, [r2, #0]
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 80003dc:	2804      	cmp	r0, #4
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80003de:	bf0c      	ite	eq
 80003e0:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80003e4:	f023 0304 	bicne.w	r3, r3, #4
 80003e8:	6013      	str	r3, [r2, #0]
 80003ea:	4770      	bx	lr
 80003ec:	e000e010 	.word	0xe000e010

080003f0 <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 80003f0:	6802      	ldr	r2, [r0, #0]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 80003f2:	4937      	ldr	r1, [pc, #220]	; (80004d0 <DMA_DeInit+0xe0>)
  DMAy_Streamx->CR  = 0;
 80003f4:	2300      	movs	r3, #0
{
 80003f6:	b410      	push	{r4}
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 80003f8:	f022 0201 	bic.w	r2, r2, #1
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 80003fc:	2421      	movs	r4, #33	; 0x21
  if (DMAy_Streamx == DMA1_Stream0)
 80003fe:	4288      	cmp	r0, r1
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 8000400:	6002      	str	r2, [r0, #0]
  DMAy_Streamx->CR  = 0;
 8000402:	6003      	str	r3, [r0, #0]
  DMAy_Streamx->NDTR = 0;
 8000404:	6043      	str	r3, [r0, #4]
  DMAy_Streamx->PAR  = 0;
 8000406:	6083      	str	r3, [r0, #8]
  DMAy_Streamx->M0AR = 0;
 8000408:	60c3      	str	r3, [r0, #12]
  DMAy_Streamx->M1AR = 0;
 800040a:	6103      	str	r3, [r0, #16]
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 800040c:	6144      	str	r4, [r0, #20]
  if (DMAy_Streamx == DMA1_Stream0)
 800040e:	d04d      	beq.n	80004ac <DMA_DeInit+0xbc>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream1)
 8000410:	4b30      	ldr	r3, [pc, #192]	; (80004d4 <DMA_DeInit+0xe4>)
 8000412:	4298      	cmp	r0, r3
 8000414:	d035      	beq.n	8000482 <DMA_DeInit+0x92>
  {
    /* Reset interrupt pending bits for DMA1 Stream1 */
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream2)
 8000416:	4b30      	ldr	r3, [pc, #192]	; (80004d8 <DMA_DeInit+0xe8>)
 8000418:	4298      	cmp	r0, r3
 800041a:	d039      	beq.n	8000490 <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA1 Stream2 */
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream3)
 800041c:	4b2f      	ldr	r3, [pc, #188]	; (80004dc <DMA_DeInit+0xec>)
 800041e:	4298      	cmp	r0, r3
 8000420:	d03d      	beq.n	800049e <DMA_DeInit+0xae>
  {
    /* Reset interrupt pending bits for DMA1 Stream3 */
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream4)
 8000422:	4b2f      	ldr	r3, [pc, #188]	; (80004e0 <DMA_DeInit+0xf0>)
 8000424:	4298      	cmp	r0, r3
 8000426:	d047      	beq.n	80004b8 <DMA_DeInit+0xc8>
  {
    /* Reset interrupt pending bits for DMA1 Stream4 */
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream5)
 8000428:	4b2e      	ldr	r3, [pc, #184]	; (80004e4 <DMA_DeInit+0xf4>)
 800042a:	4298      	cmp	r0, r3
 800042c:	d048      	beq.n	80004c0 <DMA_DeInit+0xd0>
  {
    /* Reset interrupt pending bits for DMA1 Stream5 */
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream6)
 800042e:	4b2e      	ldr	r3, [pc, #184]	; (80004e8 <DMA_DeInit+0xf8>)
 8000430:	4298      	cmp	r0, r3
 8000432:	d01d      	beq.n	8000470 <DMA_DeInit+0x80>
  {
    /* Reset interrupt pending bits for DMA1 Stream6 */
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream7)
 8000434:	4b2d      	ldr	r3, [pc, #180]	; (80004ec <DMA_DeInit+0xfc>)
 8000436:	4298      	cmp	r0, r3
 8000438:	d01e      	beq.n	8000478 <DMA_DeInit+0x88>
  {
    /* Reset interrupt pending bits for DMA1 Stream7 */
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream0)
 800043a:	4b2d      	ldr	r3, [pc, #180]	; (80004f0 <DMA_DeInit+0x100>)
 800043c:	4298      	cmp	r0, r3
 800043e:	d043      	beq.n	80004c8 <DMA_DeInit+0xd8>
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream1)
 8000440:	4b2c      	ldr	r3, [pc, #176]	; (80004f4 <DMA_DeInit+0x104>)
 8000442:	4298      	cmp	r0, r3
 8000444:	d01d      	beq.n	8000482 <DMA_DeInit+0x92>
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream2)
 8000446:	4b2c      	ldr	r3, [pc, #176]	; (80004f8 <DMA_DeInit+0x108>)
 8000448:	4298      	cmp	r0, r3
 800044a:	d021      	beq.n	8000490 <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream3)
 800044c:	4b2b      	ldr	r3, [pc, #172]	; (80004fc <DMA_DeInit+0x10c>)
 800044e:	4298      	cmp	r0, r3
 8000450:	d025      	beq.n	800049e <DMA_DeInit+0xae>
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream4)
 8000452:	4b2b      	ldr	r3, [pc, #172]	; (8000500 <DMA_DeInit+0x110>)
 8000454:	4298      	cmp	r0, r3
 8000456:	d02f      	beq.n	80004b8 <DMA_DeInit+0xc8>
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream5)
 8000458:	4b2a      	ldr	r3, [pc, #168]	; (8000504 <DMA_DeInit+0x114>)
 800045a:	4298      	cmp	r0, r3
 800045c:	d030      	beq.n	80004c0 <DMA_DeInit+0xd0>
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream6)
 800045e:	4b2a      	ldr	r3, [pc, #168]	; (8000508 <DMA_DeInit+0x118>)
 8000460:	4298      	cmp	r0, r3
 8000462:	d005      	beq.n	8000470 <DMA_DeInit+0x80>
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
  }
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
 8000464:	4b29      	ldr	r3, [pc, #164]	; (800050c <DMA_DeInit+0x11c>)
 8000466:	4298      	cmp	r0, r3
 8000468:	d006      	beq.n	8000478 <DMA_DeInit+0x88>
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
    }
  }
}
 800046a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800046e:	4770      	bx	lr
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 8000470:	4a27      	ldr	r2, [pc, #156]	; (8000510 <DMA_DeInit+0x120>)
 8000472:	f843 2c94 	str.w	r2, [r3, #-148]
 8000476:	e7f8      	b.n	800046a <DMA_DeInit+0x7a>
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 8000478:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 800047c:	f843 2cac 	str.w	r2, [r3, #-172]
}
 8000480:	e7f3      	b.n	800046a <DMA_DeInit+0x7a>
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 8000482:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8000486:	f843 2c20 	str.w	r2, [r3, #-32]
}
 800048a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800048e:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 8000490:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 8000494:	f843 2c38 	str.w	r2, [r3, #-56]
}
 8000498:	f85d 4b04 	ldr.w	r4, [sp], #4
 800049c:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 800049e:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 80004a2:	f843 2c50 	str.w	r2, [r3, #-80]
}
 80004a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80004aa:	4770      	bx	lr
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 80004ac:	4b19      	ldr	r3, [pc, #100]	; (8000514 <DMA_DeInit+0x124>)
}
 80004ae:	f85d 4b04 	ldr.w	r4, [sp], #4
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 80004b2:	223d      	movs	r2, #61	; 0x3d
 80004b4:	609a      	str	r2, [r3, #8]
}
 80004b6:	4770      	bx	lr
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 80004b8:	4a17      	ldr	r2, [pc, #92]	; (8000518 <DMA_DeInit+0x128>)
 80004ba:	f843 2c64 	str.w	r2, [r3, #-100]
 80004be:	e7d4      	b.n	800046a <DMA_DeInit+0x7a>
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 80004c0:	4a16      	ldr	r2, [pc, #88]	; (800051c <DMA_DeInit+0x12c>)
 80004c2:	f843 2c7c 	str.w	r2, [r3, #-124]
 80004c6:	e7d0      	b.n	800046a <DMA_DeInit+0x7a>
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 80004c8:	223d      	movs	r2, #61	; 0x3d
 80004ca:	f843 2c08 	str.w	r2, [r3, #-8]
 80004ce:	e7cc      	b.n	800046a <DMA_DeInit+0x7a>
 80004d0:	40026010 	.word	0x40026010
 80004d4:	40026028 	.word	0x40026028
 80004d8:	40026040 	.word	0x40026040
 80004dc:	40026058 	.word	0x40026058
 80004e0:	40026070 	.word	0x40026070
 80004e4:	40026088 	.word	0x40026088
 80004e8:	400260a0 	.word	0x400260a0
 80004ec:	400260b8 	.word	0x400260b8
 80004f0:	40026410 	.word	0x40026410
 80004f4:	40026428 	.word	0x40026428
 80004f8:	40026440 	.word	0x40026440
 80004fc:	40026458 	.word	0x40026458
 8000500:	40026470 	.word	0x40026470
 8000504:	40026488 	.word	0x40026488
 8000508:	400264a0 	.word	0x400264a0
 800050c:	400264b8 	.word	0x400264b8
 8000510:	203d0000 	.word	0x203d0000
 8000514:	40026000 	.word	0x40026000
 8000518:	2000003d 	.word	0x2000003d
 800051c:	20000f40 	.word	0x20000f40

08000520 <DMA_Init>:
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8000520:	680b      	ldr	r3, [r1, #0]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8000522:	69ca      	ldr	r2, [r1, #28]
{
 8000524:	b4f0      	push	{r4, r5, r6, r7}
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8000526:	68ce      	ldr	r6, [r1, #12]
 8000528:	694d      	ldr	r5, [r1, #20]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800052a:	698c      	ldr	r4, [r1, #24]
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800052c:	6a0f      	ldr	r7, [r1, #32]
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 800052e:	4333      	orrs	r3, r6
 8000530:	432b      	orrs	r3, r5
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8000532:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8000534:	6a4e      	ldr	r6, [r1, #36]	; 0x24
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8000536:	6a8d      	ldr	r5, [r1, #40]	; 0x28
 8000538:	6b4c      	ldr	r4, [r1, #52]	; 0x34
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800053a:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800053c:	433b      	orrs	r3, r7
 800053e:	4333      	orrs	r3, r6
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8000540:	6b8a      	ldr	r2, [r1, #56]	; 0x38
  tmpreg = DMAy_Streamx->CR;
 8000542:	6807      	ldr	r7, [r0, #0]
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000544:	4e0b      	ldr	r6, [pc, #44]	; (8000574 <DMA_Init+0x54>)
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8000546:	432b      	orrs	r3, r5
 8000548:	4323      	orrs	r3, r4
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800054a:	403e      	ands	r6, r7
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 800054c:	4313      	orrs	r3, r2
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 800054e:	4333      	orrs	r3, r6
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8000550:	6acd      	ldr	r5, [r1, #44]	; 0x2c
  DMAy_Streamx->CR = tmpreg;
 8000552:	6003      	str	r3, [r0, #0]
  tmpreg = DMAy_Streamx->FCR;
 8000554:	6942      	ldr	r2, [r0, #20]
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8000556:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 8000558:	690e      	ldr	r6, [r1, #16]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 800055a:	684c      	ldr	r4, [r1, #4]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 800055c:	6889      	ldr	r1, [r1, #8]
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 800055e:	432b      	orrs	r3, r5
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8000560:	f022 0207 	bic.w	r2, r2, #7
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8000564:	4313      	orrs	r3, r2
  DMAy_Streamx->FCR = tmpreg;
 8000566:	6143      	str	r3, [r0, #20]
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 8000568:	6046      	str	r6, [r0, #4]
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 800056a:	6084      	str	r4, [r0, #8]
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 800056c:	60c1      	str	r1, [r0, #12]
}
 800056e:	bcf0      	pop	{r4, r5, r6, r7}
 8000570:	4770      	bx	lr
 8000572:	bf00      	nop
 8000574:	f01c803f 	.word	0xf01c803f

08000578 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 8000578:	2300      	movs	r3, #0
 800057a:	6003      	str	r3, [r0, #0]

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 800057c:	6043      	str	r3, [r0, #4]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
 800057e:	6083      	str	r3, [r0, #8]

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 8000580:	60c3      	str	r3, [r0, #12]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8000582:	6103      	str	r3, [r0, #16]

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8000584:	6143      	str	r3, [r0, #20]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8000586:	6183      	str	r3, [r0, #24]

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8000588:	61c3      	str	r3, [r0, #28]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800058a:	6203      	str	r3, [r0, #32]

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 800058c:	6243      	str	r3, [r0, #36]	; 0x24

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 800058e:	6283      	str	r3, [r0, #40]	; 0x28

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 8000590:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 8000592:	6303      	str	r3, [r0, #48]	; 0x30

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 8000594:	6343      	str	r3, [r0, #52]	; 0x34

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8000596:	6383      	str	r3, [r0, #56]	; 0x38
 8000598:	4770      	bx	lr
 800059a:	bf00      	nop

0800059c <DMA_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 800059c:	6803      	ldr	r3, [r0, #0]
  if (NewState != DISABLE)
 800059e:	b919      	cbnz	r1, 80005a8 <DMA_Cmd+0xc>
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 80005a0:	f023 0301 	bic.w	r3, r3, #1
 80005a4:	6003      	str	r3, [r0, #0]
 80005a6:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 80005a8:	f043 0301 	orr.w	r3, r3, #1
 80005ac:	6003      	str	r3, [r0, #0]
 80005ae:	4770      	bx	lr

080005b0 <DMA_PeriphIncOffsetSizeConfig>:

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 80005b0:	6803      	ldr	r3, [r0, #0]
  if(DMA_Pincos != DMA_PINCOS_Psize)
 80005b2:	b919      	cbnz	r1, 80005bc <DMA_PeriphIncOffsetSizeConfig+0xc>
  }
  else
  {
    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
 80005b4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80005b8:	6003      	str	r3, [r0, #0]
 80005ba:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 80005bc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80005c0:	6003      	str	r3, [r0, #0]
 80005c2:	4770      	bx	lr

080005c4 <DMA_FlowControllerConfig>:

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 80005c4:	6803      	ldr	r3, [r0, #0]
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
 80005c6:	b919      	cbnz	r1, 80005d0 <DMA_FlowControllerConfig+0xc>
  }
  else
  {
    /* Clear the PFCTRL bit: Memory is the flow controller */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
 80005c8:	f023 0320 	bic.w	r3, r3, #32
 80005cc:	6003      	str	r3, [r0, #0]
 80005ce:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 80005d0:	f043 0320 	orr.w	r3, r3, #32
 80005d4:	6003      	str	r3, [r0, #0]
 80005d6:	4770      	bx	lr

080005d8 <DMA_SetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Write the number of data units to be transferred */
  DMAy_Streamx->NDTR = (uint16_t)Counter;
 80005d8:	6041      	str	r1, [r0, #4]
 80005da:	4770      	bx	lr

080005dc <DMA_GetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Return the number of remaining data units for DMAy Streamx */
  return ((uint16_t)(DMAy_Streamx->NDTR));
 80005dc:	6840      	ldr	r0, [r0, #4]
}
 80005de:	b280      	uxth	r0, r0
 80005e0:	4770      	bx	lr
 80005e2:	bf00      	nop

080005e4 <DMA_DoubleBufferModeConfig>:
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 80005e4:	6803      	ldr	r3, [r0, #0]
  if (DMA_CurrentMemory != DMA_Memory_0)
 80005e6:	b922      	cbnz	r2, 80005f2 <DMA_DoubleBufferModeConfig+0xe>
  }
  else
  {
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
 80005e8:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80005ec:	6003      	str	r3, [r0, #0]
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 80005ee:	6101      	str	r1, [r0, #16]
 80005f0:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 80005f2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80005f6:	6003      	str	r3, [r0, #0]
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 80005f8:	6101      	str	r1, [r0, #16]
 80005fa:	4770      	bx	lr

080005fc <DMA_DoubleBufferModeCmd>:

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 80005fc:	6803      	ldr	r3, [r0, #0]
  if (NewState != DISABLE)
 80005fe:	b919      	cbnz	r1, 8000608 <DMA_DoubleBufferModeCmd+0xc>
  }
  else
  {
    /* Disable the Double buffer mode */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
 8000600:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000604:	6003      	str	r3, [r0, #0]
 8000606:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 8000608:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800060c:	6003      	str	r3, [r0, #0]
 800060e:	4770      	bx	lr

08000610 <DMA_MemoryTargetConfig>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
 8000610:	b90a      	cbnz	r2, 8000616 <DMA_MemoryTargetConfig+0x6>
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
  }  
  else
  {
    /* Write to DMAy Streamx M0AR */
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
 8000612:	60c1      	str	r1, [r0, #12]
 8000614:	4770      	bx	lr
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
 8000616:	6101      	str	r1, [r0, #16]
 8000618:	4770      	bx	lr
 800061a:	bf00      	nop

0800061c <DMA_GetCurrentMemoryTarget>:
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Get the current memory target */
  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
 800061c:	6800      	ldr	r0, [r0, #0]
  {
    /* Current memory buffer used is Memory 0 */
    tmp = 0;    
  }
  return tmp;
}
 800061e:	f3c0 40c0 	ubfx	r0, r0, #19, #1
 8000622:	4770      	bx	lr

08000624 <DMA_GetCmdStatus>:
  FunctionalState state = DISABLE;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
 8000624:	6800      	ldr	r0, [r0, #0]
    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
        all transfers are complete) */
    state = DISABLE;
  }
  return state;
}
 8000626:	f000 0001 	and.w	r0, r0, #1
 800062a:	4770      	bx	lr

0800062c <DMA_GetFIFOStatus>:
 
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
 800062c:	6940      	ldr	r0, [r0, #20]
  
  return tmpreg;
}
 800062e:	f000 0038 	and.w	r0, r0, #56	; 0x38
 8000632:	4770      	bx	lr

08000634 <DMA_GetFlagStatus>:
    DMAy = DMA1; 
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 8000634:	4b0b      	ldr	r3, [pc, #44]	; (8000664 <DMA_GetFlagStatus+0x30>)
 8000636:	4a0c      	ldr	r2, [pc, #48]	; (8000668 <DMA_GetFlagStatus+0x34>)
{
 8000638:	b410      	push	{r4}
  if (DMAy_Streamx < DMA2_Stream0)
 800063a:	4c0c      	ldr	r4, [pc, #48]	; (800066c <DMA_GetFlagStatus+0x38>)
    DMAy = DMA2; 
 800063c:	42a0      	cmp	r0, r4
 800063e:	bf94      	ite	ls
 8000640:	4618      	movls	r0, r3
 8000642:	4610      	movhi	r0, r2
  }

  /* Check if the flag is in HISR or LISR */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8000644:	008b      	lsls	r3, r1, #2
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR;
 8000646:	bf4c      	ite	mi
 8000648:	6843      	ldrmi	r3, [r0, #4]
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
 800064a:	6803      	ldrpl	r3, [r0, #0]
    bitstatus = RESET;
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
}
 800064c:	f85d 4b04 	ldr.w	r4, [sp], #4
  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
 8000650:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8000654:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8000658:	4219      	tst	r1, r3
}
 800065a:	bf14      	ite	ne
 800065c:	2001      	movne	r0, #1
 800065e:	2000      	moveq	r0, #0
 8000660:	4770      	bx	lr
 8000662:	bf00      	nop
 8000664:	40026000 	.word	0x40026000
 8000668:	40026400 	.word	0x40026400
 800066c:	4002640f 	.word	0x4002640f

08000670 <DMA_ClearFlag>:
 8000670:	b410      	push	{r4}
 8000672:	4b09      	ldr	r3, [pc, #36]	; (8000698 <DMA_ClearFlag+0x28>)
 8000674:	4c09      	ldr	r4, [pc, #36]	; (800069c <DMA_ClearFlag+0x2c>)
 8000676:	4a0a      	ldr	r2, [pc, #40]	; (80006a0 <DMA_ClearFlag+0x30>)
 8000678:	42a0      	cmp	r0, r4
 800067a:	bf94      	ite	ls
 800067c:	4618      	movls	r0, r3
 800067e:	4610      	movhi	r0, r2
 8000680:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8000684:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8000688:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 800068c:	bf14      	ite	ne
 800068e:	60c1      	strne	r1, [r0, #12]
 8000690:	6081      	streq	r1, [r0, #8]
 8000692:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000696:	4770      	bx	lr
 8000698:	40026000 	.word	0x40026000
 800069c:	4002640f 	.word	0x4002640f
 80006a0:	40026400 	.word	0x40026400

080006a4 <DMA_ITConfig>:
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 80006a4:	060b      	lsls	r3, r1, #24
 80006a6:	d50c      	bpl.n	80006c2 <DMA_ITConfig+0x1e>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 80006a8:	6943      	ldr	r3, [r0, #20]
    if (NewState != DISABLE)
 80006aa:	b1aa      	cbz	r2, 80006d8 <DMA_ITConfig+0x34>
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 80006ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 80006b0:	2980      	cmp	r1, #128	; 0x80
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 80006b2:	6143      	str	r3, [r0, #20]
  if (DMA_IT != DMA_IT_FE)
 80006b4:	d00f      	beq.n	80006d6 <DMA_ITConfig+0x32>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 80006b6:	6803      	ldr	r3, [r0, #0]
 80006b8:	f001 011e 	and.w	r1, r1, #30
 80006bc:	4319      	orrs	r1, r3
 80006be:	6001      	str	r1, [r0, #0]
 80006c0:	4770      	bx	lr
  if (DMA_IT != DMA_IT_FE)
 80006c2:	2980      	cmp	r1, #128	; 0x80
 80006c4:	d007      	beq.n	80006d6 <DMA_ITConfig+0x32>
    if (NewState != DISABLE)
 80006c6:	2a00      	cmp	r2, #0
 80006c8:	d1f5      	bne.n	80006b6 <DMA_ITConfig+0x12>
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 80006ca:	6803      	ldr	r3, [r0, #0]
 80006cc:	f001 011e 	and.w	r1, r1, #30
 80006d0:	ea23 0101 	bic.w	r1, r3, r1
 80006d4:	6001      	str	r1, [r0, #0]
 80006d6:	4770      	bx	lr
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 80006d8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  if (DMA_IT != DMA_IT_FE)
 80006dc:	2980      	cmp	r1, #128	; 0x80
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 80006de:	6143      	str	r3, [r0, #20]
  if (DMA_IT != DMA_IT_FE)
 80006e0:	d1f3      	bne.n	80006ca <DMA_ITConfig+0x26>
 80006e2:	4770      	bx	lr

080006e4 <DMA_GetITStatus>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 80006e4:	b430      	push	{r4, r5}
    DMAy = DMA1; 
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 80006e6:	4b11      	ldr	r3, [pc, #68]	; (800072c <DMA_GetITStatus+0x48>)
  if (DMAy_Streamx < DMA2_Stream0)
 80006e8:	4d11      	ldr	r5, [pc, #68]	; (8000730 <DMA_GetITStatus+0x4c>)
    DMAy = DMA2; 
 80006ea:	4a12      	ldr	r2, [pc, #72]	; (8000734 <DMA_GetITStatus+0x50>)
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 80006ec:	f021 24f0 	bic.w	r4, r1, #4026593280	; 0xf000f000
 80006f0:	f024 14c3 	bic.w	r4, r4, #12779715	; 0xc300c3
    DMAy = DMA2; 
 80006f4:	42a8      	cmp	r0, r5
 80006f6:	bf98      	it	ls
 80006f8:	461a      	movls	r2, r3
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 80006fa:	b19c      	cbz	r4, 8000724 <DMA_GetITStatus+0x40>
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 80006fc:	6800      	ldr	r0, [r0, #0]
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
 80006fe:	ea00 20d1 	and.w	r0, r0, r1, lsr #11
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 8000702:	f000 031e 	and.w	r3, r0, #30
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8000706:	0088      	lsls	r0, r1, #2
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 8000708:	bf4c      	ite	mi
 800070a:	6850      	ldrmi	r0, [r2, #4]
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
 800070c:	6810      	ldrpl	r0, [r2, #0]

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800070e:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8000712:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8000716:	4008      	ands	r0, r1
 8000718:	d002      	beq.n	8000720 <DMA_GetITStatus+0x3c>
 800071a:	1c18      	adds	r0, r3, #0
 800071c:	bf18      	it	ne
 800071e:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the DMA_IT status */
  return  bitstatus;
}
 8000720:	bc30      	pop	{r4, r5}
 8000722:	4770      	bx	lr
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 8000724:	6943      	ldr	r3, [r0, #20]
 8000726:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800072a:	e7ec      	b.n	8000706 <DMA_GetITStatus+0x22>
 800072c:	40026000 	.word	0x40026000
 8000730:	4002640f 	.word	0x4002640f
 8000734:	40026400 	.word	0x40026400

08000738 <DMA_ClearITPendingBit>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8000738:	b410      	push	{r4}
    DMAy = DMA1; 
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 800073a:	4b09      	ldr	r3, [pc, #36]	; (8000760 <DMA_ClearITPendingBit+0x28>)
  if (DMAy_Streamx < DMA2_Stream0)
 800073c:	4c09      	ldr	r4, [pc, #36]	; (8000764 <DMA_ClearITPendingBit+0x2c>)
    DMAy = DMA2; 
 800073e:	4a0a      	ldr	r2, [pc, #40]	; (8000768 <DMA_ClearITPendingBit+0x30>)
 8000740:	42a0      	cmp	r0, r4
 8000742:	bf94      	ite	ls
 8000744:	4618      	movls	r0, r3
 8000746:	4610      	movhi	r0, r2
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8000748:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
  {
    /* Set DMAy HIFCR register clear interrupt bits */
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 800074c:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8000750:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8000754:	bf14      	ite	ne
 8000756:	60c1      	strne	r1, [r0, #12]
  }
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8000758:	6081      	streq	r1, [r0, #8]
  }   
}
 800075a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800075e:	4770      	bx	lr
 8000760:	40026000 	.word	0x40026000
 8000764:	4002640f 	.word	0x4002640f
 8000768:	40026400 	.word	0x40026400

0800076c <GPIO_DeInit>:
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 800076c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 800076e:	4b3c      	ldr	r3, [pc, #240]	; (8000860 <GPIO_DeInit+0xf4>)
 8000770:	4298      	cmp	r0, r3
 8000772:	d024      	beq.n	80007be <GPIO_DeInit+0x52>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8000774:	4b3b      	ldr	r3, [pc, #236]	; (8000864 <GPIO_DeInit+0xf8>)
 8000776:	4298      	cmp	r0, r3
 8000778:	d02b      	beq.n	80007d2 <GPIO_DeInit+0x66>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 800077a:	4b3b      	ldr	r3, [pc, #236]	; (8000868 <GPIO_DeInit+0xfc>)
 800077c:	4298      	cmp	r0, r3
 800077e:	d032      	beq.n	80007e6 <GPIO_DeInit+0x7a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 8000780:	4b3a      	ldr	r3, [pc, #232]	; (800086c <GPIO_DeInit+0x100>)
 8000782:	4298      	cmp	r0, r3
 8000784:	d039      	beq.n	80007fa <GPIO_DeInit+0x8e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 8000786:	4b3a      	ldr	r3, [pc, #232]	; (8000870 <GPIO_DeInit+0x104>)
 8000788:	4298      	cmp	r0, r3
 800078a:	d040      	beq.n	800080e <GPIO_DeInit+0xa2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 800078c:	4b39      	ldr	r3, [pc, #228]	; (8000874 <GPIO_DeInit+0x108>)
 800078e:	4298      	cmp	r0, r3
 8000790:	d047      	beq.n	8000822 <GPIO_DeInit+0xb6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 8000792:	4b39      	ldr	r3, [pc, #228]	; (8000878 <GPIO_DeInit+0x10c>)
 8000794:	4298      	cmp	r0, r3
 8000796:	d04e      	beq.n	8000836 <GPIO_DeInit+0xca>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 8000798:	4b38      	ldr	r3, [pc, #224]	; (800087c <GPIO_DeInit+0x110>)
 800079a:	4298      	cmp	r0, r3
 800079c:	d055      	beq.n	800084a <GPIO_DeInit+0xde>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOI)
 800079e:	4b38      	ldr	r3, [pc, #224]	; (8000880 <GPIO_DeInit+0x114>)
 80007a0:	4298      	cmp	r0, r3
 80007a2:	d000      	beq.n	80007a6 <GPIO_DeInit+0x3a>
 80007a4:	bd08      	pop	{r3, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 80007a6:	2101      	movs	r1, #1
 80007a8:	f44f 7080 	mov.w	r0, #256	; 0x100
 80007ac:	f000 fcc0 	bl	8001130 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80007b0:	2100      	movs	r1, #0
 80007b2:	f44f 7080 	mov.w	r0, #256	; 0x100
    }
  }
}
 80007b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80007ba:	f000 bcb9 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 80007be:	2101      	movs	r1, #1
 80007c0:	4608      	mov	r0, r1
 80007c2:	f000 fcb5 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 80007c6:	2100      	movs	r1, #0
 80007c8:	2001      	movs	r0, #1
}
 80007ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 80007ce:	f000 bcaf 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 80007d2:	2101      	movs	r1, #1
 80007d4:	2002      	movs	r0, #2
 80007d6:	f000 fcab 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 80007da:	2100      	movs	r1, #0
 80007dc:	2002      	movs	r0, #2
}
 80007de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 80007e2:	f000 bca5 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 80007e6:	2101      	movs	r1, #1
 80007e8:	2004      	movs	r0, #4
 80007ea:	f000 fca1 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 80007ee:	2100      	movs	r1, #0
 80007f0:	2004      	movs	r0, #4
}
 80007f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 80007f6:	f000 bc9b 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 80007fa:	2101      	movs	r1, #1
 80007fc:	2008      	movs	r0, #8
 80007fe:	f000 fc97 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 8000802:	2100      	movs	r1, #0
 8000804:	2008      	movs	r0, #8
}
 8000806:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 800080a:	f000 bc91 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 800080e:	2101      	movs	r1, #1
 8000810:	2010      	movs	r0, #16
 8000812:	f000 fc8d 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 8000816:	2100      	movs	r1, #0
 8000818:	2010      	movs	r0, #16
}
 800081a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 800081e:	f000 bc87 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 8000822:	2101      	movs	r1, #1
 8000824:	2020      	movs	r0, #32
 8000826:	f000 fc83 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 800082a:	2100      	movs	r1, #0
 800082c:	2020      	movs	r0, #32
}
 800082e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 8000832:	f000 bc7d 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 8000836:	2101      	movs	r1, #1
 8000838:	2040      	movs	r0, #64	; 0x40
 800083a:	f000 fc79 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 800083e:	2100      	movs	r1, #0
 8000840:	2040      	movs	r0, #64	; 0x40
}
 8000842:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 8000846:	f000 bc73 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 800084a:	2101      	movs	r1, #1
 800084c:	2080      	movs	r0, #128	; 0x80
 800084e:	f000 fc6f 	bl	8001130 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 8000852:	2100      	movs	r1, #0
 8000854:	2080      	movs	r0, #128	; 0x80
}
 8000856:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 800085a:	f000 bc69 	b.w	8001130 <RCC_AHB1PeriphResetCmd>
 800085e:	bf00      	nop
 8000860:	40020000 	.word	0x40020000
 8000864:	40020400 	.word	0x40020400
 8000868:	40020800 	.word	0x40020800
 800086c:	40020c00 	.word	0x40020c00
 8000870:	40021000 	.word	0x40021000
 8000874:	40021400 	.word	0x40021400
 8000878:	40021800 	.word	0x40021800
 800087c:	40021c00 	.word	0x40021c00
 8000880:	40022000 	.word	0x40022000

08000884 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8000884:	2200      	movs	r2, #0
 8000886:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800088a:	4613      	mov	r3, r2
 800088c:	f8d1 e000 	ldr.w	lr, [r1]
  {
    pos = ((uint32_t)0x01) << pinpos;
 8000890:	2701      	movs	r7, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8000892:	f04f 0c03 	mov.w	ip, #3
 8000896:	e004      	b.n	80008a2 <GPIO_Init+0x1e>
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8000898:	3301      	adds	r3, #1
 800089a:	2b10      	cmp	r3, #16
 800089c:	f102 0202 	add.w	r2, r2, #2
 80008a0:	d029      	beq.n	80008f6 <GPIO_Init+0x72>
    pos = ((uint32_t)0x01) << pinpos;
 80008a2:	fa07 f403 	lsl.w	r4, r7, r3
    if (currentpin == pos)
 80008a6:	ea34 050e 	bics.w	r5, r4, lr
 80008aa:	d1f5      	bne.n	8000898 <GPIO_Init+0x14>
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80008ac:	f8d0 8000 	ldr.w	r8, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80008b0:	790e      	ldrb	r6, [r1, #4]
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80008b2:	fa0c f502 	lsl.w	r5, ip, r2
 80008b6:	43ed      	mvns	r5, r5
 80008b8:	ea08 0805 	and.w	r8, r8, r5
 80008bc:	f8c0 8000 	str.w	r8, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80008c0:	f8d0 a000 	ldr.w	sl, [r0]
 80008c4:	fa06 f902 	lsl.w	r9, r6, r2

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80008c8:	3e01      	subs	r6, #1
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80008ca:	ea49 090a 	orr.w	r9, r9, sl
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80008ce:	2e01      	cmp	r6, #1
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80008d0:	fa0c f802 	lsl.w	r8, ip, r2
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80008d4:	f8c0 9000 	str.w	r9, [r0]
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80008d8:	d90f      	bls.n	80008fa <GPIO_Init+0x76>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80008da:	68c5      	ldr	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80008dc:	79cc      	ldrb	r4, [r1, #7]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80008de:	ea25 0508 	bic.w	r5, r5, r8
 80008e2:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80008e4:	68c5      	ldr	r5, [r0, #12]
 80008e6:	4094      	lsls	r4, r2
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80008e8:	3301      	adds	r3, #1
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80008ea:	432c      	orrs	r4, r5
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80008ec:	2b10      	cmp	r3, #16
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80008ee:	60c4      	str	r4, [r0, #12]
 80008f0:	f102 0202 	add.w	r2, r2, #2
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80008f4:	d1d5      	bne.n	80008a2 <GPIO_Init+0x1e>
    }
  }
}
 80008f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80008fa:	f8d0 9008 	ldr.w	r9, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80008fe:	794e      	ldrb	r6, [r1, #5]
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8000900:	ea05 0509 	and.w	r5, r5, r9
 8000904:	6085      	str	r5, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8000906:	f8d0 9008 	ldr.w	r9, [r0, #8]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800090a:	798d      	ldrb	r5, [r1, #6]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800090c:	4096      	lsls	r6, r2
 800090e:	ea46 0609 	orr.w	r6, r6, r9
 8000912:	6086      	str	r6, [r0, #8]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8000914:	6846      	ldr	r6, [r0, #4]
 8000916:	ea26 0404 	bic.w	r4, r6, r4
 800091a:	6044      	str	r4, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800091c:	6846      	ldr	r6, [r0, #4]
 800091e:	fa05 f403 	lsl.w	r4, r5, r3
 8000922:	b2a4      	uxth	r4, r4
 8000924:	4334      	orrs	r4, r6
 8000926:	6044      	str	r4, [r0, #4]
 8000928:	e7d7      	b.n	80008da <GPIO_Init+0x56>
 800092a:	bf00      	nop

0800092c <GPIO_StructInit>:
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 800092c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000930:	2300      	movs	r3, #0
 8000932:	e880 000c 	stmia.w	r0, {r2, r3}
 8000936:	4770      	bx	lr

08000938 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000938:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 800093a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800093e:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8000940:	9b01      	ldr	r3, [sp, #4]
 8000942:	430b      	orrs	r3, r1
 8000944:	9301      	str	r3, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8000946:	9b01      	ldr	r3, [sp, #4]
 8000948:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800094a:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800094c:	9b01      	ldr	r3, [sp, #4]
 800094e:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8000950:	69c3      	ldr	r3, [r0, #28]
 8000952:	9301      	str	r3, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8000954:	69c3      	ldr	r3, [r0, #28]
 8000956:	9301      	str	r3, [sp, #4]
}
 8000958:	b002      	add	sp, #8
 800095a:	4770      	bx	lr

0800095c <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 800095c:	6903      	ldr	r3, [r0, #16]
 800095e:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8000960:	bf14      	ite	ne
 8000962:	2001      	movne	r0, #1
 8000964:	2000      	moveq	r0, #0
 8000966:	4770      	bx	lr

08000968 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8000968:	6900      	ldr	r0, [r0, #16]
}
 800096a:	b280      	uxth	r0, r0
 800096c:	4770      	bx	lr
 800096e:	bf00      	nop

08000970 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8000970:	6943      	ldr	r3, [r0, #20]
 8000972:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8000974:	bf14      	ite	ne
 8000976:	2001      	movne	r0, #1
 8000978:	2000      	moveq	r0, #0
 800097a:	4770      	bx	lr

0800097c <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 800097c:	6940      	ldr	r0, [r0, #20]
}
 800097e:	b280      	uxth	r0, r0
 8000980:	4770      	bx	lr
 8000982:	bf00      	nop

08000984 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8000984:	8301      	strh	r1, [r0, #24]
 8000986:	4770      	bx	lr

08000988 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8000988:	8341      	strh	r1, [r0, #26]
 800098a:	4770      	bx	lr

0800098c <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 800098c:	b90a      	cbnz	r2, 8000992 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 800098e:	8341      	strh	r1, [r0, #26]
 8000990:	4770      	bx	lr
    GPIOx->BSRRL = GPIO_Pin;
 8000992:	8301      	strh	r1, [r0, #24]
 8000994:	4770      	bx	lr
 8000996:	bf00      	nop

08000998 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8000998:	6141      	str	r1, [r0, #20]
 800099a:	4770      	bx	lr

0800099c <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 800099c:	6943      	ldr	r3, [r0, #20]
 800099e:	4059      	eors	r1, r3
 80009a0:	6141      	str	r1, [r0, #20]
 80009a2:	4770      	bx	lr

080009a4 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80009a4:	08cb      	lsrs	r3, r1, #3
 80009a6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80009aa:	f001 0107 	and.w	r1, r1, #7
{
 80009ae:	b410      	push	{r4}
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80009b0:	6a03      	ldr	r3, [r0, #32]
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80009b2:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80009b4:	240f      	movs	r4, #15
 80009b6:	408c      	lsls	r4, r1
 80009b8:	ea23 0304 	bic.w	r3, r3, r4
 80009bc:	6203      	str	r3, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80009be:	6a03      	ldr	r3, [r0, #32]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
}
 80009c0:	f85d 4b04 	ldr.w	r4, [sp], #4
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80009c4:	fa02 f101 	lsl.w	r1, r2, r1
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80009c8:	4319      	orrs	r1, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 80009ca:	6201      	str	r1, [r0, #32]
}
 80009cc:	4770      	bx	lr
 80009ce:	bf00      	nop

080009d0 <I2C_DeInit>:
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 80009d0:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 80009d2:	4b17      	ldr	r3, [pc, #92]	; (8000a30 <I2C_DeInit+0x60>)
 80009d4:	4298      	cmp	r0, r3
 80009d6:	d012      	beq.n	80009fe <I2C_DeInit+0x2e>
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
  }
  else if (I2Cx == I2C2)
 80009d8:	4b16      	ldr	r3, [pc, #88]	; (8000a34 <I2C_DeInit+0x64>)
 80009da:	4298      	cmp	r0, r3
 80009dc:	d01b      	beq.n	8000a16 <I2C_DeInit+0x46>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
  }
  else 
  {
    if (I2Cx == I2C3)
 80009de:	4b16      	ldr	r3, [pc, #88]	; (8000a38 <I2C_DeInit+0x68>)
 80009e0:	4298      	cmp	r0, r3
 80009e2:	d000      	beq.n	80009e6 <I2C_DeInit+0x16>
 80009e4:	bd08      	pop	{r3, pc}
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
 80009e6:	2101      	movs	r1, #1
 80009e8:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80009ec:	f000 fbc4 	bl	8001178 <RCC_APB1PeriphResetCmd>
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 80009f0:	2100      	movs	r1, #0
 80009f2:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
    }
  }
}
 80009f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 80009fa:	f000 bbbd 	b.w	8001178 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 80009fe:	2101      	movs	r1, #1
 8000a00:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8000a04:	f000 fbb8 	bl	8001178 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 8000a08:	2100      	movs	r1, #0
 8000a0a:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
}
 8000a0e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 8000a12:	f000 bbb1 	b.w	8001178 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 8000a16:	2101      	movs	r1, #1
 8000a18:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8000a1c:	f000 fbac 	bl	8001178 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 8000a20:	2100      	movs	r1, #0
 8000a22:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
}
 8000a26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 8000a2a:	f000 bba5 	b.w	8001178 <RCC_APB1PeriphResetCmd>
 8000a2e:	bf00      	nop
 8000a30:	40005400 	.word	0x40005400
 8000a34:	40005800 	.word	0x40005800
 8000a38:	40005c00 	.word	0x40005c00

08000a3c <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8000a3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a3e:	4604      	mov	r4, r0
 8000a40:	b085      	sub	sp, #20
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8000a42:	4668      	mov	r0, sp
{
 8000a44:	460e      	mov	r6, r1
  tmpreg = I2Cx->CR2;
 8000a46:	88a5      	ldrh	r5, [r4, #4]
  RCC_GetClocksFreq(&rcc_clocks);
 8000a48:	f000 fac4 	bl	8000fd4 <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 8000a4c:	9802      	ldr	r0, [sp, #8]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8000a4e:	4a31      	ldr	r2, [pc, #196]	; (8000b14 <I2C_Init+0xd8>)
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8000a50:	6833      	ldr	r3, [r6, #0]
 8000a52:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 8000b1c <I2C_Init+0xe0>
  freqrange = (uint16_t)(pclk1 / 1000000);
 8000a56:	fba2 1200 	umull	r1, r2, r2, r0
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 8000a5a:	f025 053f 	bic.w	r5, r5, #63	; 0x3f
  freqrange = (uint16_t)(pclk1 / 1000000);
 8000a5e:	0c91      	lsrs	r1, r2, #18
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 8000a60:	042d      	lsls	r5, r5, #16
 8000a62:	0c2d      	lsrs	r5, r5, #16
  freqrange = (uint16_t)(pclk1 / 1000000);
 8000a64:	b28f      	uxth	r7, r1
  tmpreg |= freqrange;
 8000a66:	433d      	orrs	r5, r7
  I2Cx->CR2 = tmpreg;
 8000a68:	80a5      	strh	r5, [r4, #4]
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8000a6a:	8822      	ldrh	r2, [r4, #0]
 8000a6c:	f022 0201 	bic.w	r2, r2, #1
 8000a70:	0412      	lsls	r2, r2, #16
 8000a72:	0c12      	lsrs	r2, r2, #16
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8000a74:	4573      	cmp	r3, lr
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8000a76:	8022      	strh	r2, [r4, #0]
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8000a78:	d823      	bhi.n	8000ac2 <I2C_Init+0x86>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 8000a7a:	005b      	lsls	r3, r3, #1
 8000a7c:	fbb0 f3f3 	udiv	r3, r0, r3
 8000a80:	b29b      	uxth	r3, r3
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 8000a82:	3701      	adds	r7, #1
 8000a84:	2b04      	cmp	r3, #4
 8000a86:	bf38      	it	cc
 8000a88:	2304      	movcc	r3, #4
 8000a8a:	8427      	strh	r7, [r4, #32]
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 8000a8c:	83a3      	strh	r3, [r4, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8000a8e:	8821      	ldrh	r1, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8000a90:	88b0      	ldrh	r0, [r6, #4]
 8000a92:	8977      	ldrh	r7, [r6, #10]
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8000a94:	89b2      	ldrh	r2, [r6, #12]
 8000a96:	8935      	ldrh	r5, [r6, #8]
  I2Cx->CR1 |= I2C_CR1_PE;
 8000a98:	b289      	uxth	r1, r1
 8000a9a:	f041 0101 	orr.w	r1, r1, #1
 8000a9e:	8021      	strh	r1, [r4, #0]
  tmpreg = I2Cx->CR1;
 8000aa0:	8823      	ldrh	r3, [r4, #0]
  tmpreg &= CR1_CLEAR_MASK;
 8000aa2:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8000aa6:	f023 0302 	bic.w	r3, r3, #2
 8000aaa:	041b      	lsls	r3, r3, #16
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8000aac:	ea40 0107 	orr.w	r1, r0, r7
  tmpreg &= CR1_CLEAR_MASK;
 8000ab0:	0c1b      	lsrs	r3, r3, #16
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8000ab2:	430b      	orrs	r3, r1
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8000ab4:	432a      	orrs	r2, r5
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8000ab6:	b29b      	uxth	r3, r3
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8000ab8:	b292      	uxth	r2, r2
  I2Cx->CR1 = tmpreg;
 8000aba:	8023      	strh	r3, [r4, #0]
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8000abc:	8122      	strh	r2, [r4, #8]
}
 8000abe:	b005      	add	sp, #20
 8000ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 8000ac2:	88f5      	ldrh	r5, [r6, #6]
 8000ac4:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 8000ac8:	4295      	cmp	r5, r2
 8000aca:	d01d      	beq.n	8000b08 <I2C_Init+0xcc>
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 8000acc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000ad0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000ad4:	fbb0 f3f3 	udiv	r3, r0, r3
 8000ad8:	b29b      	uxth	r3, r3
      result |= I2C_DutyCycle_16_9;
 8000ada:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    if ((result & I2C_CCR_CCR) == 0)
 8000ade:	f3c3 020b 	ubfx	r2, r3, #0, #12
 8000ae2:	b90a      	cbnz	r2, 8000ae8 <I2C_Init+0xac>
      result |= (uint16_t)0x0001;  
 8000ae4:	f043 0301 	orr.w	r3, r3, #1
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8000ae8:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8000aec:	480a      	ldr	r0, [pc, #40]	; (8000b18 <I2C_Init+0xdc>)
 8000aee:	fb02 f201 	mul.w	r2, r2, r1
 8000af2:	fb80 0102 	smull	r0, r1, r0, r2
 8000af6:	17d2      	asrs	r2, r2, #31
 8000af8:	ebc2 12a1 	rsb	r2, r2, r1, asr #6
 8000afc:	3201      	adds	r2, #1
 8000afe:	b292      	uxth	r2, r2
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 8000b00:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8000b04:	8422      	strh	r2, [r4, #32]
 8000b06:	e7c1      	b.n	8000a8c <I2C_Init+0x50>
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 8000b08:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8000b0c:	fbb0 f3f3 	udiv	r3, r0, r3
 8000b10:	b29b      	uxth	r3, r3
 8000b12:	e7e4      	b.n	8000ade <I2C_Init+0xa2>
 8000b14:	431bde83 	.word	0x431bde83
 8000b18:	10624dd3 	.word	0x10624dd3
 8000b1c:	000186a0 	.word	0x000186a0

08000b20 <I2C_StructInit>:
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8000b20:	2300      	movs	r3, #0
{
 8000b22:	b410      	push	{r4}
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 8000b24:	f64b 71ff 	movw	r1, #49151	; 0xbfff
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 8000b28:	f241 3488 	movw	r4, #5000	; 0x1388
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8000b2c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 8000b30:	6004      	str	r4, [r0, #0]
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 8000b32:	80c1      	strh	r1, [r0, #6]
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8000b34:	8182      	strh	r2, [r0, #12]
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8000b36:	8083      	strh	r3, [r0, #4]
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 8000b38:	8103      	strh	r3, [r0, #8]
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8000b3a:	8143      	strh	r3, [r0, #10]
}
 8000b3c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b40:	4770      	bx	lr
 8000b42:	bf00      	nop

08000b44 <I2C_Cmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8000b44:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000b46:	b929      	cbnz	r1, 8000b54 <I2C_Cmd+0x10>
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8000b48:	f023 0301 	bic.w	r3, r3, #1
 8000b4c:	041b      	lsls	r3, r3, #16
 8000b4e:	0c1b      	lsrs	r3, r3, #16
 8000b50:	8003      	strh	r3, [r0, #0]
 8000b52:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_PE;
 8000b54:	b29b      	uxth	r3, r3
 8000b56:	f043 0301 	orr.w	r3, r3, #1
 8000b5a:	8003      	strh	r3, [r0, #0]
 8000b5c:	4770      	bx	lr
 8000b5e:	bf00      	nop

08000b60 <I2C_GenerateSTART>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 8000b60:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000b62:	b929      	cbnz	r1, 8000b70 <I2C_GenerateSTART+0x10>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
 8000b64:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000b68:	041b      	lsls	r3, r3, #16
 8000b6a:	0c1b      	lsrs	r3, r3, #16
 8000b6c:	8003      	strh	r3, [r0, #0]
 8000b6e:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_START;
 8000b70:	b29b      	uxth	r3, r3
 8000b72:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000b76:	8003      	strh	r3, [r0, #0]
 8000b78:	4770      	bx	lr
 8000b7a:	bf00      	nop

08000b7c <I2C_GenerateSTOP>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 8000b7c:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000b7e:	b929      	cbnz	r1, 8000b8c <I2C_GenerateSTOP+0x10>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 8000b80:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000b84:	041b      	lsls	r3, r3, #16
 8000b86:	0c1b      	lsrs	r3, r3, #16
 8000b88:	8003      	strh	r3, [r0, #0]
 8000b8a:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_STOP;
 8000b8c:	b29b      	uxth	r3, r3
 8000b8e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000b92:	8003      	strh	r3, [r0, #0]
 8000b94:	4770      	bx	lr
 8000b96:	bf00      	nop

08000b98 <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 8000b98:	b922      	cbnz	r2, 8000ba4 <I2C_Send7bitAddress+0xc>
    Address |= I2C_OAR1_ADD0;
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
 8000b9a:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 8000b9e:	b289      	uxth	r1, r1
 8000ba0:	8201      	strh	r1, [r0, #16]
 8000ba2:	4770      	bx	lr
    Address |= I2C_OAR1_ADD0;
 8000ba4:	f041 0101 	orr.w	r1, r1, #1
  I2Cx->DR = Address;
 8000ba8:	b289      	uxth	r1, r1
 8000baa:	8201      	strh	r1, [r0, #16]
 8000bac:	4770      	bx	lr
 8000bae:	bf00      	nop

08000bb0 <I2C_AcknowledgeConfig>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 8000bb0:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000bb2:	b929      	cbnz	r1, 8000bc0 <I2C_AcknowledgeConfig+0x10>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
 8000bb4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000bb8:	041b      	lsls	r3, r3, #16
 8000bba:	0c1b      	lsrs	r3, r3, #16
 8000bbc:	8003      	strh	r3, [r0, #0]
 8000bbe:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ACK;
 8000bc0:	b29b      	uxth	r3, r3
 8000bc2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000bc6:	8003      	strh	r3, [r0, #0]
 8000bc8:	4770      	bx	lr
 8000bca:	bf00      	nop

08000bcc <I2C_OwnAddress2Config>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 8000bcc:	8983      	ldrh	r3, [r0, #12]
 8000bce:	b29b      	uxth	r3, r3

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8000bd0:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
 8000bd4:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8000bd8:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 8000bda:	8183      	strh	r3, [r0, #12]
 8000bdc:	4770      	bx	lr
 8000bde:	bf00      	nop

08000be0 <I2C_DualAddressCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 8000be0:	8983      	ldrh	r3, [r0, #12]
  if (NewState != DISABLE)
 8000be2:	b929      	cbnz	r1, 8000bf0 <I2C_DualAddressCmd+0x10>
  }
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
 8000be4:	f023 0301 	bic.w	r3, r3, #1
 8000be8:	041b      	lsls	r3, r3, #16
 8000bea:	0c1b      	lsrs	r3, r3, #16
 8000bec:	8183      	strh	r3, [r0, #12]
 8000bee:	4770      	bx	lr
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 8000bf0:	b29b      	uxth	r3, r3
 8000bf2:	f043 0301 	orr.w	r3, r3, #1
 8000bf6:	8183      	strh	r3, [r0, #12]
 8000bf8:	4770      	bx	lr
 8000bfa:	bf00      	nop

08000bfc <I2C_GeneralCallCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
 8000bfc:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000bfe:	b929      	cbnz	r1, 8000c0c <I2C_GeneralCallCmd+0x10>
  }
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
 8000c00:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000c04:	041b      	lsls	r3, r3, #16
 8000c06:	0c1b      	lsrs	r3, r3, #16
 8000c08:	8003      	strh	r3, [r0, #0]
 8000c0a:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ENGC;
 8000c0c:	b29b      	uxth	r3, r3
 8000c0e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000c12:	8003      	strh	r3, [r0, #0]
 8000c14:	4770      	bx	lr
 8000c16:	bf00      	nop

08000c18 <I2C_SoftwareResetCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
 8000c18:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000c1a:	b919      	cbnz	r1, 8000c24 <I2C_SoftwareResetCmd+0xc>
  }
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
 8000c1c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000c20:	8003      	strh	r3, [r0, #0]
 8000c22:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_SWRST;
 8000c24:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8000c28:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8000c2c:	b29b      	uxth	r3, r3
 8000c2e:	8003      	strh	r3, [r0, #0]
 8000c30:	4770      	bx	lr
 8000c32:	bf00      	nop

08000c34 <I2C_StretchClockCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 8000c34:	8803      	ldrh	r3, [r0, #0]
  if (NewState == DISABLE)
 8000c36:	b129      	cbz	r1, 8000c44 <I2C_StretchClockCmd+0x10>
  }
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
 8000c38:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000c3c:	041b      	lsls	r3, r3, #16
 8000c3e:	0c1b      	lsrs	r3, r3, #16
 8000c40:	8003      	strh	r3, [r0, #0]
 8000c42:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 8000c44:	b29b      	uxth	r3, r3
 8000c46:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000c4a:	8003      	strh	r3, [r0, #0]
 8000c4c:	4770      	bx	lr
 8000c4e:	bf00      	nop

08000c50 <I2C_FastModeDutyCycleConfig>:
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 8000c50:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 8000c54:	8b83      	ldrh	r3, [r0, #28]
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 8000c56:	d005      	beq.n	8000c64 <I2C_FastModeDutyCycleConfig+0x14>
    I2Cx->CCR &= I2C_DutyCycle_2;
 8000c58:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8000c5c:	041b      	lsls	r3, r3, #16
 8000c5e:	0c1b      	lsrs	r3, r3, #16
 8000c60:	8383      	strh	r3, [r0, #28]
 8000c62:	4770      	bx	lr
  }
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
 8000c64:	b29b      	uxth	r3, r3
 8000c66:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000c6a:	8383      	strh	r3, [r0, #28]
 8000c6c:	4770      	bx	lr
 8000c6e:	bf00      	nop

08000c70 <I2C_NACKPositionConfig>:
 8000c70:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8000c74:	8803      	ldrh	r3, [r0, #0]
 8000c76:	d005      	beq.n	8000c84 <I2C_NACKPositionConfig+0x14>
 8000c78:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000c7c:	041b      	lsls	r3, r3, #16
 8000c7e:	0c1b      	lsrs	r3, r3, #16
 8000c80:	8003      	strh	r3, [r0, #0]
 8000c82:	4770      	bx	lr
 8000c84:	b29b      	uxth	r3, r3
 8000c86:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000c8a:	8003      	strh	r3, [r0, #0]
 8000c8c:	4770      	bx	lr
 8000c8e:	bf00      	nop

08000c90 <I2C_SMBusAlertConfig>:
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 8000c90:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 8000c94:	8803      	ldrh	r3, [r0, #0]
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 8000c96:	d005      	beq.n	8000ca4 <I2C_SMBusAlertConfig+0x14>
  }
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
 8000c98:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8000c9c:	041b      	lsls	r3, r3, #16
 8000c9e:	0c1b      	lsrs	r3, r3, #16
 8000ca0:	8003      	strh	r3, [r0, #0]
 8000ca2:	4770      	bx	lr
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 8000ca4:	b29b      	uxth	r3, r3
 8000ca6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000caa:	8003      	strh	r3, [r0, #0]
 8000cac:	4770      	bx	lr
 8000cae:	bf00      	nop

08000cb0 <I2C_ARPCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
 8000cb0:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000cb2:	b929      	cbnz	r1, 8000cc0 <I2C_ARPCmd+0x10>
  }
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
 8000cb4:	f023 0310 	bic.w	r3, r3, #16
 8000cb8:	041b      	lsls	r3, r3, #16
 8000cba:	0c1b      	lsrs	r3, r3, #16
 8000cbc:	8003      	strh	r3, [r0, #0]
 8000cbe:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ENARP;
 8000cc0:	b29b      	uxth	r3, r3
 8000cc2:	f043 0310 	orr.w	r3, r3, #16
 8000cc6:	8003      	strh	r3, [r0, #0]
 8000cc8:	4770      	bx	lr
 8000cca:	bf00      	nop

08000ccc <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8000ccc:	8201      	strh	r1, [r0, #16]
 8000cce:	4770      	bx	lr

08000cd0 <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8000cd0:	8a00      	ldrh	r0, [r0, #16]
}
 8000cd2:	b2c0      	uxtb	r0, r0
 8000cd4:	4770      	bx	lr
 8000cd6:	bf00      	nop

08000cd8 <I2C_TransmitPEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
 8000cd8:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000cda:	b929      	cbnz	r1, 8000ce8 <I2C_TransmitPEC+0x10>
  }
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
 8000cdc:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000ce0:	041b      	lsls	r3, r3, #16
 8000ce2:	0c1b      	lsrs	r3, r3, #16
 8000ce4:	8003      	strh	r3, [r0, #0]
 8000ce6:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_PEC;
 8000ce8:	b29b      	uxth	r3, r3
 8000cea:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000cee:	8003      	strh	r3, [r0, #0]
 8000cf0:	4770      	bx	lr
 8000cf2:	bf00      	nop

08000cf4 <I2C_PECPositionConfig>:
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8000cf4:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 8000cf8:	8803      	ldrh	r3, [r0, #0]
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8000cfa:	d005      	beq.n	8000d08 <I2C_PECPositionConfig+0x14>
  }
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
 8000cfc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000d00:	041b      	lsls	r3, r3, #16
 8000d02:	0c1b      	lsrs	r3, r3, #16
 8000d04:	8003      	strh	r3, [r0, #0]
 8000d06:	4770      	bx	lr
    I2Cx->CR1 |= I2C_PECPosition_Next;
 8000d08:	b29b      	uxth	r3, r3
 8000d0a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000d0e:	8003      	strh	r3, [r0, #0]
 8000d10:	4770      	bx	lr
 8000d12:	bf00      	nop

08000d14 <I2C_CalculatePEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 8000d14:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8000d16:	b929      	cbnz	r1, 8000d24 <I2C_CalculatePEC+0x10>
  }
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
 8000d18:	f023 0320 	bic.w	r3, r3, #32
 8000d1c:	041b      	lsls	r3, r3, #16
 8000d1e:	0c1b      	lsrs	r3, r3, #16
 8000d20:	8003      	strh	r3, [r0, #0]
 8000d22:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 8000d24:	b29b      	uxth	r3, r3
 8000d26:	f043 0320 	orr.w	r3, r3, #32
 8000d2a:	8003      	strh	r3, [r0, #0]
 8000d2c:	4770      	bx	lr
 8000d2e:	bf00      	nop

08000d30 <I2C_GetPEC>:
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
 8000d30:	8b00      	ldrh	r0, [r0, #24]
}
 8000d32:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8000d36:	4770      	bx	lr

08000d38 <I2C_DMACmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 8000d38:	8883      	ldrh	r3, [r0, #4]
  if (NewState != DISABLE)
 8000d3a:	b929      	cbnz	r1, 8000d48 <I2C_DMACmd+0x10>
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
 8000d3c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000d40:	041b      	lsls	r3, r3, #16
 8000d42:	0c1b      	lsrs	r3, r3, #16
 8000d44:	8083      	strh	r3, [r0, #4]
 8000d46:	4770      	bx	lr
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 8000d48:	b29b      	uxth	r3, r3
 8000d4a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000d4e:	8083      	strh	r3, [r0, #4]
 8000d50:	4770      	bx	lr
 8000d52:	bf00      	nop

08000d54 <I2C_DMALastTransferCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
 8000d54:	8883      	ldrh	r3, [r0, #4]
  if (NewState != DISABLE)
 8000d56:	b929      	cbnz	r1, 8000d64 <I2C_DMALastTransferCmd+0x10>
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
 8000d58:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000d5c:	041b      	lsls	r3, r3, #16
 8000d5e:	0c1b      	lsrs	r3, r3, #16
 8000d60:	8083      	strh	r3, [r0, #4]
 8000d62:	4770      	bx	lr
    I2Cx->CR2 |= I2C_CR2_LAST;
 8000d64:	b29b      	uxth	r3, r3
 8000d66:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000d6a:	8083      	strh	r3, [r0, #4]
 8000d6c:	4770      	bx	lr
 8000d6e:	bf00      	nop

08000d70 <I2C_ReadRegister>:
  *            @arg I2C_Register_CCR:   CCR register.
  *            @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 8000d70:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8000d72:	2300      	movs	r3, #0
 8000d74:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 8000d76:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 8000d78:	9b01      	ldr	r3, [sp, #4]
 8000d7a:	4419      	add	r1, r3
 8000d7c:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 8000d7e:	9b01      	ldr	r3, [sp, #4]
 8000d80:	8818      	ldrh	r0, [r3, #0]
}
 8000d82:	b280      	uxth	r0, r0
 8000d84:	b002      	add	sp, #8
 8000d86:	4770      	bx	lr

08000d88 <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8000d88:	8883      	ldrh	r3, [r0, #4]
 8000d8a:	b29b      	uxth	r3, r3
  if (NewState != DISABLE)
 8000d8c:	b91a      	cbnz	r2, 8000d96 <I2C_ITConfig+0xe>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8000d8e:	ea23 0101 	bic.w	r1, r3, r1
 8000d92:	8081      	strh	r1, [r0, #4]
 8000d94:	4770      	bx	lr
    I2Cx->CR2 |= I2C_IT;
 8000d96:	4319      	orrs	r1, r3
 8000d98:	8081      	strh	r1, [r0, #4]
 8000d9a:	4770      	bx	lr

08000d9c <I2C_CheckEvent>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8000d9c:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 8000d9e:	8b00      	ldrh	r0, [r0, #24]
  flag1 = I2Cx->SR1;
 8000da0:	b29b      	uxth	r3, r3
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 8000da2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 8000da6:	f021 407f 	bic.w	r0, r1, #4278190080	; 0xff000000
 8000daa:	4018      	ands	r0, r3
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
  }
  /* Return status */
  return status;
}
 8000dac:	1a40      	subs	r0, r0, r1
 8000dae:	fab0 f080 	clz	r0, r0
 8000db2:	0940      	lsrs	r0, r0, #5
 8000db4:	4770      	bx	lr
 8000db6:	bf00      	nop

08000db8 <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8000db8:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 8000dba:	8b02      	ldrh	r2, [r0, #24]
  flag1 = I2Cx->SR1;
 8000dbc:	b298      	uxth	r0, r3
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 8000dbe:	ea40 4002 	orr.w	r0, r0, r2, lsl #16

  /* Return status */
  return lastevent;
}
 8000dc2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000dc6:	4770      	bx	lr

08000dc8 <I2C_GetFlagStatus>:
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 8000dc8:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 8000dca:	2300      	movs	r3, #0

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 8000dcc:	0f0a      	lsrs	r2, r1, #28
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 8000dce:	9300      	str	r3, [sp, #0]
 8000dd0:	9301      	str	r3, [sp, #4]
  i2cxbase = (uint32_t)I2Cx;
 8000dd2:	9001      	str	r0, [sp, #4]
  i2creg = I2C_FLAG >> 28;
 8000dd4:	9200      	str	r2, [sp, #0]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
  
  if(i2creg != 0)
 8000dd6:	9b00      	ldr	r3, [sp, #0]
  I2C_FLAG &= FLAG_MASK;
 8000dd8:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  if(i2creg != 0)
 8000ddc:	b153      	cbz	r3, 8000df4 <I2C_GetFlagStatus+0x2c>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 8000dde:	9b01      	ldr	r3, [sp, #4]
 8000de0:	3314      	adds	r3, #20
 8000de2:	9301      	str	r3, [sp, #4]
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 8000de4:	9b01      	ldr	r3, [sp, #4]
 8000de6:	681b      	ldr	r3, [r3, #0]
 8000de8:	4219      	tst	r1, r3
    bitstatus = RESET;
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
}
 8000dea:	bf14      	ite	ne
 8000dec:	2001      	movne	r0, #1
 8000dee:	2000      	moveq	r0, #0
 8000df0:	b002      	add	sp, #8
 8000df2:	4770      	bx	lr
    i2cxbase += 0x18;
 8000df4:	9b01      	ldr	r3, [sp, #4]
 8000df6:	3318      	adds	r3, #24
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 8000df8:	0c09      	lsrs	r1, r1, #16
    i2cxbase += 0x18;
 8000dfa:	9301      	str	r3, [sp, #4]
 8000dfc:	e7f2      	b.n	8000de4 <I2C_GetFlagStatus+0x1c>
 8000dfe:	bf00      	nop

08000e00 <I2C_ClearFlag>:
 8000e00:	43c9      	mvns	r1, r1
 8000e02:	b289      	uxth	r1, r1
 8000e04:	8281      	strh	r1, [r0, #20]
 8000e06:	4770      	bx	lr

08000e08 <I2C_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 8000e08:	8883      	ldrh	r3, [r0, #4]
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8000e0a:	8a80      	ldrh	r0, [r0, #20]
 8000e0c:	b280      	uxth	r0, r0
 8000e0e:	4008      	ands	r0, r1
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 8000e10:	b29b      	uxth	r3, r3
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8000e12:	d006      	beq.n	8000e22 <I2C_GetITStatus+0x1a>
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 8000e14:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8000e18:	ea13 4311 	ands.w	r3, r3, r1, lsr #16
 8000e1c:	bf14      	ite	ne
 8000e1e:	2001      	movne	r0, #1
 8000e20:	2000      	moveq	r0, #0
    /* I2C_IT is reset */
    bitstatus = RESET;
  }
  /* Return the I2C_IT status */
  return  bitstatus;
}
 8000e22:	4770      	bx	lr

08000e24 <I2C_ClearITPendingBit>:

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8000e24:	43c9      	mvns	r1, r1
 8000e26:	b289      	uxth	r1, r1
 8000e28:	8281      	strh	r1, [r0, #20]
 8000e2a:	4770      	bx	lr

08000e2c <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000e2c:	4b0a      	ldr	r3, [pc, #40]	; (8000e58 <RCC_DeInit+0x2c>)

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000e2e:	480b      	ldr	r0, [pc, #44]	; (8000e5c <RCC_DeInit+0x30>)
  RCC->CR |= (uint32_t)0x00000001;
 8000e30:	681a      	ldr	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8000e32:	2100      	movs	r1, #0
  RCC->CR |= (uint32_t)0x00000001;
 8000e34:	f042 0201 	orr.w	r2, r2, #1
 8000e38:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8000e3a:	6099      	str	r1, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000e3c:	681a      	ldr	r2, [r3, #0]
 8000e3e:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000e42:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000e46:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 8000e48:	6058      	str	r0, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000e4a:	681a      	ldr	r2, [r3, #0]
 8000e4c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000e50:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000e52:	60d9      	str	r1, [r3, #12]
 8000e54:	4770      	bx	lr
 8000e56:	bf00      	nop
 8000e58:	40023800 	.word	0x40023800
 8000e5c:	24003010 	.word	0x24003010

08000e60 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 8000e60:	4b02      	ldr	r3, [pc, #8]	; (8000e6c <RCC_HSEConfig+0xc>)
 8000e62:	2200      	movs	r2, #0
 8000e64:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 8000e66:	7018      	strb	r0, [r3, #0]
 8000e68:	4770      	bx	lr
 8000e6a:	bf00      	nop
 8000e6c:	40023802 	.word	0x40023802

08000e70 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8000e70:	b082      	sub	sp, #8
  __IO uint32_t startupcounter = 0;
 8000e72:	2300      	movs	r3, #0

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8000e74:	4a0a      	ldr	r2, [pc, #40]	; (8000ea0 <RCC_WaitForHSEStartUp+0x30>)
  __IO uint32_t startupcounter = 0;
 8000e76:	9301      	str	r3, [sp, #4]
 8000e78:	e002      	b.n	8000e80 <RCC_WaitForHSEStartUp+0x10>
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8000e7a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8000e7e:	d008      	beq.n	8000e92 <RCC_WaitForHSEStartUp+0x22>
    statusreg = RCC->CR;
 8000e80:	6813      	ldr	r3, [r2, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8000e82:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    startupcounter++;
 8000e86:	9b01      	ldr	r3, [sp, #4]
 8000e88:	f103 0301 	add.w	r3, r3, #1
 8000e8c:	9301      	str	r3, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8000e8e:	9b01      	ldr	r3, [sp, #4]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8000e90:	d0f3      	beq.n	8000e7a <RCC_WaitForHSEStartUp+0xa>
    statusreg = RCC->CR;
 8000e92:	4b03      	ldr	r3, [pc, #12]	; (8000ea0 <RCC_WaitForHSEStartUp+0x30>)
 8000e94:	6818      	ldr	r0, [r3, #0]
  return (status);
 8000e96:	f3c0 4040 	ubfx	r0, r0, #17, #1
}
 8000e9a:	b002      	add	sp, #8
 8000e9c:	4770      	bx	lr
 8000e9e:	bf00      	nop
 8000ea0:	40023800 	.word	0x40023800

08000ea4 <RCC_AdjustHSICalibrationValue>:
  tmpreg = RCC->CR;
 8000ea4:	4a03      	ldr	r2, [pc, #12]	; (8000eb4 <RCC_AdjustHSICalibrationValue+0x10>)
 8000ea6:	6813      	ldr	r3, [r2, #0]
  tmpreg &= ~RCC_CR_HSITRIM;
 8000ea8:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8000eac:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  RCC->CR = tmpreg;
 8000eb0:	6010      	str	r0, [r2, #0]
 8000eb2:	4770      	bx	lr
 8000eb4:	40023800 	.word	0x40023800

08000eb8 <RCC_HSICmd>:
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8000eb8:	4b01      	ldr	r3, [pc, #4]	; (8000ec0 <RCC_HSICmd+0x8>)
 8000eba:	6018      	str	r0, [r3, #0]
 8000ebc:	4770      	bx	lr
 8000ebe:	bf00      	nop
 8000ec0:	42470000 	.word	0x42470000

08000ec4 <RCC_LSEConfig>:
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000ec4:	4b06      	ldr	r3, [pc, #24]	; (8000ee0 <RCC_LSEConfig+0x1c>)
 8000ec6:	2200      	movs	r2, #0
  switch (RCC_LSE)
 8000ec8:	2801      	cmp	r0, #1
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000eca:	701a      	strb	r2, [r3, #0]
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8000ecc:	701a      	strb	r2, [r3, #0]
  switch (RCC_LSE)
 8000ece:	d005      	beq.n	8000edc <RCC_LSEConfig+0x18>
 8000ed0:	2804      	cmp	r0, #4
 8000ed2:	d102      	bne.n	8000eda <RCC_LSEConfig+0x16>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8000ed4:	2205      	movs	r2, #5
 8000ed6:	701a      	strb	r2, [r3, #0]
 8000ed8:	4770      	bx	lr
 8000eda:	4770      	bx	lr
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8000edc:	7018      	strb	r0, [r3, #0]
      break;
 8000ede:	4770      	bx	lr
 8000ee0:	40023870 	.word	0x40023870

08000ee4 <RCC_LSICmd>:
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8000ee4:	4b01      	ldr	r3, [pc, #4]	; (8000eec <RCC_LSICmd+0x8>)
 8000ee6:	6018      	str	r0, [r3, #0]
 8000ee8:	4770      	bx	lr
 8000eea:	bf00      	nop
 8000eec:	42470e80 	.word	0x42470e80

08000ef0 <RCC_PLLConfig>:
{
 8000ef0:	b430      	push	{r4, r5}
 8000ef2:	9c02      	ldr	r4, [sp, #8]
  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8000ef4:	4d06      	ldr	r5, [pc, #24]	; (8000f10 <RCC_PLLConfig+0x20>)
 8000ef6:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
 8000efa:	085b      	lsrs	r3, r3, #1
 8000efc:	4308      	orrs	r0, r1
 8000efe:	3b01      	subs	r3, #1
 8000f00:	ea40 1082 	orr.w	r0, r0, r2, lsl #6
 8000f04:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8000f08:	6068      	str	r0, [r5, #4]
}
 8000f0a:	bc30      	pop	{r4, r5}
 8000f0c:	4770      	bx	lr
 8000f0e:	bf00      	nop
 8000f10:	40023800 	.word	0x40023800

08000f14 <RCC_PLLCmd>:
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8000f14:	4b01      	ldr	r3, [pc, #4]	; (8000f1c <RCC_PLLCmd+0x8>)
 8000f16:	6018      	str	r0, [r3, #0]
 8000f18:	4770      	bx	lr
 8000f1a:	bf00      	nop
 8000f1c:	42470060 	.word	0x42470060

08000f20 <RCC_PLLI2SConfig>:
  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8000f20:	0709      	lsls	r1, r1, #28
 8000f22:	4b03      	ldr	r3, [pc, #12]	; (8000f30 <RCC_PLLI2SConfig+0x10>)
 8000f24:	ea41 1180 	orr.w	r1, r1, r0, lsl #6
 8000f28:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
 8000f2c:	4770      	bx	lr
 8000f2e:	bf00      	nop
 8000f30:	40023800 	.word	0x40023800

08000f34 <RCC_PLLI2SCmd>:
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 8000f34:	4b01      	ldr	r3, [pc, #4]	; (8000f3c <RCC_PLLI2SCmd+0x8>)
 8000f36:	6018      	str	r0, [r3, #0]
 8000f38:	4770      	bx	lr
 8000f3a:	bf00      	nop
 8000f3c:	42470068 	.word	0x42470068

08000f40 <RCC_ClockSecuritySystemCmd>:
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8000f40:	4b01      	ldr	r3, [pc, #4]	; (8000f48 <RCC_ClockSecuritySystemCmd+0x8>)
 8000f42:	6018      	str	r0, [r3, #0]
 8000f44:	4770      	bx	lr
 8000f46:	bf00      	nop
 8000f48:	4247004c 	.word	0x4247004c

08000f4c <RCC_MCO1Config>:
  tmpreg = RCC->CFGR;
 8000f4c:	4a03      	ldr	r2, [pc, #12]	; (8000f5c <RCC_MCO1Config+0x10>)
 8000f4e:	6893      	ldr	r3, [r2, #8]
  tmpreg &= CFGR_MCO1_RESET_MASK;
 8000f50:	f023 63ec 	bic.w	r3, r3, #123731968	; 0x7600000
 8000f54:	4319      	orrs	r1, r3
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 8000f56:	4301      	orrs	r1, r0
  RCC->CFGR = tmpreg;  
 8000f58:	6091      	str	r1, [r2, #8]
 8000f5a:	4770      	bx	lr
 8000f5c:	40023800 	.word	0x40023800

08000f60 <RCC_MCO2Config>:
  tmpreg = RCC->CFGR;
 8000f60:	4a03      	ldr	r2, [pc, #12]	; (8000f70 <RCC_MCO2Config+0x10>)
 8000f62:	6893      	ldr	r3, [r2, #8]
  tmpreg &= CFGR_MCO2_RESET_MASK;
 8000f64:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8000f68:	4319      	orrs	r1, r3
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 8000f6a:	4301      	orrs	r1, r0
  RCC->CFGR = tmpreg;  
 8000f6c:	6091      	str	r1, [r2, #8]
 8000f6e:	4770      	bx	lr
 8000f70:	40023800 	.word	0x40023800

08000f74 <RCC_SYSCLKConfig>:
  tmpreg = RCC->CFGR;
 8000f74:	4a03      	ldr	r2, [pc, #12]	; (8000f84 <RCC_SYSCLKConfig+0x10>)
 8000f76:	6893      	ldr	r3, [r2, #8]
  tmpreg &= ~RCC_CFGR_SW;
 8000f78:	f023 0303 	bic.w	r3, r3, #3
  tmpreg |= RCC_SYSCLKSource;
 8000f7c:	4318      	orrs	r0, r3
  RCC->CFGR = tmpreg;
 8000f7e:	6090      	str	r0, [r2, #8]
 8000f80:	4770      	bx	lr
 8000f82:	bf00      	nop
 8000f84:	40023800 	.word	0x40023800

08000f88 <RCC_GetSYSCLKSource>:
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8000f88:	4b02      	ldr	r3, [pc, #8]	; (8000f94 <RCC_GetSYSCLKSource+0xc>)
 8000f8a:	6898      	ldr	r0, [r3, #8]
}
 8000f8c:	f000 000c 	and.w	r0, r0, #12
 8000f90:	4770      	bx	lr
 8000f92:	bf00      	nop
 8000f94:	40023800 	.word	0x40023800

08000f98 <RCC_HCLKConfig>:
  tmpreg = RCC->CFGR;
 8000f98:	4a03      	ldr	r2, [pc, #12]	; (8000fa8 <RCC_HCLKConfig+0x10>)
 8000f9a:	6893      	ldr	r3, [r2, #8]
  tmpreg &= ~RCC_CFGR_HPRE;
 8000f9c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpreg |= RCC_SYSCLK;
 8000fa0:	4318      	orrs	r0, r3
  RCC->CFGR = tmpreg;
 8000fa2:	6090      	str	r0, [r2, #8]
 8000fa4:	4770      	bx	lr
 8000fa6:	bf00      	nop
 8000fa8:	40023800 	.word	0x40023800

08000fac <RCC_PCLK1Config>:
  tmpreg = RCC->CFGR;
 8000fac:	4a03      	ldr	r2, [pc, #12]	; (8000fbc <RCC_PCLK1Config+0x10>)
 8000fae:	6893      	ldr	r3, [r2, #8]
  tmpreg &= ~RCC_CFGR_PPRE1;
 8000fb0:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
  tmpreg |= RCC_HCLK;
 8000fb4:	4318      	orrs	r0, r3
  RCC->CFGR = tmpreg;
 8000fb6:	6090      	str	r0, [r2, #8]
 8000fb8:	4770      	bx	lr
 8000fba:	bf00      	nop
 8000fbc:	40023800 	.word	0x40023800

08000fc0 <RCC_PCLK2Config>:
  tmpreg = RCC->CFGR;
 8000fc0:	4a03      	ldr	r2, [pc, #12]	; (8000fd0 <RCC_PCLK2Config+0x10>)
 8000fc2:	6893      	ldr	r3, [r2, #8]
  tmpreg &= ~RCC_CFGR_PPRE2;
 8000fc4:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
  tmpreg |= RCC_HCLK << 3;
 8000fc8:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  RCC->CFGR = tmpreg;
 8000fcc:	6090      	str	r0, [r2, #8]
 8000fce:	4770      	bx	lr
 8000fd0:	40023800 	.word	0x40023800

08000fd4 <RCC_GetClocksFreq>:
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000fd4:	4a1f      	ldr	r2, [pc, #124]	; (8001054 <RCC_GetClocksFreq+0x80>)
 8000fd6:	6893      	ldr	r3, [r2, #8]
 8000fd8:	f003 030c 	and.w	r3, r3, #12
  switch (tmp)
 8000fdc:	2b04      	cmp	r3, #4
{
 8000fde:	b410      	push	{r4}
  switch (tmp)
 8000fe0:	d01b      	beq.n	800101a <RCC_GetClocksFreq+0x46>
 8000fe2:	2b08      	cmp	r3, #8
 8000fe4:	d01c      	beq.n	8001020 <RCC_GetClocksFreq+0x4c>
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8000fe6:	4b1c      	ldr	r3, [pc, #112]	; (8001058 <RCC_GetClocksFreq+0x84>)
 8000fe8:	6003      	str	r3, [r0, #0]
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8000fea:	4a1a      	ldr	r2, [pc, #104]	; (8001054 <RCC_GetClocksFreq+0x80>)
  presc = APBAHBPrescTable[tmp];
 8000fec:	491b      	ldr	r1, [pc, #108]	; (800105c <RCC_GetClocksFreq+0x88>)
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8000fee:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 4;
 8000ff0:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 8000ff4:	5d0c      	ldrb	r4, [r1, r4]
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8000ff6:	40e3      	lsrs	r3, r4
 8000ff8:	6043      	str	r3, [r0, #4]
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8000ffa:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 10;
 8000ffc:	f3c4 2482 	ubfx	r4, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 8001000:	5d0c      	ldrb	r4, [r1, r4]
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001002:	fa23 f404 	lsr.w	r4, r3, r4
 8001006:	6084      	str	r4, [r0, #8]
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8001008:	6892      	ldr	r2, [r2, #8]
}
 800100a:	f85d 4b04 	ldr.w	r4, [sp], #4
  tmp = tmp >> 13;
 800100e:	f3c2 3242 	ubfx	r2, r2, #13, #3
  presc = APBAHBPrescTable[tmp];
 8001012:	5c8a      	ldrb	r2, [r1, r2]
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001014:	40d3      	lsrs	r3, r2
 8001016:	60c3      	str	r3, [r0, #12]
}
 8001018:	4770      	bx	lr
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800101a:	4b11      	ldr	r3, [pc, #68]	; (8001060 <RCC_GetClocksFreq+0x8c>)
 800101c:	6003      	str	r3, [r0, #0]
      break;
 800101e:	e7e4      	b.n	8000fea <RCC_GetClocksFreq+0x16>
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8001020:	6854      	ldr	r4, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001022:	6851      	ldr	r1, [r2, #4]
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001024:	6852      	ldr	r2, [r2, #4]
      if (pllsource != 0)
 8001026:	0263      	lsls	r3, r4, #9
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001028:	f3c2 1288 	ubfx	r2, r2, #6, #9
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800102c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8001030:	bf4c      	ite	mi
 8001032:	4b0b      	ldrmi	r3, [pc, #44]	; (8001060 <RCC_GetClocksFreq+0x8c>)
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8001034:	4b08      	ldrpl	r3, [pc, #32]	; (8001058 <RCC_GetClocksFreq+0x84>)
 8001036:	fbb3 f3f1 	udiv	r3, r3, r1
 800103a:	fb03 f302 	mul.w	r3, r3, r2
      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800103e:	4a05      	ldr	r2, [pc, #20]	; (8001054 <RCC_GetClocksFreq+0x80>)
 8001040:	6852      	ldr	r2, [r2, #4]
 8001042:	f3c2 4201 	ubfx	r2, r2, #16, #2
 8001046:	3201      	adds	r2, #1
 8001048:	0052      	lsls	r2, r2, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 800104a:	fbb3 f3f2 	udiv	r3, r3, r2
 800104e:	6003      	str	r3, [r0, #0]
      break;
 8001050:	e7cb      	b.n	8000fea <RCC_GetClocksFreq+0x16>
 8001052:	bf00      	nop
 8001054:	40023800 	.word	0x40023800
 8001058:	00f42400 	.word	0x00f42400
 800105c:	20000014 	.word	0x20000014
 8001060:	007a1200 	.word	0x007a1200

08001064 <RCC_RTCCLKConfig>:
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8001064:	f400 7340 	and.w	r3, r0, #768	; 0x300
 8001068:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800106c:	d109      	bne.n	8001082 <RCC_RTCCLKConfig+0x1e>
    tmpreg = RCC->CFGR;
 800106e:	4908      	ldr	r1, [pc, #32]	; (8001090 <RCC_RTCCLKConfig+0x2c>)
 8001070:	688a      	ldr	r2, [r1, #8]
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8001072:	f020 4370 	bic.w	r3, r0, #4026531840	; 0xf0000000
    tmpreg &= ~RCC_CFGR_RTCPRE;
 8001076:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 800107a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800107e:	4313      	orrs	r3, r2
    RCC->CFGR = tmpreg;
 8001080:	608b      	str	r3, [r1, #8]
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 8001082:	4b03      	ldr	r3, [pc, #12]	; (8001090 <RCC_RTCCLKConfig+0x2c>)
 8001084:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001086:	f3c0 000b 	ubfx	r0, r0, #0, #12
 800108a:	4310      	orrs	r0, r2
 800108c:	6718      	str	r0, [r3, #112]	; 0x70
 800108e:	4770      	bx	lr
 8001090:	40023800 	.word	0x40023800

08001094 <RCC_RTCCLKCmd>:
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8001094:	4b01      	ldr	r3, [pc, #4]	; (800109c <RCC_RTCCLKCmd+0x8>)
 8001096:	6018      	str	r0, [r3, #0]
 8001098:	4770      	bx	lr
 800109a:	bf00      	nop
 800109c:	42470e3c 	.word	0x42470e3c

080010a0 <RCC_BackupResetCmd>:
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80010a0:	4b01      	ldr	r3, [pc, #4]	; (80010a8 <RCC_BackupResetCmd+0x8>)
 80010a2:	6018      	str	r0, [r3, #0]
 80010a4:	4770      	bx	lr
 80010a6:	bf00      	nop
 80010a8:	42470e40 	.word	0x42470e40

080010ac <RCC_I2SCLKConfig>:
  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 80010ac:	4b01      	ldr	r3, [pc, #4]	; (80010b4 <RCC_I2SCLKConfig+0x8>)
 80010ae:	6018      	str	r0, [r3, #0]
 80010b0:	4770      	bx	lr
 80010b2:	bf00      	nop
 80010b4:	4247015c 	.word	0x4247015c

080010b8 <RCC_AHB1PeriphClockCmd>:
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80010b8:	4a04      	ldr	r2, [pc, #16]	; (80010cc <RCC_AHB1PeriphClockCmd+0x14>)
 80010ba:	6b13      	ldr	r3, [r2, #48]	; 0x30
  if (NewState != DISABLE)
 80010bc:	b919      	cbnz	r1, 80010c6 <RCC_AHB1PeriphClockCmd+0xe>
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80010be:	ea23 0000 	bic.w	r0, r3, r0
 80010c2:	6310      	str	r0, [r2, #48]	; 0x30
 80010c4:	4770      	bx	lr
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80010c6:	4318      	orrs	r0, r3
 80010c8:	6310      	str	r0, [r2, #48]	; 0x30
 80010ca:	4770      	bx	lr
 80010cc:	40023800 	.word	0x40023800

080010d0 <RCC_AHB2PeriphClockCmd>:
    RCC->AHB2ENR |= RCC_AHB2Periph;
 80010d0:	4a04      	ldr	r2, [pc, #16]	; (80010e4 <RCC_AHB2PeriphClockCmd+0x14>)
 80010d2:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (NewState != DISABLE)
 80010d4:	b919      	cbnz	r1, 80010de <RCC_AHB2PeriphClockCmd+0xe>
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 80010d6:	ea23 0000 	bic.w	r0, r3, r0
 80010da:	6350      	str	r0, [r2, #52]	; 0x34
 80010dc:	4770      	bx	lr
    RCC->AHB2ENR |= RCC_AHB2Periph;
 80010de:	4318      	orrs	r0, r3
 80010e0:	6350      	str	r0, [r2, #52]	; 0x34
 80010e2:	4770      	bx	lr
 80010e4:	40023800 	.word	0x40023800

080010e8 <RCC_AHB3PeriphClockCmd>:
    RCC->AHB3ENR |= RCC_AHB3Periph;
 80010e8:	4a04      	ldr	r2, [pc, #16]	; (80010fc <RCC_AHB3PeriphClockCmd+0x14>)
 80010ea:	6b93      	ldr	r3, [r2, #56]	; 0x38
  if (NewState != DISABLE)
 80010ec:	b919      	cbnz	r1, 80010f6 <RCC_AHB3PeriphClockCmd+0xe>
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 80010ee:	ea23 0000 	bic.w	r0, r3, r0
 80010f2:	6390      	str	r0, [r2, #56]	; 0x38
 80010f4:	4770      	bx	lr
    RCC->AHB3ENR |= RCC_AHB3Periph;
 80010f6:	4318      	orrs	r0, r3
 80010f8:	6390      	str	r0, [r2, #56]	; 0x38
 80010fa:	4770      	bx	lr
 80010fc:	40023800 	.word	0x40023800

08001100 <RCC_APB1PeriphClockCmd>:
    RCC->APB1ENR |= RCC_APB1Periph;
 8001100:	4a04      	ldr	r2, [pc, #16]	; (8001114 <RCC_APB1PeriphClockCmd+0x14>)
 8001102:	6c13      	ldr	r3, [r2, #64]	; 0x40
  if (NewState != DISABLE)
 8001104:	b919      	cbnz	r1, 800110e <RCC_APB1PeriphClockCmd+0xe>
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8001106:	ea23 0000 	bic.w	r0, r3, r0
 800110a:	6410      	str	r0, [r2, #64]	; 0x40
 800110c:	4770      	bx	lr
    RCC->APB1ENR |= RCC_APB1Periph;
 800110e:	4318      	orrs	r0, r3
 8001110:	6410      	str	r0, [r2, #64]	; 0x40
 8001112:	4770      	bx	lr
 8001114:	40023800 	.word	0x40023800

08001118 <RCC_APB2PeriphClockCmd>:
    RCC->APB2ENR |= RCC_APB2Periph;
 8001118:	4a04      	ldr	r2, [pc, #16]	; (800112c <RCC_APB2PeriphClockCmd+0x14>)
 800111a:	6c53      	ldr	r3, [r2, #68]	; 0x44
  if (NewState != DISABLE)
 800111c:	b919      	cbnz	r1, 8001126 <RCC_APB2PeriphClockCmd+0xe>
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800111e:	ea23 0000 	bic.w	r0, r3, r0
 8001122:	6450      	str	r0, [r2, #68]	; 0x44
 8001124:	4770      	bx	lr
    RCC->APB2ENR |= RCC_APB2Periph;
 8001126:	4318      	orrs	r0, r3
 8001128:	6450      	str	r0, [r2, #68]	; 0x44
 800112a:	4770      	bx	lr
 800112c:	40023800 	.word	0x40023800

08001130 <RCC_AHB1PeriphResetCmd>:
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8001130:	4a04      	ldr	r2, [pc, #16]	; (8001144 <RCC_AHB1PeriphResetCmd+0x14>)
 8001132:	6913      	ldr	r3, [r2, #16]
  if (NewState != DISABLE)
 8001134:	b919      	cbnz	r1, 800113e <RCC_AHB1PeriphResetCmd+0xe>
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8001136:	ea23 0000 	bic.w	r0, r3, r0
 800113a:	6110      	str	r0, [r2, #16]
 800113c:	4770      	bx	lr
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 800113e:	4318      	orrs	r0, r3
 8001140:	6110      	str	r0, [r2, #16]
 8001142:	4770      	bx	lr
 8001144:	40023800 	.word	0x40023800

08001148 <RCC_AHB2PeriphResetCmd>:
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8001148:	4a04      	ldr	r2, [pc, #16]	; (800115c <RCC_AHB2PeriphResetCmd+0x14>)
 800114a:	6953      	ldr	r3, [r2, #20]
  if (NewState != DISABLE)
 800114c:	b919      	cbnz	r1, 8001156 <RCC_AHB2PeriphResetCmd+0xe>
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 800114e:	ea23 0000 	bic.w	r0, r3, r0
 8001152:	6150      	str	r0, [r2, #20]
 8001154:	4770      	bx	lr
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8001156:	4318      	orrs	r0, r3
 8001158:	6150      	str	r0, [r2, #20]
 800115a:	4770      	bx	lr
 800115c:	40023800 	.word	0x40023800

08001160 <RCC_AHB3PeriphResetCmd>:
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8001160:	4a04      	ldr	r2, [pc, #16]	; (8001174 <RCC_AHB3PeriphResetCmd+0x14>)
 8001162:	6993      	ldr	r3, [r2, #24]
  if (NewState != DISABLE)
 8001164:	b919      	cbnz	r1, 800116e <RCC_AHB3PeriphResetCmd+0xe>
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 8001166:	ea23 0000 	bic.w	r0, r3, r0
 800116a:	6190      	str	r0, [r2, #24]
 800116c:	4770      	bx	lr
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 800116e:	4318      	orrs	r0, r3
 8001170:	6190      	str	r0, [r2, #24]
 8001172:	4770      	bx	lr
 8001174:	40023800 	.word	0x40023800

08001178 <RCC_APB1PeriphResetCmd>:
    RCC->APB1RSTR |= RCC_APB1Periph;
 8001178:	4a04      	ldr	r2, [pc, #16]	; (800118c <RCC_APB1PeriphResetCmd+0x14>)
 800117a:	6a13      	ldr	r3, [r2, #32]
  if (NewState != DISABLE)
 800117c:	b919      	cbnz	r1, 8001186 <RCC_APB1PeriphResetCmd+0xe>
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 800117e:	ea23 0000 	bic.w	r0, r3, r0
 8001182:	6210      	str	r0, [r2, #32]
 8001184:	4770      	bx	lr
    RCC->APB1RSTR |= RCC_APB1Periph;
 8001186:	4318      	orrs	r0, r3
 8001188:	6210      	str	r0, [r2, #32]
 800118a:	4770      	bx	lr
 800118c:	40023800 	.word	0x40023800

08001190 <RCC_APB2PeriphResetCmd>:
    RCC->APB2RSTR |= RCC_APB2Periph;
 8001190:	4a04      	ldr	r2, [pc, #16]	; (80011a4 <RCC_APB2PeriphResetCmd+0x14>)
 8001192:	6a53      	ldr	r3, [r2, #36]	; 0x24
  if (NewState != DISABLE)
 8001194:	b919      	cbnz	r1, 800119e <RCC_APB2PeriphResetCmd+0xe>
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8001196:	ea23 0000 	bic.w	r0, r3, r0
 800119a:	6250      	str	r0, [r2, #36]	; 0x24
 800119c:	4770      	bx	lr
    RCC->APB2RSTR |= RCC_APB2Periph;
 800119e:	4318      	orrs	r0, r3
 80011a0:	6250      	str	r0, [r2, #36]	; 0x24
 80011a2:	4770      	bx	lr
 80011a4:	40023800 	.word	0x40023800

080011a8 <RCC_AHB1PeriphClockLPModeCmd>:
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 80011a8:	4a04      	ldr	r2, [pc, #16]	; (80011bc <RCC_AHB1PeriphClockLPModeCmd+0x14>)
 80011aa:	6d13      	ldr	r3, [r2, #80]	; 0x50
  if (NewState != DISABLE)
 80011ac:	b919      	cbnz	r1, 80011b6 <RCC_AHB1PeriphClockLPModeCmd+0xe>
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 80011ae:	ea23 0000 	bic.w	r0, r3, r0
 80011b2:	6510      	str	r0, [r2, #80]	; 0x50
 80011b4:	4770      	bx	lr
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 80011b6:	4318      	orrs	r0, r3
 80011b8:	6510      	str	r0, [r2, #80]	; 0x50
 80011ba:	4770      	bx	lr
 80011bc:	40023800 	.word	0x40023800

080011c0 <RCC_AHB2PeriphClockLPModeCmd>:
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 80011c0:	4a04      	ldr	r2, [pc, #16]	; (80011d4 <RCC_AHB2PeriphClockLPModeCmd+0x14>)
 80011c2:	6d53      	ldr	r3, [r2, #84]	; 0x54
  if (NewState != DISABLE)
 80011c4:	b919      	cbnz	r1, 80011ce <RCC_AHB2PeriphClockLPModeCmd+0xe>
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 80011c6:	ea23 0000 	bic.w	r0, r3, r0
 80011ca:	6550      	str	r0, [r2, #84]	; 0x54
 80011cc:	4770      	bx	lr
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 80011ce:	4318      	orrs	r0, r3
 80011d0:	6550      	str	r0, [r2, #84]	; 0x54
 80011d2:	4770      	bx	lr
 80011d4:	40023800 	.word	0x40023800

080011d8 <RCC_AHB3PeriphClockLPModeCmd>:
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 80011d8:	4a04      	ldr	r2, [pc, #16]	; (80011ec <RCC_AHB3PeriphClockLPModeCmd+0x14>)
 80011da:	6d93      	ldr	r3, [r2, #88]	; 0x58
  if (NewState != DISABLE)
 80011dc:	b919      	cbnz	r1, 80011e6 <RCC_AHB3PeriphClockLPModeCmd+0xe>
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 80011de:	ea23 0000 	bic.w	r0, r3, r0
 80011e2:	6590      	str	r0, [r2, #88]	; 0x58
 80011e4:	4770      	bx	lr
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 80011e6:	4318      	orrs	r0, r3
 80011e8:	6590      	str	r0, [r2, #88]	; 0x58
 80011ea:	4770      	bx	lr
 80011ec:	40023800 	.word	0x40023800

080011f0 <RCC_APB1PeriphClockLPModeCmd>:
    RCC->APB1LPENR |= RCC_APB1Periph;
 80011f0:	4a04      	ldr	r2, [pc, #16]	; (8001204 <RCC_APB1PeriphClockLPModeCmd+0x14>)
 80011f2:	6e13      	ldr	r3, [r2, #96]	; 0x60
  if (NewState != DISABLE)
 80011f4:	b919      	cbnz	r1, 80011fe <RCC_APB1PeriphClockLPModeCmd+0xe>
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 80011f6:	ea23 0000 	bic.w	r0, r3, r0
 80011fa:	6610      	str	r0, [r2, #96]	; 0x60
 80011fc:	4770      	bx	lr
    RCC->APB1LPENR |= RCC_APB1Periph;
 80011fe:	4318      	orrs	r0, r3
 8001200:	6610      	str	r0, [r2, #96]	; 0x60
 8001202:	4770      	bx	lr
 8001204:	40023800 	.word	0x40023800

08001208 <RCC_APB2PeriphClockLPModeCmd>:
    RCC->APB2LPENR |= RCC_APB2Periph;
 8001208:	4a04      	ldr	r2, [pc, #16]	; (800121c <RCC_APB2PeriphClockLPModeCmd+0x14>)
 800120a:	6e53      	ldr	r3, [r2, #100]	; 0x64
  if (NewState != DISABLE)
 800120c:	b919      	cbnz	r1, 8001216 <RCC_APB2PeriphClockLPModeCmd+0xe>
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 800120e:	ea23 0000 	bic.w	r0, r3, r0
 8001212:	6650      	str	r0, [r2, #100]	; 0x64
 8001214:	4770      	bx	lr
    RCC->APB2LPENR |= RCC_APB2Periph;
 8001216:	4318      	orrs	r0, r3
 8001218:	6650      	str	r0, [r2, #100]	; 0x64
 800121a:	4770      	bx	lr
 800121c:	40023800 	.word	0x40023800

08001220 <RCC_ITConfig>:
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8001220:	4a04      	ldr	r2, [pc, #16]	; (8001234 <RCC_ITConfig+0x14>)
 8001222:	7813      	ldrb	r3, [r2, #0]
  if (NewState != DISABLE)
 8001224:	b919      	cbnz	r1, 800122e <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8001226:	ea23 0000 	bic.w	r0, r3, r0
 800122a:	7010      	strb	r0, [r2, #0]
 800122c:	4770      	bx	lr
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800122e:	4318      	orrs	r0, r3
 8001230:	7010      	strb	r0, [r2, #0]
 8001232:	4770      	bx	lr
 8001234:	4002380d 	.word	0x4002380d

08001238 <RCC_GetFlagStatus>:
  tmp = RCC_FLAG >> 5;
 8001238:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 800123a:	2b01      	cmp	r3, #1
 800123c:	d00b      	beq.n	8001256 <RCC_GetFlagStatus+0x1e>
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800123e:	2b02      	cmp	r3, #2
    statusreg = RCC->BDCR;
 8001240:	4b09      	ldr	r3, [pc, #36]	; (8001268 <RCC_GetFlagStatus+0x30>)
 8001242:	bf0c      	ite	eq
 8001244:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
    statusreg = RCC->CSR;
 8001246:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
  tmp = RCC_FLAG & FLAG_MASK;
 8001248:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800124c:	fa23 f000 	lsr.w	r0, r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8001250:	f000 0001 	and.w	r0, r0, #1
 8001254:	4770      	bx	lr
    statusreg = RCC->CR;
 8001256:	4b04      	ldr	r3, [pc, #16]	; (8001268 <RCC_GetFlagStatus+0x30>)
 8001258:	681b      	ldr	r3, [r3, #0]
  tmp = RCC_FLAG & FLAG_MASK;
 800125a:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800125e:	fa23 f000 	lsr.w	r0, r3, r0
}
 8001262:	f000 0001 	and.w	r0, r0, #1
 8001266:	4770      	bx	lr
 8001268:	40023800 	.word	0x40023800

0800126c <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 800126c:	4a02      	ldr	r2, [pc, #8]	; (8001278 <RCC_ClearFlag+0xc>)
 800126e:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8001270:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001274:	6753      	str	r3, [r2, #116]	; 0x74
 8001276:	4770      	bx	lr
 8001278:	40023800 	.word	0x40023800

0800127c <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 800127c:	4b03      	ldr	r3, [pc, #12]	; (800128c <RCC_GetITStatus+0x10>)
 800127e:	68db      	ldr	r3, [r3, #12]
 8001280:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 8001282:	bf14      	ite	ne
 8001284:	2001      	movne	r0, #1
 8001286:	2000      	moveq	r0, #0
 8001288:	4770      	bx	lr
 800128a:	bf00      	nop
 800128c:	40023800 	.word	0x40023800

08001290 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8001290:	4b01      	ldr	r3, [pc, #4]	; (8001298 <RCC_ClearITPendingBit+0x8>)
 8001292:	7018      	strb	r0, [r3, #0]
 8001294:	4770      	bx	lr
 8001296:	bf00      	nop
 8001298:	4002380e 	.word	0x4002380e

0800129c <SPI_I2S_DeInit>:
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 800129c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 800129e:	4b17      	ldr	r3, [pc, #92]	; (80012fc <SPI_I2S_DeInit+0x60>)
 80012a0:	4298      	cmp	r0, r3
 80012a2:	d012      	beq.n	80012ca <SPI_I2S_DeInit+0x2e>
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
  }
  else if (SPIx == SPI2)
 80012a4:	4b16      	ldr	r3, [pc, #88]	; (8001300 <SPI_I2S_DeInit+0x64>)
 80012a6:	4298      	cmp	r0, r3
 80012a8:	d01b      	beq.n	80012e2 <SPI_I2S_DeInit+0x46>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
    }
  else
  {
    if (SPIx == SPI3)
 80012aa:	4b16      	ldr	r3, [pc, #88]	; (8001304 <SPI_I2S_DeInit+0x68>)
 80012ac:	4298      	cmp	r0, r3
 80012ae:	d000      	beq.n	80012b2 <SPI_I2S_DeInit+0x16>
 80012b0:	bd08      	pop	{r3, pc}
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 80012b2:	2101      	movs	r1, #1
 80012b4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80012b8:	f7ff ff5e 	bl	8001178 <RCC_APB1PeriphResetCmd>
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 80012bc:	2100      	movs	r1, #0
 80012be:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    }
  }
}
 80012c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 80012c6:	f7ff bf57 	b.w	8001178 <RCC_APB1PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 80012ca:	2101      	movs	r1, #1
 80012cc:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80012d0:	f7ff ff5e 	bl	8001190 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 80012d4:	2100      	movs	r1, #0
 80012d6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
 80012da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 80012de:	f7ff bf57 	b.w	8001190 <RCC_APB2PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 80012e2:	2101      	movs	r1, #1
 80012e4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80012e8:	f7ff ff46 	bl	8001178 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 80012ec:	2100      	movs	r1, #0
 80012ee:	f44f 4080 	mov.w	r0, #16384	; 0x4000
}
 80012f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 80012f6:	f7ff bf3f 	b.w	8001178 <RCC_APB1PeriphResetCmd>
 80012fa:	bf00      	nop
 80012fc:	40013000 	.word	0x40013000
 8001300:	40003800 	.word	0x40003800
 8001304:	40003c00 	.word	0x40003c00

08001308 <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001308:	880a      	ldrh	r2, [r1, #0]
 800130a:	884b      	ldrh	r3, [r1, #2]
{
 800130c:	b4f0      	push	{r4, r5, r6, r7}
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800130e:	888f      	ldrh	r7, [r1, #4]
 8001310:	88cd      	ldrh	r5, [r1, #6]
 8001312:	890c      	ldrh	r4, [r1, #8]
 8001314:	894e      	ldrh	r6, [r1, #10]
 8001316:	4313      	orrs	r3, r2
 8001318:	433b      	orrs	r3, r7
 800131a:	432b      	orrs	r3, r5
 800131c:	4323      	orrs	r3, r4
 800131e:	898d      	ldrh	r5, [r1, #12]
 8001320:	89cc      	ldrh	r4, [r1, #14]
  tmpreg = SPIx->CR1;
 8001322:	8802      	ldrh	r2, [r0, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8001324:	8a09      	ldrh	r1, [r1, #16]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001326:	4333      	orrs	r3, r6
 8001328:	432b      	orrs	r3, r5
 800132a:	4323      	orrs	r3, r4
  tmpreg &= CR1_CLEAR_MASK;
 800132c:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8001330:	4313      	orrs	r3, r2
 8001332:	b29b      	uxth	r3, r3
  SPIx->CR1 = tmpreg;
 8001334:	8003      	strh	r3, [r0, #0]
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8001336:	8b83      	ldrh	r3, [r0, #28]
 8001338:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800133c:	041b      	lsls	r3, r3, #16
 800133e:	0c1b      	lsrs	r3, r3, #16
 8001340:	8383      	strh	r3, [r0, #28]
}
 8001342:	bcf0      	pop	{r4, r5, r6, r7}
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8001344:	8201      	strh	r1, [r0, #16]
}
 8001346:	4770      	bx	lr

08001348 <I2S_Init>:
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001348:	8b83      	ldrh	r3, [r0, #28]
 800134a:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 800134e:	f023 030f 	bic.w	r3, r3, #15
 8001352:	041b      	lsls	r3, r3, #16
  SPIx->I2SPR = 0x0002;
 8001354:	2202      	movs	r2, #2
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001356:	0c1b      	lsrs	r3, r3, #16
{
 8001358:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 800135c:	688f      	ldr	r7, [r1, #8]
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800135e:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 8001360:	8402      	strh	r2, [r0, #32]
  tmpreg = SPIx->I2SCFGR;
 8001362:	8b84      	ldrh	r4, [r0, #28]
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8001364:	4297      	cmp	r7, r2
  tmpreg = SPIx->I2SCFGR;
 8001366:	b2a4      	uxth	r4, r4
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8001368:	d04f      	beq.n	800140a <I2S_Init+0xc2>
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 800136a:	4b2a      	ldr	r3, [pc, #168]	; (8001414 <I2S_Init+0xcc>)
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 800136c:	888d      	ldrh	r5, [r1, #4]
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 800136e:	689a      	ldr	r2, [r3, #8]
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 8001370:	2d00      	cmp	r5, #0
 8001372:	bf0c      	ite	eq
 8001374:	f04f 0c20 	moveq.w	ip, #32
 8001378:	f04f 0c40 	movne.w	ip, #64	; 0x40
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 800137c:	0212      	lsls	r2, r2, #8
 800137e:	d43f      	bmi.n	8001400 <I2S_Init+0xb8>
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8001380:	4e24      	ldr	r6, [pc, #144]	; (8001414 <I2S_Init+0xcc>)
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
    
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8001382:	4a25      	ldr	r2, [pc, #148]	; (8001418 <I2S_Init+0xd0>)
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8001384:	f8d6 e084 	ldr.w	lr, [r6, #132]	; 0x84
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 8001388:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 800138c:	f8d6 8004 	ldr.w	r8, [r6, #4]
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8001390:	88ce      	ldrh	r6, [r1, #6]
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8001392:	f3ce 1e88 	ubfx	lr, lr, #6, #9
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8001396:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 800139a:	f3c3 7302 	ubfx	r3, r3, #28, #3
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 800139e:	f008 083f 	and.w	r8, r8, #63	; 0x3f
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 80013a2:	fbb2 f2f8 	udiv	r2, r2, r8
 80013a6:	fb02 f20e 	mul.w	r2, r2, lr
 80013aa:	fbb2 f2f3 	udiv	r2, r2, r3
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 80013ae:	bf0c      	ite	eq
 80013b0:	0a12      	lsreq	r2, r2, #8
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 80013b2:	fbb2 f2fc 	udivne	r2, r2, ip
 80013b6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80013ba:	0053      	lsls	r3, r2, #1
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 80013bc:	4a17      	ldr	r2, [pc, #92]	; (800141c <I2S_Init+0xd4>)
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 80013be:	fbb3 f3f7 	udiv	r3, r3, r7
 80013c2:	3305      	adds	r3, #5
 80013c4:	b29b      	uxth	r3, r3
    tmp = tmp / 10;  
 80013c6:	fba2 2303 	umull	r2, r3, r2, r3
 80013ca:	08db      	lsrs	r3, r3, #3
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 80013cc:	085f      	lsrs	r7, r3, #1
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 80013ce:	1eba      	subs	r2, r7, #2
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 80013d0:	f003 0301 	and.w	r3, r3, #1
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 80013d4:	2afd      	cmp	r2, #253	; 0xfd
 80013d6:	bf94      	ite	ls
 80013d8:	ea47 2303 	orrls.w	r3, r7, r3, lsl #8
 80013dc:	2302      	movhi	r3, #2
 80013de:	f8b1 e000 	ldrh.w	lr, [r1]
 80013e2:	884f      	ldrh	r7, [r1, #2]
 80013e4:	898a      	ldrh	r2, [r1, #12]
 80013e6:	ea4e 0107 	orr.w	r1, lr, r7
 80013ea:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 80013ee:	4311      	orrs	r1, r2
 80013f0:	430c      	orrs	r4, r1
 80013f2:	b2a4      	uxth	r4, r4
    i2sdiv = 2;
    i2sodd = 0;
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 80013f4:	4333      	orrs	r3, r6
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 80013f6:	432c      	orrs	r4, r5
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 80013f8:	8403      	strh	r3, [r0, #32]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;
 80013fa:	8384      	strh	r4, [r0, #28]
 80013fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
 8001400:	689a      	ldr	r2, [r3, #8]
 8001402:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8001406:	609a      	str	r2, [r3, #8]
 8001408:	e7ba      	b.n	8001380 <I2S_Init+0x38>
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 800140a:	463b      	mov	r3, r7
 800140c:	888d      	ldrh	r5, [r1, #4]
 800140e:	88ce      	ldrh	r6, [r1, #6]
 8001410:	e7e5      	b.n	80013de <I2S_Init+0x96>
 8001412:	bf00      	nop
 8001414:	40023800 	.word	0x40023800
 8001418:	007a1200 	.word	0x007a1200
 800141c:	cccccccd 	.word	0xcccccccd

08001420 <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8001420:	2300      	movs	r3, #0
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8001422:	2207      	movs	r2, #7
 8001424:	8202      	strh	r2, [r0, #16]
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8001426:	8003      	strh	r3, [r0, #0]
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8001428:	8043      	strh	r3, [r0, #2]
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 800142a:	8083      	strh	r3, [r0, #4]
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 800142c:	80c3      	strh	r3, [r0, #6]
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 800142e:	8103      	strh	r3, [r0, #8]
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 8001430:	8143      	strh	r3, [r0, #10]
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8001432:	8183      	strh	r3, [r0, #12]
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 8001434:	81c3      	strh	r3, [r0, #14]
 8001436:	4770      	bx	lr

08001438 <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8001438:	2300      	movs	r3, #0
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 800143a:	2202      	movs	r2, #2
 800143c:	6082      	str	r2, [r0, #8]
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 800143e:	6003      	str	r3, [r0, #0]
 8001440:	6043      	str	r3, [r0, #4]
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 8001442:	8183      	strh	r3, [r0, #12]
 8001444:	4770      	bx	lr
 8001446:	bf00      	nop

08001448 <SPI_Cmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8001448:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 800144a:	b929      	cbnz	r1, 8001458 <SPI_Cmd+0x10>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 800144c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001450:	041b      	lsls	r3, r3, #16
 8001452:	0c1b      	lsrs	r3, r3, #16
 8001454:	8003      	strh	r3, [r0, #0]
 8001456:	4770      	bx	lr
    SPIx->CR1 |= SPI_CR1_SPE;
 8001458:	b29b      	uxth	r3, r3
 800145a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800145e:	8003      	strh	r3, [r0, #0]
 8001460:	4770      	bx	lr
 8001462:	bf00      	nop

08001464 <I2S_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8001464:	8b83      	ldrh	r3, [r0, #28]
  if (NewState != DISABLE)
 8001466:	b929      	cbnz	r1, 8001474 <I2S_Cmd+0x10>
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 8001468:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800146c:	041b      	lsls	r3, r3, #16
 800146e:	0c1b      	lsrs	r3, r3, #16
 8001470:	8383      	strh	r3, [r0, #28]
 8001472:	4770      	bx	lr
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8001474:	b29b      	uxth	r3, r3
 8001476:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800147a:	8383      	strh	r3, [r0, #28]
 800147c:	4770      	bx	lr
 800147e:	bf00      	nop

08001480 <SPI_DataSizeConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
 8001480:	8803      	ldrh	r3, [r0, #0]
 8001482:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001486:	041b      	lsls	r3, r3, #16
 8001488:	0c1b      	lsrs	r3, r3, #16
 800148a:	8003      	strh	r3, [r0, #0]
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
 800148c:	8803      	ldrh	r3, [r0, #0]
 800148e:	b29b      	uxth	r3, r3
 8001490:	4319      	orrs	r1, r3
 8001492:	8001      	strh	r1, [r0, #0]
 8001494:	4770      	bx	lr
 8001496:	bf00      	nop

08001498 <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8001498:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 800149c:	8803      	ldrh	r3, [r0, #0]
  if (SPI_Direction == SPI_Direction_Tx)
 800149e:	d005      	beq.n	80014ac <SPI_BiDirectionalLineConfig+0x14>
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 80014a0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80014a4:	041b      	lsls	r3, r3, #16
 80014a6:	0c1b      	lsrs	r3, r3, #16
 80014a8:	8003      	strh	r3, [r0, #0]
 80014aa:	4770      	bx	lr
    SPIx->CR1 |= SPI_Direction_Tx;
 80014ac:	b29b      	uxth	r3, r3
 80014ae:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80014b2:	8003      	strh	r3, [r0, #0]
 80014b4:	4770      	bx	lr
 80014b6:	bf00      	nop

080014b8 <SPI_NSSInternalSoftwareConfig>:
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 80014b8:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 80014bc:	4299      	cmp	r1, r3
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 80014be:	8803      	ldrh	r3, [r0, #0]
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 80014c0:	d004      	beq.n	80014cc <SPI_NSSInternalSoftwareConfig+0x14>
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 80014c2:	b29b      	uxth	r3, r3
 80014c4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80014c8:	8003      	strh	r3, [r0, #0]
 80014ca:	4770      	bx	lr
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 80014cc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80014d0:	041b      	lsls	r3, r3, #16
 80014d2:	0c1b      	lsrs	r3, r3, #16
 80014d4:	8003      	strh	r3, [r0, #0]
 80014d6:	4770      	bx	lr

080014d8 <SPI_SSOutputCmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 80014d8:	8883      	ldrh	r3, [r0, #4]
  if (NewState != DISABLE)
 80014da:	b929      	cbnz	r1, 80014e8 <SPI_SSOutputCmd+0x10>
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 80014dc:	f023 0304 	bic.w	r3, r3, #4
 80014e0:	041b      	lsls	r3, r3, #16
 80014e2:	0c1b      	lsrs	r3, r3, #16
 80014e4:	8083      	strh	r3, [r0, #4]
 80014e6:	4770      	bx	lr
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 80014e8:	b29b      	uxth	r3, r3
 80014ea:	f043 0304 	orr.w	r3, r3, #4
 80014ee:	8083      	strh	r3, [r0, #4]
 80014f0:	4770      	bx	lr
 80014f2:	bf00      	nop

080014f4 <SPI_TIModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 80014f4:	8883      	ldrh	r3, [r0, #4]
  if (NewState != DISABLE)
 80014f6:	b929      	cbnz	r1, 8001504 <SPI_TIModeCmd+0x10>
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
 80014f8:	f023 0310 	bic.w	r3, r3, #16
 80014fc:	041b      	lsls	r3, r3, #16
 80014fe:	0c1b      	lsrs	r3, r3, #16
 8001500:	8083      	strh	r3, [r0, #4]
 8001502:	4770      	bx	lr
    SPIx->CR2 |= SPI_CR2_FRF;
 8001504:	b29b      	uxth	r3, r3
 8001506:	f043 0310 	orr.w	r3, r3, #16
 800150a:	8083      	strh	r3, [r0, #4]
 800150c:	4770      	bx	lr
 800150e:	bf00      	nop

08001510 <I2S_FullDuplexConfig>:
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001510:	8b82      	ldrh	r2, [r0, #28]
 8001512:	884b      	ldrh	r3, [r1, #2]
 8001514:	f422 627b 	bic.w	r2, r2, #4016	; 0xfb0
 8001518:	f022 020f 	bic.w	r2, r2, #15
{
 800151c:	b470      	push	{r4, r5, r6}
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800151e:	0412      	lsls	r2, r2, #16
 8001520:	888e      	ldrh	r6, [r1, #4]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8001522:	880c      	ldrh	r4, [r1, #0]
 8001524:	898d      	ldrh	r5, [r1, #12]
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8001526:	0c12      	lsrs	r2, r2, #16
  I2Sxext->I2SPR = 0x0002;
 8001528:	2102      	movs	r1, #2
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800152a:	8382      	strh	r2, [r0, #28]
 800152c:	4333      	orrs	r3, r6
  I2Sxext->I2SPR = 0x0002;
 800152e:	8401      	strh	r1, [r0, #32]
  tmpreg = I2Sxext->I2SCFGR;
 8001530:	8b81      	ldrh	r1, [r0, #28]
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8001532:	f424 7200 	bic.w	r2, r4, #512	; 0x200
 8001536:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800153a:	b292      	uxth	r2, r2
 800153c:	432b      	orrs	r3, r5
 800153e:	2a00      	cmp	r2, #0
 8001540:	ea43 0301 	orr.w	r3, r3, r1
 8001544:	b29b      	uxth	r3, r3
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    {
      tmp = I2S_Mode_SlaveTx;
 8001546:	bf0c      	ite	eq
 8001548:	f44f 7280 	moveq.w	r2, #256	; 0x100
 800154c:	2200      	movne	r2, #0
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 800154e:	4313      	orrs	r3, r2
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 8001550:	8383      	strh	r3, [r0, #28]
}
 8001552:	bc70      	pop	{r4, r5, r6}
 8001554:	4770      	bx	lr
 8001556:	bf00      	nop

08001558 <SPI_I2S_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 8001558:	8980      	ldrh	r0, [r0, #12]
}
 800155a:	b280      	uxth	r0, r0
 800155c:	4770      	bx	lr
 800155e:	bf00      	nop

08001560 <SPI_I2S_SendData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 8001560:	8181      	strh	r1, [r0, #12]
 8001562:	4770      	bx	lr

08001564 <SPI_CalculateCRC>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8001564:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8001566:	b929      	cbnz	r1, 8001574 <SPI_CalculateCRC+0x10>
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 8001568:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800156c:	041b      	lsls	r3, r3, #16
 800156e:	0c1b      	lsrs	r3, r3, #16
 8001570:	8003      	strh	r3, [r0, #0]
 8001572:	4770      	bx	lr
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8001574:	b29b      	uxth	r3, r3
 8001576:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800157a:	8003      	strh	r3, [r0, #0]
 800157c:	4770      	bx	lr
 800157e:	bf00      	nop

08001580 <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 8001580:	8803      	ldrh	r3, [r0, #0]
 8001582:	b29b      	uxth	r3, r3
 8001584:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001588:	8003      	strh	r3, [r0, #0]
 800158a:	4770      	bx	lr

0800158c <SPI_GetCRC>:
{
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
 800158c:	2901      	cmp	r1, #1
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 800158e:	bf14      	ite	ne
 8001590:	8b00      	ldrhne	r0, [r0, #24]
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 8001592:	8a80      	ldrheq	r0, [r0, #20]
 8001594:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 8001596:	4770      	bx	lr

08001598 <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 8001598:	8a00      	ldrh	r0, [r0, #16]
}
 800159a:	b280      	uxth	r0, r0
 800159c:	4770      	bx	lr
 800159e:	bf00      	nop

080015a0 <SPI_I2S_DMACmd>:
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80015a0:	8883      	ldrh	r3, [r0, #4]
 80015a2:	b29b      	uxth	r3, r3
  if (NewState != DISABLE)
 80015a4:	b91a      	cbnz	r2, 80015ae <SPI_I2S_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 80015a6:	ea23 0101 	bic.w	r1, r3, r1
 80015aa:	8081      	strh	r1, [r0, #4]
 80015ac:	4770      	bx	lr
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80015ae:	4319      	orrs	r1, r3
 80015b0:	8081      	strh	r1, [r0, #4]
 80015b2:	4770      	bx	lr

080015b4 <SPI_I2S_ITConfig>:

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 80015b4:	2301      	movs	r3, #1
 80015b6:	0909      	lsrs	r1, r1, #4
 80015b8:	fa03 f101 	lsl.w	r1, r3, r1

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 80015bc:	8883      	ldrh	r3, [r0, #4]
  itmask = (uint16_t)1 << (uint16_t)itpos;
 80015be:	b289      	uxth	r1, r1
    SPIx->CR2 |= itmask;
 80015c0:	b29b      	uxth	r3, r3
  if (NewState != DISABLE)
 80015c2:	b91a      	cbnz	r2, 80015cc <SPI_I2S_ITConfig+0x18>
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 80015c4:	ea23 0101 	bic.w	r1, r3, r1
 80015c8:	8081      	strh	r1, [r0, #4]
 80015ca:	4770      	bx	lr
    SPIx->CR2 |= itmask;
 80015cc:	4319      	orrs	r1, r3
 80015ce:	8081      	strh	r1, [r0, #4]
 80015d0:	4770      	bx	lr
 80015d2:	bf00      	nop

080015d4 <SPI_I2S_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 80015d4:	8903      	ldrh	r3, [r0, #8]
 80015d6:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 80015d8:	bf14      	ite	ne
 80015da:	2001      	movne	r0, #1
 80015dc:	2000      	moveq	r0, #0
 80015de:	4770      	bx	lr

080015e0 <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 80015e0:	43c9      	mvns	r1, r1
 80015e2:	b289      	uxth	r1, r1
 80015e4:	8101      	strh	r1, [r0, #8]
 80015e6:	4770      	bx	lr

080015e8 <SPI_I2S_GetITStatus>:
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 80015e8:	b410      	push	{r4}

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 80015ea:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80015ec:	8900      	ldrh	r0, [r0, #8]
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 80015ee:	f001 030f 	and.w	r3, r1, #15
 80015f2:	2201      	movs	r2, #1
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80015f4:	b280      	uxth	r0, r0
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 80015f6:	fa02 f303 	lsl.w	r3, r2, r3
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80015fa:	4018      	ands	r0, r3
 80015fc:	d006      	beq.n	800160c <SPI_I2S_GetITStatus+0x24>
  itmask = 0x01 << itmask;
 80015fe:	0909      	lsrs	r1, r1, #4
 8001600:	b2a4      	uxth	r4, r4
 8001602:	408a      	lsls	r2, r1
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8001604:	4214      	tst	r4, r2
 8001606:	bf14      	ite	ne
 8001608:	2001      	movne	r0, #1
 800160a:	2000      	moveq	r0, #0
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 800160c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001610:	4770      	bx	lr
 8001612:	bf00      	nop

08001614 <SPI_I2S_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI_I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8001614:	f001 010f 	and.w	r1, r1, #15
 8001618:	2301      	movs	r3, #1
 800161a:	fa03 f101 	lsl.w	r1, r3, r1

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
 800161e:	43c9      	mvns	r1, r1
 8001620:	b289      	uxth	r1, r1
 8001622:	8101      	strh	r1, [r0, #8]
 8001624:	4770      	bx	lr
 8001626:	bf00      	nop

08001628 <PrintChar>:
 *
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
void PrintChar(char c)
{
 8001628:	4770      	bx	lr
 800162a:	bf00      	nop

0800162c <PutChar>:
 * @param  pStr	Storage string.
 * @param  c    Character to write.
 */
signed int PutChar(char *pStr, char c)
{
    *pStr = c;
 800162c:	7001      	strb	r1, [r0, #0]
    return 1;
}
 800162e:	2001      	movs	r0, #1
 8001630:	4770      	bx	lr
 8001632:	bf00      	nop

08001634 <PutString>:
 */
signed int PutString(char *pStr, const char *pSource)
{
    signed int num = 0;

    while (*pSource != 0) {
 8001634:	780b      	ldrb	r3, [r1, #0]
{
 8001636:	b410      	push	{r4}
    while (*pSource != 0) {
 8001638:	b15b      	cbz	r3, 8001652 <PutString+0x1e>
 800163a:	4602      	mov	r2, r0

        *pStr++ = *pSource++;
 800163c:	f802 3b01 	strb.w	r3, [r2], #1
    while (*pSource != 0) {
 8001640:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8001644:	1a14      	subs	r4, r2, r0
 8001646:	2b00      	cmp	r3, #0
 8001648:	d1f8      	bne.n	800163c <PutString+0x8>
        num++;
    }

    return num;
}
 800164a:	4620      	mov	r0, r4
 800164c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001650:	4770      	bx	lr
    signed int num = 0;
 8001652:	461c      	mov	r4, r3
    return num;
 8001654:	e7f9      	b.n	800164a <PutString+0x16>
 8001656:	bf00      	nop

08001658 <PutUnsignedInt>:

    /* Take current digit into account when calculating width */
    width--;

    /* Recursively write upper digits */
    if ((value / 10) > 0) {
 8001658:	2b09      	cmp	r3, #9
{
 800165a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800165e:	4616      	mov	r6, r2
 8001660:	461c      	mov	r4, r3
    width--;
 8001662:	f102 37ff 	add.w	r7, r2, #4294967295
{
 8001666:	4605      	mov	r5, r0
    if ((value / 10) > 0) {
 8001668:	d814      	bhi.n	8001694 <PutUnsignedInt+0x3c>
    }
    
    /* Write filler characters */
    else {

        while (width > 0) {
 800166a:	2f00      	cmp	r7, #0
 800166c:	bfd8      	it	le
 800166e:	2001      	movle	r0, #1
 8001670:	dd04      	ble.n	800167c <PutUnsignedInt+0x24>
 8001672:	463a      	mov	r2, r7
 8001674:	f012 ffc3 	bl	80145fe <memset>
 8001678:	443d      	add	r5, r7
 800167a:	4630      	mov	r0, r6
            width--;
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (value % 10) + '0');
 800167c:	4b1d      	ldr	r3, [pc, #116]	; (80016f4 <PutUnsignedInt+0x9c>)
 800167e:	fba3 2304 	umull	r2, r3, r3, r4
 8001682:	08db      	lsrs	r3, r3, #3
 8001684:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001688:	eba4 0343 	sub.w	r3, r4, r3, lsl #1
 800168c:	3330      	adds	r3, #48	; 0x30
    *pStr = c;
 800168e:	702b      	strb	r3, [r5, #0]

    return num;
}
 8001690:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001694:	4b17      	ldr	r3, [pc, #92]	; (80016f4 <PutUnsignedInt+0x9c>)
 8001696:	fba3 3804 	umull	r3, r8, r3, r4
 800169a:	ea4f 08d8 	mov.w	r8, r8, lsr #3
    if ((value / 10) > 0) {
 800169e:	f1b8 0f09 	cmp.w	r8, #9
    width--;
 80016a2:	f1a2 0902 	sub.w	r9, r2, #2
    if ((value / 10) > 0) {
 80016a6:	d814      	bhi.n	80016d2 <PutUnsignedInt+0x7a>
        while (width > 0) {
 80016a8:	f1b9 0f00 	cmp.w	r9, #0
 80016ac:	dd1d      	ble.n	80016ea <PutUnsignedInt+0x92>
 80016ae:	464a      	mov	r2, r9
 80016b0:	f012 ffa5 	bl	80145fe <memset>
 80016b4:	44a9      	add	r9, r5
 80016b6:	4630      	mov	r0, r6
    num += PutChar(pStr, (value % 10) + '0');
 80016b8:	4b0e      	ldr	r3, [pc, #56]	; (80016f4 <PutUnsignedInt+0x9c>)
 80016ba:	fba3 2308 	umull	r2, r3, r3, r8
 80016be:	08db      	lsrs	r3, r3, #3
 80016c0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80016c4:	eba8 0343 	sub.w	r3, r8, r3, lsl #1
 80016c8:	3330      	adds	r3, #48	; 0x30
        pStr += num;
 80016ca:	443d      	add	r5, r7
    *pStr = c;
 80016cc:	f889 3000 	strb.w	r3, [r9]
 80016d0:	e7d4      	b.n	800167c <PutUnsignedInt+0x24>
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 80016d2:	4b09      	ldr	r3, [pc, #36]	; (80016f8 <PutUnsignedInt+0xa0>)
 80016d4:	fba3 2304 	umull	r2, r3, r3, r4
 80016d8:	095b      	lsrs	r3, r3, #5
 80016da:	464a      	mov	r2, r9
 80016dc:	f7ff ffbc 	bl	8001658 <PutUnsignedInt>
        pStr += num;
 80016e0:	eb05 0900 	add.w	r9, r5, r0
 80016e4:	1c47      	adds	r7, r0, #1
 80016e6:	3002      	adds	r0, #2
 80016e8:	e7e6      	b.n	80016b8 <PutUnsignedInt+0x60>
        while (width > 0) {
 80016ea:	4681      	mov	r9, r0
 80016ec:	2701      	movs	r7, #1
 80016ee:	2002      	movs	r0, #2
 80016f0:	e7e2      	b.n	80016b8 <PutUnsignedInt+0x60>
 80016f2:	bf00      	nop
 80016f4:	cccccccd 	.word	0xcccccccd
 80016f8:	51eb851f 	.word	0x51eb851f

080016fc <PutSignedInt>:
signed int PutSignedInt(
    char *pStr,
    char fill,
    signed int width,
    signed int value)
{
 80016fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    signed int num = 0;
    unsigned int absolute;

    /* Compute absolute value */
    if (value < 0) {
 8001700:	2b00      	cmp	r3, #0
{
 8001702:	4614      	mov	r4, r2
 8001704:	4605      	mov	r5, r0
    if (value < 0) {
 8001706:	db36      	blt.n	8001776 <PutSignedInt+0x7a>

    /* Take current digit into account when calculating width */
    width--;

    /* Recursively write upper digits */
    if ((absolute / 10) > 0) {
 8001708:	2b09      	cmp	r3, #9
        absolute = value;
 800170a:	461e      	mov	r6, r3
    if ((absolute / 10) > 0) {
 800170c:	dd1e      	ble.n	800174c <PutSignedInt+0x50>
        
            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
        }
        else {

            num = PutSignedInt(pStr, fill, width, absolute / 10);
 800170e:	4f51      	ldr	r7, [pc, #324]	; (8001854 <PutSignedInt+0x158>)
 8001710:	fba7 3706 	umull	r3, r7, r7, r6
 8001714:	08ff      	lsrs	r7, r7, #3
    if ((absolute / 10) > 0) {
 8001716:	2f09      	cmp	r7, #9
 8001718:	d852      	bhi.n	80017c0 <PutSignedInt+0xc4>
    width--;
 800171a:	f1a2 0802 	sub.w	r8, r2, #2

            width--;
        }

        /* Write filler characters */
        while (width > 0) {
 800171e:	f1b8 0f00 	cmp.w	r8, #0
 8001722:	f340 8088 	ble.w	8001836 <PutSignedInt+0x13a>
 8001726:	4642      	mov	r2, r8
 8001728:	f012 ff69 	bl	80145fe <memset>
 800172c:	eb05 0208 	add.w	r2, r5, r8
 8001730:	1e61      	subs	r1, r4, #1
 8001732:	4620      	mov	r0, r4
            pStr++;
        }
    }

    /* Write lower digit */
    num += PutChar(pStr, (absolute % 10) + '0');
 8001734:	4b47      	ldr	r3, [pc, #284]	; (8001854 <PutSignedInt+0x158>)
 8001736:	fba3 4307 	umull	r4, r3, r3, r7
 800173a:	08db      	lsrs	r3, r3, #3
 800173c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001740:	eba7 0343 	sub.w	r3, r7, r3, lsl #1
 8001744:	3330      	adds	r3, #48	; 0x30
    *pStr = c;
 8001746:	7013      	strb	r3, [r2, #0]
        pStr += num;
 8001748:	440d      	add	r5, r1
 800174a:	e008      	b.n	800175e <PutSignedInt+0x62>
    width--;
 800174c:	3a01      	subs	r2, #1
        while (width > 0) {
 800174e:	2a00      	cmp	r2, #0
 8001750:	bfd8      	it	le
 8001752:	2001      	movle	r0, #1
 8001754:	dd03      	ble.n	800175e <PutSignedInt+0x62>
 8001756:	4415      	add	r5, r2
 8001758:	f012 ff51 	bl	80145fe <memset>
 800175c:	4620      	mov	r0, r4
    num += PutChar(pStr, (absolute % 10) + '0');
 800175e:	4b3d      	ldr	r3, [pc, #244]	; (8001854 <PutSignedInt+0x158>)
 8001760:	fba3 2306 	umull	r2, r3, r3, r6
 8001764:	08db      	lsrs	r3, r3, #3
 8001766:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800176a:	eba6 0343 	sub.w	r3, r6, r3, lsl #1
 800176e:	3330      	adds	r3, #48	; 0x30
    *pStr = c;
 8001770:	702b      	strb	r3, [r5, #0]

    return num;
}
 8001772:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        absolute = -value;
 8001776:	425e      	negs	r6, r3
    if ((absolute / 10) > 0) {
 8001778:	3309      	adds	r3, #9
 800177a:	da15      	bge.n	80017a8 <PutSignedInt+0xac>
            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
 800177c:	4f35      	ldr	r7, [pc, #212]	; (8001854 <PutSignedInt+0x158>)
 800177e:	fba7 3706 	umull	r3, r7, r7, r6
 8001782:	08ff      	lsrs	r7, r7, #3
    if ((absolute / 10) > 0) {
 8001784:	2f09      	cmp	r7, #9
 8001786:	d83e      	bhi.n	8001806 <PutSignedInt+0x10a>
            width--;
 8001788:	f1a2 0803 	sub.w	r8, r2, #3
        while (width > 0) {
 800178c:	f1b8 0f00 	cmp.w	r8, #0
 8001790:	dd55      	ble.n	800183e <PutSignedInt+0x142>
 8001792:	4642      	mov	r2, r8
 8001794:	f012 ff33 	bl	80145fe <memset>
 8001798:	eb05 0208 	add.w	r2, r5, r8
 800179c:	1e61      	subs	r1, r4, #1
 800179e:	4620      	mov	r0, r4
    *pStr = c;
 80017a0:	232d      	movs	r3, #45	; 0x2d
 80017a2:	f802 3b01 	strb.w	r3, [r2], #1
 80017a6:	e7c5      	b.n	8001734 <PutSignedInt+0x38>
            width--;
 80017a8:	1e94      	subs	r4, r2, #2
        while (width > 0) {
 80017aa:	2c00      	cmp	r4, #0
 80017ac:	dd50      	ble.n	8001850 <PutSignedInt+0x154>
 80017ae:	4622      	mov	r2, r4
 80017b0:	4425      	add	r5, r4
 80017b2:	f012 ff24 	bl	80145fe <memset>
    *pStr = c;
 80017b6:	232d      	movs	r3, #45	; 0x2d
 80017b8:	f805 3b01 	strb.w	r3, [r5], #1
 80017bc:	1ca0      	adds	r0, r4, #2
 80017be:	e7ce      	b.n	800175e <PutSignedInt+0x62>
            num = PutSignedInt(pStr, fill, width, absolute / 10);
 80017c0:	4b25      	ldr	r3, [pc, #148]	; (8001858 <PutSignedInt+0x15c>)
 80017c2:	fba3 3806 	umull	r3, r8, r3, r6
 80017c6:	ea4f 1858 	mov.w	r8, r8, lsr #5
    if ((absolute / 10) > 0) {
 80017ca:	f1b8 0f09 	cmp.w	r8, #9
    width--;
 80017ce:	f1a2 0903 	sub.w	r9, r2, #3
    if ((absolute / 10) > 0) {
 80017d2:	d924      	bls.n	800181e <PutSignedInt+0x122>
            num = PutSignedInt(pStr, fill, width, absolute / 10);
 80017d4:	4b21      	ldr	r3, [pc, #132]	; (800185c <PutSignedInt+0x160>)
 80017d6:	fba3 2306 	umull	r2, r3, r3, r6
 80017da:	099b      	lsrs	r3, r3, #6
 80017dc:	464a      	mov	r2, r9
 80017de:	f7ff ff8d 	bl	80016fc <PutSignedInt>
        pStr += num;
 80017e2:	eb05 0e00 	add.w	lr, r5, r0
 80017e6:	1c42      	adds	r2, r0, #1
 80017e8:	1c81      	adds	r1, r0, #2
 80017ea:	3003      	adds	r0, #3
    num += PutChar(pStr, (absolute % 10) + '0');
 80017ec:	4b19      	ldr	r3, [pc, #100]	; (8001854 <PutSignedInt+0x158>)
 80017ee:	fba3 4308 	umull	r4, r3, r3, r8
 80017f2:	08db      	lsrs	r3, r3, #3
 80017f4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80017f8:	eba8 0343 	sub.w	r3, r8, r3, lsl #1
 80017fc:	3330      	adds	r3, #48	; 0x30
        pStr += num;
 80017fe:	442a      	add	r2, r5
    *pStr = c;
 8001800:	f88e 3000 	strb.w	r3, [lr]
 8001804:	e796      	b.n	8001734 <PutSignedInt+0x38>
            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
 8001806:	4b14      	ldr	r3, [pc, #80]	; (8001858 <PutSignedInt+0x15c>)
 8001808:	fba3 2306 	umull	r2, r3, r3, r6
 800180c:	095b      	lsrs	r3, r3, #5
 800180e:	1ea2      	subs	r2, r4, #2
 8001810:	425b      	negs	r3, r3
 8001812:	f7ff ff73 	bl	80016fc <PutSignedInt>
        pStr += num;
 8001816:	182a      	adds	r2, r5, r0
 8001818:	1c41      	adds	r1, r0, #1
 800181a:	3002      	adds	r0, #2
 800181c:	e78a      	b.n	8001734 <PutSignedInt+0x38>
        while (width > 0) {
 800181e:	f1b9 0f00 	cmp.w	r9, #0
 8001822:	dd10      	ble.n	8001846 <PutSignedInt+0x14a>
 8001824:	464a      	mov	r2, r9
 8001826:	f012 feea 	bl	80145fe <memset>
 800182a:	eb05 0e09 	add.w	lr, r5, r9
 800182e:	1ea2      	subs	r2, r4, #2
 8001830:	1e61      	subs	r1, r4, #1
 8001832:	4620      	mov	r0, r4
 8001834:	e7da      	b.n	80017ec <PutSignedInt+0xf0>
 8001836:	4602      	mov	r2, r0
 8001838:	2101      	movs	r1, #1
 800183a:	2002      	movs	r0, #2
 800183c:	e77a      	b.n	8001734 <PutSignedInt+0x38>
 800183e:	4602      	mov	r2, r0
 8001840:	2102      	movs	r1, #2
 8001842:	2003      	movs	r0, #3
 8001844:	e7ac      	b.n	80017a0 <PutSignedInt+0xa4>
 8001846:	4686      	mov	lr, r0
 8001848:	2102      	movs	r1, #2
 800184a:	2003      	movs	r0, #3
 800184c:	2201      	movs	r2, #1
 800184e:	e7cd      	b.n	80017ec <PutSignedInt+0xf0>
 8001850:	2400      	movs	r4, #0
 8001852:	e7b0      	b.n	80017b6 <PutSignedInt+0xba>
 8001854:	cccccccd 	.word	0xcccccccd
 8001858:	51eb851f 	.word	0x51eb851f
 800185c:	10624dd3 	.word	0x10624dd3

08001860 <PutHexa>:
    char *pStr,
    char fill,
    signed int width,
    unsigned char maj,
    unsigned int value)
{
 8001860:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001864:	b083      	sub	sp, #12
 8001866:	4615      	mov	r5, r2
 8001868:	9c0a      	ldr	r4, [sp, #40]	; 0x28

    /* Decrement width */
    width--;

    /* Recursively output upper digits */
    if ((value >> 4) > 0) {
 800186a:	ea5f 1814 	movs.w	r8, r4, lsr #4
{
 800186e:	4606      	mov	r6, r0
 8001870:	461f      	mov	r7, r3
    if ((value >> 4) > 0) {
 8001872:	d11c      	bne.n	80018ae <PutHexa+0x4e>
    width--;
 8001874:	3a01      	subs	r2, #1
        pStr += num;
    }
    /* Write filler chars */
    else {

        while (width > 0) {
 8001876:	2a00      	cmp	r2, #0
 8001878:	bfd8      	it	le
 800187a:	2001      	movle	r0, #1
 800187c:	dd03      	ble.n	8001886 <PutHexa+0x26>
 800187e:	4416      	add	r6, r2
 8001880:	f012 febd 	bl	80145fe <memset>
 8001884:	4628      	mov	r0, r5
            width--;
        }
    }

    /* Write current digit */
    if ((value & 0xF) < 10) {
 8001886:	f004 040f 	and.w	r4, r4, #15
 800188a:	2c09      	cmp	r4, #9
 800188c:	d90a      	bls.n	80018a4 <PutHexa+0x44>

        PutChar(pStr, (value & 0xF) + '0');
    }
    else if (maj) {
 800188e:	b927      	cbnz	r7, 800189a <PutHexa+0x3a>

        PutChar(pStr, (value & 0xF) - 10 + 'A');
    }
    else {

        PutChar(pStr, (value & 0xF) - 10 + 'a');
 8001890:	3457      	adds	r4, #87	; 0x57
    *pStr = c;
 8001892:	7034      	strb	r4, [r6, #0]
    }
    num++;

    return num;
}
 8001894:	b003      	add	sp, #12
 8001896:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        PutChar(pStr, (value & 0xF) - 10 + 'A');
 800189a:	3437      	adds	r4, #55	; 0x37
    *pStr = c;
 800189c:	7034      	strb	r4, [r6, #0]
}
 800189e:	b003      	add	sp, #12
 80018a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        PutChar(pStr, (value & 0xF) + '0');
 80018a4:	3430      	adds	r4, #48	; 0x30
    *pStr = c;
 80018a6:	7034      	strb	r4, [r6, #0]
}
 80018a8:	b003      	add	sp, #12
 80018aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    width--;
 80018ae:	f1a2 0902 	sub.w	r9, r2, #2
    if ((value >> 4) > 0) {
 80018b2:	0a22      	lsrs	r2, r4, #8
 80018b4:	d117      	bne.n	80018e6 <PutHexa+0x86>
        while (width > 0) {
 80018b6:	f1b9 0f00 	cmp.w	r9, #0
 80018ba:	dd22      	ble.n	8001902 <PutHexa+0xa2>
 80018bc:	464a      	mov	r2, r9
 80018be:	f012 fe9e 	bl	80145fe <memset>
 80018c2:	44b1      	add	r9, r6
 80018c4:	1e6a      	subs	r2, r5, #1
 80018c6:	4628      	mov	r0, r5
    if ((value & 0xF) < 10) {
 80018c8:	f008 030f 	and.w	r3, r8, #15
 80018cc:	2b09      	cmp	r3, #9
 80018ce:	d905      	bls.n	80018dc <PutHexa+0x7c>
    else if (maj) {
 80018d0:	b997      	cbnz	r7, 80018f8 <PutHexa+0x98>
        PutChar(pStr, (value & 0xF) - 10 + 'a');
 80018d2:	3357      	adds	r3, #87	; 0x57
    *pStr = c;
 80018d4:	f889 3000 	strb.w	r3, [r9]
        pStr += num;
 80018d8:	4416      	add	r6, r2
 80018da:	e7d4      	b.n	8001886 <PutHexa+0x26>
        PutChar(pStr, (value & 0xF) + '0');
 80018dc:	3330      	adds	r3, #48	; 0x30
    *pStr = c;
 80018de:	f889 3000 	strb.w	r3, [r9]
        pStr += num;
 80018e2:	4416      	add	r6, r2
 80018e4:	e7cf      	b.n	8001886 <PutHexa+0x26>
        num += PutHexa(pStr, fill, width, maj, value >> 4);
 80018e6:	9200      	str	r2, [sp, #0]
 80018e8:	464a      	mov	r2, r9
 80018ea:	f7ff ffb9 	bl	8001860 <PutHexa>
        pStr += num;
 80018ee:	eb06 0900 	add.w	r9, r6, r0
 80018f2:	1c42      	adds	r2, r0, #1
 80018f4:	3002      	adds	r0, #2
 80018f6:	e7e7      	b.n	80018c8 <PutHexa+0x68>
        PutChar(pStr, (value & 0xF) - 10 + 'A');
 80018f8:	3337      	adds	r3, #55	; 0x37
    *pStr = c;
 80018fa:	f889 3000 	strb.w	r3, [r9]
        pStr += num;
 80018fe:	4416      	add	r6, r2
 8001900:	e7c1      	b.n	8001886 <PutHexa+0x26>
        while (width > 0) {
 8001902:	4681      	mov	r9, r0
 8001904:	2201      	movs	r2, #1
 8001906:	2002      	movs	r0, #2
 8001908:	e7de      	b.n	80018c8 <PutHexa+0x68>
 800190a:	bf00      	nop

0800190c <vsnprintf>:
 * @param ap      Argument list.
 *
 * @return  The number of characters written.
 */
signed int vsnprintf(char *pStr, size_t length, const char *pFormat, va_list ap)
{
 800190c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001910:	468a      	mov	sl, r1
 8001912:	b089      	sub	sp, #36	; 0x24
    unsigned char width;
    signed int    num = 0;
    signed int    size = 0;

    /* Clear the string */
    if (pStr) {
 8001914:	4606      	mov	r6, r0
 8001916:	b108      	cbz	r0, 800191c <vsnprintf+0x10>

        *pStr = 0;
 8001918:	2100      	movs	r1, #0
 800191a:	7001      	strb	r1, [r0, #0]
            size++;
        }
        /* Escaped '%' */
        else if (*(pFormat+1) == '%') {

            *pStr++ = '%';
 800191c:	f04f 0b00 	mov.w	fp, #0
    while (*pFormat != 0 && size < length) {
 8001920:	7811      	ldrb	r1, [r2, #0]
 8001922:	b161      	cbz	r1, 800193e <vsnprintf+0x32>
 8001924:	45d3      	cmp	fp, sl
 8001926:	f080 80f8 	bcs.w	8001b1a <vsnprintf+0x20e>
        if (*pFormat != '%') {
 800192a:	2925      	cmp	r1, #37	; 0x25
 800192c:	d00f      	beq.n	800194e <vsnprintf+0x42>
            *pStr++ = *pFormat++;
 800192e:	3201      	adds	r2, #1
 8001930:	7031      	strb	r1, [r6, #0]
    while (*pFormat != 0 && size < length) {
 8001932:	7811      	ldrb	r1, [r2, #0]
            size++;
 8001934:	f10b 0b01 	add.w	fp, fp, #1
            *pStr++ = *pFormat++;
 8001938:	3601      	adds	r6, #1
    while (*pFormat != 0 && size < length) {
 800193a:	2900      	cmp	r1, #0
 800193c:	d1f2      	bne.n	8001924 <vsnprintf+0x18>
            size += num;
        }
    }

    /* NULL-terminated (final \0 is not counted) */
    if (size < length) {
 800193e:	45da      	cmp	sl, fp
 8001940:	f240 80eb 	bls.w	8001b1a <vsnprintf+0x20e>
        *(--pStr) = 0;
        size--;
    }

    return size;
}
 8001944:	4658      	mov	r0, fp
        *pStr = 0;
 8001946:	7031      	strb	r1, [r6, #0]
}
 8001948:	b009      	add	sp, #36	; 0x24
 800194a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        else if (*(pFormat+1) == '%') {
 800194e:	7850      	ldrb	r0, [r2, #1]
 8001950:	2825      	cmp	r0, #37	; 0x25
 8001952:	d036      	beq.n	80019c2 <vsnprintf+0xb6>
            if (*pFormat == '0') {
 8001954:	2830      	cmp	r0, #48	; 0x30
 8001956:	d03a      	beq.n	80019ce <vsnprintf+0xc2>
            pFormat++;
 8001958:	1c55      	adds	r5, r2, #1
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
 800195a:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
 800195e:	2a09      	cmp	r2, #9
            fill = ' ';
 8001960:	f04f 0120 	mov.w	r1, #32
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
 8001964:	d83b      	bhi.n	80019de <vsnprintf+0xd2>
 8001966:	2400      	movs	r4, #0
                width = (width*10) + *pFormat-'0';
 8001968:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 800196c:	eb00 0444 	add.w	r4, r0, r4, lsl #1
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
 8001970:	f815 0f01 	ldrb.w	r0, [r5, #1]!
 8001974:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
                width = (width*10) + *pFormat-'0';
 8001978:	3c30      	subs	r4, #48	; 0x30
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
 800197a:	2a09      	cmp	r2, #9
                width = (width*10) + *pFormat-'0';
 800197c:	f004 04ff 	and.w	r4, r4, #255	; 0xff
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
 8001980:	d9f2      	bls.n	8001968 <vsnprintf+0x5c>
 8001982:	4622      	mov	r2, r4
            if (size + width > length) {
 8001984:	445a      	add	r2, fp
 8001986:	4592      	cmp	sl, r2
                width = length - size;
 8001988:	bf38      	it	cc
 800198a:	ebaa 040b 	subcc.w	r4, sl, fp
            switch (*pFormat) {
 800198e:	f1a0 0058 	sub.w	r0, r0, #88	; 0x58
                width = length - size;
 8001992:	bf38      	it	cc
 8001994:	b2e4      	uxtbcc	r4, r4
            switch (*pFormat) {
 8001996:	2820      	cmp	r0, #32
 8001998:	f200 80c8 	bhi.w	8001b2c <vsnprintf+0x220>
 800199c:	e8df f000 	tbb	[pc, r0]
 80019a0:	c6c6c69c 	.word	0xc6c6c69c
 80019a4:	c6c6c6c6 	.word	0xc6c6c6c6
 80019a8:	96c6c6c6 	.word	0x96c6c6c6
 80019ac:	c6c6c674 	.word	0xc6c6c674
 80019b0:	c6c674c6 	.word	0xc6c674c6
 80019b4:	c6c6c6c6 	.word	0xc6c6c6c6
 80019b8:	63c6c6c6 	.word	0x63c6c6c6
 80019bc:	c6c63ec6 	.word	0xc6c63ec6
 80019c0:	22          	.byte	0x22
 80019c1:	00          	.byte	0x00
            *pStr++ = '%';
 80019c2:	7030      	strb	r0, [r6, #0]
            pFormat += 2;
 80019c4:	3202      	adds	r2, #2
            size++;
 80019c6:	f10b 0b01 	add.w	fp, fp, #1
            *pStr++ = '%';
 80019ca:	3601      	adds	r6, #1
 80019cc:	e7a8      	b.n	8001920 <vsnprintf+0x14>
 80019ce:	7890      	ldrb	r0, [r2, #2]
                pFormat++;
 80019d0:	1c95      	adds	r5, r2, #2
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
 80019d2:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
 80019d6:	2a09      	cmp	r2, #9
                fill = '0';
 80019d8:	f04f 0130 	mov.w	r1, #48	; 0x30
            while ((*pFormat >= '0') && (*pFormat <= '9')) {
 80019dc:	d9c3      	bls.n	8001966 <vsnprintf+0x5a>
 80019de:	2200      	movs	r2, #0
 80019e0:	4614      	mov	r4, r2
 80019e2:	e7cf      	b.n	8001984 <vsnprintf+0x78>
            case 'x': num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int)); break;
 80019e4:	f8d3 8000 	ldr.w	r8, [r3]
    if ((value >> 4) > 0) {
 80019e8:	ea5f 1918 	movs.w	r9, r8, lsr #4
            case 'x': num = PutHexa(pStr, fill, width, 0, va_arg(ap, unsigned int)); break;
 80019ec:	f103 0704 	add.w	r7, r3, #4
    if ((value >> 4) > 0) {
 80019f0:	f040 80c4 	bne.w	8001b7c <vsnprintf+0x270>
    width--;
 80019f4:	f104 39ff 	add.w	r9, r4, #4294967295
        while (width > 0) {
 80019f8:	f1b9 0f00 	cmp.w	r9, #0
 80019fc:	f340 81d6 	ble.w	8001dac <vsnprintf+0x4a0>
 8001a00:	464a      	mov	r2, r9
 8001a02:	4630      	mov	r0, r6
 8001a04:	f012 fdfb 	bl	80145fe <memset>
 8001a08:	44b1      	add	r9, r6
 8001a0a:	4621      	mov	r1, r4
    if ((value & 0xF) < 10) {
 8001a0c:	f008 080f 	and.w	r8, r8, #15
 8001a10:	f1b8 0f09 	cmp.w	r8, #9
 8001a14:	d97b      	bls.n	8001b0e <vsnprintf+0x202>
        PutChar(pStr, (value & 0xF) - 10 + 'a');
 8001a16:	f108 0857 	add.w	r8, r8, #87	; 0x57
 8001a1a:	e07a      	b.n	8001b12 <vsnprintf+0x206>
            case 'u': num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned int)); break;
 8001a1c:	f8d3 8000 	ldr.w	r8, [r3]
    if ((value / 10) > 0) {
 8001a20:	f1b8 0f09 	cmp.w	r8, #9
    width--;
 8001a24:	f104 39ff 	add.w	r9, r4, #4294967295
            case 'u': num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned int)); break;
 8001a28:	f103 0704 	add.w	r7, r3, #4
    if ((value / 10) > 0) {
 8001a2c:	f200 80fb 	bhi.w	8001c26 <vsnprintf+0x31a>
        while (width > 0) {
 8001a30:	f1b9 0f00 	cmp.w	r9, #0
 8001a34:	f340 81a1 	ble.w	8001d7a <vsnprintf+0x46e>
 8001a38:	464a      	mov	r2, r9
 8001a3a:	4630      	mov	r0, r6
 8001a3c:	f012 fddf 	bl	80145fe <memset>
 8001a40:	44b1      	add	r9, r6
 8001a42:	4621      	mov	r1, r4
    num += PutChar(pStr, (value % 10) + '0');
 8001a44:	4bd6      	ldr	r3, [pc, #856]	; (8001da0 <vsnprintf+0x494>)
 8001a46:	fba3 2308 	umull	r2, r3, r3, r8
 8001a4a:	08db      	lsrs	r3, r3, #3
 8001a4c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001a50:	eba8 0343 	sub.w	r3, r8, r3, lsl #1
 8001a54:	f103 0230 	add.w	r2, r3, #48	; 0x30
    *pStr = c;
 8001a58:	f889 2000 	strb.w	r2, [r9]
            case 'u': num = PutUnsignedInt(pStr, fill, width, va_arg(ap, unsigned int)); break;
 8001a5c:	463b      	mov	r3, r7
            pFormat++;
 8001a5e:	1c6a      	adds	r2, r5, #1
            pStr += num;
 8001a60:	440e      	add	r6, r1
            size += num;
 8001a62:	44a3      	add	fp, r4
 8001a64:	e75c      	b.n	8001920 <vsnprintf+0x14>
            case 's': num = PutString(pStr, va_arg(ap, char *)); break;
 8001a66:	6818      	ldr	r0, [r3, #0]
    while (*pSource != 0) {
 8001a68:	7801      	ldrb	r1, [r0, #0]
            case 's': num = PutString(pStr, va_arg(ap, char *)); break;
 8001a6a:	1d1f      	adds	r7, r3, #4
    while (*pSource != 0) {
 8001a6c:	2900      	cmp	r1, #0
 8001a6e:	f000 8144 	beq.w	8001cfa <vsnprintf+0x3ee>
 8001a72:	4632      	mov	r2, r6
        *pStr++ = *pSource++;
 8001a74:	f802 1b01 	strb.w	r1, [r2], #1
    while (*pSource != 0) {
 8001a78:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 8001a7c:	1b94      	subs	r4, r2, r6
 8001a7e:	2900      	cmp	r1, #0
 8001a80:	d1f8      	bne.n	8001a74 <vsnprintf+0x168>
            case 's': num = PutString(pStr, va_arg(ap, char *)); break;
 8001a82:	463b      	mov	r3, r7
 8001a84:	4621      	mov	r1, r4
 8001a86:	e7ea      	b.n	8001a5e <vsnprintf+0x152>
            case 'i': num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int)); break;
 8001a88:	681a      	ldr	r2, [r3, #0]
    if (value < 0) {
 8001a8a:	2a00      	cmp	r2, #0
            case 'i': num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int)); break;
 8001a8c:	f103 0704 	add.w	r7, r3, #4
    if (value < 0) {
 8001a90:	f2c0 80b4 	blt.w	8001bfc <vsnprintf+0x2f0>
    if ((absolute / 10) > 0) {
 8001a94:	2a09      	cmp	r2, #9
        absolute = value;
 8001a96:	4690      	mov	r8, r2
    if ((absolute / 10) > 0) {
 8001a98:	dc4e      	bgt.n	8001b38 <vsnprintf+0x22c>
    width--;
 8001a9a:	f104 39ff 	add.w	r9, r4, #4294967295
        while (width > 0) {
 8001a9e:	f1b9 0f00 	cmp.w	r9, #0
 8001aa2:	f340 819b 	ble.w	8001ddc <vsnprintf+0x4d0>
 8001aa6:	464a      	mov	r2, r9
 8001aa8:	4630      	mov	r0, r6
 8001aaa:	f012 fda8 	bl	80145fe <memset>
 8001aae:	eb06 0009 	add.w	r0, r6, r9
 8001ab2:	4621      	mov	r1, r4
    num += PutChar(pStr, (absolute % 10) + '0');
 8001ab4:	4bba      	ldr	r3, [pc, #744]	; (8001da0 <vsnprintf+0x494>)
 8001ab6:	fba3 2308 	umull	r2, r3, r3, r8
 8001aba:	08db      	lsrs	r3, r3, #3
 8001abc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001ac0:	eba8 0243 	sub.w	r2, r8, r3, lsl #1
 8001ac4:	3230      	adds	r2, #48	; 0x30
            case 'i': num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int)); break;
 8001ac6:	463b      	mov	r3, r7
    *pStr = c;
 8001ac8:	7002      	strb	r2, [r0, #0]
            case 'i': num = PutSignedInt(pStr, fill, width, va_arg(ap, signed int)); break;
 8001aca:	e7c8      	b.n	8001a5e <vsnprintf+0x152>
            case 'c': num = PutChar(pStr, va_arg(ap, unsigned int)); break;
 8001acc:	681a      	ldr	r2, [r3, #0]
 8001ace:	7032      	strb	r2, [r6, #0]
 8001ad0:	2101      	movs	r1, #1
 8001ad2:	3304      	adds	r3, #4
 8001ad4:	460c      	mov	r4, r1
 8001ad6:	e7c2      	b.n	8001a5e <vsnprintf+0x152>
            case 'X': num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int)); break;
 8001ad8:	f8d3 8000 	ldr.w	r8, [r3]
    if ((value >> 4) > 0) {
 8001adc:	ea5f 1918 	movs.w	r9, r8, lsr #4
            case 'X': num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int)); break;
 8001ae0:	f103 0704 	add.w	r7, r3, #4
    if ((value >> 4) > 0) {
 8001ae4:	d16a      	bne.n	8001bbc <vsnprintf+0x2b0>
    width--;
 8001ae6:	f104 39ff 	add.w	r9, r4, #4294967295
        while (width > 0) {
 8001aea:	f1b9 0f00 	cmp.w	r9, #0
 8001aee:	f340 8161 	ble.w	8001db4 <vsnprintf+0x4a8>
 8001af2:	464a      	mov	r2, r9
 8001af4:	4630      	mov	r0, r6
 8001af6:	f012 fd82 	bl	80145fe <memset>
 8001afa:	44b1      	add	r9, r6
 8001afc:	4621      	mov	r1, r4
    if ((value & 0xF) < 10) {
 8001afe:	f008 080f 	and.w	r8, r8, #15
 8001b02:	f1b8 0f09 	cmp.w	r8, #9
 8001b06:	d902      	bls.n	8001b0e <vsnprintf+0x202>
        PutChar(pStr, (value & 0xF) - 10 + 'A');
 8001b08:	f108 0837 	add.w	r8, r8, #55	; 0x37
 8001b0c:	e001      	b.n	8001b12 <vsnprintf+0x206>
        PutChar(pStr, (value & 0xF) + '0');
 8001b0e:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8001b12:	f889 8000 	strb.w	r8, [r9]
            case 'X': num = PutHexa(pStr, fill, width, 1, va_arg(ap, unsigned int)); break;
 8001b16:	463b      	mov	r3, r7
 8001b18:	e7a1      	b.n	8001a5e <vsnprintf+0x152>
        size--;
 8001b1a:	f10b 3bff 	add.w	fp, fp, #4294967295
        *(--pStr) = 0;
 8001b1e:	2300      	movs	r3, #0
}
 8001b20:	4658      	mov	r0, fp
        *(--pStr) = 0;
 8001b22:	f806 3c01 	strb.w	r3, [r6, #-1]
}
 8001b26:	b009      	add	sp, #36	; 0x24
 8001b28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                return EOF;
 8001b2c:	f04f 3bff 	mov.w	fp, #4294967295
}
 8001b30:	4658      	mov	r0, fp
 8001b32:	b009      	add	sp, #36	; 0x24
 8001b34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            num = PutSignedInt(pStr, fill, width, absolute / 10);
 8001b38:	4b99      	ldr	r3, [pc, #612]	; (8001da0 <vsnprintf+0x494>)
 8001b3a:	fba3 3902 	umull	r3, r9, r3, r2
 8001b3e:	ea4f 09d9 	mov.w	r9, r9, lsr #3
    if ((absolute / 10) > 0) {
 8001b42:	f1b9 0f09 	cmp.w	r9, #9
 8001b46:	f200 80b0 	bhi.w	8001caa <vsnprintf+0x39e>
    width--;
 8001b4a:	1ea3      	subs	r3, r4, #2
        while (width > 0) {
 8001b4c:	2b00      	cmp	r3, #0
 8001b4e:	f340 8169 	ble.w	8001e24 <vsnprintf+0x518>
 8001b52:	461a      	mov	r2, r3
 8001b54:	4630      	mov	r0, r6
 8001b56:	9302      	str	r3, [sp, #8]
 8001b58:	f012 fd51 	bl	80145fe <memset>
 8001b5c:	9b02      	ldr	r3, [sp, #8]
 8001b5e:	1e60      	subs	r0, r4, #1
 8001b60:	4433      	add	r3, r6
 8001b62:	4621      	mov	r1, r4
    num += PutChar(pStr, (absolute % 10) + '0');
 8001b64:	4a8e      	ldr	r2, [pc, #568]	; (8001da0 <vsnprintf+0x494>)
 8001b66:	fba2 e209 	umull	lr, r2, r2, r9
 8001b6a:	08d2      	lsrs	r2, r2, #3
 8001b6c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8001b70:	eba9 0242 	sub.w	r2, r9, r2, lsl #1
 8001b74:	3230      	adds	r2, #48	; 0x30
    *pStr = c;
 8001b76:	701a      	strb	r2, [r3, #0]
        pStr += num;
 8001b78:	4430      	add	r0, r6
 8001b7a:	e79b      	b.n	8001ab4 <vsnprintf+0x1a8>
    if ((value >> 4) > 0) {
 8001b7c:	ea5f 2318 	movs.w	r3, r8, lsr #8
 8001b80:	9302      	str	r3, [sp, #8]
 8001b82:	f040 80dc 	bne.w	8001d3e <vsnprintf+0x432>
    width--;
 8001b86:	1ea3      	subs	r3, r4, #2
        while (width > 0) {
 8001b88:	2b00      	cmp	r3, #0
 8001b8a:	f340 816f 	ble.w	8001e6c <vsnprintf+0x560>
 8001b8e:	461a      	mov	r2, r3
 8001b90:	4630      	mov	r0, r6
 8001b92:	9302      	str	r3, [sp, #8]
 8001b94:	f012 fd33 	bl	80145fe <memset>
 8001b98:	9b02      	ldr	r3, [sp, #8]
 8001b9a:	1e62      	subs	r2, r4, #1
 8001b9c:	4433      	add	r3, r6
 8001b9e:	4621      	mov	r1, r4
    if ((value & 0xF) < 10) {
 8001ba0:	f009 090f 	and.w	r9, r9, #15
 8001ba4:	f1b9 0f09 	cmp.w	r9, #9
        PutChar(pStr, (value & 0xF) + '0');
 8001ba8:	bf94      	ite	ls
 8001baa:	f109 0930 	addls.w	r9, r9, #48	; 0x30
        PutChar(pStr, (value & 0xF) - 10 + 'a');
 8001bae:	f109 0957 	addhi.w	r9, r9, #87	; 0x57
 8001bb2:	f883 9000 	strb.w	r9, [r3]
        pStr += num;
 8001bb6:	eb06 0902 	add.w	r9, r6, r2
 8001bba:	e727      	b.n	8001a0c <vsnprintf+0x100>
    if ((value >> 4) > 0) {
 8001bbc:	ea5f 2318 	movs.w	r3, r8, lsr #8
 8001bc0:	9302      	str	r3, [sp, #8]
 8001bc2:	f040 809d 	bne.w	8001d00 <vsnprintf+0x3f4>
    width--;
 8001bc6:	1ea3      	subs	r3, r4, #2
        while (width > 0) {
 8001bc8:	2b00      	cmp	r3, #0
 8001bca:	f340 814a 	ble.w	8001e62 <vsnprintf+0x556>
 8001bce:	461a      	mov	r2, r3
 8001bd0:	4630      	mov	r0, r6
 8001bd2:	9302      	str	r3, [sp, #8]
 8001bd4:	f012 fd13 	bl	80145fe <memset>
 8001bd8:	9b02      	ldr	r3, [sp, #8]
 8001bda:	1e62      	subs	r2, r4, #1
 8001bdc:	4433      	add	r3, r6
 8001bde:	4621      	mov	r1, r4
    if ((value & 0xF) < 10) {
 8001be0:	f009 090f 	and.w	r9, r9, #15
 8001be4:	f1b9 0f09 	cmp.w	r9, #9
        PutChar(pStr, (value & 0xF) + '0');
 8001be8:	bf94      	ite	ls
 8001bea:	f109 0930 	addls.w	r9, r9, #48	; 0x30
        PutChar(pStr, (value & 0xF) - 10 + 'A');
 8001bee:	f109 0937 	addhi.w	r9, r9, #55	; 0x37
 8001bf2:	f883 9000 	strb.w	r9, [r3]
        pStr += num;
 8001bf6:	eb06 0902 	add.w	r9, r6, r2
 8001bfa:	e780      	b.n	8001afe <vsnprintf+0x1f2>
        absolute = -value;
 8001bfc:	f1c2 0800 	rsb	r8, r2, #0
    if ((absolute / 10) > 0) {
 8001c00:	3209      	adds	r2, #9
 8001c02:	db30      	blt.n	8001c66 <vsnprintf+0x35a>
            width--;
 8001c04:	f1a4 0902 	sub.w	r9, r4, #2
        while (width > 0) {
 8001c08:	f1b9 0f00 	cmp.w	r9, #0
 8001c0c:	f340 8170 	ble.w	8001ef0 <vsnprintf+0x5e4>
 8001c10:	464a      	mov	r2, r9
 8001c12:	4630      	mov	r0, r6
 8001c14:	f012 fcf3 	bl	80145fe <memset>
 8001c18:	eb06 0009 	add.w	r0, r6, r9
 8001c1c:	4621      	mov	r1, r4
    *pStr = c;
 8001c1e:	232d      	movs	r3, #45	; 0x2d
 8001c20:	f800 3b01 	strb.w	r3, [r0], #1
 8001c24:	e746      	b.n	8001ab4 <vsnprintf+0x1a8>
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001c26:	4b5e      	ldr	r3, [pc, #376]	; (8001da0 <vsnprintf+0x494>)
 8001c28:	fba3 2308 	umull	r2, r3, r3, r8
 8001c2c:	08db      	lsrs	r3, r3, #3
    width--;
 8001c2e:	1ea2      	subs	r2, r4, #2
    if ((value / 10) > 0) {
 8001c30:	2b09      	cmp	r3, #9
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001c32:	9303      	str	r3, [sp, #12]
    width--;
 8001c34:	9202      	str	r2, [sp, #8]
    if ((value / 10) > 0) {
 8001c36:	f200 80d5 	bhi.w	8001de4 <vsnprintf+0x4d8>
        while (width > 0) {
 8001c3a:	2a00      	cmp	r2, #0
 8001c3c:	dd2e      	ble.n	8001c9c <vsnprintf+0x390>
 8001c3e:	4630      	mov	r0, r6
 8001c40:	f012 fcdd 	bl	80145fe <memset>
 8001c44:	9b02      	ldr	r3, [sp, #8]
 8001c46:	9803      	ldr	r0, [sp, #12]
 8001c48:	4433      	add	r3, r6
 8001c4a:	461a      	mov	r2, r3
 8001c4c:	4621      	mov	r1, r4
    num += PutChar(pStr, (value % 10) + '0');
 8001c4e:	4b54      	ldr	r3, [pc, #336]	; (8001da0 <vsnprintf+0x494>)
 8001c50:	fba3 e300 	umull	lr, r3, r3, r0
 8001c54:	08db      	lsrs	r3, r3, #3
 8001c56:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001c5a:	eba0 0343 	sub.w	r3, r0, r3, lsl #1
 8001c5e:	3330      	adds	r3, #48	; 0x30
        pStr += num;
 8001c60:	44b1      	add	r9, r6
    *pStr = c;
 8001c62:	7013      	strb	r3, [r2, #0]
 8001c64:	e6ee      	b.n	8001a44 <vsnprintf+0x138>
            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
 8001c66:	f8df 9138 	ldr.w	r9, [pc, #312]	; 8001da0 <vsnprintf+0x494>
 8001c6a:	fba9 3908 	umull	r3, r9, r9, r8
 8001c6e:	ea4f 09d9 	mov.w	r9, r9, lsr #3
    if ((absolute / 10) > 0) {
 8001c72:	f1b9 0f09 	cmp.w	r9, #9
 8001c76:	f200 8084 	bhi.w	8001d82 <vsnprintf+0x476>
            width--;
 8001c7a:	1ee3      	subs	r3, r4, #3
        while (width > 0) {
 8001c7c:	2b00      	cmp	r3, #0
 8001c7e:	f340 8106 	ble.w	8001e8e <vsnprintf+0x582>
 8001c82:	461a      	mov	r2, r3
 8001c84:	4630      	mov	r0, r6
 8001c86:	9302      	str	r3, [sp, #8]
 8001c88:	f012 fcb9 	bl	80145fe <memset>
 8001c8c:	9b02      	ldr	r3, [sp, #8]
 8001c8e:	1e60      	subs	r0, r4, #1
 8001c90:	4433      	add	r3, r6
 8001c92:	4621      	mov	r1, r4
    *pStr = c;
 8001c94:	222d      	movs	r2, #45	; 0x2d
 8001c96:	f803 2b01 	strb.w	r2, [r3], #1
 8001c9a:	e763      	b.n	8001b64 <vsnprintf+0x258>
        while (width > 0) {
 8001c9c:	2102      	movs	r1, #2
 8001c9e:	460c      	mov	r4, r1
 8001ca0:	4632      	mov	r2, r6
 8001ca2:	f04f 0901 	mov.w	r9, #1
 8001ca6:	4618      	mov	r0, r3
 8001ca8:	e7d1      	b.n	8001c4e <vsnprintf+0x342>
            num = PutSignedInt(pStr, fill, width, absolute / 10);
 8001caa:	4b3e      	ldr	r3, [pc, #248]	; (8001da4 <vsnprintf+0x498>)
 8001cac:	fba3 2308 	umull	r2, r3, r3, r8
 8001cb0:	095b      	lsrs	r3, r3, #5
 8001cb2:	461a      	mov	r2, r3
    if ((absolute / 10) > 0) {
 8001cb4:	2a09      	cmp	r2, #9
            num = PutSignedInt(pStr, fill, width, absolute / 10);
 8001cb6:	9302      	str	r3, [sp, #8]
    width--;
 8001cb8:	f1a4 0303 	sub.w	r3, r4, #3
    if ((absolute / 10) > 0) {
 8001cbc:	d97e      	bls.n	8001dbc <vsnprintf+0x4b0>
            num = PutSignedInt(pStr, fill, width, absolute / 10);
 8001cbe:	4a3a      	ldr	r2, [pc, #232]	; (8001da8 <vsnprintf+0x49c>)
 8001cc0:	fba2 2008 	umull	r2, r0, r2, r8
 8001cc4:	461a      	mov	r2, r3
 8001cc6:	0983      	lsrs	r3, r0, #6
 8001cc8:	4630      	mov	r0, r6
 8001cca:	f7ff fd17 	bl	80016fc <PutSignedInt>
 8001cce:	1c43      	adds	r3, r0, #1
 8001cd0:	1cc4      	adds	r4, r0, #3
 8001cd2:	9303      	str	r3, [sp, #12]
 8001cd4:	9b02      	ldr	r3, [sp, #8]
        pStr += num;
 8001cd6:	eb06 0e00 	add.w	lr, r6, r0
 8001cda:	4621      	mov	r1, r4
 8001cdc:	3002      	adds	r0, #2
    num += PutChar(pStr, (absolute % 10) + '0');
 8001cde:	4a30      	ldr	r2, [pc, #192]	; (8001da0 <vsnprintf+0x494>)
 8001ce0:	fba2 c203 	umull	ip, r2, r2, r3
 8001ce4:	08d2      	lsrs	r2, r2, #3
 8001ce6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8001cea:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
        pStr += num;
 8001cee:	9b03      	ldr	r3, [sp, #12]
    num += PutChar(pStr, (absolute % 10) + '0');
 8001cf0:	3230      	adds	r2, #48	; 0x30
        pStr += num;
 8001cf2:	4433      	add	r3, r6
    *pStr = c;
 8001cf4:	f88e 2000 	strb.w	r2, [lr]
 8001cf8:	e734      	b.n	8001b64 <vsnprintf+0x258>
            case 's': num = PutString(pStr, va_arg(ap, char *)); break;
 8001cfa:	463b      	mov	r3, r7
    signed int num = 0;
 8001cfc:	460c      	mov	r4, r1
 8001cfe:	e6ae      	b.n	8001a5e <vsnprintf+0x152>
    if ((value >> 4) > 0) {
 8001d00:	ea5f 3218 	movs.w	r2, r8, lsr #12
    width--;
 8001d04:	f1a4 0303 	sub.w	r3, r4, #3
    if ((value >> 4) > 0) {
 8001d08:	f040 809e 	bne.w	8001e48 <vsnprintf+0x53c>
        while (width > 0) {
 8001d0c:	2b00      	cmp	r3, #0
 8001d0e:	f340 80b2 	ble.w	8001e76 <vsnprintf+0x56a>
 8001d12:	461a      	mov	r2, r3
 8001d14:	4630      	mov	r0, r6
 8001d16:	9303      	str	r3, [sp, #12]
 8001d18:	f012 fc71 	bl	80145fe <memset>
 8001d1c:	9b03      	ldr	r3, [sp, #12]
 8001d1e:	1e62      	subs	r2, r4, #1
 8001d20:	eb06 0e03 	add.w	lr, r6, r3
 8001d24:	4621      	mov	r1, r4
 8001d26:	1ea3      	subs	r3, r4, #2
    if ((value & 0xF) < 10) {
 8001d28:	9802      	ldr	r0, [sp, #8]
 8001d2a:	f000 000f 	and.w	r0, r0, #15
 8001d2e:	2809      	cmp	r0, #9
        PutChar(pStr, (value & 0xF) + '0');
 8001d30:	bf94      	ite	ls
 8001d32:	3030      	addls	r0, #48	; 0x30
        PutChar(pStr, (value & 0xF) - 10 + 'A');
 8001d34:	3037      	addhi	r0, #55	; 0x37
 8001d36:	f88e 0000 	strb.w	r0, [lr]
        pStr += num;
 8001d3a:	4433      	add	r3, r6
 8001d3c:	e750      	b.n	8001be0 <vsnprintf+0x2d4>
    if ((value >> 4) > 0) {
 8001d3e:	ea5f 3218 	movs.w	r2, r8, lsr #12
    width--;
 8001d42:	f1a4 0303 	sub.w	r3, r4, #3
    if ((value >> 4) > 0) {
 8001d46:	d172      	bne.n	8001e2e <vsnprintf+0x522>
        while (width > 0) {
 8001d48:	2b00      	cmp	r3, #0
 8001d4a:	f340 809a 	ble.w	8001e82 <vsnprintf+0x576>
 8001d4e:	461a      	mov	r2, r3
 8001d50:	4630      	mov	r0, r6
 8001d52:	9303      	str	r3, [sp, #12]
 8001d54:	f012 fc53 	bl	80145fe <memset>
 8001d58:	9b03      	ldr	r3, [sp, #12]
 8001d5a:	1e62      	subs	r2, r4, #1
 8001d5c:	eb06 0e03 	add.w	lr, r6, r3
 8001d60:	4621      	mov	r1, r4
 8001d62:	1ea3      	subs	r3, r4, #2
    if ((value & 0xF) < 10) {
 8001d64:	9802      	ldr	r0, [sp, #8]
 8001d66:	f000 000f 	and.w	r0, r0, #15
 8001d6a:	2809      	cmp	r0, #9
        PutChar(pStr, (value & 0xF) + '0');
 8001d6c:	bf94      	ite	ls
 8001d6e:	3030      	addls	r0, #48	; 0x30
        PutChar(pStr, (value & 0xF) - 10 + 'a');
 8001d70:	3057      	addhi	r0, #87	; 0x57
 8001d72:	f88e 0000 	strb.w	r0, [lr]
        pStr += num;
 8001d76:	4433      	add	r3, r6
 8001d78:	e712      	b.n	8001ba0 <vsnprintf+0x294>
        while (width > 0) {
 8001d7a:	2101      	movs	r1, #1
 8001d7c:	460c      	mov	r4, r1
 8001d7e:	46b1      	mov	r9, r6
 8001d80:	e660      	b.n	8001a44 <vsnprintf+0x138>
            num = PutSignedInt(pStr, fill, width, -(absolute / 10));
 8001d82:	4b08      	ldr	r3, [pc, #32]	; (8001da4 <vsnprintf+0x498>)
 8001d84:	fba3 2308 	umull	r2, r3, r3, r8
 8001d88:	095b      	lsrs	r3, r3, #5
 8001d8a:	1ea2      	subs	r2, r4, #2
 8001d8c:	425b      	negs	r3, r3
 8001d8e:	4630      	mov	r0, r6
 8001d90:	f7ff fcb4 	bl	80016fc <PutSignedInt>
 8001d94:	1c84      	adds	r4, r0, #2
        pStr += num;
 8001d96:	1833      	adds	r3, r6, r0
 8001d98:	4621      	mov	r1, r4
 8001d9a:	3001      	adds	r0, #1
 8001d9c:	e6e2      	b.n	8001b64 <vsnprintf+0x258>
 8001d9e:	bf00      	nop
 8001da0:	cccccccd 	.word	0xcccccccd
 8001da4:	51eb851f 	.word	0x51eb851f
 8001da8:	10624dd3 	.word	0x10624dd3
        while (width > 0) {
 8001dac:	2101      	movs	r1, #1
 8001dae:	460c      	mov	r4, r1
 8001db0:	46b1      	mov	r9, r6
 8001db2:	e62b      	b.n	8001a0c <vsnprintf+0x100>
 8001db4:	2101      	movs	r1, #1
 8001db6:	460c      	mov	r4, r1
 8001db8:	46b1      	mov	r9, r6
 8001dba:	e6a0      	b.n	8001afe <vsnprintf+0x1f2>
        while (width > 0) {
 8001dbc:	2b00      	cmp	r3, #0
 8001dbe:	dd6b      	ble.n	8001e98 <vsnprintf+0x58c>
 8001dc0:	461a      	mov	r2, r3
 8001dc2:	4630      	mov	r0, r6
 8001dc4:	9303      	str	r3, [sp, #12]
 8001dc6:	f012 fc1a 	bl	80145fe <memset>
 8001dca:	9b03      	ldr	r3, [sp, #12]
 8001dcc:	eb06 0e03 	add.w	lr, r6, r3
 8001dd0:	1ea3      	subs	r3, r4, #2
 8001dd2:	9303      	str	r3, [sp, #12]
 8001dd4:	1e60      	subs	r0, r4, #1
 8001dd6:	4621      	mov	r1, r4
 8001dd8:	9b02      	ldr	r3, [sp, #8]
 8001dda:	e780      	b.n	8001cde <vsnprintf+0x3d2>
 8001ddc:	2101      	movs	r1, #1
 8001dde:	460c      	mov	r4, r1
 8001de0:	4630      	mov	r0, r6
 8001de2:	e667      	b.n	8001ab4 <vsnprintf+0x1a8>
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001de4:	4b56      	ldr	r3, [pc, #344]	; (8001f40 <vsnprintf+0x634>)
 8001de6:	fba3 2308 	umull	r2, r3, r3, r8
 8001dea:	095b      	lsrs	r3, r3, #5
    width--;
 8001dec:	1ee2      	subs	r2, r4, #3
    if ((value / 10) > 0) {
 8001dee:	2b09      	cmp	r3, #9
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001df0:	9305      	str	r3, [sp, #20]
    width--;
 8001df2:	9204      	str	r2, [sp, #16]
    if ((value / 10) > 0) {
 8001df4:	d858      	bhi.n	8001ea8 <vsnprintf+0x59c>
        while (width > 0) {
 8001df6:	2a00      	cmp	r2, #0
 8001df8:	dd7e      	ble.n	8001ef8 <vsnprintf+0x5ec>
 8001dfa:	4630      	mov	r0, r6
 8001dfc:	f012 fbff 	bl	80145fe <memset>
 8001e00:	9b04      	ldr	r3, [sp, #16]
 8001e02:	4621      	mov	r1, r4
 8001e04:	4433      	add	r3, r6
    num += PutChar(pStr, (value % 10) + '0');
 8001e06:	9a05      	ldr	r2, [sp, #20]
 8001e08:	484e      	ldr	r0, [pc, #312]	; (8001f44 <vsnprintf+0x638>)
 8001e0a:	fba0 e002 	umull	lr, r0, r0, r2
 8001e0e:	08c0      	lsrs	r0, r0, #3
 8001e10:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001e14:	eba2 0040 	sub.w	r0, r2, r0, lsl #1
        pStr += num;
 8001e18:	9a02      	ldr	r2, [sp, #8]
    num += PutChar(pStr, (value % 10) + '0');
 8001e1a:	3030      	adds	r0, #48	; 0x30
    *pStr = c;
 8001e1c:	7018      	strb	r0, [r3, #0]
        pStr += num;
 8001e1e:	4432      	add	r2, r6
 8001e20:	9803      	ldr	r0, [sp, #12]
 8001e22:	e714      	b.n	8001c4e <vsnprintf+0x342>
        while (width > 0) {
 8001e24:	2102      	movs	r1, #2
 8001e26:	460c      	mov	r4, r1
 8001e28:	4633      	mov	r3, r6
 8001e2a:	2001      	movs	r0, #1
 8001e2c:	e69a      	b.n	8001b64 <vsnprintf+0x258>
        num += PutHexa(pStr, fill, width, maj, value >> 4);
 8001e2e:	9200      	str	r2, [sp, #0]
 8001e30:	4630      	mov	r0, r6
 8001e32:	461a      	mov	r2, r3
 8001e34:	2300      	movs	r3, #0
 8001e36:	f7ff fd13 	bl	8001860 <PutHexa>
 8001e3a:	1cc4      	adds	r4, r0, #3
 8001e3c:	4621      	mov	r1, r4
        pStr += num;
 8001e3e:	eb06 0e00 	add.w	lr, r6, r0
 8001e42:	1c43      	adds	r3, r0, #1
 8001e44:	1c82      	adds	r2, r0, #2
 8001e46:	e78d      	b.n	8001d64 <vsnprintf+0x458>
        num += PutHexa(pStr, fill, width, maj, value >> 4);
 8001e48:	9200      	str	r2, [sp, #0]
 8001e4a:	4630      	mov	r0, r6
 8001e4c:	461a      	mov	r2, r3
 8001e4e:	2301      	movs	r3, #1
 8001e50:	f7ff fd06 	bl	8001860 <PutHexa>
 8001e54:	1cc4      	adds	r4, r0, #3
 8001e56:	4621      	mov	r1, r4
        pStr += num;
 8001e58:	eb06 0e00 	add.w	lr, r6, r0
 8001e5c:	1c43      	adds	r3, r0, #1
 8001e5e:	1c82      	adds	r2, r0, #2
 8001e60:	e762      	b.n	8001d28 <vsnprintf+0x41c>
        while (width > 0) {
 8001e62:	2102      	movs	r1, #2
 8001e64:	460c      	mov	r4, r1
 8001e66:	4633      	mov	r3, r6
 8001e68:	2201      	movs	r2, #1
 8001e6a:	e6b9      	b.n	8001be0 <vsnprintf+0x2d4>
 8001e6c:	2102      	movs	r1, #2
 8001e6e:	460c      	mov	r4, r1
 8001e70:	4633      	mov	r3, r6
 8001e72:	2201      	movs	r2, #1
 8001e74:	e694      	b.n	8001ba0 <vsnprintf+0x294>
 8001e76:	2103      	movs	r1, #3
 8001e78:	460c      	mov	r4, r1
 8001e7a:	46b6      	mov	lr, r6
 8001e7c:	2202      	movs	r2, #2
 8001e7e:	2301      	movs	r3, #1
 8001e80:	e752      	b.n	8001d28 <vsnprintf+0x41c>
 8001e82:	2103      	movs	r1, #3
 8001e84:	460c      	mov	r4, r1
 8001e86:	46b6      	mov	lr, r6
 8001e88:	2202      	movs	r2, #2
 8001e8a:	2301      	movs	r3, #1
 8001e8c:	e76a      	b.n	8001d64 <vsnprintf+0x458>
        while (width > 0) {
 8001e8e:	2103      	movs	r1, #3
 8001e90:	460c      	mov	r4, r1
 8001e92:	4633      	mov	r3, r6
 8001e94:	2002      	movs	r0, #2
 8001e96:	e6fd      	b.n	8001c94 <vsnprintf+0x388>
 8001e98:	2301      	movs	r3, #1
 8001e9a:	2103      	movs	r1, #3
 8001e9c:	9303      	str	r3, [sp, #12]
 8001e9e:	460c      	mov	r4, r1
 8001ea0:	46b6      	mov	lr, r6
 8001ea2:	2002      	movs	r0, #2
 8001ea4:	4613      	mov	r3, r2
 8001ea6:	e71a      	b.n	8001cde <vsnprintf+0x3d2>
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001ea8:	4b27      	ldr	r3, [pc, #156]	; (8001f48 <vsnprintf+0x63c>)
 8001eaa:	fba3 2308 	umull	r2, r3, r3, r8
 8001eae:	099b      	lsrs	r3, r3, #6
 8001eb0:	461a      	mov	r2, r3
    if ((value / 10) > 0) {
 8001eb2:	2a09      	cmp	r2, #9
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001eb4:	9306      	str	r3, [sp, #24]
    width--;
 8001eb6:	f1a4 0304 	sub.w	r3, r4, #4
    if ((value / 10) > 0) {
 8001eba:	d82e      	bhi.n	8001f1a <vsnprintf+0x60e>
        while (width > 0) {
 8001ebc:	2b00      	cmp	r3, #0
 8001ebe:	dd23      	ble.n	8001f08 <vsnprintf+0x5fc>
 8001ec0:	461a      	mov	r2, r3
 8001ec2:	4630      	mov	r0, r6
 8001ec4:	9307      	str	r3, [sp, #28]
 8001ec6:	f012 fb9a 	bl	80145fe <memset>
 8001eca:	9b07      	ldr	r3, [sp, #28]
 8001ecc:	9a06      	ldr	r2, [sp, #24]
 8001ece:	eb06 0e03 	add.w	lr, r6, r3
 8001ed2:	9b04      	ldr	r3, [sp, #16]
 8001ed4:	4621      	mov	r1, r4
    num += PutChar(pStr, (value % 10) + '0');
 8001ed6:	481b      	ldr	r0, [pc, #108]	; (8001f44 <vsnprintf+0x638>)
 8001ed8:	fba0 c002 	umull	ip, r0, r0, r2
 8001edc:	08c0      	lsrs	r0, r0, #3
 8001ede:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001ee2:	eba2 0040 	sub.w	r0, r2, r0, lsl #1
 8001ee6:	3030      	adds	r0, #48	; 0x30
        pStr += num;
 8001ee8:	4433      	add	r3, r6
    *pStr = c;
 8001eea:	f88e 0000 	strb.w	r0, [lr]
 8001eee:	e78a      	b.n	8001e06 <vsnprintf+0x4fa>
        while (width > 0) {
 8001ef0:	2102      	movs	r1, #2
 8001ef2:	460c      	mov	r4, r1
 8001ef4:	4630      	mov	r0, r6
 8001ef6:	e692      	b.n	8001c1e <vsnprintf+0x312>
        while (width > 0) {
 8001ef8:	2103      	movs	r1, #3
 8001efa:	2201      	movs	r2, #1
 8001efc:	460c      	mov	r4, r1
 8001efe:	4633      	mov	r3, r6
 8001f00:	f04f 0902 	mov.w	r9, #2
 8001f04:	9202      	str	r2, [sp, #8]
 8001f06:	e77e      	b.n	8001e06 <vsnprintf+0x4fa>
 8001f08:	2302      	movs	r3, #2
 8001f0a:	2104      	movs	r1, #4
 8001f0c:	9302      	str	r3, [sp, #8]
 8001f0e:	460c      	mov	r4, r1
 8001f10:	46b6      	mov	lr, r6
 8001f12:	f04f 0903 	mov.w	r9, #3
 8001f16:	2301      	movs	r3, #1
 8001f18:	e7dd      	b.n	8001ed6 <vsnprintf+0x5ca>
        num = PutUnsignedInt(pStr, fill, width, value / 10);
 8001f1a:	4a0c      	ldr	r2, [pc, #48]	; (8001f4c <vsnprintf+0x640>)
 8001f1c:	fba2 2008 	umull	r2, r0, r2, r8
 8001f20:	461a      	mov	r2, r3
 8001f22:	0b43      	lsrs	r3, r0, #13
 8001f24:	4630      	mov	r0, r6
 8001f26:	f7ff fb97 	bl	8001658 <PutUnsignedInt>
 8001f2a:	1c82      	adds	r2, r0, #2
 8001f2c:	1d04      	adds	r4, r0, #4
 8001f2e:	9202      	str	r2, [sp, #8]
 8001f30:	4621      	mov	r1, r4
        pStr += num;
 8001f32:	eb06 0e00 	add.w	lr, r6, r0
 8001f36:	1c43      	adds	r3, r0, #1
 8001f38:	f100 0903 	add.w	r9, r0, #3
 8001f3c:	9a06      	ldr	r2, [sp, #24]
 8001f3e:	e7ca      	b.n	8001ed6 <vsnprintf+0x5ca>
 8001f40:	51eb851f 	.word	0x51eb851f
 8001f44:	cccccccd 	.word	0xcccccccd
 8001f48:	10624dd3 	.word	0x10624dd3
 8001f4c:	d1b71759 	.word	0xd1b71759

08001f50 <snprintf>:
 * @param ...     Other arguments
 *
 * @return  The number of characters written.
 */
signed int snprintf(char *pString, size_t length, const char *pFormat, ...)
{
 8001f50:	b40c      	push	{r2, r3}
 8001f52:	b500      	push	{lr}
 8001f54:	b083      	sub	sp, #12
 8001f56:	ab04      	add	r3, sp, #16
 8001f58:	f853 2b04 	ldr.w	r2, [r3], #4
    va_list    ap;
    signed int rc;

    va_start(ap, pFormat);
 8001f5c:	9301      	str	r3, [sp, #4]
    rc = vsnprintf(pString, length, pFormat, ap);
 8001f5e:	f7ff fcd5 	bl	800190c <vsnprintf>
    va_end(ap);

    return rc;
}
 8001f62:	b003      	add	sp, #12
 8001f64:	f85d eb04 	ldr.w	lr, [sp], #4
 8001f68:	b002      	add	sp, #8
 8001f6a:	4770      	bx	lr

08001f6c <vsprintf>:
 *
 * @return  The number of characters written.
 */
signed int vsprintf(char *pString, const char *pFormat, va_list ap)
{
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8001f6c:	4613      	mov	r3, r2
 8001f6e:	460a      	mov	r2, r1
 8001f70:	2164      	movs	r1, #100	; 0x64
 8001f72:	f7ff bccb 	b.w	800190c <vsnprintf>
 8001f76:	bf00      	nop

08001f78 <vfprintf>:
 * @param pStream  Output stream.
 * @param pFormat  Format string
 * @param ap       Argument list. 
 */
signed int vfprintf(FILE *pStream, const char *pFormat, va_list ap)
{
 8001f78:	b510      	push	{r4, lr}
 8001f7a:	b09a      	sub	sp, #104	; 0x68
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8001f7c:	4613      	mov	r3, r2
{
 8001f7e:	4604      	mov	r4, r0
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8001f80:	460a      	mov	r2, r1
 8001f82:	a801      	add	r0, sp, #4
 8001f84:	2164      	movs	r1, #100	; 0x64
 8001f86:	f7ff fcc1 	bl	800190c <vsnprintf>
    char pStr[MAX_STRING_SIZE];
    char pError[] = "stdio.c: increase MAX_STRING_SIZE\n\r";

    /* Write formatted string in buffer */
    if (vsprintf(pStr, pFormat, ap) >= MAX_STRING_SIZE) {
 8001f8a:	2863      	cmp	r0, #99	; 0x63
 8001f8c:	dc17      	bgt.n	8001fbe <vfprintf+0x46>
 */
signed int fputs(const char *pStr, FILE *pStream)
{
    signed int num = 0;

    while (*pStr != 0) {
 8001f8e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8001f92:	b158      	cbz	r0, 8001fac <vfprintf+0x34>
 8001f94:	4b0f      	ldr	r3, [pc, #60]	; (8001fd4 <vfprintf+0x5c>)
 8001f96:	681b      	ldr	r3, [r3, #0]
 8001f98:	689a      	ldr	r2, [r3, #8]
 8001f9a:	4294      	cmp	r4, r2
 8001f9c:	d010      	beq.n	8001fc0 <vfprintf+0x48>
 8001f9e:	68da      	ldr	r2, [r3, #12]
 8001fa0:	2000      	movs	r0, #0
 8001fa2:	ab01      	add	r3, sp, #4
    if ((pStream == stdout) || (pStream == stderr)) {
 8001fa4:	4294      	cmp	r4, r2
 8001fa6:	d003      	beq.n	8001fb0 <vfprintf+0x38>

        if (fputc(*pStr, pStream) == -1) {

            return -1;
 8001fa8:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001fac:	b01a      	add	sp, #104	; 0x68
 8001fae:	bd10      	pop	{r4, pc}
    while (*pStr != 0) {
 8001fb0:	f813 1f01 	ldrb.w	r1, [r3, #1]!
        }
        num++;
 8001fb4:	3001      	adds	r0, #1
    while (*pStr != 0) {
 8001fb6:	2900      	cmp	r1, #0
 8001fb8:	d1f4      	bne.n	8001fa4 <vfprintf+0x2c>
}
 8001fba:	b01a      	add	sp, #104	; 0x68
 8001fbc:	bd10      	pop	{r4, pc}
 8001fbe:	e7fe      	b.n	8001fbe <vfprintf+0x46>
    while (*pStr != 0) {
 8001fc0:	ab01      	add	r3, sp, #4
 8001fc2:	2000      	movs	r0, #0
 8001fc4:	f813 2f01 	ldrb.w	r2, [r3, #1]!
        num++;
 8001fc8:	3001      	adds	r0, #1
    while (*pStr != 0) {
 8001fca:	2a00      	cmp	r2, #0
 8001fcc:	d1fa      	bne.n	8001fc4 <vfprintf+0x4c>
}
 8001fce:	b01a      	add	sp, #104	; 0x68
 8001fd0:	bd10      	pop	{r4, pc}
 8001fd2:	bf00      	nop
 8001fd4:	20000024 	.word	0x20000024

08001fd8 <vprintf>:
{
 8001fd8:	b530      	push	{r4, r5, lr}
    return vfprintf(stdout, pFormat, ap);
 8001fda:	4d16      	ldr	r5, [pc, #88]	; (8002034 <vprintf+0x5c>)
{
 8001fdc:	b09b      	sub	sp, #108	; 0x6c
    return vfprintf(stdout, pFormat, ap);
 8001fde:	682c      	ldr	r4, [r5, #0]
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8001fe0:	460b      	mov	r3, r1
 8001fe2:	4602      	mov	r2, r0
 8001fe4:	2164      	movs	r1, #100	; 0x64
 8001fe6:	a801      	add	r0, sp, #4
    return vfprintf(stdout, pFormat, ap);
 8001fe8:	68a4      	ldr	r4, [r4, #8]
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8001fea:	f7ff fc8f 	bl	800190c <vsnprintf>
    if (vsprintf(pStr, pFormat, ap) >= MAX_STRING_SIZE) {
 8001fee:	2863      	cmp	r0, #99	; 0x63
 8001ff0:	dc16      	bgt.n	8002020 <vprintf+0x48>
    while (*pStr != 0) {
 8001ff2:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8001ff6:	b150      	cbz	r0, 800200e <vprintf+0x36>
 8001ff8:	682b      	ldr	r3, [r5, #0]
 8001ffa:	689a      	ldr	r2, [r3, #8]
 8001ffc:	4294      	cmp	r4, r2
 8001ffe:	d010      	beq.n	8002022 <vprintf+0x4a>
 8002000:	68da      	ldr	r2, [r3, #12]
 8002002:	2000      	movs	r0, #0
 8002004:	ab01      	add	r3, sp, #4
    if ((pStream == stdout) || (pStream == stderr)) {
 8002006:	4294      	cmp	r4, r2
 8002008:	d003      	beq.n	8002012 <vprintf+0x3a>
            return -1;
 800200a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800200e:	b01b      	add	sp, #108	; 0x6c
 8002010:	bd30      	pop	{r4, r5, pc}
    while (*pStr != 0) {
 8002012:	f813 1f01 	ldrb.w	r1, [r3, #1]!
        num++;
 8002016:	3001      	adds	r0, #1
    while (*pStr != 0) {
 8002018:	2900      	cmp	r1, #0
 800201a:	d1f4      	bne.n	8002006 <vprintf+0x2e>
}
 800201c:	b01b      	add	sp, #108	; 0x6c
 800201e:	bd30      	pop	{r4, r5, pc}
 8002020:	e7fe      	b.n	8002020 <vprintf+0x48>
    while (*pStr != 0) {
 8002022:	ab01      	add	r3, sp, #4
 8002024:	2000      	movs	r0, #0
 8002026:	f813 2f01 	ldrb.w	r2, [r3, #1]!
        num++;
 800202a:	3001      	adds	r0, #1
    while (*pStr != 0) {
 800202c:	2a00      	cmp	r2, #0
 800202e:	d1fa      	bne.n	8002026 <vprintf+0x4e>
}
 8002030:	b01b      	add	sp, #108	; 0x6c
 8002032:	bd30      	pop	{r4, r5, pc}
 8002034:	20000024 	.word	0x20000024

08002038 <fprintf>:
{
 8002038:	b40e      	push	{r1, r2, r3}
 800203a:	b510      	push	{r4, lr}
 800203c:	b09b      	sub	sp, #108	; 0x6c
 800203e:	ab1d      	add	r3, sp, #116	; 0x74
 8002040:	4604      	mov	r4, r0
 8002042:	f853 2b04 	ldr.w	r2, [r3], #4
    va_start(ap, pFormat);
 8002046:	9300      	str	r3, [sp, #0]
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8002048:	a801      	add	r0, sp, #4
 800204a:	2164      	movs	r1, #100	; 0x64
 800204c:	f7ff fc5e 	bl	800190c <vsnprintf>
    if (vsprintf(pStr, pFormat, ap) >= MAX_STRING_SIZE) {
 8002050:	2863      	cmp	r0, #99	; 0x63
 8002052:	dc1d      	bgt.n	8002090 <fprintf+0x58>
    while (*pStr != 0) {
 8002054:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8002058:	b158      	cbz	r0, 8002072 <fprintf+0x3a>
 800205a:	4b14      	ldr	r3, [pc, #80]	; (80020ac <fprintf+0x74>)
 800205c:	681b      	ldr	r3, [r3, #0]
 800205e:	689a      	ldr	r2, [r3, #8]
 8002060:	4294      	cmp	r4, r2
 8002062:	d016      	beq.n	8002092 <fprintf+0x5a>
 8002064:	68da      	ldr	r2, [r3, #12]
 8002066:	2000      	movs	r0, #0
 8002068:	ab01      	add	r3, sp, #4
    if ((pStream == stdout) || (pStream == stderr)) {
 800206a:	4294      	cmp	r4, r2
 800206c:	d006      	beq.n	800207c <fprintf+0x44>
            return -1;
 800206e:	f04f 30ff 	mov.w	r0, #4294967295
}
 8002072:	b01b      	add	sp, #108	; 0x6c
 8002074:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8002078:	b003      	add	sp, #12
 800207a:	4770      	bx	lr
    while (*pStr != 0) {
 800207c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
        num++;
 8002080:	3001      	adds	r0, #1
    while (*pStr != 0) {
 8002082:	2900      	cmp	r1, #0
 8002084:	d1f1      	bne.n	800206a <fprintf+0x32>
}
 8002086:	b01b      	add	sp, #108	; 0x6c
 8002088:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800208c:	b003      	add	sp, #12
 800208e:	4770      	bx	lr
 8002090:	e7fe      	b.n	8002090 <fprintf+0x58>
    while (*pStr != 0) {
 8002092:	ab01      	add	r3, sp, #4
 8002094:	2000      	movs	r0, #0
 8002096:	f813 2f01 	ldrb.w	r2, [r3, #1]!
        num++;
 800209a:	3001      	adds	r0, #1
    while (*pStr != 0) {
 800209c:	2a00      	cmp	r2, #0
 800209e:	d1fa      	bne.n	8002096 <fprintf+0x5e>
}
 80020a0:	b01b      	add	sp, #108	; 0x6c
 80020a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80020a6:	b003      	add	sp, #12
 80020a8:	4770      	bx	lr
 80020aa:	bf00      	nop
 80020ac:	20000024 	.word	0x20000024

080020b0 <printf>:
{
 80020b0:	b40f      	push	{r0, r1, r2, r3}
 80020b2:	b530      	push	{r4, r5, lr}
    return vfprintf(stdout, pFormat, ap);
 80020b4:	4d1b      	ldr	r5, [pc, #108]	; (8002124 <printf+0x74>)
{
 80020b6:	b09b      	sub	sp, #108	; 0x6c
 80020b8:	ab1e      	add	r3, sp, #120	; 0x78
    return vfprintf(stdout, pFormat, ap);
 80020ba:	682c      	ldr	r4, [r5, #0]
{
 80020bc:	f853 2b04 	ldr.w	r2, [r3], #4
    va_start(ap, pFormat);
 80020c0:	9300      	str	r3, [sp, #0]
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 80020c2:	a801      	add	r0, sp, #4
 80020c4:	2164      	movs	r1, #100	; 0x64
    return vfprintf(stdout, pFormat, ap);
 80020c6:	68a4      	ldr	r4, [r4, #8]
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 80020c8:	f7ff fc20 	bl	800190c <vsnprintf>
    if (vsprintf(pStr, pFormat, ap) >= MAX_STRING_SIZE) {
 80020cc:	2863      	cmp	r0, #99	; 0x63
 80020ce:	dc1c      	bgt.n	800210a <printf+0x5a>
    while (*pStr != 0) {
 80020d0:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80020d4:	b150      	cbz	r0, 80020ec <printf+0x3c>
 80020d6:	682b      	ldr	r3, [r5, #0]
 80020d8:	689a      	ldr	r2, [r3, #8]
 80020da:	4294      	cmp	r4, r2
 80020dc:	d016      	beq.n	800210c <printf+0x5c>
 80020de:	68da      	ldr	r2, [r3, #12]
 80020e0:	2000      	movs	r0, #0
 80020e2:	ab01      	add	r3, sp, #4
    if ((pStream == stdout) || (pStream == stderr)) {
 80020e4:	4294      	cmp	r4, r2
 80020e6:	d006      	beq.n	80020f6 <printf+0x46>
            return -1;
 80020e8:	f04f 30ff 	mov.w	r0, #4294967295
}
 80020ec:	b01b      	add	sp, #108	; 0x6c
 80020ee:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80020f2:	b004      	add	sp, #16
 80020f4:	4770      	bx	lr
    while (*pStr != 0) {
 80020f6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
        num++;
 80020fa:	3001      	adds	r0, #1
    while (*pStr != 0) {
 80020fc:	2900      	cmp	r1, #0
 80020fe:	d1f1      	bne.n	80020e4 <printf+0x34>
}
 8002100:	b01b      	add	sp, #108	; 0x6c
 8002102:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8002106:	b004      	add	sp, #16
 8002108:	4770      	bx	lr
 800210a:	e7fe      	b.n	800210a <printf+0x5a>
    while (*pStr != 0) {
 800210c:	ab01      	add	r3, sp, #4
 800210e:	2000      	movs	r0, #0
 8002110:	f813 2f01 	ldrb.w	r2, [r3, #1]!
        num++;
 8002114:	3001      	adds	r0, #1
    while (*pStr != 0) {
 8002116:	2a00      	cmp	r2, #0
 8002118:	d1fa      	bne.n	8002110 <printf+0x60>
}
 800211a:	b01b      	add	sp, #108	; 0x6c
 800211c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8002120:	b004      	add	sp, #16
 8002122:	4770      	bx	lr
 8002124:	20000024 	.word	0x20000024

08002128 <sprintf>:
{
 8002128:	b40e      	push	{r1, r2, r3}
 800212a:	b500      	push	{lr}
 800212c:	b082      	sub	sp, #8
 800212e:	ab03      	add	r3, sp, #12
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8002130:	2164      	movs	r1, #100	; 0x64
{
 8002132:	f853 2b04 	ldr.w	r2, [r3], #4
    va_start(ap, pFormat);
 8002136:	9301      	str	r3, [sp, #4]
   return vsnprintf(pString, MAX_STRING_SIZE, pFormat, ap);
 8002138:	f7ff fbe8 	bl	800190c <vsnprintf>
}
 800213c:	b002      	add	sp, #8
 800213e:	f85d eb04 	ldr.w	lr, [sp], #4
 8002142:	b003      	add	sp, #12
 8002144:	4770      	bx	lr
 8002146:	bf00      	nop

08002148 <puts>:
    while (*pStr != 0) {
 8002148:	7803      	ldrb	r3, [r0, #0]
 800214a:	b12b      	cbz	r3, 8002158 <puts+0x10>
 800214c:	2300      	movs	r3, #0
 800214e:	f810 2f01 	ldrb.w	r2, [r0, #1]!
        num++;
 8002152:	3301      	adds	r3, #1
    while (*pStr != 0) {
 8002154:	2a00      	cmp	r2, #0
 8002156:	d1fa      	bne.n	800214e <puts+0x6>
}
 8002158:	4618      	mov	r0, r3
 800215a:	4770      	bx	lr

0800215c <fputc>:
    if ((pStream == stdout) || (pStream == stderr)) {
 800215c:	4b05      	ldr	r3, [pc, #20]	; (8002174 <fputc+0x18>)
 800215e:	681b      	ldr	r3, [r3, #0]
 8002160:	689a      	ldr	r2, [r3, #8]
 8002162:	428a      	cmp	r2, r1
 8002164:	d004      	beq.n	8002170 <fputc+0x14>
 8002166:	68db      	ldr	r3, [r3, #12]
        return EOF;
 8002168:	4299      	cmp	r1, r3
 800216a:	bf18      	it	ne
 800216c:	f04f 30ff 	movne.w	r0, #4294967295
}
 8002170:	4770      	bx	lr
 8002172:	bf00      	nop
 8002174:	20000024 	.word	0x20000024

08002178 <fputs>:
    while (*pStr != 0) {
 8002178:	7803      	ldrb	r3, [r0, #0]
 800217a:	b1f3      	cbz	r3, 80021ba <fputs+0x42>
 800217c:	4b10      	ldr	r3, [pc, #64]	; (80021c0 <fputs+0x48>)
 800217e:	681b      	ldr	r3, [r3, #0]
 8002180:	689a      	ldr	r2, [r3, #8]
 8002182:	428a      	cmp	r2, r1
 8002184:	d013      	beq.n	80021ae <fputs+0x36>
{
 8002186:	b410      	push	{r4}
 8002188:	68dc      	ldr	r4, [r3, #12]
    while (*pStr != 0) {
 800218a:	2300      	movs	r3, #0
    if ((pStream == stdout) || (pStream == stderr)) {
 800218c:	42a1      	cmp	r1, r4
 800218e:	d005      	beq.n	800219c <fputs+0x24>
            return -1;
 8002190:	f04f 33ff 	mov.w	r3, #4294967295
        pStr++;
    }

    return num;
}
 8002194:	4618      	mov	r0, r3
 8002196:	f85d 4b04 	ldr.w	r4, [sp], #4
 800219a:	4770      	bx	lr
    while (*pStr != 0) {
 800219c:	f810 2f01 	ldrb.w	r2, [r0, #1]!
        num++;
 80021a0:	3301      	adds	r3, #1
    while (*pStr != 0) {
 80021a2:	2a00      	cmp	r2, #0
 80021a4:	d1f2      	bne.n	800218c <fputs+0x14>
}
 80021a6:	4618      	mov	r0, r3
 80021a8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80021ac:	4770      	bx	lr
    while (*pStr != 0) {
 80021ae:	2300      	movs	r3, #0
 80021b0:	f810 2f01 	ldrb.w	r2, [r0, #1]!
        num++;
 80021b4:	3301      	adds	r3, #1
    while (*pStr != 0) {
 80021b6:	2a00      	cmp	r2, #0
 80021b8:	d1fa      	bne.n	80021b0 <fputs+0x38>
}
 80021ba:	4618      	mov	r0, r3
 80021bc:	4770      	bx	lr
 80021be:	bf00      	nop
 80021c0:	20000024 	.word	0x20000024

080021c4 <_sbrk>:
caddr_t _sbrk ( int incr )
{
  static unsigned char *heap = NULL;
  unsigned char *prev_heap;

  if (heap == NULL) {
 80021c4:	4a04      	ldr	r2, [pc, #16]	; (80021d8 <_sbrk+0x14>)
 80021c6:	4905      	ldr	r1, [pc, #20]	; (80021dc <_sbrk+0x18>)
 80021c8:	6813      	ldr	r3, [r2, #0]
 80021ca:	2b00      	cmp	r3, #0
 80021cc:	bf08      	it	eq
 80021ce:	460b      	moveq	r3, r1
    heap = (unsigned char *)&_end;
  }
  prev_heap = heap;

  heap += incr;
 80021d0:	4418      	add	r0, r3
 80021d2:	6010      	str	r0, [r2, #0]

  return (caddr_t) prev_heap;
}
 80021d4:	4618      	mov	r0, r3
 80021d6:	4770      	bx	lr
 80021d8:	20002124 	.word	0x20002124
 80021dc:	20010d20 	.word	0x20010d20

080021e0 <link>:

int link(char *old, char *new) {
return -1;
}
 80021e0:	f04f 30ff 	mov.w	r0, #4294967295
 80021e4:	4770      	bx	lr
 80021e6:	bf00      	nop

080021e8 <_close>:

int _close(int file)
{
  return -1;
}
 80021e8:	f04f 30ff 	mov.w	r0, #4294967295
 80021ec:	4770      	bx	lr
 80021ee:	bf00      	nop

080021f0 <_fstat>:

int _fstat(int file, struct stat *st)
{
  st->st_mode = S_IFCHR;
 80021f0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80021f4:	604b      	str	r3, [r1, #4]
  return 0;
}
 80021f6:	2000      	movs	r0, #0
 80021f8:	4770      	bx	lr
 80021fa:	bf00      	nop

080021fc <_isatty>:

int _isatty(int file)
{
  return 1;
}
 80021fc:	2001      	movs	r0, #1
 80021fe:	4770      	bx	lr

08002200 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
  return 0;
}
 8002200:	2000      	movs	r0, #0
 8002202:	4770      	bx	lr

08002204 <_read>:

int _read(int file, char *ptr, int len)
{
  return 0;
}
 8002204:	2000      	movs	r0, #0
 8002206:	4770      	bx	lr

08002208 <_write>:

int _write(int file, char *ptr, int len)
{
  return len;
}
 8002208:	4610      	mov	r0, r2
 800220a:	4770      	bx	lr

0800220c <abort>:

void abort(void)
{
 800220c:	e7fe      	b.n	800220c <abort>
 800220e:	bf00      	nop

08002210 <UB_AUDIO_SetI2SClock>:
//--------------------------------------------------------------
// stellt I2S-Clock auf 135,5MHz ein
//--------------------------------------------------------------
void UB_AUDIO_SetI2SClock(void)
{
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 8002210:	4a07      	ldr	r2, [pc, #28]	; (8002230 <UB_AUDIO_SetI2SClock+0x20>)

  /* Configure PLLI2S */
  RCC->PLLI2SCFGR = (CS43L22_PLLI2S_N << 6) | (CS43L22_PLLI2S_R << 28);
 8002212:	4908      	ldr	r1, [pc, #32]	; (8002234 <UB_AUDIO_SetI2SClock+0x24>)
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 8002214:	6893      	ldr	r3, [r2, #8]
 8002216:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800221a:	6093      	str	r3, [r2, #8]
  RCC->PLLI2SCFGR = (CS43L22_PLLI2S_N << 6) | (CS43L22_PLLI2S_R << 28);
 800221c:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84

  /* Enable PLLI2S */
  RCC->CR |= ((uint32_t)RCC_CR_PLLI2SON);
 8002220:	6813      	ldr	r3, [r2, #0]
 8002222:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8002226:	6013      	str	r3, [r2, #0]

  /* Wait till PLLI2S is ready */
  while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
 8002228:	6813      	ldr	r3, [r2, #0]
 800222a:	011b      	lsls	r3, r3, #4
 800222c:	d5fc      	bpl.n	8002228 <UB_AUDIO_SetI2SClock+0x18>
  {
  }
}
 800222e:	4770      	bx	lr
 8002230:	40023800 	.word	0x40023800
 8002234:	200043c0 	.word	0x200043c0

08002238 <EVAL_AUDIO_Init>:



//--------------------------------------------------------------
uint32_t EVAL_AUDIO_Init(uint8_t Volume, uint32_t AudioFreq)
{
 8002238:	b5f0      	push	{r4, r5, r6, r7, lr}
 800223a:	4606      	mov	r6, r0
 800223c:	b085      	sub	sp, #20
static void Codec_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable Reset GPIO Clock */
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
 800223e:	2008      	movs	r0, #8
{
 8002240:	460d      	mov	r5, r1
  RCC_AHB1PeriphClockCmd(AUDIO_RESET_GPIO_CLK,ENABLE);
 8002242:	2101      	movs	r1, #1
 8002244:	f7fe ff38 	bl	80010b8 <RCC_AHB1PeriphClockCmd>

  /* Audio reset pin configuration -------------------------------------------------*/
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN;
 8002248:	2410      	movs	r4, #16
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800224a:	f240 2301 	movw	r3, #513	; 0x201
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);
 800224e:	4669      	mov	r1, sp
 8002250:	4884      	ldr	r0, [pc, #528]	; (8002464 <EVAL_AUDIO_Init+0x22c>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002252:	9301      	str	r3, [sp, #4]
  GPIO_InitStructure.GPIO_Pin = AUDIO_RESET_PIN;
 8002254:	9400      	str	r4, [sp, #0]
  GPIO_Init(AUDIO_RESET_GPIO, &GPIO_InitStructure);
 8002256:	f7fe fb15 	bl	8000884 <GPIO_Init>

  /* Enable I2S GPIO clocks */
  RCC_AHB1PeriphClockCmd(CODEC_I2S_GPIO_CLOCK, ENABLE);
 800225a:	2101      	movs	r1, #1
 800225c:	2005      	movs	r0, #5
 800225e:	f7fe ff2b 	bl	80010b8 <RCC_AHB1PeriphClockCmd>

  /* CODEC_I2S pins configuration: WS, SCK and SD pins -----------------------------*/
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002262:	f240 2702 	movw	r7, #514	; 0x202
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_SCK_PIN | CODEC_I2S_SD_PIN;
 8002266:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
 800226a:	4669      	mov	r1, sp
 800226c:	487e      	ldr	r0, [pc, #504]	; (8002468 <EVAL_AUDIO_Init+0x230>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800226e:	e88d 0088 	stmia.w	sp, {r3, r7}
  GPIO_Init(CODEC_I2S_GPIO, &GPIO_InitStructure);
 8002272:	f7fe fb07 	bl	8000884 <GPIO_Init>

  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_WS_GPIO, CODEC_I2S_WS_PINSRC, CODEC_I2S_GPIO_AF);
 8002276:	2206      	movs	r2, #6
 8002278:	2104      	movs	r1, #4
 800227a:	487c      	ldr	r0, [pc, #496]	; (800246c <EVAL_AUDIO_Init+0x234>)
 800227c:	f7fe fb92 	bl	80009a4 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SCK_PINSRC, CODEC_I2S_GPIO_AF);
 8002280:	2206      	movs	r2, #6
 8002282:	210a      	movs	r1, #10
 8002284:	4878      	ldr	r0, [pc, #480]	; (8002468 <EVAL_AUDIO_Init+0x230>)
 8002286:	f7fe fb8d 	bl	80009a4 <GPIO_PinAFConfig>

  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_WS_PIN ;
  GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure);
 800228a:	4669      	mov	r1, sp
 800228c:	4877      	ldr	r0, [pc, #476]	; (800246c <EVAL_AUDIO_Init+0x234>)
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_WS_PIN ;
 800228e:	9400      	str	r4, [sp, #0]
  GPIO_Init(CODEC_I2S_WS_GPIO, &GPIO_InitStructure);
 8002290:	f7fe faf8 	bl	8000884 <GPIO_Init>
  GPIO_PinAFConfig(CODEC_I2S_GPIO, CODEC_I2S_SD_PINSRC, CODEC_I2S_GPIO_AF);
 8002294:	2206      	movs	r2, #6
 8002296:	210c      	movs	r1, #12
 8002298:	4873      	ldr	r0, [pc, #460]	; (8002468 <EVAL_AUDIO_Init+0x230>)
 800229a:	f7fe fb83 	bl	80009a4 <GPIO_PinAFConfig>


#ifdef CODEC_MCLK_ENABLED
  /* CODEC_I2S pins configuration: MCK pin */
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN;
 800229e:	2380      	movs	r3, #128	; 0x80
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);
 80022a0:	4669      	mov	r1, sp
 80022a2:	4871      	ldr	r0, [pc, #452]	; (8002468 <EVAL_AUDIO_Init+0x230>)
  GPIO_InitStructure.GPIO_Pin = CODEC_I2S_MCK_PIN;
 80022a4:	e88d 0088 	stmia.w	sp, {r3, r7}
  GPIO_Init(CODEC_I2S_MCK_GPIO, &GPIO_InitStructure);
 80022a8:	f7fe faec 	bl	8000884 <GPIO_Init>
  /* Connect pins to I2S peripheral  */
  GPIO_PinAFConfig(CODEC_I2S_MCK_GPIO, CODEC_I2S_MCK_PINSRC, CODEC_I2S_GPIO_AF);
 80022ac:	2206      	movs	r2, #6
 80022ae:	2107      	movs	r1, #7
 80022b0:	486d      	ldr	r0, [pc, #436]	; (8002468 <EVAL_AUDIO_Init+0x230>)
 80022b2:	f7fe fb77 	bl	80009a4 <GPIO_PinAFConfig>

//--------------------------------------------------------------
static void Codec_Reset(void)
{
  /* Power Down the codec */
  GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_RESET);
 80022b6:	4621      	mov	r1, r4
 80022b8:	2200      	movs	r2, #0
 80022ba:	486a      	ldr	r0, [pc, #424]	; (8002464 <EVAL_AUDIO_Init+0x22c>)
 80022bc:	f7fe fb66 	bl	800098c <GPIO_WriteBit>
 80022c0:	f644 73ff 	movw	r3, #20479	; 0x4fff


//--------------------------------------------------------------
static void Delay(volatile uint32_t nCount)
{
  for (; nCount != 0; nCount--);
 80022c4:	3b01      	subs	r3, #1
 80022c6:	d1fd      	bne.n	80022c4 <EVAL_AUDIO_Init+0x8c>
  GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_SET);
 80022c8:	2201      	movs	r2, #1
 80022ca:	2110      	movs	r1, #16
 80022cc:	4865      	ldr	r0, [pc, #404]	; (8002464 <EVAL_AUDIO_Init+0x22c>)
 80022ce:	f7fe fb5d 	bl	800098c <GPIO_WriteBit>

//--------------------------------------------------------------
static void Codec_CtrlInterface_Init(void)
{
  // init vom I2C
  UB_I2C1_Init();
 80022d2:	f00d fedd 	bl	8010090 <UB_I2C1_Init>
  RCC_AHB1PeriphClockCmd(AUDIO_I2S_DMA_CLOCK, ENABLE);
 80022d6:	2101      	movs	r1, #1
 80022d8:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80022dc:	f7fe feec 	bl	80010b8 <RCC_AHB1PeriphClockCmd>
static uint32_t Codec_WriteRegister(uint8_t RegisterAddr, uint8_t RegisterValue)
{
  uint32_t result = 0;
  int16_t check=0;

  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80022e0:	2201      	movs	r2, #1
 80022e2:	2102      	movs	r1, #2
 80022e4:	2094      	movs	r0, #148	; 0x94
 80022e6:	f00e f935 	bl	8010554 <UB_I2C1_WriteByte>
static uint32_t Codec_ReadRegister(uint8_t RegisterAddr)
{
  uint32_t result = 0;
  int16_t check=0;

  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80022ea:	2102      	movs	r1, #2
 80022ec:	2094      	movs	r0, #148	; 0x94
 80022ee:	f00d ff37 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80022f2:	22af      	movs	r2, #175	; 0xaf
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80022f4:	4604      	mov	r4, r0
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80022f6:	2104      	movs	r1, #4
 80022f8:	2094      	movs	r0, #148	; 0x94
 80022fa:	f00e f92b 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80022fe:	2104      	movs	r1, #4
 8002300:	2094      	movs	r0, #148	; 0x94
 8002302:	f00d ff2d 	bl	8010160 <UB_I2C1_ReadByte>
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
 8002306:	f114 34ff 	adds.w	r4, r4, #4294967295
 800230a:	bf18      	it	ne
 800230c:	2401      	movne	r4, #1
  counter += Codec_WriteRegister(0x04, 0xAF); /* SPK always OFF & HP always ON */
 800230e:	28af      	cmp	r0, #175	; 0xaf
 8002310:	bf18      	it	ne
 8002312:	3401      	addne	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002314:	2281      	movs	r2, #129	; 0x81
 8002316:	2105      	movs	r1, #5
 8002318:	2094      	movs	r0, #148	; 0x94
 800231a:	f00e f91b 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800231e:	2105      	movs	r1, #5
 8002320:	2094      	movs	r0, #148	; 0x94
 8002322:	f00d ff1d 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002326:	2204      	movs	r2, #4
  counter += Codec_WriteRegister(0x05, 0x81);
 8002328:	2881      	cmp	r0, #129	; 0x81
 800232a:	bf18      	it	ne
 800232c:	3401      	addne	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800232e:	2106      	movs	r1, #6
 8002330:	2094      	movs	r0, #148	; 0x94
 8002332:	f00e f90f 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002336:	2106      	movs	r1, #6
 8002338:	2094      	movs	r0, #148	; 0x94
 800233a:	f00d ff11 	bl	8010160 <UB_I2C1_ReadByte>
  counter += Codec_WriteRegister(0x06, CODEC_STANDARD);
 800233e:	2804      	cmp	r0, #4
 8002340:	bf18      	it	ne
 8002342:	3401      	addne	r4, #1
  Codec_VolumeCtrl( VOLUME_CONVERT(Volume));
 8002344:	2e64      	cmp	r6, #100	; 0x64
 8002346:	f200 808a 	bhi.w	800245e <EVAL_AUDIO_Init+0x226>
 800234a:	4b49      	ldr	r3, [pc, #292]	; (8002470 <EVAL_AUDIO_Init+0x238>)
 800234c:	ebc6 2606 	rsb	r6, r6, r6, lsl #8
 8002350:	fb83 2306 	smull	r2, r3, r3, r6
 8002354:	17f6      	asrs	r6, r6, #31
 8002356:	ebc6 1363 	rsb	r3, r6, r3, asr #5
 800235a:	b2de      	uxtb	r6, r3
    counter += Codec_WriteRegister(0x20, Volume - 0xE7);
 800235c:	3619      	adds	r6, #25
 800235e:	b2f6      	uxtb	r6, r6
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002360:	4632      	mov	r2, r6
 8002362:	2120      	movs	r1, #32
 8002364:	2094      	movs	r0, #148	; 0x94
 8002366:	f00e f8f5 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800236a:	2120      	movs	r1, #32
 800236c:	2094      	movs	r0, #148	; 0x94
 800236e:	f00d fef7 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002372:	4632      	mov	r2, r6
 8002374:	2121      	movs	r1, #33	; 0x21
 8002376:	2094      	movs	r0, #148	; 0x94
 8002378:	f00e f8ec 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800237c:	2121      	movs	r1, #33	; 0x21
 800237e:	2094      	movs	r0, #148	; 0x94
 8002380:	f00d feee 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002384:	229e      	movs	r2, #158	; 0x9e
 8002386:	2102      	movs	r1, #2
 8002388:	2094      	movs	r0, #148	; 0x94
 800238a:	f00e f8e3 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800238e:	2102      	movs	r1, #2
 8002390:	2094      	movs	r0, #148	; 0x94
 8002392:	f00d fee5 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002396:	2200      	movs	r2, #0
  counter += Codec_WriteRegister(0x02, 0x9E);
 8002398:	289e      	cmp	r0, #158	; 0x9e
 800239a:	bf18      	it	ne
 800239c:	3401      	addne	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800239e:	210a      	movs	r1, #10
 80023a0:	2094      	movs	r0, #148	; 0x94
 80023a2:	f00e f8d7 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80023a6:	210a      	movs	r1, #10
 80023a8:	2094      	movs	r0, #148	; 0x94
 80023aa:	f00d fed9 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023ae:	2204      	movs	r2, #4
  counter += Codec_WriteRegister(0x0A, 0x00);
 80023b0:	2800      	cmp	r0, #0
 80023b2:	bfc8      	it	gt
 80023b4:	3401      	addgt	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023b6:	210e      	movs	r1, #14
 80023b8:	2094      	movs	r0, #148	; 0x94
 80023ba:	f00e f8cb 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80023be:	210e      	movs	r1, #14
 80023c0:	2094      	movs	r0, #148	; 0x94
 80023c2:	f00d fecd 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023c6:	2200      	movs	r2, #0
  counter += Codec_WriteRegister(0x0E, 0x04);
 80023c8:	2804      	cmp	r0, #4
 80023ca:	bf18      	it	ne
 80023cc:	3401      	addne	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023ce:	2127      	movs	r1, #39	; 0x27
 80023d0:	2094      	movs	r0, #148	; 0x94
 80023d2:	f00e f8bf 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80023d6:	2127      	movs	r1, #39	; 0x27
 80023d8:	2094      	movs	r0, #148	; 0x94
 80023da:	f00d fec1 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023de:	220f      	movs	r2, #15
  counter += Codec_WriteRegister(0x27, 0x00);
 80023e0:	2800      	cmp	r0, #0
 80023e2:	bfc8      	it	gt
 80023e4:	3401      	addgt	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023e6:	211f      	movs	r1, #31
 80023e8:	2094      	movs	r0, #148	; 0x94
 80023ea:	f00e f8b3 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80023ee:	211f      	movs	r1, #31
 80023f0:	2094      	movs	r0, #148	; 0x94
 80023f2:	f00d feb5 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023f6:	220a      	movs	r2, #10
  counter += Codec_WriteRegister(0x1F, 0x0F);
 80023f8:	280f      	cmp	r0, #15
 80023fa:	bf18      	it	ne
 80023fc:	3401      	addne	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80023fe:	211a      	movs	r1, #26
 8002400:	2094      	movs	r0, #148	; 0x94
 8002402:	f00e f8a7 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002406:	211a      	movs	r1, #26
 8002408:	2094      	movs	r0, #148	; 0x94
 800240a:	f00d fea9 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800240e:	220a      	movs	r2, #10
  counter += Codec_WriteRegister(0x1A, 0x0A);
 8002410:	4290      	cmp	r0, r2
 8002412:	bf18      	it	ne
 8002414:	3401      	addne	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002416:	211b      	movs	r1, #27
 8002418:	2094      	movs	r0, #148	; 0x94
 800241a:	f00e f89b 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800241e:	211b      	movs	r1, #27
 8002420:	2094      	movs	r0, #148	; 0x94
 8002422:	f00d fe9d 	bl	8010160 <UB_I2C1_ReadByte>
static void Codec_AudioInterface_Init(uint32_t AudioFreq)
{
  I2S_InitTypeDef I2S_InitStructure;

  /* Enable the CODEC_I2S peripheral clock */
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, ENABLE);
 8002426:	2101      	movs	r1, #1
  counter += Codec_WriteRegister(0x1B, 0x0A);
 8002428:	280a      	cmp	r0, #10
 800242a:	bf18      	it	ne
 800242c:	3401      	addne	r4, #1
  RCC_APB1PeriphClockCmd(CODEC_I2S_CLK, ENABLE);
 800242e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8002432:	f7fe fe65 	bl	8001100 <RCC_APB1PeriphClockCmd>

  /* CODEC_I2S peripheral configuration */
  SPI_I2S_DeInit(CODEC_I2S);
 8002436:	480f      	ldr	r0, [pc, #60]	; (8002474 <EVAL_AUDIO_Init+0x23c>)
 8002438:	f7fe ff30 	bl	800129c <SPI_I2S_DeInit>
  I2S_InitStructure.I2S_AudioFreq = AudioFreq;
  I2S_InitStructure.I2S_Standard = I2S_STANDARD;
  I2S_InitStructure.I2S_DataFormat = I2S_DataFormat_16b;
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
 800243c:	2600      	movs	r6, #0
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;
 800243e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002442:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
#else
#error "No selection for the MCLK output has been defined !"
#endif /* CODEC_MCLK_ENABLED */

  /* Initialize the I2S peripheral with the structure above */
  I2S_Init(CODEC_I2S, &I2S_InitStructure);
 8002446:	4669      	mov	r1, sp
 8002448:	480a      	ldr	r0, [pc, #40]	; (8002474 <EVAL_AUDIO_Init+0x23c>)
  I2S_InitStructure.I2S_AudioFreq = AudioFreq;
 800244a:	9502      	str	r5, [sp, #8]
  I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
 800244c:	f8ad 600c 	strh.w	r6, [sp, #12]
  I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;
 8002450:	e88d 000c 	stmia.w	sp, {r2, r3}
  I2S_Init(CODEC_I2S, &I2S_InitStructure);
 8002454:	f7fe ff78 	bl	8001348 <I2S_Init>
}
 8002458:	4620      	mov	r0, r4
 800245a:	b005      	add	sp, #20
 800245c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800245e:	267d      	movs	r6, #125	; 0x7d
 8002460:	e77e      	b.n	8002360 <EVAL_AUDIO_Init+0x128>
 8002462:	bf00      	nop
 8002464:	40020c00 	.word	0x40020c00
 8002468:	40020800 	.word	0x40020800
 800246c:	40020000 	.word	0x40020000
 8002470:	51eb851f 	.word	0x51eb851f
 8002474:	40003c00 	.word	0x40003c00

08002478 <EVAL_AUDIO_Play>:
{
 8002478:	b510      	push	{r4, lr}
    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 800247a:	4b0b      	ldr	r3, [pc, #44]	; (80024a8 <EVAL_AUDIO_Play+0x30>)
  SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, ENABLE);
 800247c:	4c0b      	ldr	r4, [pc, #44]	; (80024ac <EVAL_AUDIO_Play+0x34>)
 800247e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8002482:	2240      	movs	r2, #64	; 0x40
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8002484:	6059      	str	r1, [r3, #4]
 8002486:	4620      	mov	r0, r4
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8002488:	f883 232f 	strb.w	r2, [r3, #815]	; 0x32f
 800248c:	2102      	movs	r1, #2
 800248e:	2201      	movs	r2, #1
 8002490:	f7ff f886 	bl	80015a0 <SPI_I2S_DMACmd>
  if ((CODEC_I2S->I2SCFGR & I2S_ENABLE_MASK) == 0)
 8002494:	8ba3      	ldrh	r3, [r4, #28]
 8002496:	055b      	lsls	r3, r3, #21
 8002498:	d500      	bpl.n	800249c <EVAL_AUDIO_Play+0x24>
 800249a:	bd10      	pop	{r4, pc}
    I2S_Cmd(CODEC_I2S, ENABLE);
 800249c:	4620      	mov	r0, r4
 800249e:	2101      	movs	r1, #1
}
 80024a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    I2S_Cmd(CODEC_I2S, ENABLE);
 80024a4:	f7fe bfde 	b.w	8001464 <I2S_Cmd>
 80024a8:	e000e100 	.word	0xe000e100
 80024ac:	40003c00 	.word	0x40003c00

080024b0 <EVAL_AUDIO_PauseResume>:
{
 80024b0:	b538      	push	{r3, r4, r5, lr}
  if (Cmd == AUDIO_PAUSE)
 80024b2:	2800      	cmp	r0, #0
 80024b4:	d03a      	beq.n	800252c <EVAL_AUDIO_PauseResume+0x7c>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80024b6:	22af      	movs	r2, #175	; 0xaf
 80024b8:	2104      	movs	r1, #4
 80024ba:	2094      	movs	r0, #148	; 0x94
 80024bc:	f00e f84a 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80024c0:	2104      	movs	r1, #4
 80024c2:	2094      	movs	r0, #148	; 0x94
 80024c4:	f00d fe4c 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80024c8:	22af      	movs	r2, #175	; 0xaf
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80024ca:	4604      	mov	r4, r0
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80024cc:	2104      	movs	r1, #4
 80024ce:	2094      	movs	r0, #148	; 0x94
 80024d0:	f00e f840 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80024d4:	2104      	movs	r1, #4
 80024d6:	2094      	movs	r0, #148	; 0x94
 80024d8:	f00d fe42 	bl	8010160 <UB_I2C1_ReadByte>
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
 80024dc:	3caf      	subs	r4, #175	; 0xaf
 80024de:	bf18      	it	ne
 80024e0:	2401      	movne	r4, #1
    counter += Codec_WriteRegister(0x04, 0xAF);
 80024e2:	28af      	cmp	r0, #175	; 0xaf
 80024e4:	bf18      	it	ne
 80024e6:	3401      	addne	r4, #1
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80024e8:	229e      	movs	r2, #158	; 0x9e
 80024ea:	2102      	movs	r1, #2
 80024ec:	2094      	movs	r0, #148	; 0x94
 80024ee:	f00e f831 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80024f2:	2102      	movs	r1, #2
 80024f4:	2094      	movs	r0, #148	; 0x94
 80024f6:	f00d fe33 	bl	8010160 <UB_I2C1_ReadByte>
    counter += Codec_WriteRegister(0x02, 0x9E);
 80024fa:	289e      	cmp	r0, #158	; 0x9e
 80024fc:	bf18      	it	ne
 80024fe:	3401      	addne	r4, #1
  if (Codec_PauseResume(Cmd) != 0)
 8002500:	b114      	cbz	r4, 8002508 <EVAL_AUDIO_PauseResume+0x58>
    return 1;
 8002502:	2401      	movs	r4, #1
}
 8002504:	4620      	mov	r0, r4
 8002506:	bd38      	pop	{r3, r4, r5, pc}
    DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
  }
  else /* AUDIO_RESUME */
  {
    /* Enable the I2S DMA request */
    SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, ENABLE);
 8002508:	4d1b      	ldr	r5, [pc, #108]	; (8002578 <EVAL_AUDIO_PauseResume+0xc8>)
 800250a:	2201      	movs	r2, #1
 800250c:	4628      	mov	r0, r5
 800250e:	2102      	movs	r1, #2
 8002510:	f7ff f846 	bl	80015a0 <SPI_I2S_DMACmd>
    /* Resume the I2S DMA Stream
        Note. For the STM32F40x devices, the DMA implements a pause feature,
              by disabling the stream, all configuration is preserved and data
              transfer is paused till the next enable of the stream.
              This feature is not available on STM32F40x devices. */
    DMA_Cmd(AUDIO_I2S_DMA_STREAM, ENABLE);
 8002514:	2101      	movs	r1, #1
 8002516:	4819      	ldr	r0, [pc, #100]	; (800257c <EVAL_AUDIO_PauseResume+0xcc>)
 8002518:	f7fe f840 	bl	800059c <DMA_Cmd>

    /* If the I2S peripheral is still not enabled, enable it */
    if ((CODEC_I2S->I2SCFGR & I2S_ENABLE_MASK) == 0)
 800251c:	8bab      	ldrh	r3, [r5, #28]
 800251e:	055b      	lsls	r3, r3, #21
 8002520:	d4f0      	bmi.n	8002504 <EVAL_AUDIO_PauseResume+0x54>
    {
      I2S_Cmd(CODEC_I2S, ENABLE);
 8002522:	4628      	mov	r0, r5
 8002524:	2101      	movs	r1, #1
 8002526:	f7fe ff9d 	bl	8001464 <I2S_Cmd>
 800252a:	e7eb      	b.n	8002504 <EVAL_AUDIO_PauseResume+0x54>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800252c:	22ff      	movs	r2, #255	; 0xff
 800252e:	2104      	movs	r1, #4
 8002530:	2094      	movs	r0, #148	; 0x94
 8002532:	f00e f80f 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002536:	2104      	movs	r1, #4
 8002538:	2094      	movs	r0, #148	; 0x94
 800253a:	f00d fe11 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800253e:	2201      	movs	r2, #1
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002540:	4604      	mov	r4, r0
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002542:	2102      	movs	r1, #2
 8002544:	2094      	movs	r0, #148	; 0x94
 8002546:	f00e f805 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800254a:	2102      	movs	r1, #2
 800254c:	2094      	movs	r0, #148	; 0x94
 800254e:	f00d fe07 	bl	8010160 <UB_I2C1_ReadByte>
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
 8002552:	3cff      	subs	r4, #255	; 0xff
 8002554:	bf18      	it	ne
 8002556:	2401      	movne	r4, #1
    counter += Codec_WriteRegister(0x02, 0x01);
 8002558:	2801      	cmp	r0, #1
 800255a:	bf18      	it	ne
 800255c:	3401      	addne	r4, #1
  if (Codec_PauseResume(Cmd) != 0)
 800255e:	2c00      	cmp	r4, #0
 8002560:	d1cf      	bne.n	8002502 <EVAL_AUDIO_PauseResume+0x52>
    SPI_I2S_DMACmd(CODEC_I2S, SPI_I2S_DMAReq_Tx, DISABLE);
 8002562:	4622      	mov	r2, r4
 8002564:	2102      	movs	r1, #2
 8002566:	4804      	ldr	r0, [pc, #16]	; (8002578 <EVAL_AUDIO_PauseResume+0xc8>)
 8002568:	f7ff f81a 	bl	80015a0 <SPI_I2S_DMACmd>
    DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 800256c:	4621      	mov	r1, r4
 800256e:	4803      	ldr	r0, [pc, #12]	; (800257c <EVAL_AUDIO_PauseResume+0xcc>)
 8002570:	f7fe f814 	bl	800059c <DMA_Cmd>
}
 8002574:	4620      	mov	r0, r4
 8002576:	bd38      	pop	{r3, r4, r5, pc}
 8002578:	40003c00 	.word	0x40003c00
 800257c:	400260b8 	.word	0x400260b8

08002580 <EVAL_AUDIO_Stop>:
{
 8002580:	b538      	push	{r3, r4, r5, lr}
 8002582:	4605      	mov	r5, r0
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 8002584:	4818      	ldr	r0, [pc, #96]	; (80025e8 <EVAL_AUDIO_Stop+0x68>)
 8002586:	2100      	movs	r1, #0
  while (DMA_GetCmdStatus(AUDIO_I2S_DMA_STREAM) != DISABLE)
 8002588:	4604      	mov	r4, r0
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 800258a:	f7fe f807 	bl	800059c <DMA_Cmd>
  while (DMA_GetCmdStatus(AUDIO_I2S_DMA_STREAM) != DISABLE)
 800258e:	4620      	mov	r0, r4
 8002590:	f7fe f848 	bl	8000624 <DMA_GetCmdStatus>
 8002594:	2800      	cmp	r0, #0
 8002596:	d1fa      	bne.n	800258e <EVAL_AUDIO_Stop+0xe>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002598:	22ff      	movs	r2, #255	; 0xff
 800259a:	2104      	movs	r1, #4
 800259c:	2094      	movs	r0, #148	; 0x94
 800259e:	f00d ffd9 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80025a2:	2104      	movs	r1, #4
 80025a4:	2094      	movs	r0, #148	; 0x94
 80025a6:	f00d fddb 	bl	8010160 <UB_I2C1_ReadByte>
  if (CodecPdwnMode == CODEC_PDWN_SW)
 80025aa:	2d02      	cmp	r5, #2
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80025ac:	f04f 029f 	mov.w	r2, #159	; 0x9f
  if (CodecPdwnMode == CODEC_PDWN_SW)
 80025b0:	d010      	beq.n	80025d4 <EVAL_AUDIO_Stop+0x54>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80025b2:	2102      	movs	r1, #2
 80025b4:	2094      	movs	r0, #148	; 0x94
 80025b6:	f00d ffcd 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80025ba:	2102      	movs	r1, #2
 80025bc:	2094      	movs	r0, #148	; 0x94
 80025be:	f00d fdcf 	bl	8010160 <UB_I2C1_ReadByte>
 80025c2:	f640 72ff 	movw	r2, #4095	; 0xfff
  for (; nCount != 0; nCount--);
 80025c6:	3a01      	subs	r2, #1
 80025c8:	d1fd      	bne.n	80025c6 <EVAL_AUDIO_Stop+0x46>
    GPIO_WriteBit(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, Bit_RESET);
 80025ca:	2110      	movs	r1, #16
 80025cc:	4807      	ldr	r0, [pc, #28]	; (80025ec <EVAL_AUDIO_Stop+0x6c>)
 80025ce:	f7fe f9dd 	bl	800098c <GPIO_WriteBit>
 80025d2:	bd38      	pop	{r3, r4, r5, pc}
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 80025d4:	4629      	mov	r1, r5
 80025d6:	2094      	movs	r0, #148	; 0x94
 80025d8:	f00d ffbc 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 80025dc:	4629      	mov	r1, r5
 80025de:	2094      	movs	r0, #148	; 0x94
 80025e0:	f00d fdbe 	bl	8010160 <UB_I2C1_ReadByte>
 80025e4:	bd38      	pop	{r3, r4, r5, pc}
 80025e6:	bf00      	nop
 80025e8:	400260b8 	.word	0x400260b8
 80025ec:	40020c00 	.word	0x40020c00

080025f0 <EVAL_AUDIO_StopDMA>:
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 80025f0:	4805      	ldr	r0, [pc, #20]	; (8002608 <EVAL_AUDIO_StopDMA+0x18>)
{
 80025f2:	b510      	push	{r4, lr}
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 80025f4:	2100      	movs	r1, #0
  while (DMA_GetCmdStatus(AUDIO_I2S_DMA_STREAM) != DISABLE)
 80025f6:	4604      	mov	r4, r0
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 80025f8:	f7fd ffd0 	bl	800059c <DMA_Cmd>
  while (DMA_GetCmdStatus(AUDIO_I2S_DMA_STREAM) != DISABLE)
 80025fc:	4620      	mov	r0, r4
 80025fe:	f7fe f811 	bl	8000624 <DMA_GetCmdStatus>
 8002602:	2800      	cmp	r0, #0
 8002604:	d1fa      	bne.n	80025fc <EVAL_AUDIO_StopDMA+0xc>
}
 8002606:	bd10      	pop	{r4, pc}
 8002608:	400260b8 	.word	0x400260b8

0800260c <EVAL_AUDIO_VolumeCtl>:
  return (Codec_VolumeCtrl(VOLUME_CONVERT(Volume)));
 800260c:	2864      	cmp	r0, #100	; 0x64
{
 800260e:	b570      	push	{r4, r5, r6, lr}
  return (Codec_VolumeCtrl(VOLUME_CONVERT(Volume)));
 8002610:	d84d      	bhi.n	80026ae <EVAL_AUDIO_VolumeCtl+0xa2>
 8002612:	4b28      	ldr	r3, [pc, #160]	; (80026b4 <EVAL_AUDIO_VolumeCtl+0xa8>)
 8002614:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
 8002618:	fb83 2300 	smull	r2, r3, r3, r0
 800261c:	17c0      	asrs	r0, r0, #31
 800261e:	ebc0 1063 	rsb	r0, r0, r3, asr #5
 8002622:	b2c5      	uxtb	r5, r0
    counter += Codec_WriteRegister(0x20, Volume - 0xE7);
 8002624:	3519      	adds	r5, #25
  if (Volume > 0xE6)
 8002626:	28e6      	cmp	r0, #230	; 0xe6
    counter += Codec_WriteRegister(0x20, Volume - 0xE7);
 8002628:	b2ed      	uxtb	r5, r5
  if (Volume > 0xE6)
 800262a:	dd1f      	ble.n	800266c <EVAL_AUDIO_VolumeCtl+0x60>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800262c:	462a      	mov	r2, r5
 800262e:	2120      	movs	r1, #32
 8002630:	2094      	movs	r0, #148	; 0x94
 8002632:	f00d ff8f 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002636:	2120      	movs	r1, #32
 8002638:	2094      	movs	r0, #148	; 0x94
 800263a:	f00d fd91 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800263e:	462a      	mov	r2, r5
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002640:	4604      	mov	r4, r0
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002642:	2121      	movs	r1, #33	; 0x21
 8002644:	2094      	movs	r0, #148	; 0x94
 8002646:	f00d ff85 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800264a:	2121      	movs	r1, #33	; 0x21
 800264c:	2094      	movs	r0, #148	; 0x94
 800264e:	f00d fd87 	bl	8010160 <UB_I2C1_ReadByte>
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
 8002652:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 8002656:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 800265a:	b224      	sxth	r4, r4
 800265c:	b203      	sxth	r3, r0
 800265e:	1b60      	subs	r0, r4, r5
 8002660:	bf18      	it	ne
 8002662:	2001      	movne	r0, #1
    counter += Codec_WriteRegister(0x21, Volume - 0xE7);
 8002664:	42ab      	cmp	r3, r5
 8002666:	bf18      	it	ne
 8002668:	3001      	addne	r0, #1
 800266a:	bd70      	pop	{r4, r5, r6, pc}
 800266c:	462e      	mov	r6, r5
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 800266e:	462a      	mov	r2, r5
 8002670:	2120      	movs	r1, #32
 8002672:	2094      	movs	r0, #148	; 0x94
 8002674:	f00d ff6e 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002678:	2120      	movs	r1, #32
 800267a:	2094      	movs	r0, #148	; 0x94
 800267c:	f00d fd70 	bl	8010160 <UB_I2C1_ReadByte>
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002680:	462a      	mov	r2, r5
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 8002682:	4604      	mov	r4, r0
  check=UB_I2C1_WriteByte(CODEC_ADDRESS, RegisterAddr, RegisterValue);
 8002684:	2121      	movs	r1, #33	; 0x21
 8002686:	2094      	movs	r0, #148	; 0x94
 8002688:	f00d ff64 	bl	8010554 <UB_I2C1_WriteByte>
  check=UB_I2C1_ReadByte(CODEC_ADDRESS, RegisterAddr);
 800268c:	2121      	movs	r1, #33	; 0x21
 800268e:	2094      	movs	r0, #148	; 0x94
 8002690:	f00d fd66 	bl	8010160 <UB_I2C1_ReadByte>
  result = (Codec_ReadRegister(RegisterAddr) == RegisterValue)? 0:1;
 8002694:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 8002698:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 800269c:	b224      	sxth	r4, r4
 800269e:	b203      	sxth	r3, r0
 80026a0:	1ba0      	subs	r0, r4, r6
 80026a2:	bf18      	it	ne
 80026a4:	2001      	movne	r0, #1
    counter += Codec_WriteRegister(0x21, Volume + 0x19);
 80026a6:	42b3      	cmp	r3, r6
 80026a8:	bf18      	it	ne
 80026aa:	3001      	addne	r0, #1
}
 80026ac:	bd70      	pop	{r4, r5, r6, pc}
 80026ae:	267d      	movs	r6, #125	; 0x7d
 80026b0:	4635      	mov	r5, r6
 80026b2:	e7dc      	b.n	800266e <EVAL_AUDIO_VolumeCtl+0x62>
 80026b4:	51eb851f 	.word	0x51eb851f

080026b8 <EVAL_IRQ_ENABLE>:
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 80026b8:	4b02      	ldr	r3, [pc, #8]	; (80026c4 <EVAL_IRQ_ENABLE+0xc>)
 80026ba:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80026be:	605a      	str	r2, [r3, #4]
 80026c0:	4770      	bx	lr
 80026c2:	bf00      	nop
 80026c4:	e000e100 	.word	0xe000e100

080026c8 <EVAL_IRQ_DISABLE>:
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
 80026c8:	4b02      	ldr	r3, [pc, #8]	; (80026d4 <EVAL_IRQ_DISABLE+0xc>)
 80026ca:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80026ce:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 80026d2:	4770      	bx	lr
 80026d4:	e000e100 	.word	0xe000e100

080026d8 <EVAL_SET_DMA>:
{
 80026d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 80026da:	4c1a      	ldr	r4, [pc, #104]	; (8002744 <EVAL_SET_DMA+0x6c>)
{
 80026dc:	4605      	mov	r5, r0
 80026de:	460e      	mov	r6, r1
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, DISABLE);
 80026e0:	4620      	mov	r0, r4
 80026e2:	2100      	movs	r1, #0
 80026e4:	f7fd ff5a 	bl	800059c <DMA_Cmd>
  DMA_DeInit(AUDIO_I2S_DMA_STREAM);
 80026e8:	4620      	mov	r0, r4
 80026ea:	f7fd fe81 	bl	80003f0 <DMA_DeInit>
  DMA_InitStructure.DMA_Channel = AUDIO_I2S_DMA_CHANNEL;
 80026ee:	4b16      	ldr	r3, [pc, #88]	; (8002748 <EVAL_SET_DMA+0x70>)
  DMA_InitStructure.DMA_PeripheralBaseAddr = AUDIO_I2S_DMA_DREG;
 80026f0:	4916      	ldr	r1, [pc, #88]	; (800274c <EVAL_SET_DMA+0x74>)
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)next_samples;
 80026f2:	609e      	str	r6, [r3, #8]
  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 80026f4:	2040      	movs	r0, #64	; 0x40
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 80026f6:	f44f 6280 	mov.w	r2, #1024	; 0x400
  DMA_InitStructure.DMA_BufferSize = (uint32_t)next_puffer_len;
 80026fa:	611d      	str	r5, [r3, #16]
  DMA_InitStructure.DMA_PeripheralBaseAddr = AUDIO_I2S_DMA_DREG;
 80026fc:	6059      	str	r1, [r3, #4]
  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 80026fe:	60d8      	str	r0, [r3, #12]
  DMA_Init(AUDIO_I2S_DMA_STREAM, &DMA_InitStructure);
 8002700:	4619      	mov	r1, r3
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8002702:	619a      	str	r2, [r3, #24]
  DMA_Init(AUDIO_I2S_DMA_STREAM, &DMA_InitStructure);
 8002704:	4620      	mov	r0, r4
  DMA_InitStructure.DMA_Channel = AUDIO_I2S_DMA_CHANNEL;
 8002706:	2200      	movs	r2, #0
  DMA_InitStructure.DMA_PeripheralDataSize = AUDIO_MAL_DMA_PERIPH_DATA_SIZE;
 8002708:	f44f 6700 	mov.w	r7, #2048	; 0x800
  DMA_InitStructure.DMA_MemoryDataSize = AUDIO_MAL_DMA_MEM_DATA_SIZE;
 800270c:	f44f 5600 	mov.w	r6, #8192	; 0x2000
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8002710:	f44f 3500 	mov.w	r5, #131072	; 0x20000
  DMA_InitStructure.DMA_Channel = AUDIO_I2S_DMA_CHANNEL;
 8002714:	601a      	str	r2, [r3, #0]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8002716:	615a      	str	r2, [r3, #20]
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8002718:	625a      	str	r2, [r3, #36]	; 0x24
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
 800271a:	62da      	str	r2, [r3, #44]	; 0x2c
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 800271c:	631a      	str	r2, [r3, #48]	; 0x30
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
 800271e:	635a      	str	r2, [r3, #52]	; 0x34
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8002720:	639a      	str	r2, [r3, #56]	; 0x38
  DMA_InitStructure.DMA_PeripheralDataSize = AUDIO_MAL_DMA_PERIPH_DATA_SIZE;
 8002722:	61df      	str	r7, [r3, #28]
  DMA_InitStructure.DMA_MemoryDataSize = AUDIO_MAL_DMA_MEM_DATA_SIZE;
 8002724:	621e      	str	r6, [r3, #32]
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8002726:	629d      	str	r5, [r3, #40]	; 0x28
  DMA_Init(AUDIO_I2S_DMA_STREAM, &DMA_InitStructure);
 8002728:	f7fd fefa 	bl	8000520 <DMA_Init>
  DMA_ITConfig(AUDIO_I2S_DMA_STREAM, DMA_IT_TC, ENABLE);
 800272c:	4620      	mov	r0, r4
 800272e:	2110      	movs	r1, #16
 8002730:	2201      	movs	r2, #1
 8002732:	f7fd ffb7 	bl	80006a4 <DMA_ITConfig>
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, ENABLE);
 8002736:	4620      	mov	r0, r4
 8002738:	2101      	movs	r1, #1
}
 800273a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  DMA_Cmd(AUDIO_I2S_DMA_STREAM, ENABLE);
 800273e:	f7fd bf2d 	b.w	800059c <DMA_Cmd>
 8002742:	bf00      	nop
 8002744:	400260b8 	.word	0x400260b8
 8002748:	2000809c 	.word	0x2000809c
 800274c:	40003c0c 	.word	0x40003c0c

08002750 <DMA1_Stream7_IRQHandler>:


//--------------------------------------------------------------
void Audio_MAL_I2S_IRQHandler(void)
{
  EVAL_AUDIO_TransferComplete_CallBack();
 8002750:	f00d bb92 	b.w	800fe78 <EVAL_AUDIO_TransferComplete_CallBack>

08002754 <disk_initialize>:
)
{
	DSTATUS stat;
	int result;

	switch (pdrv) {
 8002754:	2801      	cmp	r0, #1
{
 8002756:	b508      	push	{r3, lr}
	switch (pdrv) {
 8002758:	d010      	beq.n	800277c <disk_initialize+0x28>
 800275a:	d309      	bcc.n	8002770 <disk_initialize+0x1c>
 800275c:	2802      	cmp	r0, #2
 800275e:	d105      	bne.n	800276c <disk_initialize+0x18>
	case ATA :
		result = ATA_disk_initialize();
 8002760:	f005 fcae 	bl	80080c0 <ATA_disk_initialize>
		// translate the reslut code here
		if(result==0) {
		  stat=0;
		}
		else {
		  stat=STA_NOINIT;
 8002764:	3000      	adds	r0, #0
 8002766:	bf18      	it	ne
 8002768:	2001      	movne	r0, #1
 800276a:	bd08      	pop	{r3, pc}
		  stat=STA_NOINIT;
		}

		return stat;
	}
	return STA_NOINIT;
 800276c:	2001      	movs	r0, #1
}
 800276e:	bd08      	pop	{r3, pc}
		result = USB_disk_initialize();
 8002770:	f005 fcf2 	bl	8008158 <USB_disk_initialize>
		  stat=STA_NOINIT;
 8002774:	3000      	adds	r0, #0
 8002776:	bf18      	it	ne
 8002778:	2001      	movne	r0, #1
 800277a:	bd08      	pop	{r3, pc}
		result = MMC_disk_initialize();
 800277c:	f005 fcb8 	bl	80080f0 <MMC_disk_initialize>
		  stat=STA_NOINIT;
 8002780:	3000      	adds	r0, #0
 8002782:	bf18      	it	ne
 8002784:	2001      	movne	r0, #1
 8002786:	bd08      	pop	{r3, pc}

08002788 <disk_status>:
)
{
	DSTATUS stat;
	int result;

	switch (pdrv) {
 8002788:	2801      	cmp	r0, #1
{
 800278a:	b508      	push	{r3, lr}
	switch (pdrv) {
 800278c:	d009      	beq.n	80027a2 <disk_status+0x1a>
 800278e:	d30e      	bcc.n	80027ae <disk_status+0x26>
 8002790:	2802      	cmp	r0, #2
 8002792:	d104      	bne.n	800279e <disk_status+0x16>
	case ATA :
		result = ATA_disk_status();
 8002794:	f005 fc98 	bl	80080c8 <ATA_disk_status>

		// translate the reslut code here
		if(result==0) {
 8002798:	b138      	cbz	r0, 80027aa <disk_status+0x22>
		  stat=0;
		}
		else {
		  stat=STA_NODISK | STA_NOINIT;
 800279a:	2003      	movs	r0, #3
 800279c:	bd08      	pop	{r3, pc}
		  stat=STA_NODISK | STA_NOINIT;
		}

		return stat;
	}
	return STA_NOINIT;
 800279e:	2001      	movs	r0, #1
}
 80027a0:	bd08      	pop	{r3, pc}
		result = MMC_disk_status();
 80027a2:	f005 fca9 	bl	80080f8 <MMC_disk_status>
		if(result==0) {
 80027a6:	2800      	cmp	r0, #0
 80027a8:	d1f7      	bne.n	800279a <disk_status+0x12>
		  stat=0;
 80027aa:	2000      	movs	r0, #0
 80027ac:	bd08      	pop	{r3, pc}
		result = USB_disk_status();
 80027ae:	f005 fce7 	bl	8008180 <USB_disk_status>
		if(result==0) {
 80027b2:	2800      	cmp	r0, #0
 80027b4:	d0f9      	beq.n	80027aa <disk_status+0x22>
		  stat=STA_NODISK | STA_NOINIT;
 80027b6:	2003      	movs	r0, #3
 80027b8:	bd08      	pop	{r3, pc}
 80027ba:	bf00      	nop

080027bc <disk_read>:
)
{
	DRESULT res;
	int result;

	switch (pdrv) {
 80027bc:	2801      	cmp	r0, #1
{
 80027be:	b510      	push	{r4, lr}
 80027c0:	460c      	mov	r4, r1
 80027c2:	4611      	mov	r1, r2
	switch (pdrv) {
 80027c4:	d014      	beq.n	80027f0 <disk_read+0x34>
 80027c6:	d30b      	bcc.n	80027e0 <disk_read+0x24>
 80027c8:	2802      	cmp	r0, #2
 80027ca:	d107      	bne.n	80027dc <disk_read+0x20>
	case ATA :
		// translate the arguments here

		result = ATA_disk_read(buff, sector, count);
 80027cc:	461a      	mov	r2, r3
 80027ce:	4620      	mov	r0, r4
 80027d0:	f005 fc7e 	bl	80080d0 <ATA_disk_read>
		// translate the reslut code here
		if(result==0) {
		  res=RES_OK;
		}
		else {
		  res=RES_ERROR;
 80027d4:	3000      	adds	r0, #0
 80027d6:	bf18      	it	ne
 80027d8:	2001      	movne	r0, #1
 80027da:	bd10      	pop	{r4, pc}
		  res=RES_ERROR;
		}

		return res;
	}
	return RES_PARERR;
 80027dc:	2004      	movs	r0, #4
}
 80027de:	bd10      	pop	{r4, pc}
		result = USB_disk_read(buff, sector, count);
 80027e0:	461a      	mov	r2, r3
 80027e2:	4620      	mov	r0, r4
 80027e4:	f005 fce0 	bl	80081a8 <USB_disk_read>
		  res=RES_ERROR;
 80027e8:	3000      	adds	r0, #0
 80027ea:	bf18      	it	ne
 80027ec:	2001      	movne	r0, #1
 80027ee:	bd10      	pop	{r4, pc}
		result = MMC_disk_read(buff, sector, count);
 80027f0:	461a      	mov	r2, r3
 80027f2:	4620      	mov	r0, r4
 80027f4:	f005 fc84 	bl	8008100 <MMC_disk_read>
		  res=RES_ERROR;
 80027f8:	3000      	adds	r0, #0
 80027fa:	bf18      	it	ne
 80027fc:	2001      	movne	r0, #1
 80027fe:	bd10      	pop	{r4, pc}

08002800 <disk_write>:
)
{
	DRESULT res;
	int result;

	switch (pdrv) {
 8002800:	2801      	cmp	r0, #1
{
 8002802:	b510      	push	{r4, lr}
 8002804:	460c      	mov	r4, r1
 8002806:	4611      	mov	r1, r2
	switch (pdrv) {
 8002808:	d014      	beq.n	8002834 <disk_write+0x34>
 800280a:	d30b      	bcc.n	8002824 <disk_write+0x24>
 800280c:	2802      	cmp	r0, #2
 800280e:	d107      	bne.n	8002820 <disk_write+0x20>
	case ATA :
		// translate the arguments here

		result = ATA_disk_write(buff, sector, count);
 8002810:	461a      	mov	r2, r3
 8002812:	4620      	mov	r0, r4
 8002814:	f005 fc60 	bl	80080d8 <ATA_disk_write>
		// translate the reslut code here
		if(result==0) {
		  res=RES_OK;
		}
		else {
		  res=RES_ERROR;
 8002818:	3000      	adds	r0, #0
 800281a:	bf18      	it	ne
 800281c:	2001      	movne	r0, #1
 800281e:	bd10      	pop	{r4, pc}
		  res=RES_ERROR;
		}

		return res;
	}
	return RES_PARERR;
 8002820:	2004      	movs	r0, #4
}
 8002822:	bd10      	pop	{r4, pc}
		result = USB_disk_write(buff, sector, count);
 8002824:	461a      	mov	r2, r3
 8002826:	4620      	mov	r0, r4
 8002828:	f005 fcf2 	bl	8008210 <USB_disk_write>
		  res=RES_ERROR;
 800282c:	3000      	adds	r0, #0
 800282e:	bf18      	it	ne
 8002830:	2001      	movne	r0, #1
 8002832:	bd10      	pop	{r4, pc}
		result = MMC_disk_write(buff, sector, count);
 8002834:	461a      	mov	r2, r3
 8002836:	4620      	mov	r0, r4
 8002838:	f005 fc66 	bl	8008108 <MMC_disk_write>
		  res=RES_ERROR;
 800283c:	3000      	adds	r0, #0
 800283e:	bf18      	it	ne
 8002840:	2001      	movne	r0, #1
 8002842:	bd10      	pop	{r4, pc}

08002844 <get_fattime>:
			| (9UL << 16)	      // Day = 9
			| (22U << 11)	      // Hour = 22
			| (30U << 5)	      // Min = 30
			| (0U >> 1)	      // Sec = 0
			;
}
 8002844:	4800      	ldr	r0, [pc, #0]	; (8002848 <get_fattime+0x4>)
 8002846:	4770      	bx	lr
 8002848:	3449b3c0 	.word	0x3449b3c0

0800284c <disk_ioctl>:
)
{
	DRESULT res;
	int result;

	switch (pdrv) {
 800284c:	2801      	cmp	r0, #1
{
 800284e:	b508      	push	{r3, lr}
 8002850:	460b      	mov	r3, r1
	switch (pdrv) {
 8002852:	d014      	beq.n	800287e <disk_ioctl+0x32>
 8002854:	d30b      	bcc.n	800286e <disk_ioctl+0x22>
 8002856:	2802      	cmp	r0, #2
 8002858:	d107      	bne.n	800286a <disk_ioctl+0x1e>
	case ATA :
		// pre-process here

		result = ATA_disk_ioctl(cmd, buff);
 800285a:	4611      	mov	r1, r2
 800285c:	4618      	mov	r0, r3
 800285e:	f005 fc3f 	bl	80080e0 <ATA_disk_ioctl>
		// post-process here
		if(result==0) {
		  res=RES_OK;
		}
		else {
		  res=RES_ERROR;
 8002862:	3000      	adds	r0, #0
 8002864:	bf18      	it	ne
 8002866:	2001      	movne	r0, #1
 8002868:	bd08      	pop	{r3, pc}
		  res=RES_ERROR;
		}

		return res;
	}
	return RES_PARERR;
 800286a:	2004      	movs	r0, #4
}
 800286c:	bd08      	pop	{r3, pc}
		result = USB_disk_ioctl(cmd, buff);
 800286e:	4611      	mov	r1, r2
 8002870:	4618      	mov	r0, r3
 8002872:	f005 fd01 	bl	8008278 <USB_disk_ioctl>
		  res=RES_ERROR;
 8002876:	3000      	adds	r0, #0
 8002878:	bf18      	it	ne
 800287a:	2001      	movne	r0, #1
 800287c:	bd08      	pop	{r3, pc}
		result = MMC_disk_ioctl(cmd, buff);
 800287e:	4611      	mov	r1, r2
 8002880:	4618      	mov	r0, r3
 8002882:	f005 fc45 	bl	8008110 <MMC_disk_ioctl>
		  res=RES_ERROR;
 8002886:	3000      	adds	r0, #0
 8002888:	bf18      	it	ne
 800288a:	2001      	movne	r0, #1
 800288c:	bd08      	pop	{r3, pc}
 800288e:	bf00      	nop

08002890 <get_fileinfo.isra.2>:
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
static
void get_fileinfo (		/* No return code */
 8002890:	b410      	push	{r4}
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
 8002892:	f102 0409 	add.w	r4, r2, #9
	if (dj->sect) {
 8002896:	2800      	cmp	r0, #0
 8002898:	d06e      	beq.n	8002978 <get_fileinfo.isra.2+0xe8>
		dir = dj->dir;
 800289a:	680b      	ldr	r3, [r1, #0]
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
 800289c:	7819      	ldrb	r1, [r3, #0]
			if (c == ' ') break;
 800289e:	2920      	cmp	r1, #32
 80028a0:	d071      	beq.n	8002986 <get_fileinfo.isra.2+0xf6>
			if (c == NDDE) c = (TCHAR)DDE;
 80028a2:	2905      	cmp	r1, #5
 80028a4:	bf08      	it	eq
 80028a6:	21e5      	moveq	r1, #229	; 0xe5
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
 80028a8:	7251      	strb	r1, [r2, #9]
			c = dir[i];
 80028aa:	7858      	ldrb	r0, [r3, #1]
			if (c == ' ') break;
 80028ac:	2820      	cmp	r0, #32
			*p++ = c;
 80028ae:	f102 010a 	add.w	r1, r2, #10
			if (c == ' ') break;
 80028b2:	d03b      	beq.n	800292c <get_fileinfo.isra.2+0x9c>
			if (c == NDDE) c = (TCHAR)DDE;
 80028b4:	2805      	cmp	r0, #5
 80028b6:	bf08      	it	eq
 80028b8:	20e5      	moveq	r0, #229	; 0xe5
			*p++ = c;
 80028ba:	7290      	strb	r0, [r2, #10]
			c = dir[i];
 80028bc:	7898      	ldrb	r0, [r3, #2]
			if (c == ' ') break;
 80028be:	2820      	cmp	r0, #32
			*p++ = c;
 80028c0:	f102 010b 	add.w	r1, r2, #11
			if (c == ' ') break;
 80028c4:	d032      	beq.n	800292c <get_fileinfo.isra.2+0x9c>
			if (c == NDDE) c = (TCHAR)DDE;
 80028c6:	2805      	cmp	r0, #5
 80028c8:	bf08      	it	eq
 80028ca:	20e5      	moveq	r0, #229	; 0xe5
			*p++ = c;
 80028cc:	72d0      	strb	r0, [r2, #11]
			c = dir[i];
 80028ce:	78d8      	ldrb	r0, [r3, #3]
			if (c == ' ') break;
 80028d0:	2820      	cmp	r0, #32
			*p++ = c;
 80028d2:	f102 010c 	add.w	r1, r2, #12
			if (c == ' ') break;
 80028d6:	d029      	beq.n	800292c <get_fileinfo.isra.2+0x9c>
			if (c == NDDE) c = (TCHAR)DDE;
 80028d8:	2805      	cmp	r0, #5
 80028da:	bf08      	it	eq
 80028dc:	20e5      	moveq	r0, #229	; 0xe5
			*p++ = c;
 80028de:	7310      	strb	r0, [r2, #12]
			c = dir[i];
 80028e0:	7918      	ldrb	r0, [r3, #4]
			if (c == ' ') break;
 80028e2:	2820      	cmp	r0, #32
			*p++ = c;
 80028e4:	f102 010d 	add.w	r1, r2, #13
			if (c == ' ') break;
 80028e8:	d020      	beq.n	800292c <get_fileinfo.isra.2+0x9c>
			if (c == NDDE) c = (TCHAR)DDE;
 80028ea:	2805      	cmp	r0, #5
 80028ec:	bf08      	it	eq
 80028ee:	20e5      	moveq	r0, #229	; 0xe5
			*p++ = c;
 80028f0:	7350      	strb	r0, [r2, #13]
			c = dir[i];
 80028f2:	7958      	ldrb	r0, [r3, #5]
			if (c == ' ') break;
 80028f4:	2820      	cmp	r0, #32
			*p++ = c;
 80028f6:	f102 010e 	add.w	r1, r2, #14
			if (c == ' ') break;
 80028fa:	d017      	beq.n	800292c <get_fileinfo.isra.2+0x9c>
			if (c == NDDE) c = (TCHAR)DDE;
 80028fc:	2805      	cmp	r0, #5
 80028fe:	bf08      	it	eq
 8002900:	20e5      	moveq	r0, #229	; 0xe5
			*p++ = c;
 8002902:	7390      	strb	r0, [r2, #14]
			c = dir[i];
 8002904:	7998      	ldrb	r0, [r3, #6]
			if (c == ' ') break;
 8002906:	2820      	cmp	r0, #32
			*p++ = c;
 8002908:	f102 010f 	add.w	r1, r2, #15
			if (c == ' ') break;
 800290c:	d00e      	beq.n	800292c <get_fileinfo.isra.2+0x9c>
			if (c == NDDE) c = (TCHAR)DDE;
 800290e:	2805      	cmp	r0, #5
 8002910:	bf08      	it	eq
 8002912:	20e5      	moveq	r0, #229	; 0xe5
			*p++ = c;
 8002914:	73d0      	strb	r0, [r2, #15]
			c = dir[i];
 8002916:	79d8      	ldrb	r0, [r3, #7]
			if (c == ' ') break;
 8002918:	2820      	cmp	r0, #32
			*p++ = c;
 800291a:	f102 0110 	add.w	r1, r2, #16
			if (c == ' ') break;
 800291e:	d005      	beq.n	800292c <get_fileinfo.isra.2+0x9c>
			if (c == NDDE) c = (TCHAR)DDE;
 8002920:	2805      	cmp	r0, #5
 8002922:	bf08      	it	eq
 8002924:	20e5      	moveq	r0, #229	; 0xe5
			*p++ = c;
 8002926:	7410      	strb	r0, [r2, #16]
 8002928:	f102 0111 	add.w	r1, r2, #17
		}
		if (dir[8] != ' ') {		/* Copy name extension */
 800292c:	7a18      	ldrb	r0, [r3, #8]
 800292e:	2820      	cmp	r0, #32
 8002930:	d027      	beq.n	8002982 <get_fileinfo.isra.2+0xf2>
			*p++ = '.';
 8002932:	202e      	movs	r0, #46	; 0x2e
 8002934:	7008      	strb	r0, [r1, #0]
			for (i = 8; i < 11; i++) {
				c = dir[i];
 8002936:	7a18      	ldrb	r0, [r3, #8]
				if (c == ' ') break;
 8002938:	2820      	cmp	r0, #32
			*p++ = '.';
 800293a:	f101 0401 	add.w	r4, r1, #1
				if (c == ' ') break;
 800293e:	d00d      	beq.n	800295c <get_fileinfo.isra.2+0xcc>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
 8002940:	7048      	strb	r0, [r1, #1]
				c = dir[i];
 8002942:	7a58      	ldrb	r0, [r3, #9]
				if (c == ' ') break;
 8002944:	2820      	cmp	r0, #32
				*p++ = c;
 8002946:	f101 0402 	add.w	r4, r1, #2
				if (c == ' ') break;
 800294a:	d007      	beq.n	800295c <get_fileinfo.isra.2+0xcc>
				*p++ = c;
 800294c:	7088      	strb	r0, [r1, #2]
				c = dir[i];
 800294e:	7a98      	ldrb	r0, [r3, #10]
				if (c == ' ') break;
 8002950:	2820      	cmp	r0, #32
				*p++ = c;
 8002952:	f101 0403 	add.w	r4, r1, #3
				if (c == ' ') break;
 8002956:	d001      	beq.n	800295c <get_fileinfo.isra.2+0xcc>
				*p++ = c;
 8002958:	70c8      	strb	r0, [r1, #3]
 800295a:	1d0c      	adds	r4, r1, #4
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 800295c:	7ad9      	ldrb	r1, [r3, #11]
 800295e:	7211      	strb	r1, [r2, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 8002960:	69d9      	ldr	r1, [r3, #28]
 8002962:	6011      	str	r1, [r2, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 8002964:	7e58      	ldrb	r0, [r3, #25]
 8002966:	7e19      	ldrb	r1, [r3, #24]
 8002968:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 800296c:	8091      	strh	r1, [r2, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 800296e:	7dd9      	ldrb	r1, [r3, #23]
 8002970:	7d9b      	ldrb	r3, [r3, #22]
 8002972:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8002976:	80d3      	strh	r3, [r2, #6]
	}
	*p = 0;		/* Terminate SFN str by a \0 */
 8002978:	2300      	movs	r3, #0
 800297a:	7023      	strb	r3, [r4, #0]
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
 800297c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002980:	4770      	bx	lr
		if (dir[8] != ' ') {		/* Copy name extension */
 8002982:	460c      	mov	r4, r1
 8002984:	e7ea      	b.n	800295c <get_fileinfo.isra.2+0xcc>
	p = fno->fname;
 8002986:	4621      	mov	r1, r4
 8002988:	e7d0      	b.n	800292c <get_fileinfo.isra.2+0x9c>
 800298a:	bf00      	nop

0800298c <sync_window.part.4>:
FRESULT sync_window (
 800298c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		wsect = fs->winsect;	/* Current sector number */
 800298e:	6b05      	ldr	r5, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002990:	f100 0734 	add.w	r7, r0, #52	; 0x34
FRESULT sync_window (
 8002994:	4604      	mov	r4, r0
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002996:	462a      	mov	r2, r5
 8002998:	7840      	ldrb	r0, [r0, #1]
 800299a:	4639      	mov	r1, r7
 800299c:	2301      	movs	r3, #1
 800299e:	f7ff ff2f 	bl	8002800 <disk_write>
 80029a2:	b9c0      	cbnz	r0, 80029d6 <sync_window.part.4+0x4a>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80029a4:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 80029a6:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80029a8:	4295      	cmp	r5, r2
 80029aa:	d312      	bcc.n	80029d2 <sync_window.part.4+0x46>
 80029ac:	69e3      	ldr	r3, [r4, #28]
 80029ae:	441a      	add	r2, r3
 80029b0:	4295      	cmp	r5, r2
 80029b2:	d20e      	bcs.n	80029d2 <sync_window.part.4+0x46>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80029b4:	78e6      	ldrb	r6, [r4, #3]
 80029b6:	2e01      	cmp	r6, #1
 80029b8:	d801      	bhi.n	80029be <sync_window.part.4+0x32>
 80029ba:	e00a      	b.n	80029d2 <sync_window.part.4+0x46>
 80029bc:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80029be:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80029c0:	441d      	add	r5, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80029c2:	3e01      	subs	r6, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 80029c4:	462a      	mov	r2, r5
 80029c6:	2301      	movs	r3, #1
 80029c8:	4639      	mov	r1, r7
 80029ca:	f7ff ff19 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80029ce:	2e01      	cmp	r6, #1
 80029d0:	d1f4      	bne.n	80029bc <sync_window.part.4+0x30>
	return FR_OK;
 80029d2:	2000      	movs	r0, #0
 80029d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return FR_DISK_ERR;
 80029d6:	2001      	movs	r0, #1
}
 80029d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80029da:	bf00      	nop

080029dc <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 80029dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
 80029e0:	6804      	ldr	r4, [r0, #0]
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
 80029e2:	7823      	ldrb	r3, [r4, #0]
 80029e4:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 80029e6:	2b09      	cmp	r3, #9
 80029e8:	d802      	bhi.n	80029f0 <chk_mounted+0x14>
 80029ea:	7865      	ldrb	r5, [r4, #1]
 80029ec:	2d3a      	cmp	r5, #58	; 0x3a
 80029ee:	d013      	beq.n	8002a18 <chk_mounted+0x3c>
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
 80029f0:	2300      	movs	r3, #0
 80029f2:	600b      	str	r3, [r1, #0]
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
 80029f4:	4eb2      	ldr	r6, [pc, #712]	; (8002cc0 <chk_mounted+0x2e4>)
 80029f6:	6835      	ldr	r5, [r6, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80029f8:	b30d      	cbz	r5, 8002a3e <chk_mounted+0x62>

	ENTER_FF(fs);						/* Lock volume */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
 80029fa:	600d      	str	r5, [r1, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 80029fc:	782b      	ldrb	r3, [r5, #0]
 80029fe:	4614      	mov	r4, r2
 8002a00:	b19b      	cbz	r3, 8002a2a <chk_mounted+0x4e>
		stat = disk_status(fs->drv);
 8002a02:	7868      	ldrb	r0, [r5, #1]
 8002a04:	f7ff fec0 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 8002a08:	07c7      	lsls	r7, r0, #31
 8002a0a:	d40e      	bmi.n	8002a2a <chk_mounted+0x4e>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8002a0c:	b304      	cbz	r4, 8002a50 <chk_mounted+0x74>
 8002a0e:	f010 0004 	ands.w	r0, r0, #4
 8002a12:	d11a      	bne.n	8002a4a <chk_mounted+0x6e>
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
 8002a14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		p += 2; *path = p;				/* Return pointer to the path name */
 8002a18:	3402      	adds	r4, #2
	*rfs = 0;
 8002a1a:	2500      	movs	r5, #0
		p += 2; *path = p;				/* Return pointer to the path name */
 8002a1c:	6004      	str	r4, [r0, #0]
	*rfs = 0;
 8002a1e:	600d      	str	r5, [r1, #0]
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 8002a20:	2b00      	cmp	r3, #0
 8002a22:	d0e7      	beq.n	80029f4 <chk_mounted+0x18>
		return FR_INVALID_DRIVE;
 8002a24:	200b      	movs	r0, #11
 8002a26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 8002a2a:	2000      	movs	r0, #0
 8002a2c:	7028      	strb	r0, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8002a2e:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8002a30:	f7ff fe90 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8002a34:	07c1      	lsls	r1, r0, #31
 8002a36:	d505      	bpl.n	8002a44 <chk_mounted+0x68>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8002a38:	2003      	movs	r0, #3
 8002a3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8002a3e:	200c      	movs	r0, #12
 8002a40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8002a44:	b13c      	cbz	r4, 8002a56 <chk_mounted+0x7a>
 8002a46:	0742      	lsls	r2, r0, #29
 8002a48:	d505      	bpl.n	8002a56 <chk_mounted+0x7a>
				return FR_WRITE_PROTECTED;
 8002a4a:	200a      	movs	r0, #10
 8002a4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return FR_OK;				/* The file system object is valid */
 8002a50:	4620      	mov	r0, r4
 8002a52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8002a56:	f105 0734 	add.w	r7, r5, #52	; 0x34
 8002a5a:	4639      	mov	r1, r7
 8002a5c:	2301      	movs	r3, #1
 8002a5e:	2200      	movs	r2, #0
 8002a60:	7868      	ldrb	r0, [r5, #1]
 8002a62:	f7ff feab 	bl	80027bc <disk_read>
 8002a66:	b110      	cbz	r0, 8002a6e <chk_mounted+0x92>
	if (fmt == 3) return FR_DISK_ERR;
 8002a68:	2001      	movs	r0, #1
 8002a6a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8002a6e:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8002a72:	f895 8232 	ldrb.w	r8, [r5, #562]	; 0x232
 8002a76:	4b93      	ldr	r3, [pc, #588]	; (8002cc4 <chk_mounted+0x2e8>)
 8002a78:	ea48 2802 	orr.w	r8, r8, r2, lsl #8
 8002a7c:	fa0f f888 	sxth.w	r8, r8
 8002a80:	4598      	cmp	r8, r3
 8002a82:	d002      	beq.n	8002a8a <chk_mounted+0xae>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8002a84:	200d      	movs	r0, #13
 8002a86:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8002a8a:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 8002a8e:	f8df 923c 	ldr.w	r9, [pc, #572]	; 8002ccc <chk_mounted+0x2f0>
 8002a92:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8002a96:	454b      	cmp	r3, r9
 8002a98:	f000 80bd 	beq.w	8002c16 <chk_mounted+0x23a>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8002a9c:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
 8002aa0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8002aa4:	454b      	cmp	r3, r9
 8002aa6:	f000 80b6 	beq.w	8002c16 <chk_mounted+0x23a>
		if (tbl[4]) {						/* Is the partition existing? */
 8002aaa:	f895 31f6 	ldrb.w	r3, [r5, #502]	; 0x1f6
 8002aae:	2b00      	cmp	r3, #0
 8002ab0:	d0e8      	beq.n	8002a84 <chk_mounted+0xa8>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 8002ab2:	f8d5 41fa 	ldr.w	r4, [r5, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8002ab6:	7868      	ldrb	r0, [r5, #1]
 8002ab8:	4622      	mov	r2, r4
 8002aba:	2301      	movs	r3, #1
 8002abc:	4639      	mov	r1, r7
 8002abe:	f7ff fe7d 	bl	80027bc <disk_read>
 8002ac2:	2800      	cmp	r0, #0
 8002ac4:	d1d0      	bne.n	8002a68 <chk_mounted+0x8c>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8002ac6:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8002aca:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
 8002ace:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002ad2:	b21b      	sxth	r3, r3
 8002ad4:	4543      	cmp	r3, r8
 8002ad6:	d1d5      	bne.n	8002a84 <chk_mounted+0xa8>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8002ad8:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 8002adc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8002ae0:	454b      	cmp	r3, r9
 8002ae2:	d005      	beq.n	8002af0 <chk_mounted+0x114>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8002ae4:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
 8002ae8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8002aec:	454b      	cmp	r3, r9
 8002aee:	d1c9      	bne.n	8002a84 <chk_mounted+0xa8>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8002af0:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
 8002af4:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
 8002af8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002afc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002b00:	d1c0      	bne.n	8002a84 <chk_mounted+0xa8>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8002b02:	f895 204b 	ldrb.w	r2, [r5, #75]	; 0x4b
 8002b06:	f895 304a 	ldrb.w	r3, [r5, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 8002b0a:	f895 0044 	ldrb.w	r0, [r5, #68]	; 0x44
 8002b0e:	70e8      	strb	r0, [r5, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8002b10:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8002b14:	bf18      	it	ne
 8002b16:	461a      	movne	r2, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8002b18:	f100 33ff 	add.w	r3, r0, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8002b1c:	bf08      	it	eq
 8002b1e:	6daa      	ldreq	r2, [r5, #88]	; 0x58
	fs->fsize = fasize;
 8002b20:	61ea      	str	r2, [r5, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8002b22:	2b01      	cmp	r3, #1
 8002b24:	d8ae      	bhi.n	8002a84 <chk_mounted+0xa8>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 8002b26:	f895 8041 	ldrb.w	r8, [r5, #65]	; 0x41
 8002b2a:	f885 8002 	strb.w	r8, [r5, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8002b2e:	f1b8 0f00 	cmp.w	r8, #0
 8002b32:	d0a7      	beq.n	8002a84 <chk_mounted+0xa8>
 8002b34:	f108 33ff 	add.w	r3, r8, #4294967295
 8002b38:	ea13 0f08 	tst.w	r3, r8
 8002b3c:	d1a2      	bne.n	8002a84 <chk_mounted+0xa8>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8002b3e:	f895 3046 	ldrb.w	r3, [r5, #70]	; 0x46
 8002b42:	f895 1045 	ldrb.w	r1, [r5, #69]	; 0x45
 8002b46:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8002b4a:	070b      	lsls	r3, r1, #28
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8002b4c:	8129      	strh	r1, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8002b4e:	d199      	bne.n	8002a84 <chk_mounted+0xa8>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8002b50:	f895 e048 	ldrb.w	lr, [r5, #72]	; 0x48
 8002b54:	f895 3047 	ldrb.w	r3, [r5, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8002b58:	f895 c043 	ldrb.w	ip, [r5, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8002b5c:	ea53 230e 	orrs.w	r3, r3, lr, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8002b60:	f895 e042 	ldrb.w	lr, [r5, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8002b64:	bf08      	it	eq
 8002b66:	6d6b      	ldreq	r3, [r5, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 8002b68:	ea5e 2e0c 	orrs.w	lr, lr, ip, lsl #8
 8002b6c:	d08a      	beq.n	8002a84 <chk_mounted+0xa8>
	fasize *= b;										/* Number of sectors for FAT area */
 8002b6e:	fb02 f000 	mul.w	r0, r2, r0
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8002b72:	eb0e 1c11 	add.w	ip, lr, r1, lsr #4
 8002b76:	4484      	add	ip, r0
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8002b78:	4563      	cmp	r3, ip
 8002b7a:	d383      	bcc.n	8002a84 <chk_mounted+0xa8>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8002b7c:	eba3 030c 	sub.w	r3, r3, ip
 8002b80:	fbb3 f3f8 	udiv	r3, r3, r8
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8002b84:	2b00      	cmp	r3, #0
 8002b86:	f43f af7d 	beq.w	8002a84 <chk_mounted+0xa8>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8002b8a:	f640 78f5 	movw	r8, #4085	; 0xff5
 8002b8e:	4543      	cmp	r3, r8
 8002b90:	d974      	bls.n	8002c7c <chk_mounted+0x2a0>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8002b92:	f64f 78f5 	movw	r8, #65525	; 0xfff5
 8002b96:	4543      	cmp	r3, r8
 8002b98:	d954      	bls.n	8002c44 <chk_mounted+0x268>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8002b9a:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8002b9c:	44a6      	add	lr, r4
	fs->database = bsect + sysect;						/* Data start sector */
 8002b9e:	eb0c 0004 	add.w	r0, ip, r4
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8002ba2:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8002ba4:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8002ba8:	62e8      	str	r0, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8002baa:	622c      	str	r4, [r5, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8002bac:	2900      	cmp	r1, #0
 8002bae:	f47f af69 	bne.w	8002a84 <chk_mounted+0xa8>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 8002bb2:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002bb4:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8002bb8:	6e28      	ldr	r0, [r5, #96]	; 0x60
 8002bba:	62a8      	str	r0, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002bbc:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
 8002bc0:	f4ff af60 	bcc.w	8002a84 <chk_mounted+0xa8>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8002bc4:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 8002bc8:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
	fs->last_clust = 0;
 8002bcc:	60e9      	str	r1, [r5, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8002bce:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8002bd2:	4422      	add	r2, r4
	fs->free_clust = 0xFFFFFFFF;
 8002bd4:	f04f 33ff 	mov.w	r3, #4294967295
	 	fs->fsi_flag = 0;
 8002bd8:	7169      	strb	r1, [r5, #5]
	fs->free_clust = 0xFFFFFFFF;
 8002bda:	612b      	str	r3, [r5, #16]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8002bdc:	4639      	mov	r1, r7
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8002bde:	616a      	str	r2, [r5, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8002be0:	2301      	movs	r3, #1
 8002be2:	7868      	ldrb	r0, [r5, #1]
 8002be4:	f7ff fdea 	bl	80027bc <disk_read>
 8002be8:	b948      	cbnz	r0, 8002bfe <chk_mounted+0x222>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8002bea:	f895 1233 	ldrb.w	r1, [r5, #563]	; 0x233
 8002bee:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8002bf2:	f64a 2255 	movw	r2, #43605	; 0xaa55
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8002bf6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8002bfa:	4293      	cmp	r3, r2
 8002bfc:	d00d      	beq.n	8002c1a <chk_mounted+0x23e>
 8002bfe:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 8002c00:	88b2      	ldrh	r2, [r6, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 8002c02:	702b      	strb	r3, [r5, #0]
	fs->winsect = 0;		/* Invalidate sector cache */
 8002c04:	2000      	movs	r0, #0
	fs->id = ++Fsid;		/* File system mount ID */
 8002c06:	1c53      	adds	r3, r2, #1
 8002c08:	b29b      	uxth	r3, r3
	fs->wflag = 0;
 8002c0a:	7128      	strb	r0, [r5, #4]
	fs->id = ++Fsid;		/* File system mount ID */
 8002c0c:	80b3      	strh	r3, [r6, #4]
 8002c0e:	80eb      	strh	r3, [r5, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 8002c10:	6328      	str	r0, [r5, #48]	; 0x30
	return FR_OK;
 8002c12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 8002c16:	4604      	mov	r4, r0
 8002c18:	e76a      	b.n	8002af0 <chk_mounted+0x114>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8002c1a:	4b2b      	ldr	r3, [pc, #172]	; (8002cc8 <chk_mounted+0x2ec>)
 8002c1c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8002c1e:	429a      	cmp	r2, r3
 8002c20:	d1ed      	bne.n	8002bfe <chk_mounted+0x222>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8002c22:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 8002c26:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8002c2a:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
 8002c2e:	3320      	adds	r3, #32
 8002c30:	429a      	cmp	r2, r3
 8002c32:	d1e4      	bne.n	8002bfe <chk_mounted+0x222>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8002c34:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8002c38:	f8d5 2220 	ldr.w	r2, [r5, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8002c3c:	612b      	str	r3, [r5, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8002c3e:	60ea      	str	r2, [r5, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8002c40:	2303      	movs	r3, #3
 8002c42:	e7dd      	b.n	8002c00 <chk_mounted+0x224>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8002c44:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8002c46:	eb0e 0704 	add.w	r7, lr, r4
	fs->database = bsect + sysect;						/* Data start sector */
 8002c4a:	44a4      	add	ip, r4
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8002c4c:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8002c4e:	626f      	str	r7, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8002c50:	f8c5 c02c 	str.w	ip, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8002c54:	622c      	str	r4, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8002c56:	2900      	cmp	r1, #0
 8002c58:	f43f af14 	beq.w	8002a84 <chk_mounted+0xa8>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8002c5c:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002c5e:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8002c62:	4438      	add	r0, r7
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002c64:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8002c68:	62a8      	str	r0, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002c6a:	f4ff af0b 	bcc.w	8002a84 <chk_mounted+0xa8>
	fs->last_clust = 0;
 8002c6e:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8002c70:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8002c74:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 8002c76:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 8002c78:	2302      	movs	r3, #2
 8002c7a:	e7c1      	b.n	8002c00 <chk_mounted+0x224>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8002c7c:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8002c7e:	eb0e 0704 	add.w	r7, lr, r4
	fs->database = bsect + sysect;						/* Data start sector */
 8002c82:	44a4      	add	ip, r4
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8002c84:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8002c86:	626f      	str	r7, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8002c88:	f8c5 c02c 	str.w	ip, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8002c8c:	622c      	str	r4, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8002c8e:	2900      	cmp	r1, #0
 8002c90:	f43f aef8 	beq.w	8002a84 <chk_mounted+0xa8>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8002c94:	f003 0101 	and.w	r1, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002c98:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8002c9c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002ca0:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8002ca4:	4438      	add	r0, r7
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002ca6:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8002caa:	62a8      	str	r0, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8002cac:	f4ff aeea 	bcc.w	8002a84 <chk_mounted+0xa8>
	fs->last_clust = 0;
 8002cb0:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8002cb2:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8002cb6:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 8002cb8:	612a      	str	r2, [r5, #16]
	fmt = FS_FAT12;
 8002cba:	2301      	movs	r3, #1
 8002cbc:	e7a0      	b.n	8002c00 <chk_mounted+0x224>
 8002cbe:	bf00      	nop
 8002cc0:	20002128 	.word	0x20002128
 8002cc4:	ffffaa55 	.word	0xffffaa55
 8002cc8:	41615252 	.word	0x41615252
 8002ccc:	00544146 	.word	0x00544146

08002cd0 <sync_fs>:
{
 8002cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002cd2:	7903      	ldrb	r3, [r0, #4]
{
 8002cd4:	4604      	mov	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002cd6:	b95b      	cbnz	r3, 8002cf0 <sync_fs+0x20>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 8002cd8:	7823      	ldrb	r3, [r4, #0]
 8002cda:	2b03      	cmp	r3, #3
 8002cdc:	d02c      	beq.n	8002d38 <sync_fs+0x68>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 8002cde:	2200      	movs	r2, #0
 8002ce0:	7860      	ldrb	r0, [r4, #1]
 8002ce2:	4611      	mov	r1, r2
 8002ce4:	f7ff fdb2 	bl	800284c <disk_ioctl>
 8002ce8:	3000      	adds	r0, #0
 8002cea:	bf18      	it	ne
 8002cec:	2001      	movne	r0, #1
 8002cee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
 8002cf0:	6b05      	ldr	r5, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002cf2:	7840      	ldrb	r0, [r0, #1]
 8002cf4:	f104 0734 	add.w	r7, r4, #52	; 0x34
 8002cf8:	462a      	mov	r2, r5
 8002cfa:	4639      	mov	r1, r7
 8002cfc:	2301      	movs	r3, #1
 8002cfe:	f7ff fd7f 	bl	8002800 <disk_write>
 8002d02:	b9b8      	cbnz	r0, 8002d34 <sync_fs+0x64>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002d04:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 8002d06:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002d08:	4295      	cmp	r5, r2
 8002d0a:	d3e5      	bcc.n	8002cd8 <sync_fs+0x8>
 8002d0c:	69e3      	ldr	r3, [r4, #28]
 8002d0e:	441a      	add	r2, r3
 8002d10:	4295      	cmp	r5, r2
 8002d12:	d2e1      	bcs.n	8002cd8 <sync_fs+0x8>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002d14:	78e6      	ldrb	r6, [r4, #3]
 8002d16:	2e01      	cmp	r6, #1
 8002d18:	d801      	bhi.n	8002d1e <sync_fs+0x4e>
 8002d1a:	e7dd      	b.n	8002cd8 <sync_fs+0x8>
 8002d1c:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8002d1e:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8002d20:	441d      	add	r5, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002d22:	3e01      	subs	r6, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 8002d24:	462a      	mov	r2, r5
 8002d26:	2301      	movs	r3, #1
 8002d28:	4639      	mov	r1, r7
 8002d2a:	f7ff fd69 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002d2e:	2e01      	cmp	r6, #1
 8002d30:	d1f4      	bne.n	8002d1c <sync_fs+0x4c>
 8002d32:	e7d1      	b.n	8002cd8 <sync_fs+0x8>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002d34:	2001      	movs	r0, #1
	return res;
 8002d36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 8002d38:	7963      	ldrb	r3, [r4, #5]
 8002d3a:	2b00      	cmp	r3, #0
 8002d3c:	d0cf      	beq.n	8002cde <sync_fs+0xe>
			fs->winsect = 0;
 8002d3e:	2600      	movs	r6, #0
		*d++ = (BYTE)val;
 8002d40:	f104 0534 	add.w	r5, r4, #52	; 0x34
 8002d44:	4631      	mov	r1, r6
 8002d46:	4628      	mov	r0, r5
 8002d48:	f44f 7200 	mov.w	r2, #512	; 0x200
			fs->winsect = 0;
 8002d4c:	6326      	str	r6, [r4, #48]	; 0x30
 8002d4e:	f011 fc56 	bl	80145fe <memset>
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8002d52:	6922      	ldr	r2, [r4, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8002d54:	68e3      	ldr	r3, [r4, #12]
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8002d56:	f884 221c 	strb.w	r2, [r4, #540]	; 0x21c
 8002d5a:	f3c2 2e07 	ubfx	lr, r2, #8, #8
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 8002d5e:	4629      	mov	r1, r5
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8002d60:	0c15      	lsrs	r5, r2, #16
 8002d62:	0e12      	lsrs	r2, r2, #24
 8002d64:	f884 521e 	strb.w	r5, [r4, #542]	; 0x21e
 8002d68:	f884 221f 	strb.w	r2, [r4, #543]	; 0x21f
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8002d6c:	f3c3 2507 	ubfx	r5, r3, #8, #8
 8002d70:	0c1a      	lsrs	r2, r3, #16
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8002d72:	480e      	ldr	r0, [pc, #56]	; (8002dac <sync_fs+0xdc>)
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8002d74:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
 8002d78:	f884 5221 	strb.w	r5, [r4, #545]	; 0x221
 8002d7c:	0e1b      	lsrs	r3, r3, #24
 8002d7e:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 8002d82:	4f0b      	ldr	r7, [pc, #44]	; (8002db0 <sync_fs+0xe0>)
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8002d84:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 8002d88:	22aa      	movs	r2, #170	; 0xaa
 8002d8a:	2555      	movs	r5, #85	; 0x55
 8002d8c:	f884 2233 	strb.w	r2, [r4, #563]	; 0x233
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8002d90:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8002d94:	f884 e21d 	strb.w	lr, [r4, #541]	; 0x21d
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 8002d98:	f884 5232 	strb.w	r5, [r4, #562]	; 0x232
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 8002d9c:	6367      	str	r7, [r4, #52]	; 0x34
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 8002d9e:	2301      	movs	r3, #1
 8002da0:	6962      	ldr	r2, [r4, #20]
 8002da2:	7860      	ldrb	r0, [r4, #1]
 8002da4:	f7ff fd2c 	bl	8002800 <disk_write>
			fs->fsi_flag = 0;
 8002da8:	7166      	strb	r6, [r4, #5]
 8002daa:	e798      	b.n	8002cde <sync_fs+0xe>
 8002dac:	61417272 	.word	0x61417272
 8002db0:	41615252 	.word	0x41615252

08002db4 <put_fat.part.8>:
FRESULT put_fat (
 8002db4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		switch (fs->fs_type) {
 8002db8:	7803      	ldrb	r3, [r0, #0]
 8002dba:	2b02      	cmp	r3, #2
FRESULT put_fat (
 8002dbc:	4604      	mov	r4, r0
 8002dbe:	460d      	mov	r5, r1
 8002dc0:	4617      	mov	r7, r2
		switch (fs->fs_type) {
 8002dc2:	d078      	beq.n	8002eb6 <put_fat.part.8+0x102>
 8002dc4:	2b03      	cmp	r3, #3
 8002dc6:	d044      	beq.n	8002e52 <put_fat.part.8+0x9e>
 8002dc8:	2b01      	cmp	r3, #1
 8002dca:	d004      	beq.n	8002dd6 <put_fat.part.8+0x22>
			res = FR_INT_ERR;
 8002dcc:	2002      	movs	r0, #2
		fs->wflag = 1;
 8002dce:	2301      	movs	r3, #1
 8002dd0:	7123      	strb	r3, [r4, #4]
}
 8002dd2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002dd6:	6a46      	ldr	r6, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8002dd8:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 8002ddc:	eb01 0951 	add.w	r9, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002de0:	eb06 2a59 	add.w	sl, r6, r9, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 8002de4:	45c2      	cmp	sl, r8
 8002de6:	d012      	beq.n	8002e0e <put_fat.part.8+0x5a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002de8:	7902      	ldrb	r2, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002dea:	f100 0634 	add.w	r6, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002dee:	2a00      	cmp	r2, #0
 8002df0:	f040 8087 	bne.w	8002f02 <put_fat.part.8+0x14e>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8002df4:	4631      	mov	r1, r6
 8002df6:	2301      	movs	r3, #1
 8002df8:	4652      	mov	r2, sl
 8002dfa:	7860      	ldrb	r0, [r4, #1]
 8002dfc:	f7ff fcde 	bl	80027bc <disk_read>
 8002e00:	2800      	cmp	r0, #0
 8002e02:	f040 8100 	bne.w	8003006 <put_fat.part.8+0x252>
 8002e06:	6a66      	ldr	r6, [r4, #36]	; 0x24
		fs->winsect = sector;
 8002e08:	f8c4 a030 	str.w	sl, [r4, #48]	; 0x30
 8002e0c:	46d0      	mov	r8, sl
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8002e0e:	f015 0501 	ands.w	r5, r5, #1
			p = &fs->win[bc % SS(fs)];
 8002e12:	f3c9 0308 	ubfx	r3, r9, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8002e16:	f000 80e2 	beq.w	8002fde <put_fat.part.8+0x22a>
 8002e1a:	4423      	add	r3, r4
			bc++;
 8002e1c:	f109 0901 	add.w	r9, r9, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8002e20:	f893 1034 	ldrb.w	r1, [r3, #52]	; 0x34
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002e24:	eb06 2659 	add.w	r6, r6, r9, lsr #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8002e28:	f001 010f 	and.w	r1, r1, #15
 8002e2c:	ea41 1207 	orr.w	r2, r1, r7, lsl #4
	if (sector != fs->winsect) {	/* Changed current window */
 8002e30:	4546      	cmp	r6, r8
			fs->wflag = 1;
 8002e32:	f04f 0101 	mov.w	r1, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8002e36:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
			fs->wflag = 1;
 8002e3a:	7121      	strb	r1, [r4, #4]
	if (sector != fs->winsect) {	/* Changed current window */
 8002e3c:	f040 80da 	bne.w	8002ff4 <put_fat.part.8+0x240>
			p = &fs->win[bc % SS(fs)];
 8002e40:	f3c9 0308 	ubfx	r3, r9, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8002e44:	f3c7 1707 	ubfx	r7, r7, #4, #8
 8002e48:	4423      	add	r3, r4
 8002e4a:	f883 7034 	strb.w	r7, [r3, #52]	; 0x34
 8002e4e:	2000      	movs	r0, #0
 8002e50:	e7bd      	b.n	8002dce <put_fat.part.8+0x1a>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8002e52:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8002e54:	f8d0 9030 	ldr.w	r9, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8002e58:	eb03 18d1 	add.w	r8, r3, r1, lsr #7
	if (sector != fs->winsect) {	/* Changed current window */
 8002e5c:	45c8      	cmp	r8, r9
 8002e5e:	d010      	beq.n	8002e82 <put_fat.part.8+0xce>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002e60:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002e62:	f100 0634 	add.w	r6, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002e66:	2b00      	cmp	r3, #0
 8002e68:	f040 8094 	bne.w	8002f94 <put_fat.part.8+0x1e0>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8002e6c:	4631      	mov	r1, r6
 8002e6e:	2301      	movs	r3, #1
 8002e70:	4642      	mov	r2, r8
 8002e72:	7860      	ldrb	r0, [r4, #1]
 8002e74:	f7ff fca2 	bl	80027bc <disk_read>
 8002e78:	2800      	cmp	r0, #0
 8002e7a:	f040 80c4 	bne.w	8003006 <put_fat.part.8+0x252>
		fs->winsect = sector;
 8002e7e:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
			p = &fs->win[clst * 4 % SS(fs)];
 8002e82:	00ad      	lsls	r5, r5, #2
 8002e84:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8002e88:	f105 0234 	add.w	r2, r5, #52	; 0x34
 8002e8c:	4422      	add	r2, r4
			val |= LD_DWORD(p) & 0xF0000000;
 8002e8e:	4425      	add	r5, r4
 8002e90:	78d3      	ldrb	r3, [r2, #3]
 8002e92:	061b      	lsls	r3, r3, #24
 8002e94:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8002e98:	431f      	orrs	r7, r3
			ST_DWORD(p, val);
 8002e9a:	0e3b      	lsrs	r3, r7, #24
 8002e9c:	f885 7034 	strb.w	r7, [r5, #52]	; 0x34
 8002ea0:	f3c7 2607 	ubfx	r6, r7, #8, #8
 8002ea4:	70d3      	strb	r3, [r2, #3]
 8002ea6:	0c39      	lsrs	r1, r7, #16
		fs->wflag = 1;
 8002ea8:	2301      	movs	r3, #1
			ST_DWORD(p, val);
 8002eaa:	7056      	strb	r6, [r2, #1]
 8002eac:	7091      	strb	r1, [r2, #2]
		fs->wflag = 1;
 8002eae:	7123      	strb	r3, [r4, #4]
			ST_DWORD(p, val);
 8002eb0:	2000      	movs	r0, #0
}
 8002eb2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8002eb6:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8002eb8:	f8d0 9030 	ldr.w	r9, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8002ebc:	eb03 2811 	add.w	r8, r3, r1, lsr #8
	if (sector != fs->winsect) {	/* Changed current window */
 8002ec0:	45c8      	cmp	r8, r9
 8002ec2:	d00f      	beq.n	8002ee4 <put_fat.part.8+0x130>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002ec4:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002ec6:	f100 0634 	add.w	r6, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002eca:	2b00      	cmp	r3, #0
 8002ecc:	d13e      	bne.n	8002f4c <put_fat.part.8+0x198>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8002ece:	4631      	mov	r1, r6
 8002ed0:	2301      	movs	r3, #1
 8002ed2:	4642      	mov	r2, r8
 8002ed4:	7860      	ldrb	r0, [r4, #1]
 8002ed6:	f7ff fc71 	bl	80027bc <disk_read>
 8002eda:	2800      	cmp	r0, #0
 8002edc:	f040 8093 	bne.w	8003006 <put_fat.part.8+0x252>
		fs->winsect = sector;
 8002ee0:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
			p = &fs->win[clst * 2 % SS(fs)];
 8002ee4:	006d      	lsls	r5, r5, #1
 8002ee6:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
 8002eea:	4425      	add	r5, r4
 8002eec:	f3c7 2307 	ubfx	r3, r7, #8, #8
 8002ef0:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
		fs->wflag = 1;
 8002ef4:	2301      	movs	r3, #1
			ST_WORD(p, (WORD)val);
 8002ef6:	f885 7034 	strb.w	r7, [r5, #52]	; 0x34
		fs->wflag = 1;
 8002efa:	7123      	strb	r3, [r4, #4]
			ST_WORD(p, (WORD)val);
 8002efc:	2000      	movs	r0, #0
}
 8002efe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002f02:	4631      	mov	r1, r6
 8002f04:	4642      	mov	r2, r8
 8002f06:	7840      	ldrb	r0, [r0, #1]
 8002f08:	f7ff fc7a 	bl	8002800 <disk_write>
 8002f0c:	2800      	cmp	r0, #0
 8002f0e:	d17a      	bne.n	8003006 <put_fat.part.8+0x252>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002f10:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 8002f12:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002f14:	4590      	cmp	r8, r2
 8002f16:	f4ff af6d 	bcc.w	8002df4 <put_fat.part.8+0x40>
 8002f1a:	69e3      	ldr	r3, [r4, #28]
 8002f1c:	441a      	add	r2, r3
 8002f1e:	4590      	cmp	r8, r2
 8002f20:	f4bf af68 	bcs.w	8002df4 <put_fat.part.8+0x40>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002f24:	f894 b003 	ldrb.w	fp, [r4, #3]
 8002f28:	f1bb 0f01 	cmp.w	fp, #1
 8002f2c:	d801      	bhi.n	8002f32 <put_fat.part.8+0x17e>
 8002f2e:	e761      	b.n	8002df4 <put_fat.part.8+0x40>
 8002f30:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8002f32:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8002f34:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002f36:	f10b 3bff 	add.w	fp, fp, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8002f3a:	4642      	mov	r2, r8
 8002f3c:	2301      	movs	r3, #1
 8002f3e:	4631      	mov	r1, r6
 8002f40:	f7ff fc5e 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002f44:	f1bb 0f01 	cmp.w	fp, #1
 8002f48:	d1f2      	bne.n	8002f30 <put_fat.part.8+0x17c>
 8002f4a:	e753      	b.n	8002df4 <put_fat.part.8+0x40>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002f4c:	4631      	mov	r1, r6
 8002f4e:	2301      	movs	r3, #1
 8002f50:	464a      	mov	r2, r9
 8002f52:	7840      	ldrb	r0, [r0, #1]
 8002f54:	f7ff fc54 	bl	8002800 <disk_write>
 8002f58:	2800      	cmp	r0, #0
 8002f5a:	d154      	bne.n	8003006 <put_fat.part.8+0x252>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002f5c:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 8002f5e:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002f60:	4591      	cmp	r9, r2
 8002f62:	d3b4      	bcc.n	8002ece <put_fat.part.8+0x11a>
 8002f64:	69e3      	ldr	r3, [r4, #28]
 8002f66:	441a      	add	r2, r3
 8002f68:	4591      	cmp	r9, r2
 8002f6a:	d2b0      	bcs.n	8002ece <put_fat.part.8+0x11a>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002f6c:	f894 a003 	ldrb.w	sl, [r4, #3]
 8002f70:	f1ba 0f01 	cmp.w	sl, #1
 8002f74:	d801      	bhi.n	8002f7a <put_fat.part.8+0x1c6>
 8002f76:	e7aa      	b.n	8002ece <put_fat.part.8+0x11a>
 8002f78:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8002f7a:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8002f7c:	4499      	add	r9, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002f7e:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8002f82:	464a      	mov	r2, r9
 8002f84:	2301      	movs	r3, #1
 8002f86:	4631      	mov	r1, r6
 8002f88:	f7ff fc3a 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002f8c:	f1ba 0f01 	cmp.w	sl, #1
 8002f90:	d1f2      	bne.n	8002f78 <put_fat.part.8+0x1c4>
 8002f92:	e79c      	b.n	8002ece <put_fat.part.8+0x11a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002f94:	4631      	mov	r1, r6
 8002f96:	2301      	movs	r3, #1
 8002f98:	464a      	mov	r2, r9
 8002f9a:	7840      	ldrb	r0, [r0, #1]
 8002f9c:	f7ff fc30 	bl	8002800 <disk_write>
 8002fa0:	bb88      	cbnz	r0, 8003006 <put_fat.part.8+0x252>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002fa2:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 8002fa4:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8002fa6:	4591      	cmp	r9, r2
 8002fa8:	f4ff af60 	bcc.w	8002e6c <put_fat.part.8+0xb8>
 8002fac:	69e3      	ldr	r3, [r4, #28]
 8002fae:	441a      	add	r2, r3
 8002fb0:	4591      	cmp	r9, r2
 8002fb2:	f4bf af5b 	bcs.w	8002e6c <put_fat.part.8+0xb8>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002fb6:	f894 a003 	ldrb.w	sl, [r4, #3]
 8002fba:	f1ba 0f01 	cmp.w	sl, #1
 8002fbe:	d801      	bhi.n	8002fc4 <put_fat.part.8+0x210>
 8002fc0:	e754      	b.n	8002e6c <put_fat.part.8+0xb8>
 8002fc2:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8002fc4:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8002fc6:	4499      	add	r9, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002fc8:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8002fcc:	464a      	mov	r2, r9
 8002fce:	2301      	movs	r3, #1
 8002fd0:	4631      	mov	r1, r6
 8002fd2:	f7ff fc15 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002fd6:	f1ba 0f01 	cmp.w	sl, #1
 8002fda:	d1f2      	bne.n	8002fc2 <put_fat.part.8+0x20e>
 8002fdc:	e746      	b.n	8002e6c <put_fat.part.8+0xb8>
			bc++;
 8002fde:	f109 0901 	add.w	r9, r9, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8002fe2:	4423      	add	r3, r4
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8002fe4:	eb06 2659 	add.w	r6, r6, r9, lsr #9
			fs->wflag = 1;
 8002fe8:	2201      	movs	r2, #1
	if (sector != fs->winsect) {	/* Changed current window */
 8002fea:	4546      	cmp	r6, r8
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8002fec:	f883 7034 	strb.w	r7, [r3, #52]	; 0x34
			fs->wflag = 1;
 8002ff0:	7122      	strb	r2, [r4, #4]
	if (sector != fs->winsect) {	/* Changed current window */
 8002ff2:	d03f      	beq.n	8003074 <put_fat.part.8+0x2c0>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8002ff4:	f104 0b34 	add.w	fp, r4, #52	; 0x34
 8002ff8:	4659      	mov	r1, fp
 8002ffa:	2301      	movs	r3, #1
 8002ffc:	4642      	mov	r2, r8
 8002ffe:	7860      	ldrb	r0, [r4, #1]
 8003000:	f7ff fbfe 	bl	8002800 <disk_write>
 8003004:	b120      	cbz	r0, 8003010 <put_fat.part.8+0x25c>
		fs->wflag = 1;
 8003006:	2301      	movs	r3, #1
 8003008:	7123      	strb	r3, [r4, #4]
			res = FR_INT_ERR;
 800300a:	2001      	movs	r0, #1
}
 800300c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003010:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 8003012:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003014:	4590      	cmp	r8, r2
 8003016:	d316      	bcc.n	8003046 <put_fat.part.8+0x292>
 8003018:	69e3      	ldr	r3, [r4, #28]
 800301a:	441a      	add	r2, r3
 800301c:	4590      	cmp	r8, r2
 800301e:	d212      	bcs.n	8003046 <put_fat.part.8+0x292>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003020:	f894 a003 	ldrb.w	sl, [r4, #3]
 8003024:	f1ba 0f01 	cmp.w	sl, #1
 8003028:	d801      	bhi.n	800302e <put_fat.part.8+0x27a>
 800302a:	e00c      	b.n	8003046 <put_fat.part.8+0x292>
 800302c:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800302e:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8003030:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003032:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8003036:	4642      	mov	r2, r8
 8003038:	2301      	movs	r3, #1
 800303a:	4659      	mov	r1, fp
 800303c:	f7ff fbe0 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003040:	f1ba 0f01 	cmp.w	sl, #1
 8003044:	d1f2      	bne.n	800302c <put_fat.part.8+0x278>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8003046:	4659      	mov	r1, fp
 8003048:	2301      	movs	r3, #1
 800304a:	4632      	mov	r2, r6
 800304c:	7860      	ldrb	r0, [r4, #1]
 800304e:	f7ff fbb5 	bl	80027bc <disk_read>
 8003052:	2800      	cmp	r0, #0
 8003054:	d1d7      	bne.n	8003006 <put_fat.part.8+0x252>
		fs->winsect = sector;
 8003056:	6326      	str	r6, [r4, #48]	; 0x30
			p = &fs->win[bc % SS(fs)];
 8003058:	f3c9 0308 	ubfx	r3, r9, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800305c:	2d00      	cmp	r5, #0
 800305e:	f47f aef1 	bne.w	8002e44 <put_fat.part.8+0x90>
 8003062:	4423      	add	r3, r4
 8003064:	f3c7 2203 	ubfx	r2, r7, #8, #4
 8003068:	f893 7034 	ldrb.w	r7, [r3, #52]	; 0x34
 800306c:	f027 070f 	bic.w	r7, r7, #15
 8003070:	4317      	orrs	r7, r2
 8003072:	e6ea      	b.n	8002e4a <put_fat.part.8+0x96>
			p = &fs->win[bc % SS(fs)];
 8003074:	f3c9 0308 	ubfx	r3, r9, #0, #9
 8003078:	e7f3      	b.n	8003062 <put_fat.part.8+0x2ae>
 800307a:	bf00      	nop

0800307c <remove_chain.part.10>:
FRESULT remove_chain (
 800307c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003080:	4604      	mov	r4, r0
 8003082:	460d      	mov	r5, r1
		while (clst < fs->n_fatent) {			/* Not a last link? */
 8003084:	69a3      	ldr	r3, [r4, #24]
 8003086:	429d      	cmp	r5, r3
FRESULT remove_chain (
 8003088:	b083      	sub	sp, #12
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800308a:	f100 0634 	add.w	r6, r0, #52	; 0x34
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800308e:	f04f 0a01 	mov.w	sl, #1
		while (clst < fs->n_fatent) {			/* Not a last link? */
 8003092:	f080 80b6 	bcs.w	8003202 <remove_chain.part.10+0x186>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8003096:	2d01      	cmp	r5, #1
 8003098:	d972      	bls.n	8003180 <remove_chain.part.10+0x104>
	switch (fs->fs_type) {
 800309a:	7823      	ldrb	r3, [r4, #0]
 800309c:	2b02      	cmp	r3, #2
 800309e:	f000 80b2 	beq.w	8003206 <remove_chain.part.10+0x18a>
 80030a2:	2b03      	cmp	r3, #3
 80030a4:	d070      	beq.n	8003188 <remove_chain.part.10+0x10c>
 80030a6:	2b01      	cmp	r3, #1
 80030a8:	d003      	beq.n	80030b2 <remove_chain.part.10+0x36>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 80030aa:	2001      	movs	r0, #1
}
 80030ac:	b003      	add	sp, #12
 80030ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 80030b2:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 80030b4:	6b27      	ldr	r7, [r4, #48]	; 0x30
		bc = (UINT)clst; bc += bc / 2;
 80030b6:	eb05 0855 	add.w	r8, r5, r5, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 80030ba:	eb02 2b58 	add.w	fp, r2, r8, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 80030be:	45bb      	cmp	fp, r7
 80030c0:	d00f      	beq.n	80030e2 <remove_chain.part.10+0x66>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80030c2:	7922      	ldrb	r2, [r4, #4]
 80030c4:	2a00      	cmp	r2, #0
 80030c6:	f040 8108 	bne.w	80032da <remove_chain.part.10+0x25e>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80030ca:	2301      	movs	r3, #1
 80030cc:	465a      	mov	r2, fp
 80030ce:	4631      	mov	r1, r6
 80030d0:	7860      	ldrb	r0, [r4, #1]
 80030d2:	f7ff fb73 	bl	80027bc <disk_read>
 80030d6:	2800      	cmp	r0, #0
 80030d8:	d1e7      	bne.n	80030aa <remove_chain.part.10+0x2e>
 80030da:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->winsect = sector;
 80030dc:	f8c4 b030 	str.w	fp, [r4, #48]	; 0x30
 80030e0:	465f      	mov	r7, fp
		wc = fs->win[bc % SS(fs)]; bc++;
 80030e2:	f3c8 0308 	ubfx	r3, r8, #0, #9
 80030e6:	f108 0801 	add.w	r8, r8, #1
 80030ea:	4423      	add	r3, r4
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 80030ec:	eb02 2958 	add.w	r9, r2, r8, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 80030f0:	45b9      	cmp	r9, r7
		wc = fs->win[bc % SS(fs)]; bc++;
 80030f2:	f893 b034 	ldrb.w	fp, [r3, #52]	; 0x34
	if (sector != fs->winsect) {	/* Changed current window */
 80030f6:	d031      	beq.n	800315c <remove_chain.part.10+0xe0>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80030f8:	7923      	ldrb	r3, [r4, #4]
 80030fa:	b32b      	cbz	r3, 8003148 <remove_chain.part.10+0xcc>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80030fc:	2301      	movs	r3, #1
 80030fe:	463a      	mov	r2, r7
 8003100:	4631      	mov	r1, r6
 8003102:	7860      	ldrb	r0, [r4, #1]
 8003104:	f7ff fb7c 	bl	8002800 <disk_write>
 8003108:	2800      	cmp	r0, #0
 800310a:	d1ce      	bne.n	80030aa <remove_chain.part.10+0x2e>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800310c:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 800310e:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003110:	42ba      	cmp	r2, r7
 8003112:	d819      	bhi.n	8003148 <remove_chain.part.10+0xcc>
 8003114:	69e3      	ldr	r3, [r4, #28]
 8003116:	441a      	add	r2, r3
 8003118:	42ba      	cmp	r2, r7
 800311a:	d915      	bls.n	8003148 <remove_chain.part.10+0xcc>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800311c:	78e2      	ldrb	r2, [r4, #3]
 800311e:	2a01      	cmp	r2, #1
 8003120:	d912      	bls.n	8003148 <remove_chain.part.10+0xcc>
 8003122:	f8cd b004 	str.w	fp, [sp, #4]
 8003126:	4693      	mov	fp, r2
 8003128:	e000      	b.n	800312c <remove_chain.part.10+0xb0>
 800312a:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800312c:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 800312e:	441f      	add	r7, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003130:	f10b 3bff 	add.w	fp, fp, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8003134:	463a      	mov	r2, r7
 8003136:	2301      	movs	r3, #1
 8003138:	4631      	mov	r1, r6
 800313a:	f7ff fb61 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800313e:	f1bb 0f01 	cmp.w	fp, #1
 8003142:	d1f2      	bne.n	800312a <remove_chain.part.10+0xae>
 8003144:	f8dd b004 	ldr.w	fp, [sp, #4]
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8003148:	7860      	ldrb	r0, [r4, #1]
 800314a:	2301      	movs	r3, #1
 800314c:	464a      	mov	r2, r9
 800314e:	4631      	mov	r1, r6
 8003150:	f7ff fb34 	bl	80027bc <disk_read>
 8003154:	2800      	cmp	r0, #0
 8003156:	d1a8      	bne.n	80030aa <remove_chain.part.10+0x2e>
		fs->winsect = sector;
 8003158:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
		wc |= fs->win[bc % SS(fs)] << 8;
 800315c:	f3c8 0308 	ubfx	r3, r8, #0, #9
 8003160:	4423      	add	r3, r4
 8003162:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8003166:	ea4b 2703 	orr.w	r7, fp, r3, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800316a:	07eb      	lsls	r3, r5, #31
 800316c:	f140 80db 	bpl.w	8003326 <remove_chain.part.10+0x2aa>
 8003170:	093f      	lsrs	r7, r7, #4
			if (nxt == 0) break;				/* Empty cluster? */
 8003172:	2f00      	cmp	r7, #0
 8003174:	d045      	beq.n	8003202 <remove_chain.part.10+0x186>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8003176:	2f01      	cmp	r7, #1
 8003178:	d002      	beq.n	8003180 <remove_chain.part.10+0x104>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800317a:	69a3      	ldr	r3, [r4, #24]
 800317c:	429d      	cmp	r5, r3
 800317e:	d32c      	bcc.n	80031da <remove_chain.part.10+0x15e>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8003180:	2002      	movs	r0, #2
}
 8003182:	b003      	add	sp, #12
 8003184:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 8003188:	6a67      	ldr	r7, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 800318a:	f8d4 8030 	ldr.w	r8, [r4, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 800318e:	eb07 17d5 	add.w	r7, r7, r5, lsr #7
	if (sector != fs->winsect) {	/* Changed current window */
 8003192:	4547      	cmp	r7, r8
 8003194:	d00c      	beq.n	80031b0 <remove_chain.part.10+0x134>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003196:	7923      	ldrb	r3, [r4, #4]
 8003198:	2b00      	cmp	r3, #0
 800319a:	d177      	bne.n	800328c <remove_chain.part.10+0x210>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800319c:	2301      	movs	r3, #1
 800319e:	463a      	mov	r2, r7
 80031a0:	4631      	mov	r1, r6
 80031a2:	7860      	ldrb	r0, [r4, #1]
 80031a4:	f7ff fb0a 	bl	80027bc <disk_read>
 80031a8:	2800      	cmp	r0, #0
 80031aa:	f47f af7e 	bne.w	80030aa <remove_chain.part.10+0x2e>
		fs->winsect = sector;
 80031ae:	6327      	str	r7, [r4, #48]	; 0x30
		p = &fs->win[clst * 4 % SS(fs)];
 80031b0:	00ab      	lsls	r3, r5, #2
 80031b2:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 80031b6:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80031ba:	4422      	add	r2, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
 80031bc:	4423      	add	r3, r4
 80031be:	7897      	ldrb	r7, [r2, #2]
 80031c0:	78d0      	ldrb	r0, [r2, #3]
 80031c2:	f893 1034 	ldrb.w	r1, [r3, #52]	; 0x34
 80031c6:	7853      	ldrb	r3, [r2, #1]
 80031c8:	043f      	lsls	r7, r7, #16
 80031ca:	ea47 6700 	orr.w	r7, r7, r0, lsl #24
 80031ce:	430f      	orrs	r7, r1
 80031d0:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
 80031d4:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
 80031d8:	e7cb      	b.n	8003172 <remove_chain.part.10+0xf6>
 80031da:	4629      	mov	r1, r5
 80031dc:	2200      	movs	r2, #0
 80031de:	4620      	mov	r0, r4
 80031e0:	f7ff fde8 	bl	8002db4 <put_fat.part.8>
			if (res != FR_OK) break;
 80031e4:	2800      	cmp	r0, #0
 80031e6:	f47f af61 	bne.w	80030ac <remove_chain.part.10+0x30>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 80031ea:	6923      	ldr	r3, [r4, #16]
 80031ec:	1c5a      	adds	r2, r3, #1
 80031ee:	d003      	beq.n	80031f8 <remove_chain.part.10+0x17c>
				fs->free_clust++;
 80031f0:	3301      	adds	r3, #1
 80031f2:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
 80031f4:	f884 a005 	strb.w	sl, [r4, #5]
		while (clst < fs->n_fatent) {			/* Not a last link? */
 80031f8:	69a3      	ldr	r3, [r4, #24]
FRESULT remove_chain (
 80031fa:	463d      	mov	r5, r7
		while (clst < fs->n_fatent) {			/* Not a last link? */
 80031fc:	429d      	cmp	r5, r3
 80031fe:	f4ff af4a 	bcc.w	8003096 <remove_chain.part.10+0x1a>
FRESULT remove_chain (
 8003202:	2000      	movs	r0, #0
 8003204:	e752      	b.n	80030ac <remove_chain.part.10+0x30>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 8003206:	6a67      	ldr	r7, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8003208:	f8d4 8030 	ldr.w	r8, [r4, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 800320c:	eb07 2715 	add.w	r7, r7, r5, lsr #8
	if (sector != fs->winsect) {	/* Changed current window */
 8003210:	4547      	cmp	r7, r8
 8003212:	d00b      	beq.n	800322c <remove_chain.part.10+0x1b0>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003214:	7923      	ldrb	r3, [r4, #4]
 8003216:	b9a3      	cbnz	r3, 8003242 <remove_chain.part.10+0x1c6>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8003218:	2301      	movs	r3, #1
 800321a:	463a      	mov	r2, r7
 800321c:	4631      	mov	r1, r6
 800321e:	7860      	ldrb	r0, [r4, #1]
 8003220:	f7ff facc 	bl	80027bc <disk_read>
 8003224:	2800      	cmp	r0, #0
 8003226:	f47f af40 	bne.w	80030aa <remove_chain.part.10+0x2e>
		fs->winsect = sector;
 800322a:	6327      	str	r7, [r4, #48]	; 0x30
		p = &fs->win[clst * 2 % SS(fs)];
 800322c:	006b      	lsls	r3, r5, #1
 800322e:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
		return LD_WORD(p);
 8003232:	4423      	add	r3, r4
 8003234:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8003238:	f893 7034 	ldrb.w	r7, [r3, #52]	; 0x34
 800323c:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
 8003240:	e797      	b.n	8003172 <remove_chain.part.10+0xf6>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003242:	2301      	movs	r3, #1
 8003244:	4642      	mov	r2, r8
 8003246:	4631      	mov	r1, r6
 8003248:	7860      	ldrb	r0, [r4, #1]
 800324a:	f7ff fad9 	bl	8002800 <disk_write>
 800324e:	2800      	cmp	r0, #0
 8003250:	f47f af2b 	bne.w	80030aa <remove_chain.part.10+0x2e>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003254:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 8003256:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003258:	4590      	cmp	r8, r2
 800325a:	d3dd      	bcc.n	8003218 <remove_chain.part.10+0x19c>
 800325c:	69e3      	ldr	r3, [r4, #28]
 800325e:	441a      	add	r2, r3
 8003260:	4590      	cmp	r8, r2
 8003262:	d2d9      	bcs.n	8003218 <remove_chain.part.10+0x19c>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003264:	f894 9003 	ldrb.w	r9, [r4, #3]
 8003268:	f1b9 0f01 	cmp.w	r9, #1
 800326c:	d801      	bhi.n	8003272 <remove_chain.part.10+0x1f6>
 800326e:	e7d3      	b.n	8003218 <remove_chain.part.10+0x19c>
 8003270:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8003272:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8003274:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003276:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 800327a:	4642      	mov	r2, r8
 800327c:	2301      	movs	r3, #1
 800327e:	4631      	mov	r1, r6
 8003280:	f7ff fabe 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003284:	f1b9 0f01 	cmp.w	r9, #1
 8003288:	d1f2      	bne.n	8003270 <remove_chain.part.10+0x1f4>
 800328a:	e7c5      	b.n	8003218 <remove_chain.part.10+0x19c>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800328c:	2301      	movs	r3, #1
 800328e:	4642      	mov	r2, r8
 8003290:	4631      	mov	r1, r6
 8003292:	7860      	ldrb	r0, [r4, #1]
 8003294:	f7ff fab4 	bl	8002800 <disk_write>
 8003298:	2800      	cmp	r0, #0
 800329a:	f47f af06 	bne.w	80030aa <remove_chain.part.10+0x2e>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800329e:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 80032a0:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80032a2:	4590      	cmp	r8, r2
 80032a4:	f4ff af7a 	bcc.w	800319c <remove_chain.part.10+0x120>
 80032a8:	69e3      	ldr	r3, [r4, #28]
 80032aa:	441a      	add	r2, r3
 80032ac:	4590      	cmp	r8, r2
 80032ae:	f4bf af75 	bcs.w	800319c <remove_chain.part.10+0x120>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80032b2:	f894 9003 	ldrb.w	r9, [r4, #3]
 80032b6:	f1b9 0f01 	cmp.w	r9, #1
 80032ba:	d801      	bhi.n	80032c0 <remove_chain.part.10+0x244>
 80032bc:	e76e      	b.n	800319c <remove_chain.part.10+0x120>
 80032be:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80032c0:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80032c2:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80032c4:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80032c8:	4642      	mov	r2, r8
 80032ca:	2301      	movs	r3, #1
 80032cc:	4631      	mov	r1, r6
 80032ce:	f7ff fa97 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80032d2:	f1b9 0f01 	cmp.w	r9, #1
 80032d6:	d1f2      	bne.n	80032be <remove_chain.part.10+0x242>
 80032d8:	e760      	b.n	800319c <remove_chain.part.10+0x120>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80032da:	463a      	mov	r2, r7
 80032dc:	4631      	mov	r1, r6
 80032de:	7860      	ldrb	r0, [r4, #1]
 80032e0:	f7ff fa8e 	bl	8002800 <disk_write>
 80032e4:	2800      	cmp	r0, #0
 80032e6:	f47f aee0 	bne.w	80030aa <remove_chain.part.10+0x2e>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80032ea:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 80032ec:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80032ee:	4297      	cmp	r7, r2
 80032f0:	f4ff aeeb 	bcc.w	80030ca <remove_chain.part.10+0x4e>
 80032f4:	69e3      	ldr	r3, [r4, #28]
 80032f6:	441a      	add	r2, r3
 80032f8:	4297      	cmp	r7, r2
 80032fa:	f4bf aee6 	bcs.w	80030ca <remove_chain.part.10+0x4e>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80032fe:	f894 9003 	ldrb.w	r9, [r4, #3]
 8003302:	f1b9 0f01 	cmp.w	r9, #1
 8003306:	d801      	bhi.n	800330c <remove_chain.part.10+0x290>
 8003308:	e6df      	b.n	80030ca <remove_chain.part.10+0x4e>
 800330a:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800330c:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 800330e:	441f      	add	r7, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003310:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8003314:	463a      	mov	r2, r7
 8003316:	2301      	movs	r3, #1
 8003318:	4631      	mov	r1, r6
 800331a:	f7ff fa71 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800331e:	f1b9 0f01 	cmp.w	r9, #1
 8003322:	d1f2      	bne.n	800330a <remove_chain.part.10+0x28e>
 8003324:	e6d1      	b.n	80030ca <remove_chain.part.10+0x4e>
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8003326:	f3c7 070b 	ubfx	r7, r7, #0, #12
 800332a:	e722      	b.n	8003172 <remove_chain.part.10+0xf6>

0800332c <get_fat.part.6>:
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 800332c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	switch (fs->fs_type) {
 8003330:	7803      	ldrb	r3, [r0, #0]
 8003332:	2b02      	cmp	r3, #2
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 8003334:	4604      	mov	r4, r0
 8003336:	460d      	mov	r5, r1
	switch (fs->fs_type) {
 8003338:	d075      	beq.n	8003426 <get_fat.part.6+0xfa>
 800333a:	2b03      	cmp	r3, #3
 800333c:	d048      	beq.n	80033d0 <get_fat.part.6+0xa4>
 800333e:	2b01      	cmp	r3, #1
 8003340:	d003      	beq.n	800334a <get_fat.part.6+0x1e>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 8003342:	f04f 30ff 	mov.w	r0, #4294967295
 8003346:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800334a:	6a42      	ldr	r2, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 800334c:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
		bc = (UINT)clst; bc += bc / 2;
 8003350:	eb01 0651 	add.w	r6, r1, r1, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003354:	eb02 2956 	add.w	r9, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 8003358:	45c1      	cmp	r9, r8
 800335a:	d011      	beq.n	8003380 <get_fat.part.6+0x54>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800335c:	7902      	ldrb	r2, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800335e:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003362:	2a00      	cmp	r2, #0
 8003364:	f040 80ca 	bne.w	80034fc <get_fat.part.6+0x1d0>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8003368:	4639      	mov	r1, r7
 800336a:	2301      	movs	r3, #1
 800336c:	464a      	mov	r2, r9
 800336e:	7860      	ldrb	r0, [r4, #1]
 8003370:	f7ff fa24 	bl	80027bc <disk_read>
 8003374:	2800      	cmp	r0, #0
 8003376:	d1e4      	bne.n	8003342 <get_fat.part.6+0x16>
 8003378:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->winsect = sector;
 800337a:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
 800337e:	46c8      	mov	r8, r9
		wc = fs->win[bc % SS(fs)]; bc++;
 8003380:	f3c6 0308 	ubfx	r3, r6, #0, #9
 8003384:	f106 0a01 	add.w	sl, r6, #1
 8003388:	4423      	add	r3, r4
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800338a:	eb02 295a 	add.w	r9, r2, sl, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 800338e:	45c1      	cmp	r9, r8
		wc = fs->win[bc % SS(fs)]; bc++;
 8003390:	f893 6034 	ldrb.w	r6, [r3, #52]	; 0x34
	if (sector != fs->winsect) {	/* Changed current window */
 8003394:	d00f      	beq.n	80033b6 <get_fat.part.6+0x8a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003396:	7923      	ldrb	r3, [r4, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003398:	f104 0734 	add.w	r7, r4, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800339c:	2b00      	cmp	r3, #0
 800339e:	f040 80d3 	bne.w	8003548 <get_fat.part.6+0x21c>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80033a2:	4639      	mov	r1, r7
 80033a4:	2301      	movs	r3, #1
 80033a6:	464a      	mov	r2, r9
 80033a8:	7860      	ldrb	r0, [r4, #1]
 80033aa:	f7ff fa07 	bl	80027bc <disk_read>
 80033ae:	2800      	cmp	r0, #0
 80033b0:	d1c7      	bne.n	8003342 <get_fat.part.6+0x16>
		fs->winsect = sector;
 80033b2:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
		wc |= fs->win[bc % SS(fs)] << 8;
 80033b6:	f3ca 0a08 	ubfx	sl, sl, #0, #9
 80033ba:	4454      	add	r4, sl
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 80033bc:	07eb      	lsls	r3, r5, #31
		wc |= fs->win[bc % SS(fs)] << 8;
 80033be:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 80033c2:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 80033c6:	f140 80e6 	bpl.w	8003596 <get_fat.part.6+0x26a>
 80033ca:	0900      	lsrs	r0, r0, #4
 80033cc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 80033d0:	6a46      	ldr	r6, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 80033d2:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 80033d6:	eb06 16d1 	add.w	r6, r6, r1, lsr #7
	if (sector != fs->winsect) {	/* Changed current window */
 80033da:	4546      	cmp	r6, r8
 80033dc:	d00d      	beq.n	80033fa <get_fat.part.6+0xce>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80033de:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80033e0:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80033e4:	2b00      	cmp	r3, #0
 80033e6:	d164      	bne.n	80034b2 <get_fat.part.6+0x186>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80033e8:	4639      	mov	r1, r7
 80033ea:	2301      	movs	r3, #1
 80033ec:	4632      	mov	r2, r6
 80033ee:	7860      	ldrb	r0, [r4, #1]
 80033f0:	f7ff f9e4 	bl	80027bc <disk_read>
 80033f4:	2800      	cmp	r0, #0
 80033f6:	d1a4      	bne.n	8003342 <get_fat.part.6+0x16>
		fs->winsect = sector;
 80033f8:	6326      	str	r6, [r4, #48]	; 0x30
		p = &fs->win[clst * 4 % SS(fs)];
 80033fa:	00ad      	lsls	r5, r5, #2
 80033fc:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8003400:	f105 0334 	add.w	r3, r5, #52	; 0x34
 8003404:	4423      	add	r3, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
 8003406:	442c      	add	r4, r5
 8003408:	7898      	ldrb	r0, [r3, #2]
 800340a:	78d9      	ldrb	r1, [r3, #3]
 800340c:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8003410:	785b      	ldrb	r3, [r3, #1]
 8003412:	0400      	lsls	r0, r0, #16
 8003414:	ea40 6001 	orr.w	r0, r0, r1, lsl #24
 8003418:	4310      	orrs	r0, r2
 800341a:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 800341e:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 8003422:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 8003426:	6a46      	ldr	r6, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8003428:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 800342c:	eb06 2611 	add.w	r6, r6, r1, lsr #8
	if (sector != fs->winsect) {	/* Changed current window */
 8003430:	4546      	cmp	r6, r8
 8003432:	d00d      	beq.n	8003450 <get_fat.part.6+0x124>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003434:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003436:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800343a:	b9ab      	cbnz	r3, 8003468 <get_fat.part.6+0x13c>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800343c:	4639      	mov	r1, r7
 800343e:	2301      	movs	r3, #1
 8003440:	4632      	mov	r2, r6
 8003442:	7860      	ldrb	r0, [r4, #1]
 8003444:	f7ff f9ba 	bl	80027bc <disk_read>
 8003448:	2800      	cmp	r0, #0
 800344a:	f47f af7a 	bne.w	8003342 <get_fat.part.6+0x16>
		fs->winsect = sector;
 800344e:	6326      	str	r6, [r4, #48]	; 0x30
		p = &fs->win[clst * 2 % SS(fs)];
 8003450:	006d      	lsls	r5, r5, #1
 8003452:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
		return LD_WORD(p);
 8003456:	442c      	add	r4, r5
 8003458:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800345c:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 8003460:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8003464:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003468:	4639      	mov	r1, r7
 800346a:	2301      	movs	r3, #1
 800346c:	4642      	mov	r2, r8
 800346e:	7840      	ldrb	r0, [r0, #1]
 8003470:	f7ff f9c6 	bl	8002800 <disk_write>
 8003474:	2800      	cmp	r0, #0
 8003476:	f47f af64 	bne.w	8003342 <get_fat.part.6+0x16>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800347a:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 800347c:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800347e:	4590      	cmp	r8, r2
 8003480:	d3dc      	bcc.n	800343c <get_fat.part.6+0x110>
 8003482:	69e3      	ldr	r3, [r4, #28]
 8003484:	441a      	add	r2, r3
 8003486:	4590      	cmp	r8, r2
 8003488:	d2d8      	bcs.n	800343c <get_fat.part.6+0x110>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800348a:	f894 9003 	ldrb.w	r9, [r4, #3]
 800348e:	f1b9 0f01 	cmp.w	r9, #1
 8003492:	d801      	bhi.n	8003498 <get_fat.part.6+0x16c>
 8003494:	e7d2      	b.n	800343c <get_fat.part.6+0x110>
 8003496:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8003498:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 800349a:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800349c:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80034a0:	4642      	mov	r2, r8
 80034a2:	2301      	movs	r3, #1
 80034a4:	4639      	mov	r1, r7
 80034a6:	f7ff f9ab 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80034aa:	f1b9 0f01 	cmp.w	r9, #1
 80034ae:	d1f2      	bne.n	8003496 <get_fat.part.6+0x16a>
 80034b0:	e7c4      	b.n	800343c <get_fat.part.6+0x110>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80034b2:	4639      	mov	r1, r7
 80034b4:	2301      	movs	r3, #1
 80034b6:	4642      	mov	r2, r8
 80034b8:	7840      	ldrb	r0, [r0, #1]
 80034ba:	f7ff f9a1 	bl	8002800 <disk_write>
 80034be:	2800      	cmp	r0, #0
 80034c0:	f47f af3f 	bne.w	8003342 <get_fat.part.6+0x16>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80034c4:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 80034c6:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80034c8:	4590      	cmp	r8, r2
 80034ca:	d38d      	bcc.n	80033e8 <get_fat.part.6+0xbc>
 80034cc:	69e3      	ldr	r3, [r4, #28]
 80034ce:	441a      	add	r2, r3
 80034d0:	4590      	cmp	r8, r2
 80034d2:	d289      	bcs.n	80033e8 <get_fat.part.6+0xbc>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80034d4:	f894 9003 	ldrb.w	r9, [r4, #3]
 80034d8:	f1b9 0f01 	cmp.w	r9, #1
 80034dc:	d801      	bhi.n	80034e2 <get_fat.part.6+0x1b6>
 80034de:	e783      	b.n	80033e8 <get_fat.part.6+0xbc>
 80034e0:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80034e2:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80034e4:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80034e6:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80034ea:	4642      	mov	r2, r8
 80034ec:	2301      	movs	r3, #1
 80034ee:	4639      	mov	r1, r7
 80034f0:	f7ff f986 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80034f4:	f1b9 0f01 	cmp.w	r9, #1
 80034f8:	d1f2      	bne.n	80034e0 <get_fat.part.6+0x1b4>
 80034fa:	e775      	b.n	80033e8 <get_fat.part.6+0xbc>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80034fc:	4639      	mov	r1, r7
 80034fe:	4642      	mov	r2, r8
 8003500:	7840      	ldrb	r0, [r0, #1]
 8003502:	f7ff f97d 	bl	8002800 <disk_write>
 8003506:	2800      	cmp	r0, #0
 8003508:	f47f af1b 	bne.w	8003342 <get_fat.part.6+0x16>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800350c:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 800350e:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003510:	4590      	cmp	r8, r2
 8003512:	f4ff af29 	bcc.w	8003368 <get_fat.part.6+0x3c>
 8003516:	69e3      	ldr	r3, [r4, #28]
 8003518:	441a      	add	r2, r3
 800351a:	4590      	cmp	r8, r2
 800351c:	f4bf af24 	bcs.w	8003368 <get_fat.part.6+0x3c>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003520:	f894 a003 	ldrb.w	sl, [r4, #3]
 8003524:	f1ba 0f01 	cmp.w	sl, #1
 8003528:	d801      	bhi.n	800352e <get_fat.part.6+0x202>
 800352a:	e71d      	b.n	8003368 <get_fat.part.6+0x3c>
 800352c:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800352e:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8003530:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003532:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8003536:	4642      	mov	r2, r8
 8003538:	2301      	movs	r3, #1
 800353a:	4639      	mov	r1, r7
 800353c:	f7ff f960 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003540:	f1ba 0f01 	cmp.w	sl, #1
 8003544:	d1f2      	bne.n	800352c <get_fat.part.6+0x200>
 8003546:	e70f      	b.n	8003368 <get_fat.part.6+0x3c>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003548:	4639      	mov	r1, r7
 800354a:	2301      	movs	r3, #1
 800354c:	4642      	mov	r2, r8
 800354e:	7860      	ldrb	r0, [r4, #1]
 8003550:	f7ff f956 	bl	8002800 <disk_write>
 8003554:	2800      	cmp	r0, #0
 8003556:	f47f aef4 	bne.w	8003342 <get_fat.part.6+0x16>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800355a:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 800355c:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800355e:	4542      	cmp	r2, r8
 8003560:	f63f af1f 	bhi.w	80033a2 <get_fat.part.6+0x76>
 8003564:	69e3      	ldr	r3, [r4, #28]
 8003566:	441a      	add	r2, r3
 8003568:	4542      	cmp	r2, r8
 800356a:	f67f af1a 	bls.w	80033a2 <get_fat.part.6+0x76>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800356e:	f894 b003 	ldrb.w	fp, [r4, #3]
 8003572:	f1bb 0f01 	cmp.w	fp, #1
 8003576:	d801      	bhi.n	800357c <get_fat.part.6+0x250>
 8003578:	e713      	b.n	80033a2 <get_fat.part.6+0x76>
 800357a:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800357c:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 800357e:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003580:	f10b 3bff 	add.w	fp, fp, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8003584:	4642      	mov	r2, r8
 8003586:	2301      	movs	r3, #1
 8003588:	4639      	mov	r1, r7
 800358a:	f7ff f939 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800358e:	f1bb 0f01 	cmp.w	fp, #1
 8003592:	d1f2      	bne.n	800357a <get_fat.part.6+0x24e>
 8003594:	e705      	b.n	80033a2 <get_fat.part.6+0x76>
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8003596:	f3c0 000b 	ubfx	r0, r0, #0, #12
 800359a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800359e:	bf00      	nop

080035a0 <dir_sdi>:
{
 80035a0:	b570      	push	{r4, r5, r6, lr}
 80035a2:	460c      	mov	r4, r1
	clst = dj->sclust;
 80035a4:	6881      	ldr	r1, [r0, #8]
	dj->index = idx;
 80035a6:	80c4      	strh	r4, [r0, #6]
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 80035a8:	2901      	cmp	r1, #1
 80035aa:	d004      	beq.n	80035b6 <dir_sdi+0x16>
 80035ac:	4605      	mov	r5, r0
 80035ae:	6800      	ldr	r0, [r0, #0]
 80035b0:	6983      	ldr	r3, [r0, #24]
 80035b2:	4299      	cmp	r1, r3
 80035b4:	d301      	bcc.n	80035ba <dir_sdi+0x1a>
		return FR_INT_ERR;
 80035b6:	2002      	movs	r0, #2
 80035b8:	bd70      	pop	{r4, r5, r6, pc}
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 80035ba:	b9b9      	cbnz	r1, 80035ec <dir_sdi+0x4c>
 80035bc:	7802      	ldrb	r2, [r0, #0]
 80035be:	2a03      	cmp	r2, #3
 80035c0:	d011      	beq.n	80035e6 <dir_sdi+0x46>
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 80035c2:	8903      	ldrh	r3, [r0, #8]
		dj->clust = clst;
 80035c4:	2200      	movs	r2, #0
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 80035c6:	42a3      	cmp	r3, r4
		dj->clust = clst;
 80035c8:	60ea      	str	r2, [r5, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 80035ca:	d9f4      	bls.n	80035b6 <dir_sdi+0x16>
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 80035cc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80035ce:	f3c4 120f 	ubfx	r2, r4, #4, #16
 80035d2:	4413      	add	r3, r2
 80035d4:	612b      	str	r3, [r5, #16]
	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
 80035d6:	3034      	adds	r0, #52	; 0x34
 80035d8:	f004 040f 	and.w	r4, r4, #15
 80035dc:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 80035e0:	616c      	str	r4, [r5, #20]
	return FR_OK;	/* Seek succeeded */
 80035e2:	2000      	movs	r0, #0
 80035e4:	bd70      	pop	{r4, r5, r6, pc}
		clst = dj->fs->dirbase;
 80035e6:	6a81      	ldr	r1, [r0, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
 80035e8:	2900      	cmp	r1, #0
 80035ea:	d0ea      	beq.n	80035c2 <dir_sdi+0x22>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
 80035ec:	7886      	ldrb	r6, [r0, #2]
 80035ee:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
 80035f0:	42b4      	cmp	r4, r6
 80035f2:	d318      	bcc.n	8003626 <dir_sdi+0x86>
 80035f4:	1ba4      	subs	r4, r4, r6
 80035f6:	b2a4      	uxth	r4, r4
 80035f8:	e00f      	b.n	800361a <dir_sdi+0x7a>
 80035fa:	f7ff fe97 	bl	800332c <get_fat.part.6>
 80035fe:	1ba2      	subs	r2, r4, r6
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003600:	1c43      	adds	r3, r0, #1
 8003602:	4601      	mov	r1, r0
 8003604:	b292      	uxth	r2, r2
 8003606:	d01d      	beq.n	8003644 <dir_sdi+0xa4>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 8003608:	2801      	cmp	r0, #1
 800360a:	d9d4      	bls.n	80035b6 <dir_sdi+0x16>
 800360c:	6828      	ldr	r0, [r5, #0]
 800360e:	6983      	ldr	r3, [r0, #24]
 8003610:	428b      	cmp	r3, r1
 8003612:	d9d0      	bls.n	80035b6 <dir_sdi+0x16>
		while (idx >= ic) {	/* Follow cluster chain */
 8003614:	42a6      	cmp	r6, r4
 8003616:	d806      	bhi.n	8003626 <dir_sdi+0x86>
 8003618:	4614      	mov	r4, r2
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 800361a:	2901      	cmp	r1, #1
 800361c:	d9cb      	bls.n	80035b6 <dir_sdi+0x16>
 800361e:	4299      	cmp	r1, r3
 8003620:	d3eb      	bcc.n	80035fa <dir_sdi+0x5a>
		return FR_INT_ERR;
 8003622:	2002      	movs	r0, #2
 8003624:	bd70      	pop	{r4, r5, r6, pc}
	clst -= 2;
 8003626:	1e8a      	subs	r2, r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003628:	3b02      	subs	r3, #2
 800362a:	429a      	cmp	r2, r3
		dj->clust = clst;
 800362c:	60e9      	str	r1, [r5, #12]
	return clst * fs->csize + fs->database;
 800362e:	bf3b      	ittet	cc
 8003630:	7883      	ldrbcc	r3, [r0, #2]
 8003632:	6ac1      	ldrcc	r1, [r0, #44]	; 0x2c
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003634:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
 8003636:	fb02 1203 	mlacc	r2, r2, r3, r1
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 800363a:	f3c4 130f 	ubfx	r3, r4, #4, #16
 800363e:	4413      	add	r3, r2
 8003640:	612b      	str	r3, [r5, #16]
 8003642:	e7c8      	b.n	80035d6 <dir_sdi+0x36>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003644:	2001      	movs	r0, #1
}
 8003646:	bd70      	pop	{r4, r5, r6, pc}

08003648 <create_chain>:
{
 8003648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800364c:	b083      	sub	sp, #12
 800364e:	4605      	mov	r5, r0
	if (clst == 0) {		/* Create a new chain */
 8003650:	9100      	str	r1, [sp, #0]
 8003652:	bb01      	cbnz	r1, 8003696 <create_chain+0x4e>
		scl = fs->last_clust;			/* Get suggested start point */
 8003654:	68c6      	ldr	r6, [r0, #12]
 8003656:	6983      	ldr	r3, [r0, #24]
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8003658:	b346      	cbz	r6, 80036ac <create_chain+0x64>
 800365a:	429e      	cmp	r6, r3
 800365c:	bf28      	it	cs
 800365e:	2601      	movcs	r6, #1
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003660:	f105 0734 	add.w	r7, r5, #52	; 0x34
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8003664:	4634      	mov	r4, r6
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003666:	46b8      	mov	r8, r7
		ncl++;							/* Next cluster */
 8003668:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
 800366a:	429c      	cmp	r4, r3
 800366c:	d320      	bcc.n	80036b0 <create_chain+0x68>
			if (ncl > scl) return 0;	/* No free cluster */
 800366e:	2e01      	cmp	r6, #1
 8003670:	f240 8120 	bls.w	80038b4 <create_chain+0x26c>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8003674:	2b02      	cmp	r3, #2
 8003676:	d914      	bls.n	80036a2 <create_chain+0x5a>
	switch (fs->fs_type) {
 8003678:	782b      	ldrb	r3, [r5, #0]
 800367a:	2b02      	cmp	r3, #2
			ncl = 2;
 800367c:	f04f 0402 	mov.w	r4, #2
	switch (fs->fs_type) {
 8003680:	d01b      	beq.n	80036ba <create_chain+0x72>
 8003682:	2b03      	cmp	r3, #3
 8003684:	d07d      	beq.n	8003782 <create_chain+0x13a>
 8003686:	2b01      	cmp	r3, #1
 8003688:	d03f      	beq.n	800370a <create_chain+0xc2>
 800368a:	f04f 34ff 	mov.w	r4, #4294967295
}
 800368e:	4620      	mov	r0, r4
 8003690:	b003      	add	sp, #12
 8003692:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8003696:	2901      	cmp	r1, #1
 8003698:	d903      	bls.n	80036a2 <create_chain+0x5a>
 800369a:	6983      	ldr	r3, [r0, #24]
 800369c:	4299      	cmp	r1, r3
 800369e:	f0c0 810b 	bcc.w	80038b8 <create_chain+0x270>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 80036a2:	2401      	movs	r4, #1
}
 80036a4:	4620      	mov	r0, r4
 80036a6:	b003      	add	sp, #12
 80036a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!scl || scl >= fs->n_fatent) scl = 1;
 80036ac:	2601      	movs	r6, #1
 80036ae:	e7d7      	b.n	8003660 <create_chain+0x18>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 80036b0:	2c01      	cmp	r4, #1
 80036b2:	d9f6      	bls.n	80036a2 <create_chain+0x5a>
	switch (fs->fs_type) {
 80036b4:	782b      	ldrb	r3, [r5, #0]
 80036b6:	2b02      	cmp	r3, #2
 80036b8:	d1e3      	bne.n	8003682 <create_chain+0x3a>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 80036ba:	6a6f      	ldr	r7, [r5, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 80036bc:	f8d5 9030 	ldr.w	r9, [r5, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 80036c0:	eb07 2714 	add.w	r7, r7, r4, lsr #8
	if (sector != fs->winsect) {	/* Changed current window */
 80036c4:	454f      	cmp	r7, r9
 80036c6:	d00c      	beq.n	80036e2 <create_chain+0x9a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80036c8:	792b      	ldrb	r3, [r5, #4]
 80036ca:	2b00      	cmp	r3, #0
 80036cc:	f040 80cb 	bne.w	8003866 <create_chain+0x21e>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80036d0:	2301      	movs	r3, #1
 80036d2:	463a      	mov	r2, r7
 80036d4:	4641      	mov	r1, r8
 80036d6:	7868      	ldrb	r0, [r5, #1]
 80036d8:	f7ff f870 	bl	80027bc <disk_read>
 80036dc:	2800      	cmp	r0, #0
 80036de:	d1d4      	bne.n	800368a <create_chain+0x42>
		fs->winsect = sector;
 80036e0:	632f      	str	r7, [r5, #48]	; 0x30
		p = &fs->win[clst * 2 % SS(fs)];
 80036e2:	0062      	lsls	r2, r4, #1
 80036e4:	f402 72ff 	and.w	r2, r2, #510	; 0x1fe
		return LD_WORD(p);
 80036e8:	442a      	add	r2, r5
 80036ea:	f892 1035 	ldrb.w	r1, [r2, #53]	; 0x35
 80036ee:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 80036f2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (cs == 0) break;				/* Found a free cluster */
 80036f6:	2b00      	cmp	r3, #0
 80036f8:	f000 8111 	beq.w	800391e <create_chain+0x2d6>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 80036fc:	2b01      	cmp	r3, #1
 80036fe:	d0d0      	beq.n	80036a2 <create_chain+0x5a>
		if (ncl == scl) return 0;		/* No free cluster */
 8003700:	42a6      	cmp	r6, r4
 8003702:	f000 80d7 	beq.w	80038b4 <create_chain+0x26c>
 8003706:	69ab      	ldr	r3, [r5, #24]
 8003708:	e7ae      	b.n	8003668 <create_chain+0x20>
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800370a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 800370c:	6b2f      	ldr	r7, [r5, #48]	; 0x30
		bc = (UINT)clst; bc += bc / 2;
 800370e:	eb04 0954 	add.w	r9, r4, r4, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003712:	eb02 2b59 	add.w	fp, r2, r9, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 8003716:	45bb      	cmp	fp, r7
 8003718:	d00e      	beq.n	8003738 <create_chain+0xf0>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800371a:	792a      	ldrb	r2, [r5, #4]
 800371c:	2a00      	cmp	r2, #0
 800371e:	d159      	bne.n	80037d4 <create_chain+0x18c>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8003720:	2301      	movs	r3, #1
 8003722:	465a      	mov	r2, fp
 8003724:	4641      	mov	r1, r8
 8003726:	7868      	ldrb	r0, [r5, #1]
 8003728:	f7ff f848 	bl	80027bc <disk_read>
 800372c:	2800      	cmp	r0, #0
 800372e:	d1ac      	bne.n	800368a <create_chain+0x42>
 8003730:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->winsect = sector;
 8003732:	f8c5 b030 	str.w	fp, [r5, #48]	; 0x30
 8003736:	465f      	mov	r7, fp
		wc = fs->win[bc % SS(fs)]; bc++;
 8003738:	f3c9 0308 	ubfx	r3, r9, #0, #9
 800373c:	f109 0901 	add.w	r9, r9, #1
 8003740:	442b      	add	r3, r5
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003742:	eb02 2a59 	add.w	sl, r2, r9, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 8003746:	45ba      	cmp	sl, r7
		wc = fs->win[bc % SS(fs)]; bc++;
 8003748:	f893 b034 	ldrb.w	fp, [r3, #52]	; 0x34
	if (sector != fs->winsect) {	/* Changed current window */
 800374c:	d00d      	beq.n	800376a <create_chain+0x122>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800374e:	792b      	ldrb	r3, [r5, #4]
 8003750:	2b00      	cmp	r3, #0
 8003752:	f040 80bd 	bne.w	80038d0 <create_chain+0x288>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8003756:	2301      	movs	r3, #1
 8003758:	4652      	mov	r2, sl
 800375a:	4641      	mov	r1, r8
 800375c:	7868      	ldrb	r0, [r5, #1]
 800375e:	f7ff f82d 	bl	80027bc <disk_read>
 8003762:	2800      	cmp	r0, #0
 8003764:	d191      	bne.n	800368a <create_chain+0x42>
		fs->winsect = sector;
 8003766:	f8c5 a030 	str.w	sl, [r5, #48]	; 0x30
		wc |= fs->win[bc % SS(fs)] << 8;
 800376a:	f3c9 0308 	ubfx	r3, r9, #0, #9
 800376e:	442b      	add	r3, r5
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8003770:	07e2      	lsls	r2, r4, #31
		wc |= fs->win[bc % SS(fs)] << 8;
 8003772:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8003776:	ea4b 2303 	orr.w	r3, fp, r3, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800377a:	f140 80f5 	bpl.w	8003968 <create_chain+0x320>
 800377e:	091b      	lsrs	r3, r3, #4
 8003780:	e7b9      	b.n	80036f6 <create_chain+0xae>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 8003782:	6a6f      	ldr	r7, [r5, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8003784:	f8d5 9030 	ldr.w	r9, [r5, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 8003788:	eb07 17d4 	add.w	r7, r7, r4, lsr #7
	if (sector != fs->winsect) {	/* Changed current window */
 800378c:	454f      	cmp	r7, r9
 800378e:	d00c      	beq.n	80037aa <create_chain+0x162>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003790:	792b      	ldrb	r3, [r5, #4]
 8003792:	2b00      	cmp	r3, #0
 8003794:	d142      	bne.n	800381c <create_chain+0x1d4>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8003796:	2301      	movs	r3, #1
 8003798:	463a      	mov	r2, r7
 800379a:	4641      	mov	r1, r8
 800379c:	7868      	ldrb	r0, [r5, #1]
 800379e:	f7ff f80d 	bl	80027bc <disk_read>
 80037a2:	2800      	cmp	r0, #0
 80037a4:	f47f af71 	bne.w	800368a <create_chain+0x42>
		fs->winsect = sector;
 80037a8:	632f      	str	r7, [r5, #48]	; 0x30
		p = &fs->win[clst * 4 % SS(fs)];
 80037aa:	00a3      	lsls	r3, r4, #2
 80037ac:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 80037b0:	f103 0134 	add.w	r1, r3, #52	; 0x34
 80037b4:	4429      	add	r1, r5
		return LD_DWORD(p) & 0x0FFFFFFF;
 80037b6:	18ea      	adds	r2, r5, r3
 80037b8:	788b      	ldrb	r3, [r1, #2]
 80037ba:	78cf      	ldrb	r7, [r1, #3]
 80037bc:	f892 0034 	ldrb.w	r0, [r2, #52]	; 0x34
 80037c0:	784a      	ldrb	r2, [r1, #1]
 80037c2:	041b      	lsls	r3, r3, #16
 80037c4:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 80037c8:	4303      	orrs	r3, r0
 80037ca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80037ce:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 80037d2:	e790      	b.n	80036f6 <create_chain+0xae>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80037d4:	463a      	mov	r2, r7
 80037d6:	4641      	mov	r1, r8
 80037d8:	7868      	ldrb	r0, [r5, #1]
 80037da:	f7ff f811 	bl	8002800 <disk_write>
 80037de:	2800      	cmp	r0, #0
 80037e0:	f47f af53 	bne.w	800368a <create_chain+0x42>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80037e4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 80037e6:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80037e8:	4297      	cmp	r7, r2
 80037ea:	d399      	bcc.n	8003720 <create_chain+0xd8>
 80037ec:	69eb      	ldr	r3, [r5, #28]
 80037ee:	441a      	add	r2, r3
 80037f0:	4297      	cmp	r7, r2
 80037f2:	d295      	bcs.n	8003720 <create_chain+0xd8>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80037f4:	f895 a003 	ldrb.w	sl, [r5, #3]
 80037f8:	f1ba 0f01 	cmp.w	sl, #1
 80037fc:	d801      	bhi.n	8003802 <create_chain+0x1ba>
 80037fe:	e78f      	b.n	8003720 <create_chain+0xd8>
 8003800:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8003802:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 8003804:	441f      	add	r7, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003806:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 800380a:	463a      	mov	r2, r7
 800380c:	2301      	movs	r3, #1
 800380e:	4641      	mov	r1, r8
 8003810:	f7fe fff6 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003814:	f1ba 0f01 	cmp.w	sl, #1
 8003818:	d1f2      	bne.n	8003800 <create_chain+0x1b8>
 800381a:	e781      	b.n	8003720 <create_chain+0xd8>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800381c:	2301      	movs	r3, #1
 800381e:	464a      	mov	r2, r9
 8003820:	4641      	mov	r1, r8
 8003822:	7868      	ldrb	r0, [r5, #1]
 8003824:	f7fe ffec 	bl	8002800 <disk_write>
 8003828:	2800      	cmp	r0, #0
 800382a:	f47f af2e 	bne.w	800368a <create_chain+0x42>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800382e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 8003830:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003832:	4591      	cmp	r9, r2
 8003834:	d3af      	bcc.n	8003796 <create_chain+0x14e>
 8003836:	69eb      	ldr	r3, [r5, #28]
 8003838:	441a      	add	r2, r3
 800383a:	4591      	cmp	r9, r2
 800383c:	d2ab      	bcs.n	8003796 <create_chain+0x14e>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800383e:	f895 a003 	ldrb.w	sl, [r5, #3]
 8003842:	f1ba 0f01 	cmp.w	sl, #1
 8003846:	d801      	bhi.n	800384c <create_chain+0x204>
 8003848:	e7a5      	b.n	8003796 <create_chain+0x14e>
 800384a:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800384c:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 800384e:	4499      	add	r9, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003850:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8003854:	464a      	mov	r2, r9
 8003856:	2301      	movs	r3, #1
 8003858:	4641      	mov	r1, r8
 800385a:	f7fe ffd1 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800385e:	f1ba 0f01 	cmp.w	sl, #1
 8003862:	d1f2      	bne.n	800384a <create_chain+0x202>
 8003864:	e797      	b.n	8003796 <create_chain+0x14e>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8003866:	2301      	movs	r3, #1
 8003868:	464a      	mov	r2, r9
 800386a:	4641      	mov	r1, r8
 800386c:	7868      	ldrb	r0, [r5, #1]
 800386e:	f7fe ffc7 	bl	8002800 <disk_write>
 8003872:	2800      	cmp	r0, #0
 8003874:	f47f af09 	bne.w	800368a <create_chain+0x42>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8003878:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 800387a:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800387c:	4591      	cmp	r9, r2
 800387e:	f4ff af27 	bcc.w	80036d0 <create_chain+0x88>
 8003882:	69eb      	ldr	r3, [r5, #28]
 8003884:	441a      	add	r2, r3
 8003886:	4591      	cmp	r9, r2
 8003888:	f4bf af22 	bcs.w	80036d0 <create_chain+0x88>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800388c:	f895 a003 	ldrb.w	sl, [r5, #3]
 8003890:	f1ba 0f01 	cmp.w	sl, #1
 8003894:	d801      	bhi.n	800389a <create_chain+0x252>
 8003896:	e71b      	b.n	80036d0 <create_chain+0x88>
 8003898:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800389a:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 800389c:	4499      	add	r9, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800389e:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80038a2:	464a      	mov	r2, r9
 80038a4:	2301      	movs	r3, #1
 80038a6:	4641      	mov	r1, r8
 80038a8:	f7fe ffaa 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80038ac:	f1ba 0f01 	cmp.w	sl, #1
 80038b0:	d1f2      	bne.n	8003898 <create_chain+0x250>
 80038b2:	e70d      	b.n	80036d0 <create_chain+0x88>
			if (ncl > scl) return 0;	/* No free cluster */
 80038b4:	2400      	movs	r4, #0
 80038b6:	e6f5      	b.n	80036a4 <create_chain+0x5c>
 80038b8:	f7ff fd38 	bl	800332c <get_fat.part.6>
		if (cs < 2) return 1;			/* It is an invalid cluster */
 80038bc:	2801      	cmp	r0, #1
 80038be:	4604      	mov	r4, r0
 80038c0:	f67f aeef 	bls.w	80036a2 <create_chain+0x5a>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 80038c4:	69ab      	ldr	r3, [r5, #24]
 80038c6:	4283      	cmp	r3, r0
 80038c8:	f63f aeec 	bhi.w	80036a4 <create_chain+0x5c>
 80038cc:	9e00      	ldr	r6, [sp, #0]
 80038ce:	e6c7      	b.n	8003660 <create_chain+0x18>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80038d0:	2301      	movs	r3, #1
 80038d2:	463a      	mov	r2, r7
 80038d4:	4641      	mov	r1, r8
 80038d6:	7868      	ldrb	r0, [r5, #1]
 80038d8:	f7fe ff92 	bl	8002800 <disk_write>
 80038dc:	2800      	cmp	r0, #0
 80038de:	f47f aed4 	bne.w	800368a <create_chain+0x42>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80038e2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 80038e4:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80038e6:	42ba      	cmp	r2, r7
 80038e8:	f63f af35 	bhi.w	8003756 <create_chain+0x10e>
 80038ec:	69eb      	ldr	r3, [r5, #28]
 80038ee:	441a      	add	r2, r3
 80038f0:	42ba      	cmp	r2, r7
 80038f2:	f67f af30 	bls.w	8003756 <create_chain+0x10e>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80038f6:	78ea      	ldrb	r2, [r5, #3]
 80038f8:	2a01      	cmp	r2, #1
 80038fa:	f67f af2c 	bls.w	8003756 <create_chain+0x10e>
 80038fe:	9601      	str	r6, [sp, #4]
 8003900:	4616      	mov	r6, r2
 8003902:	e000      	b.n	8003906 <create_chain+0x2be>
 8003904:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8003906:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 8003908:	441f      	add	r7, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800390a:	3e01      	subs	r6, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 800390c:	463a      	mov	r2, r7
 800390e:	2301      	movs	r3, #1
 8003910:	4641      	mov	r1, r8
 8003912:	f7fe ff75 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003916:	2e01      	cmp	r6, #1
 8003918:	d1f4      	bne.n	8003904 <create_chain+0x2bc>
 800391a:	9e01      	ldr	r6, [sp, #4]
 800391c:	e71b      	b.n	8003756 <create_chain+0x10e>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800391e:	69ab      	ldr	r3, [r5, #24]
 8003920:	42a3      	cmp	r3, r4
 8003922:	f67f aebe 	bls.w	80036a2 <create_chain+0x5a>
 8003926:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 800392a:	4621      	mov	r1, r4
 800392c:	4628      	mov	r0, r5
 800392e:	f7ff fa41 	bl	8002db4 <put_fat.part.8>
	if (res == FR_OK && clst != 0) {
 8003932:	b9e0      	cbnz	r0, 800396e <create_chain+0x326>
 8003934:	9b00      	ldr	r3, [sp, #0]
 8003936:	b16b      	cbz	r3, 8003954 <create_chain+0x30c>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003938:	2b01      	cmp	r3, #1
 800393a:	461a      	mov	r2, r3
 800393c:	f67f aeb1 	bls.w	80036a2 <create_chain+0x5a>
 8003940:	69ab      	ldr	r3, [r5, #24]
 8003942:	429a      	cmp	r2, r3
 8003944:	f4bf aead 	bcs.w	80036a2 <create_chain+0x5a>
 8003948:	4611      	mov	r1, r2
 800394a:	4628      	mov	r0, r5
 800394c:	4622      	mov	r2, r4
 800394e:	f7ff fa31 	bl	8002db4 <put_fat.part.8>
	if (res == FR_OK) {
 8003952:	b960      	cbnz	r0, 800396e <create_chain+0x326>
		if (fs->free_clust != 0xFFFFFFFF) {
 8003954:	692b      	ldr	r3, [r5, #16]
		fs->last_clust = ncl;			/* Update FSINFO */
 8003956:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
 8003958:	1c59      	adds	r1, r3, #1
 800395a:	f43f aea3 	beq.w	80036a4 <create_chain+0x5c>
			fs->free_clust--;
 800395e:	3b01      	subs	r3, #1
			fs->fsi_flag = 1;
 8003960:	2201      	movs	r2, #1
			fs->free_clust--;
 8003962:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
 8003964:	716a      	strb	r2, [r5, #5]
 8003966:	e69d      	b.n	80036a4 <create_chain+0x5c>
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8003968:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800396c:	e6c3      	b.n	80036f6 <create_chain+0xae>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 800396e:	2801      	cmp	r0, #1
 8003970:	f43f ae8b 	beq.w	800368a <create_chain+0x42>
 8003974:	e695      	b.n	80036a2 <create_chain+0x5a>
 8003976:	bf00      	nop

08003978 <f_write.part.12>:
#if !_FS_READONLY
/*-----------------------------------------------------------------------*/
/* Write File                                                            */
/*-----------------------------------------------------------------------*/

FRESULT f_write (
 8003978:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800397c:	4692      	mov	sl, r2
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
 800397e:	68c2      	ldr	r2, [r0, #12]
 8003980:	eb12 0f0a 	cmn.w	r2, sl
FRESULT f_write (
 8003984:	b089      	sub	sp, #36	; 0x24
 8003986:	4681      	mov	r9, r0
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
 8003988:	f080 818e 	bcs.w	8003ca8 <f_write.part.12+0x330>

	for ( ;  btw;							/* Repeat until all data written */
 800398c:	f1ba 0f00 	cmp.w	sl, #0
 8003990:	f000 818a 	beq.w	8003ca8 <f_write.part.12+0x330>
 8003994:	4698      	mov	r8, r3
 8003996:	f100 0324 	add.w	r3, r0, #36	; 0x24
 800399a:	9301      	str	r3, [sp, #4]
 800399c:	425b      	negs	r3, r3
 800399e:	f003 0303 	and.w	r3, r3, #3
 80039a2:	4618      	mov	r0, r3
 80039a4:	9303      	str	r3, [sp, #12]
 80039a6:	f5c3 73fe 	rsb	r3, r3, #508	; 0x1fc
 80039aa:	089b      	lsrs	r3, r3, #2
 80039ac:	3301      	adds	r3, #1
 80039ae:	9305      	str	r3, [sp, #20]
 80039b0:	009b      	lsls	r3, r3, #2
 80039b2:	9302      	str	r3, [sp, #8]
 80039b4:	f5c0 7300 	rsb	r3, r0, #512	; 0x200
 80039b8:	9306      	str	r3, [sp, #24]
 80039ba:	f100 0324 	add.w	r3, r0, #36	; 0x24
 80039be:	9307      	str	r3, [sp, #28]
 80039c0:	f8d9 5008 	ldr.w	r5, [r9, #8]
 80039c4:	f109 0328 	add.w	r3, r9, #40	; 0x28
 80039c8:	460f      	mov	r7, r1
 80039ca:	9304      	str	r3, [sp, #16]
 80039cc:	46c3      	mov	fp, r8
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 80039ce:	f3c5 0208 	ubfx	r2, r5, #0, #9
 80039d2:	2a00      	cmp	r2, #0
 80039d4:	f040 80ba 	bne.w	8003b4c <f_write.part.12+0x1d4>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 80039d8:	f8d9 0000 	ldr.w	r0, [r9]
 80039dc:	7886      	ldrb	r6, [r0, #2]
 80039de:	3e01      	subs	r6, #1
 80039e0:	ea06 2655 	and.w	r6, r6, r5, lsr #9
			if (!csect) {					/* On the cluster boundary? */
 80039e4:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 80039e8:	d111      	bne.n	8003a0e <f_write.part.12+0x96>
				if (fp->fptr == 0) {		/* On the top of the file? */
 80039ea:	2d00      	cmp	r5, #0
 80039ec:	f040 814f 	bne.w	8003c8e <f_write.part.12+0x316>
					clst = fp->sclust;		/* Follow from the origin */
 80039f0:	f8d9 3010 	ldr.w	r3, [r9, #16]
					if (clst == 0)			/* When no cluster is allocated, */
 80039f4:	2b00      	cmp	r3, #0
 80039f6:	f000 8168 	beq.w	8003cca <f_write.part.12+0x352>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 80039fa:	2b01      	cmp	r3, #1
 80039fc:	f000 8199 	beq.w	8003d32 <f_write.part.12+0x3ba>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8003a00:	1c5a      	adds	r2, r3, #1
 8003a02:	f000 813a 	beq.w	8003c7a <f_write.part.12+0x302>
 8003a06:	f8d9 0000 	ldr.w	r0, [r9]
				fp->clust = clst;			/* Update current cluster */
 8003a0a:	f8c9 3014 	str.w	r3, [r9, #20]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 8003a0e:	f899 1006 	ldrb.w	r1, [r9, #6]
 8003a12:	064b      	lsls	r3, r1, #25
 8003a14:	f100 8117 	bmi.w	8003c46 <f_write.part.12+0x2ce>
	clst -= 2;
 8003a18:	f8d9 3014 	ldr.w	r3, [r9, #20]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003a1c:	6982      	ldr	r2, [r0, #24]
	clst -= 2;
 8003a1e:	f1a3 0802 	sub.w	r8, r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003a22:	3a02      	subs	r2, #2
 8003a24:	4590      	cmp	r8, r2
 8003a26:	f080 817e 	bcs.w	8003d26 <f_write.part.12+0x3ae>
	return clst * fs->csize + fs->database;
 8003a2a:	7883      	ldrb	r3, [r0, #2]
 8003a2c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8003a2e:	9200      	str	r2, [sp, #0]
 8003a30:	fb08 f803 	mul.w	r8, r8, r3
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8003a34:	eb18 0502 	adds.w	r5, r8, r2
 8003a38:	f000 8175 	beq.w	8003d26 <f_write.part.12+0x3ae>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 8003a3c:	ea5f 245a 	movs.w	r4, sl, lsr #9
			sect += csect;
 8003a40:	4435      	add	r5, r6
			if (cc) {						/* Write maximum contiguous sectors directly */
 8003a42:	d074      	beq.n	8003b2e <f_write.part.12+0x1b6>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 8003a44:	1932      	adds	r2, r6, r4
 8003a46:	4293      	cmp	r3, r2
					cc = fp->fs->csize - csect;
 8003a48:	bf38      	it	cc
 8003a4a:	1b9c      	subcc	r4, r3, r6
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
 8003a4c:	7840      	ldrb	r0, [r0, #1]
 8003a4e:	b2e3      	uxtb	r3, r4
 8003a50:	462a      	mov	r2, r5
 8003a52:	4639      	mov	r1, r7
 8003a54:	f7fe fed4 	bl	8002800 <disk_write>
 8003a58:	2800      	cmp	r0, #0
 8003a5a:	f040 810e 	bne.w	8003c7a <f_write.part.12+0x302>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8003a5e:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8003a62:	1b55      	subs	r5, r2, r5
 8003a64:	42ac      	cmp	r4, r5
 8003a66:	d95d      	bls.n	8003b24 <f_write.part.12+0x1ac>
 8003a68:	9b00      	ldr	r3, [sp, #0]
 8003a6a:	9804      	ldr	r0, [sp, #16]
 8003a6c:	1b92      	subs	r2, r2, r6
 8003a6e:	1ad2      	subs	r2, r2, r3
 8003a70:	eba2 0208 	sub.w	r2, r2, r8
 8003a74:	0252      	lsls	r2, r2, #9
 8003a76:	18b9      	adds	r1, r7, r2
 8003a78:	4288      	cmp	r0, r1
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 8003a7a:	eb07 2345 	add.w	r3, r7, r5, lsl #9
 8003a7e:	d905      	bls.n	8003a8c <f_write.part.12+0x114>
 8003a80:	1d11      	adds	r1, r2, #4
 8003a82:	9801      	ldr	r0, [sp, #4]
 8003a84:	4439      	add	r1, r7
 8003a86:	4288      	cmp	r0, r1
 8003a88:	f0c0 813a 	bcc.w	8003d00 <f_write.part.12+0x388>
 8003a8c:	9803      	ldr	r0, [sp, #12]
 8003a8e:	2800      	cmp	r0, #0
 8003a90:	f000 8130 	beq.w	8003cf4 <f_write.part.12+0x37c>
		*d++ = *s++;
 8003a94:	7819      	ldrb	r1, [r3, #0]
 8003a96:	f889 1024 	strb.w	r1, [r9, #36]	; 0x24
 8003a9a:	2801      	cmp	r0, #1
 8003a9c:	f109 0625 	add.w	r6, r9, #37	; 0x25
 8003aa0:	f103 0e01 	add.w	lr, r3, #1
 8003aa4:	f000 813b 	beq.w	8003d1e <f_write.part.12+0x3a6>
 8003aa8:	7859      	ldrb	r1, [r3, #1]
 8003aaa:	f889 1025 	strb.w	r1, [r9, #37]	; 0x25
 8003aae:	2803      	cmp	r0, #3
 8003ab0:	f109 0626 	add.w	r6, r9, #38	; 0x26
 8003ab4:	f103 0e02 	add.w	lr, r3, #2
 8003ab8:	f040 812d 	bne.w	8003d16 <f_write.part.12+0x39e>
 8003abc:	7899      	ldrb	r1, [r3, #2]
 8003abe:	f889 1026 	strb.w	r1, [r9, #38]	; 0x26
 8003ac2:	f103 0e03 	add.w	lr, r3, #3
 8003ac6:	f109 0627 	add.w	r6, r9, #39	; 0x27
 8003aca:	f240 15fd 	movw	r5, #509	; 0x1fd
 8003ace:	4603      	mov	r3, r0
 8003ad0:	4413      	add	r3, r2
 8003ad2:	9a07      	ldr	r2, [sp, #28]
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 8003ad4:	f8dd c014 	ldr.w	ip, [sp, #20]
 8003ad8:	eb09 0102 	add.w	r1, r9, r2
 8003adc:	443b      	add	r3, r7
 8003ade:	2200      	movs	r2, #0
 8003ae0:	3201      	adds	r2, #1
		*d++ = *s++;
 8003ae2:	f853 0b04 	ldr.w	r0, [r3], #4
 8003ae6:	f841 0b04 	str.w	r0, [r1], #4
 8003aea:	4594      	cmp	ip, r2
 8003aec:	d8f8      	bhi.n	8003ae0 <f_write.part.12+0x168>
 8003aee:	9802      	ldr	r0, [sp, #8]
 8003af0:	9906      	ldr	r1, [sp, #24]
 8003af2:	4288      	cmp	r0, r1
 8003af4:	eba5 0500 	sub.w	r5, r5, r0
 8003af8:	eb06 0300 	add.w	r3, r6, r0
 8003afc:	eb0e 0200 	add.w	r2, lr, r0
 8003b00:	d00a      	beq.n	8003b18 <f_write.part.12+0x1a0>
 8003b02:	f81e 1000 	ldrb.w	r1, [lr, r0]
 8003b06:	5431      	strb	r1, [r6, r0]
	while (cnt--)
 8003b08:	2d01      	cmp	r5, #1
 8003b0a:	d005      	beq.n	8003b18 <f_write.part.12+0x1a0>
		*d++ = *s++;
 8003b0c:	7851      	ldrb	r1, [r2, #1]
 8003b0e:	7059      	strb	r1, [r3, #1]
	while (cnt--)
 8003b10:	2d02      	cmp	r5, #2
 8003b12:	d001      	beq.n	8003b18 <f_write.part.12+0x1a0>
		*d++ = *s++;
 8003b14:	7892      	ldrb	r2, [r2, #2]
 8003b16:	709a      	strb	r2, [r3, #2]
					fp->flag &= ~FA__DIRTY;
 8003b18:	f899 3006 	ldrb.w	r3, [r9, #6]
 8003b1c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003b20:	f889 3006 	strb.w	r3, [r9, #6]
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 8003b24:	0263      	lsls	r3, r4, #9
 8003b26:	18f9      	adds	r1, r7, r3
 8003b28:	f8d9 5008 	ldr.w	r5, [r9, #8]
 8003b2c:	e075      	b.n	8003c1a <f_write.part.12+0x2a2>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 8003b2e:	f8d9 3018 	ldr.w	r3, [r9, #24]
				if (fp->fptr < fp->fsize &&
 8003b32:	f8d9 2008 	ldr.w	r2, [r9, #8]
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 8003b36:	429d      	cmp	r5, r3
 8003b38:	d004      	beq.n	8003b44 <f_write.part.12+0x1cc>
				if (fp->fptr < fp->fsize &&
 8003b3a:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8003b3e:	429a      	cmp	r2, r3
 8003b40:	f0c0 80cd 	bcc.w	8003cde <f_write.part.12+0x366>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
 8003b44:	f8c9 5018 	str.w	r5, [r9, #24]
 8003b48:	f3c2 0208 	ubfx	r2, r2, #0, #9
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 8003b4c:	f5c2 7300 	rsb	r3, r2, #512	; 0x200
 8003b50:	f102 0124 	add.w	r1, r2, #36	; 0x24
 8003b54:	3228      	adds	r2, #40	; 0x28
 8003b56:	4553      	cmp	r3, sl
 8003b58:	444a      	add	r2, r9
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8003b5a:	eb09 0001 	add.w	r0, r9, r1
 8003b5e:	f107 0404 	add.w	r4, r7, #4
 8003b62:	bf28      	it	cs
 8003b64:	4653      	movcs	r3, sl
 8003b66:	42a0      	cmp	r0, r4
 8003b68:	bf38      	it	cc
 8003b6a:	4297      	cmpcc	r7, r2
	while (cnt--)
 8003b6c:	f103 3eff 	add.w	lr, r3, #4294967295
 8003b70:	d37a      	bcc.n	8003c68 <f_write.part.12+0x2f0>
 8003b72:	2b0b      	cmp	r3, #11
 8003b74:	d978      	bls.n	8003c68 <f_write.part.12+0x2f0>
 8003b76:	427a      	negs	r2, r7
 8003b78:	f012 0203 	ands.w	r2, r2, #3
 8003b7c:	d05f      	beq.n	8003c3e <f_write.part.12+0x2c6>
		*d++ = *s++;
 8003b7e:	783c      	ldrb	r4, [r7, #0]
 8003b80:	f809 4001 	strb.w	r4, [r9, r1]
 8003b84:	2a01      	cmp	r2, #1
 8003b86:	f100 0401 	add.w	r4, r0, #1
 8003b8a:	f107 0501 	add.w	r5, r7, #1
	while (cnt--)
 8003b8e:	f1a3 0602 	sub.w	r6, r3, #2
 8003b92:	d00e      	beq.n	8003bb2 <f_write.part.12+0x23a>
		*d++ = *s++;
 8003b94:	787c      	ldrb	r4, [r7, #1]
 8003b96:	7044      	strb	r4, [r0, #1]
 8003b98:	2a03      	cmp	r2, #3
 8003b9a:	f100 0402 	add.w	r4, r0, #2
 8003b9e:	f107 0502 	add.w	r5, r7, #2
	while (cnt--)
 8003ba2:	f1a3 0603 	sub.w	r6, r3, #3
 8003ba6:	d104      	bne.n	8003bb2 <f_write.part.12+0x23a>
		*d++ = *s++;
 8003ba8:	78bc      	ldrb	r4, [r7, #2]
 8003baa:	7084      	strb	r4, [r0, #2]
 8003bac:	1cfd      	adds	r5, r7, #3
 8003bae:	1cc4      	adds	r4, r0, #3
	while (cnt--)
 8003bb0:	1f1e      	subs	r6, r3, #4
 8003bb2:	eba3 0802 	sub.w	r8, r3, r2
 8003bb6:	f1a8 0004 	sub.w	r0, r8, #4
 8003bba:	0880      	lsrs	r0, r0, #2
 8003bbc:	ebae 0e02 	sub.w	lr, lr, r2
 8003bc0:	3001      	adds	r0, #1
 8003bc2:	f1be 0f02 	cmp.w	lr, #2
 8003bc6:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 8003bca:	d914      	bls.n	8003bf6 <f_write.part.12+0x27e>
 8003bcc:	4411      	add	r1, r2
 8003bce:	4449      	add	r1, r9
 8003bd0:	443a      	add	r2, r7
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8003bd2:	f04f 0e00 	mov.w	lr, #0
 8003bd6:	9700      	str	r7, [sp, #0]
 8003bd8:	f10e 0e01 	add.w	lr, lr, #1
		*d++ = *s++;
 8003bdc:	f852 7b04 	ldr.w	r7, [r2], #4
 8003be0:	f841 7b04 	str.w	r7, [r1], #4
 8003be4:	4586      	cmp	lr, r0
 8003be6:	d3f7      	bcc.n	8003bd8 <f_write.part.12+0x260>
 8003be8:	45e0      	cmp	r8, ip
 8003bea:	9f00      	ldr	r7, [sp, #0]
 8003bec:	4464      	add	r4, ip
 8003bee:	4465      	add	r5, ip
 8003bf0:	eba6 060c 	sub.w	r6, r6, ip
 8003bf4:	d021      	beq.n	8003c3a <f_write.part.12+0x2c2>
 8003bf6:	782a      	ldrb	r2, [r5, #0]
 8003bf8:	7022      	strb	r2, [r4, #0]
	while (cnt--)
 8003bfa:	b1f6      	cbz	r6, 8003c3a <f_write.part.12+0x2c2>
		*d++ = *s++;
 8003bfc:	786a      	ldrb	r2, [r5, #1]
 8003bfe:	7062      	strb	r2, [r4, #1]
	while (cnt--)
 8003c00:	2e01      	cmp	r6, #1
 8003c02:	d01a      	beq.n	8003c3a <f_write.part.12+0x2c2>
		*d++ = *s++;
 8003c04:	78aa      	ldrb	r2, [r5, #2]
 8003c06:	70a2      	strb	r2, [r4, #2]
 8003c08:	18f9      	adds	r1, r7, r3
		fp->flag |= FA__DIRTY;
 8003c0a:	f899 2006 	ldrb.w	r2, [r9, #6]
 8003c0e:	f8d9 5008 	ldr.w	r5, [r9, #8]
 8003c12:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003c16:	f889 2006 	strb.w	r2, [r9, #6]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 8003c1a:	f8db 2000 	ldr.w	r2, [fp]
 8003c1e:	441d      	add	r5, r3
 8003c20:	441a      	add	r2, r3
	for ( ;  btw;							/* Repeat until all data written */
 8003c22:	ebba 0a03 	subs.w	sl, sl, r3
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 8003c26:	f8c9 5008 	str.w	r5, [r9, #8]
 8003c2a:	460f      	mov	r7, r1
 8003c2c:	f8cb 2000 	str.w	r2, [fp]
	for ( ;  btw;							/* Repeat until all data written */
 8003c30:	f47f aecd 	bne.w	80039ce <f_write.part.12+0x56>
 8003c34:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8003c38:	e038      	b.n	8003cac <f_write.part.12+0x334>
 8003c3a:	18f9      	adds	r1, r7, r3
 8003c3c:	e7e5      	b.n	8003c0a <f_write.part.12+0x292>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8003c3e:	4604      	mov	r4, r0
	while (cnt--)
 8003c40:	4676      	mov	r6, lr
 8003c42:	463d      	mov	r5, r7
 8003c44:	e7b5      	b.n	8003bb2 <f_write.part.12+0x23a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 8003c46:	7840      	ldrb	r0, [r0, #1]
 8003c48:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8003c4c:	9901      	ldr	r1, [sp, #4]
 8003c4e:	2301      	movs	r3, #1
 8003c50:	f7fe fdd6 	bl	8002800 <disk_write>
 8003c54:	b988      	cbnz	r0, 8003c7a <f_write.part.12+0x302>
				fp->flag &= ~FA__DIRTY;
 8003c56:	f899 1006 	ldrb.w	r1, [r9, #6]
 8003c5a:	f8d9 0000 	ldr.w	r0, [r9]
 8003c5e:	f001 01bf 	and.w	r1, r1, #191	; 0xbf
 8003c62:	f889 1006 	strb.w	r1, [r9, #6]
 8003c66:	e6d7      	b.n	8003a18 <f_write.part.12+0xa0>
 8003c68:	3801      	subs	r0, #1
 8003c6a:	18f9      	adds	r1, r7, r3
		*d++ = *s++;
 8003c6c:	f817 2b01 	ldrb.w	r2, [r7], #1
 8003c70:	f800 2f01 	strb.w	r2, [r0, #1]!
	while (cnt--)
 8003c74:	42b9      	cmp	r1, r7
 8003c76:	d1f9      	bne.n	8003c6c <f_write.part.12+0x2f4>
 8003c78:	e7c7      	b.n	8003c0a <f_write.part.12+0x292>
						ABORT(fp->fs, FR_DISK_ERR);
 8003c7a:	f899 3006 	ldrb.w	r3, [r9, #6]
 8003c7e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8003c82:	f889 3006 	strb.w	r3, [r9, #6]
 8003c86:	2001      	movs	r0, #1

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
 8003c88:	b009      	add	sp, #36	; 0x24
 8003c8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8003c8e:	f8d9 1014 	ldr.w	r1, [r9, #20]
 8003c92:	f7ff fcd9 	bl	8003648 <create_chain>
 8003c96:	4603      	mov	r3, r0
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8003c98:	2b00      	cmp	r3, #0
 8003c9a:	f47f aeae 	bne.w	80039fa <f_write.part.12+0x82>
 8003c9e:	f8d9 5008 	ldr.w	r5, [r9, #8]
 8003ca2:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8003ca6:	e001      	b.n	8003cac <f_write.part.12+0x334>
 8003ca8:	f8d9 5008 	ldr.w	r5, [r9, #8]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 8003cac:	f899 3006 	ldrb.w	r3, [r9, #6]
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8003cb0:	42aa      	cmp	r2, r5
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 8003cb2:	f043 0320 	orr.w	r3, r3, #32
	LEAVE_FF(fp->fs, FR_OK);
 8003cb6:	f04f 0000 	mov.w	r0, #0
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8003cba:	bf38      	it	cc
 8003cbc:	f8c9 500c 	strcc.w	r5, [r9, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 8003cc0:	f889 3006 	strb.w	r3, [r9, #6]
}
 8003cc4:	b009      	add	sp, #36	; 0x24
 8003cc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 8003cca:	4631      	mov	r1, r6
 8003ccc:	f7ff fcbc 	bl	8003648 <create_chain>
 8003cd0:	4603      	mov	r3, r0
 8003cd2:	f8c9 0010 	str.w	r0, [r9, #16]
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8003cd6:	2b00      	cmp	r3, #0
 8003cd8:	f47f ae8f 	bne.w	80039fa <f_write.part.12+0x82>
 8003cdc:	e7df      	b.n	8003c9e <f_write.part.12+0x326>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
 8003cde:	7840      	ldrb	r0, [r0, #1]
 8003ce0:	9901      	ldr	r1, [sp, #4]
 8003ce2:	2301      	movs	r3, #1
 8003ce4:	462a      	mov	r2, r5
 8003ce6:	f7fe fd69 	bl	80027bc <disk_read>
				if (fp->fptr < fp->fsize &&
 8003cea:	2800      	cmp	r0, #0
 8003cec:	d1c5      	bne.n	8003c7a <f_write.part.12+0x302>
 8003cee:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8003cf2:	e727      	b.n	8003b44 <f_write.part.12+0x1cc>
	const BYTE *s = (const BYTE*)src;
 8003cf4:	469e      	mov	lr, r3
	BYTE *d = (BYTE*)dst;
 8003cf6:	9e01      	ldr	r6, [sp, #4]
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 8003cf8:	f44f 7500 	mov.w	r5, #512	; 0x200
 8003cfc:	4603      	mov	r3, r0
 8003cfe:	e6e7      	b.n	8003ad0 <f_write.part.12+0x158>
 8003d00:	f109 0223 	add.w	r2, r9, #35	; 0x23
 8003d04:	f503 7000 	add.w	r0, r3, #512	; 0x200
		*d++ = *s++;
 8003d08:	f813 1b01 	ldrb.w	r1, [r3], #1
 8003d0c:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (cnt--)
 8003d10:	4283      	cmp	r3, r0
 8003d12:	d1f9      	bne.n	8003d08 <f_write.part.12+0x390>
 8003d14:	e700      	b.n	8003b18 <f_write.part.12+0x1a0>
		*d++ = *s++;
 8003d16:	f44f 75ff 	mov.w	r5, #510	; 0x1fe
 8003d1a:	4603      	mov	r3, r0
 8003d1c:	e6d8      	b.n	8003ad0 <f_write.part.12+0x158>
 8003d1e:	f240 15ff 	movw	r5, #511	; 0x1ff
 8003d22:	4603      	mov	r3, r0
 8003d24:	e6d4      	b.n	8003ad0 <f_write.part.12+0x158>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8003d26:	f061 017f 	orn	r1, r1, #127	; 0x7f
 8003d2a:	f889 1006 	strb.w	r1, [r9, #6]
 8003d2e:	2002      	movs	r0, #2
 8003d30:	e7aa      	b.n	8003c88 <f_write.part.12+0x310>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 8003d32:	f899 3006 	ldrb.w	r3, [r9, #6]
 8003d36:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8003d3a:	f889 3006 	strb.w	r3, [r9, #6]
 8003d3e:	2002      	movs	r0, #2
 8003d40:	e7a2      	b.n	8003c88 <f_write.part.12+0x310>
 8003d42:	bf00      	nop

08003d44 <f_read.part.11>:
FRESULT f_read (
 8003d44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	remain = fp->fsize - fp->fptr;
 8003d48:	6885      	ldr	r5, [r0, #8]
 8003d4a:	68c4      	ldr	r4, [r0, #12]
 8003d4c:	eba4 0a05 	sub.w	sl, r4, r5
 8003d50:	4592      	cmp	sl, r2
 8003d52:	bf28      	it	cs
 8003d54:	4692      	movcs	sl, r2
FRESULT f_read (
 8003d56:	b089      	sub	sp, #36	; 0x24
	for ( ;  btr;								/* Repeat until all data read */
 8003d58:	f1ba 0f00 	cmp.w	sl, #0
 8003d5c:	d06f      	beq.n	8003e3e <f_read.part.11+0xfa>
 8003d5e:	f100 0224 	add.w	r2, r0, #36	; 0x24
 8003d62:	469b      	mov	fp, r3
 8003d64:	4253      	negs	r3, r2
 8003d66:	9201      	str	r2, [sp, #4]
 8003d68:	f003 0203 	and.w	r2, r3, #3
 8003d6c:	f5c2 73fe 	rsb	r3, r2, #508	; 0x1fc
 8003d70:	089b      	lsrs	r3, r3, #2
 8003d72:	4680      	mov	r8, r0
 8003d74:	1c58      	adds	r0, r3, #1
 8003d76:	9202      	str	r2, [sp, #8]
 8003d78:	9005      	str	r0, [sp, #20]
 8003d7a:	4689      	mov	r9, r1
 8003d7c:	0081      	lsls	r1, r0, #2
 8003d7e:	4610      	mov	r0, r2
 8003d80:	f5c2 7200 	rsb	r2, r2, #512	; 0x200
 8003d84:	9206      	str	r2, [sp, #24]
 8003d86:	f100 0224 	add.w	r2, r0, #36	; 0x24
 8003d8a:	9207      	str	r2, [sp, #28]
 8003d8c:	f108 0228 	add.w	r2, r8, #40	; 0x28
 8003d90:	9104      	str	r1, [sp, #16]
 8003d92:	9203      	str	r2, [sp, #12]
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 8003d94:	f3c5 0208 	ubfx	r2, r5, #0, #9
 8003d98:	2a00      	cmp	r2, #0
 8003d9a:	d17b      	bne.n	8003e94 <f_read.part.11+0x150>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 8003d9c:	f8d8 0000 	ldr.w	r0, [r8]
 8003da0:	7886      	ldrb	r6, [r0, #2]
 8003da2:	3e01      	subs	r6, #1
 8003da4:	ea06 2655 	and.w	r6, r6, r5, lsr #9
			if (!csect) {						/* On the cluster boundary? */
 8003da8:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 8003dac:	f040 80d6 	bne.w	8003f5c <f_read.part.11+0x218>
				if (fp->fptr == 0) {			/* On the top of the file? */
 8003db0:	2d00      	cmp	r5, #0
 8003db2:	f040 80e4 	bne.w	8003f7e <f_read.part.11+0x23a>
					clst = fp->sclust;			/* Follow from the origin */
 8003db6:	f8d8 5010 	ldr.w	r5, [r8, #16]
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 8003dba:	2d01      	cmp	r5, #1
 8003dbc:	f240 80e6 	bls.w	8003f8c <f_read.part.11+0x248>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8003dc0:	1c69      	adds	r1, r5, #1
 8003dc2:	f000 80ed 	beq.w	8003fa0 <f_read.part.11+0x25c>
 8003dc6:	f8d8 0000 	ldr.w	r0, [r8]
				fp->clust = clst;				/* Update current cluster */
 8003dca:	f8c8 5014 	str.w	r5, [r8, #20]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003dce:	6983      	ldr	r3, [r0, #24]
	clst -= 2;
 8003dd0:	3d02      	subs	r5, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003dd2:	3b02      	subs	r3, #2
 8003dd4:	429d      	cmp	r5, r3
 8003dd6:	f080 80d9 	bcs.w	8003f8c <f_read.part.11+0x248>
	return clst * fs->csize + fs->database;
 8003dda:	7883      	ldrb	r3, [r0, #2]
 8003ddc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8003dde:	9200      	str	r2, [sp, #0]
 8003de0:	fb05 f503 	mul.w	r5, r5, r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8003de4:	18af      	adds	r7, r5, r2
 8003de6:	f000 80d1 	beq.w	8003f8c <f_read.part.11+0x248>
			if (cc) {							/* Read maximum contiguous sectors directly */
 8003dea:	ea5f 245a 	movs.w	r4, sl, lsr #9
			sect += csect;
 8003dee:	4437      	add	r7, r6
			if (cc) {							/* Read maximum contiguous sectors directly */
 8003df0:	d029      	beq.n	8003e46 <f_read.part.11+0x102>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 8003df2:	1932      	adds	r2, r6, r4
 8003df4:	4293      	cmp	r3, r2
					cc = fp->fs->csize - csect;
 8003df6:	bf38      	it	cc
 8003df8:	1b9c      	subcc	r4, r3, r6
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
 8003dfa:	b2e3      	uxtb	r3, r4
 8003dfc:	7840      	ldrb	r0, [r0, #1]
 8003dfe:	463a      	mov	r2, r7
 8003e00:	4649      	mov	r1, r9
 8003e02:	f7fe fcdb 	bl	80027bc <disk_read>
					ABORT(fp->fs, FR_DISK_ERR);
 8003e06:	f898 3006 	ldrb.w	r3, [r8, #6]
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
 8003e0a:	2800      	cmp	r0, #0
 8003e0c:	f040 80ca 	bne.w	8003fa4 <f_read.part.11+0x260>
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
 8003e10:	065a      	lsls	r2, r3, #25
 8003e12:	d505      	bpl.n	8003e20 <f_read.part.11+0xdc>
 8003e14:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8003e18:	1bd7      	subs	r7, r2, r7
 8003e1a:	42bc      	cmp	r4, r7
 8003e1c:	f200 80ca 	bhi.w	8003fb4 <f_read.part.11+0x270>
 8003e20:	f8d8 5008 	ldr.w	r5, [r8, #8]
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
 8003e24:	0263      	lsls	r3, r4, #9
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8003e26:	f8db 2000 	ldr.w	r2, [fp]
 8003e2a:	441d      	add	r5, r3
 8003e2c:	441a      	add	r2, r3
	for ( ;  btr;								/* Repeat until all data read */
 8003e2e:	ebba 0a03 	subs.w	sl, sl, r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8003e32:	f8c8 5008 	str.w	r5, [r8, #8]
 8003e36:	4499      	add	r9, r3
 8003e38:	f8cb 2000 	str.w	r2, [fp]
	for ( ;  btr;								/* Repeat until all data read */
 8003e3c:	d1aa      	bne.n	8003d94 <f_read.part.11+0x50>
	LEAVE_FF(fp->fs, FR_OK);
 8003e3e:	2000      	movs	r0, #0
}
 8003e40:	b009      	add	sp, #36	; 0x24
 8003e42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
 8003e46:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8003e4a:	4297      	cmp	r7, r2
 8003e4c:	d01c      	beq.n	8003e88 <f_read.part.11+0x144>
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
 8003e4e:	f898 3006 	ldrb.w	r3, [r8, #6]
 8003e52:	065b      	lsls	r3, r3, #25
 8003e54:	d50f      	bpl.n	8003e76 <f_read.part.11+0x132>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 8003e56:	2301      	movs	r3, #1
 8003e58:	7840      	ldrb	r0, [r0, #1]
 8003e5a:	9901      	ldr	r1, [sp, #4]
 8003e5c:	f7fe fcd0 	bl	8002800 <disk_write>
						ABORT(fp->fs, FR_DISK_ERR);
 8003e60:	f898 3006 	ldrb.w	r3, [r8, #6]
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 8003e64:	2800      	cmp	r0, #0
 8003e66:	f040 809d 	bne.w	8003fa4 <f_read.part.11+0x260>
					fp->flag &= ~FA__DIRTY;
 8003e6a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003e6e:	f8d8 0000 	ldr.w	r0, [r8]
 8003e72:	f888 3006 	strb.w	r3, [r8, #6]
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
 8003e76:	7840      	ldrb	r0, [r0, #1]
 8003e78:	9901      	ldr	r1, [sp, #4]
 8003e7a:	2301      	movs	r3, #1
 8003e7c:	463a      	mov	r2, r7
 8003e7e:	f7fe fc9d 	bl	80027bc <disk_read>
 8003e82:	2800      	cmp	r0, #0
 8003e84:	f040 808c 	bne.w	8003fa0 <f_read.part.11+0x25c>
 8003e88:	f8d8 2008 	ldr.w	r2, [r8, #8]
			fp->dsect = sect;
 8003e8c:	f8c8 7018 	str.w	r7, [r8, #24]
 8003e90:	f3c2 0208 	ubfx	r2, r2, #0, #9
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 8003e94:	f5c2 7300 	rsb	r3, r2, #512	; 0x200
 8003e98:	f102 0124 	add.w	r1, r2, #36	; 0x24
 8003e9c:	3228      	adds	r2, #40	; 0x28
 8003e9e:	4553      	cmp	r3, sl
 8003ea0:	4442      	add	r2, r8
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 8003ea2:	eb08 0001 	add.w	r0, r8, r1
 8003ea6:	f109 0404 	add.w	r4, r9, #4
 8003eaa:	bf28      	it	cs
 8003eac:	4653      	movcs	r3, sl
 8003eae:	42a0      	cmp	r0, r4
 8003eb0:	bf38      	it	cc
 8003eb2:	4591      	cmpcc	r9, r2
	while (cnt--)
 8003eb4:	f103 37ff 	add.w	r7, r3, #4294967295
 8003eb8:	d357      	bcc.n	8003f6a <f_read.part.11+0x226>
 8003eba:	2b0b      	cmp	r3, #11
 8003ebc:	d955      	bls.n	8003f6a <f_read.part.11+0x226>
 8003ebe:	4242      	negs	r2, r0
 8003ec0:	f012 0203 	ands.w	r2, r2, #3
 8003ec4:	d04d      	beq.n	8003f62 <f_read.part.11+0x21e>
		*d++ = *s++;
 8003ec6:	f818 4001 	ldrb.w	r4, [r8, r1]
 8003eca:	f889 4000 	strb.w	r4, [r9]
 8003ece:	2a01      	cmp	r2, #1
 8003ed0:	f109 0401 	add.w	r4, r9, #1
 8003ed4:	f100 0501 	add.w	r5, r0, #1
	while (cnt--)
 8003ed8:	f1a3 0602 	sub.w	r6, r3, #2
 8003edc:	d011      	beq.n	8003f02 <f_read.part.11+0x1be>
		*d++ = *s++;
 8003ede:	7844      	ldrb	r4, [r0, #1]
 8003ee0:	f889 4001 	strb.w	r4, [r9, #1]
 8003ee4:	2a03      	cmp	r2, #3
 8003ee6:	f109 0402 	add.w	r4, r9, #2
 8003eea:	f100 0502 	add.w	r5, r0, #2
	while (cnt--)
 8003eee:	f1a3 0603 	sub.w	r6, r3, #3
 8003ef2:	d106      	bne.n	8003f02 <f_read.part.11+0x1be>
		*d++ = *s++;
 8003ef4:	7884      	ldrb	r4, [r0, #2]
 8003ef6:	f889 4002 	strb.w	r4, [r9, #2]
 8003efa:	1cc5      	adds	r5, r0, #3
 8003efc:	f109 0403 	add.w	r4, r9, #3
	while (cnt--)
 8003f00:	1f1e      	subs	r6, r3, #4
 8003f02:	eba3 0c02 	sub.w	ip, r3, r2
 8003f06:	f1ac 0004 	sub.w	r0, ip, #4
 8003f0a:	0880      	lsrs	r0, r0, #2
 8003f0c:	1abf      	subs	r7, r7, r2
 8003f0e:	3001      	adds	r0, #1
 8003f10:	2f02      	cmp	r7, #2
 8003f12:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8003f16:	d915      	bls.n	8003f44 <f_read.part.11+0x200>
 8003f18:	4411      	add	r1, r2
 8003f1a:	f8cd 9000 	str.w	r9, [sp]
 8003f1e:	444a      	add	r2, r9
 8003f20:	4441      	add	r1, r8
 8003f22:	2700      	movs	r7, #0
 8003f24:	4681      	mov	r9, r0
 8003f26:	3701      	adds	r7, #1
		*d++ = *s++;
 8003f28:	f851 0b04 	ldr.w	r0, [r1], #4
 8003f2c:	f842 0b04 	str.w	r0, [r2], #4
 8003f30:	45b9      	cmp	r9, r7
 8003f32:	d8f8      	bhi.n	8003f26 <f_read.part.11+0x1e2>
 8003f34:	45f4      	cmp	ip, lr
 8003f36:	f8dd 9000 	ldr.w	r9, [sp]
 8003f3a:	4474      	add	r4, lr
 8003f3c:	4475      	add	r5, lr
 8003f3e:	eba6 060e 	sub.w	r6, r6, lr
 8003f42:	d008      	beq.n	8003f56 <f_read.part.11+0x212>
 8003f44:	782a      	ldrb	r2, [r5, #0]
 8003f46:	7022      	strb	r2, [r4, #0]
	while (cnt--)
 8003f48:	b12e      	cbz	r6, 8003f56 <f_read.part.11+0x212>
		*d++ = *s++;
 8003f4a:	786a      	ldrb	r2, [r5, #1]
 8003f4c:	7062      	strb	r2, [r4, #1]
	while (cnt--)
 8003f4e:	2e01      	cmp	r6, #1
 8003f50:	d001      	beq.n	8003f56 <f_read.part.11+0x212>
		*d++ = *s++;
 8003f52:	78aa      	ldrb	r2, [r5, #2]
 8003f54:	70a2      	strb	r2, [r4, #2]
 8003f56:	f8d8 5008 	ldr.w	r5, [r8, #8]
 8003f5a:	e764      	b.n	8003e26 <f_read.part.11+0xe2>
 8003f5c:	f8d8 5014 	ldr.w	r5, [r8, #20]
 8003f60:	e735      	b.n	8003dce <f_read.part.11+0x8a>
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 8003f62:	4605      	mov	r5, r0
	while (cnt--)
 8003f64:	463e      	mov	r6, r7
 8003f66:	464c      	mov	r4, r9
 8003f68:	e7cb      	b.n	8003f02 <f_read.part.11+0x1be>
 8003f6a:	f109 32ff 	add.w	r2, r9, #4294967295
 8003f6e:	18c4      	adds	r4, r0, r3
		*d++ = *s++;
 8003f70:	f810 1b01 	ldrb.w	r1, [r0], #1
 8003f74:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (cnt--)
 8003f78:	42a0      	cmp	r0, r4
 8003f7a:	d1f9      	bne.n	8003f70 <f_read.part.11+0x22c>
 8003f7c:	e7eb      	b.n	8003f56 <f_read.part.11+0x212>
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
 8003f7e:	f8d8 1014 	ldr.w	r1, [r8, #20]
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8003f82:	2901      	cmp	r1, #1
 8003f84:	d902      	bls.n	8003f8c <f_read.part.11+0x248>
 8003f86:	6983      	ldr	r3, [r0, #24]
 8003f88:	4299      	cmp	r1, r3
 8003f8a:	d374      	bcc.n	8004076 <f_read.part.11+0x332>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8003f8c:	f898 3006 	ldrb.w	r3, [r8, #6]
 8003f90:	2002      	movs	r0, #2
 8003f92:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8003f96:	f888 3006 	strb.w	r3, [r8, #6]
}
 8003f9a:	b009      	add	sp, #36	; 0x24
 8003f9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					ABORT(fp->fs, FR_DISK_ERR);
 8003fa0:	f898 3006 	ldrb.w	r3, [r8, #6]
 8003fa4:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8003fa8:	2001      	movs	r0, #1
 8003faa:	f888 3006 	strb.w	r3, [r8, #6]
}
 8003fae:	b009      	add	sp, #36	; 0x24
 8003fb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003fb4:	9b00      	ldr	r3, [sp, #0]
 8003fb6:	9903      	ldr	r1, [sp, #12]
 8003fb8:	1b92      	subs	r2, r2, r6
 8003fba:	1ad2      	subs	r2, r2, r3
 8003fbc:	1b52      	subs	r2, r2, r5
 8003fbe:	0252      	lsls	r2, r2, #9
 8003fc0:	eb09 0302 	add.w	r3, r9, r2
 8003fc4:	4299      	cmp	r1, r3
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 8003fc6:	eb09 2747 	add.w	r7, r9, r7, lsl #9
 8003fca:	d90f      	bls.n	8003fec <f_read.part.11+0x2a8>
 8003fcc:	1d13      	adds	r3, r2, #4
 8003fce:	9901      	ldr	r1, [sp, #4]
 8003fd0:	444b      	add	r3, r9
 8003fd2:	4299      	cmp	r1, r3
 8003fd4:	d20a      	bcs.n	8003fec <f_read.part.11+0x2a8>
 8003fd6:	460b      	mov	r3, r1
 8003fd8:	1e7a      	subs	r2, r7, #1
 8003fda:	f508 7009 	add.w	r0, r8, #548	; 0x224
		*d++ = *s++;
 8003fde:	f813 1b01 	ldrb.w	r1, [r3], #1
 8003fe2:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (cnt--)
 8003fe6:	4283      	cmp	r3, r0
 8003fe8:	d1f9      	bne.n	8003fde <f_read.part.11+0x29a>
 8003fea:	e719      	b.n	8003e20 <f_read.part.11+0xdc>
 8003fec:	9902      	ldr	r1, [sp, #8]
 8003fee:	2900      	cmp	r1, #0
 8003ff0:	d045      	beq.n	800407e <f_read.part.11+0x33a>
		*d++ = *s++;
 8003ff2:	f898 3024 	ldrb.w	r3, [r8, #36]	; 0x24
 8003ff6:	703b      	strb	r3, [r7, #0]
 8003ff8:	2901      	cmp	r1, #1
 8003ffa:	f107 0001 	add.w	r0, r7, #1
 8003ffe:	f108 0525 	add.w	r5, r8, #37	; 0x25
 8004002:	d046      	beq.n	8004092 <f_read.part.11+0x34e>
 8004004:	f898 3025 	ldrb.w	r3, [r8, #37]	; 0x25
 8004008:	707b      	strb	r3, [r7, #1]
 800400a:	2903      	cmp	r1, #3
 800400c:	f107 0002 	add.w	r0, r7, #2
 8004010:	f108 0526 	add.w	r5, r8, #38	; 0x26
 8004014:	d139      	bne.n	800408a <f_read.part.11+0x346>
 8004016:	f898 3026 	ldrb.w	r3, [r8, #38]	; 0x26
 800401a:	70bb      	strb	r3, [r7, #2]
 800401c:	1cf8      	adds	r0, r7, #3
 800401e:	f108 0527 	add.w	r5, r8, #39	; 0x27
 8004022:	f240 16fd 	movw	r6, #509	; 0x1fd
 8004026:	460b      	mov	r3, r1
 8004028:	441a      	add	r2, r3
 800402a:	9b07      	ldr	r3, [sp, #28]
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 800402c:	f8dd e014 	ldr.w	lr, [sp, #20]
 8004030:	eb08 0103 	add.w	r1, r8, r3
 8004034:	444a      	add	r2, r9
 8004036:	2300      	movs	r3, #0
 8004038:	3301      	adds	r3, #1
		*d++ = *s++;
 800403a:	f851 7b04 	ldr.w	r7, [r1], #4
 800403e:	f842 7b04 	str.w	r7, [r2], #4
 8004042:	459e      	cmp	lr, r3
 8004044:	d8f8      	bhi.n	8004038 <f_read.part.11+0x2f4>
 8004046:	9f04      	ldr	r7, [sp, #16]
 8004048:	9906      	ldr	r1, [sp, #24]
 800404a:	428f      	cmp	r7, r1
 800404c:	eba6 0607 	sub.w	r6, r6, r7
 8004050:	eb00 0307 	add.w	r3, r0, r7
 8004054:	eb05 0207 	add.w	r2, r5, r7
 8004058:	f43f aee2 	beq.w	8003e20 <f_read.part.11+0xdc>
 800405c:	5de9      	ldrb	r1, [r5, r7]
 800405e:	55c1      	strb	r1, [r0, r7]
	while (cnt--)
 8004060:	2e01      	cmp	r6, #1
 8004062:	f43f aedd 	beq.w	8003e20 <f_read.part.11+0xdc>
		*d++ = *s++;
 8004066:	7851      	ldrb	r1, [r2, #1]
 8004068:	7059      	strb	r1, [r3, #1]
	while (cnt--)
 800406a:	2e02      	cmp	r6, #2
 800406c:	f43f aed8 	beq.w	8003e20 <f_read.part.11+0xdc>
		*d++ = *s++;
 8004070:	7892      	ldrb	r2, [r2, #2]
 8004072:	709a      	strb	r2, [r3, #2]
 8004074:	e6d4      	b.n	8003e20 <f_read.part.11+0xdc>
 8004076:	f7ff f959 	bl	800332c <get_fat.part.6>
 800407a:	4605      	mov	r5, r0
 800407c:	e69d      	b.n	8003dba <f_read.part.11+0x76>
	BYTE *d = (BYTE*)dst;
 800407e:	4638      	mov	r0, r7
	const BYTE *s = (const BYTE*)src;
 8004080:	9d01      	ldr	r5, [sp, #4]
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 8004082:	f44f 7600 	mov.w	r6, #512	; 0x200
 8004086:	460b      	mov	r3, r1
 8004088:	e7ce      	b.n	8004028 <f_read.part.11+0x2e4>
		*d++ = *s++;
 800408a:	f44f 76ff 	mov.w	r6, #510	; 0x1fe
 800408e:	460b      	mov	r3, r1
 8004090:	e7ca      	b.n	8004028 <f_read.part.11+0x2e4>
 8004092:	f240 16ff 	movw	r6, #511	; 0x1ff
 8004096:	460b      	mov	r3, r1
 8004098:	e7c6      	b.n	8004028 <f_read.part.11+0x2e4>
 800409a:	bf00      	nop

0800409c <follow_path>:
{
 800409c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 80040a0:	780b      	ldrb	r3, [r1, #0]
 80040a2:	2b2f      	cmp	r3, #47	; 0x2f
{
 80040a4:	460c      	mov	r4, r1
 80040a6:	4606      	mov	r6, r0
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 80040a8:	d076      	beq.n	8004198 <follow_path+0xfc>
 80040aa:	2b5c      	cmp	r3, #92	; 0x5c
 80040ac:	d074      	beq.n	8004198 <follow_path+0xfc>
	dj->sclust = 0;						/* Start from the root dir */
 80040ae:	2500      	movs	r5, #0
 80040b0:	60b5      	str	r5, [r6, #8]
	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
 80040b2:	7823      	ldrb	r3, [r4, #0]
 80040b4:	2b1f      	cmp	r3, #31
 80040b6:	d975      	bls.n	80041a4 <follow_path+0x108>
 80040b8:	69b2      	ldr	r2, [r6, #24]
			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
 80040ba:	46a2      	mov	sl, r4
 80040bc:	4654      	mov	r4, sl
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 80040be:	7823      	ldrb	r3, [r4, #0]
 80040c0:	2b2f      	cmp	r3, #47	; 0x2f
 80040c2:	4621      	mov	r1, r4
 80040c4:	f104 0401 	add.w	r4, r4, #1
 80040c8:	d0f9      	beq.n	80040be <follow_path+0x22>
 80040ca:	2b5c      	cmp	r3, #92	; 0x5c
 80040cc:	d0f7      	beq.n	80040be <follow_path+0x22>
		*d++ = (BYTE)val;
 80040ce:	2320      	movs	r3, #32
 80040d0:	2700      	movs	r7, #0
 80040d2:	7013      	strb	r3, [r2, #0]
 80040d4:	7053      	strb	r3, [r2, #1]
 80040d6:	7093      	strb	r3, [r2, #2]
 80040d8:	70d3      	strb	r3, [r2, #3]
 80040da:	7113      	strb	r3, [r2, #4]
 80040dc:	7153      	strb	r3, [r2, #5]
 80040de:	7193      	strb	r3, [r2, #6]
 80040e0:	71d3      	strb	r3, [r2, #7]
 80040e2:	7213      	strb	r3, [r2, #8]
 80040e4:	7253      	strb	r3, [r2, #9]
 80040e6:	7293      	strb	r3, [r2, #10]
 80040e8:	463c      	mov	r4, r7
 80040ea:	46bc      	mov	ip, r7
 80040ec:	f101 3eff 	add.w	lr, r1, #4294967295
 80040f0:	f04f 0808 	mov.w	r8, #8
		c = (BYTE)p[si++];
 80040f4:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 80040f8:	2b20      	cmp	r3, #32
		c = (BYTE)p[si++];
 80040fa:	f104 0401 	add.w	r4, r4, #1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 80040fe:	d922      	bls.n	8004146 <follow_path+0xaa>
 8004100:	2b2f      	cmp	r3, #47	; 0x2f
 8004102:	d043      	beq.n	800418c <follow_path+0xf0>
 8004104:	2b5c      	cmp	r3, #92	; 0x5c
 8004106:	d041      	beq.n	800418c <follow_path+0xf0>
		if (c == '.' || i >= ni) {
 8004108:	2b2e      	cmp	r3, #46	; 0x2e
 800410a:	d025      	beq.n	8004158 <follow_path+0xbc>
 800410c:	45b8      	cmp	r8, r7
 800410e:	d91e      	bls.n	800414e <follow_path+0xb2>
		if (c >= 0x80) {				/* Extended char? */
 8004110:	0618      	lsls	r0, r3, #24
 8004112:	d435      	bmi.n	8004180 <follow_path+0xe4>
	while (*str && *str != chr) str++;
 8004114:	2b22      	cmp	r3, #34	; 0x22
 8004116:	d01a      	beq.n	800414e <follow_path+0xb2>
 8004118:	4da3      	ldr	r5, [pc, #652]	; (80043a8 <follow_path+0x30c>)
 800411a:	202a      	movs	r0, #42	; 0x2a
 800411c:	4283      	cmp	r3, r0
 800411e:	d016      	beq.n	800414e <follow_path+0xb2>
 8004120:	f815 0f01 	ldrb.w	r0, [r5, #1]!
 8004124:	2800      	cmp	r0, #0
 8004126:	d1f9      	bne.n	800411c <follow_path+0x80>
			if (IsUpper(c)) {			/* ASCII large capital? */
 8004128:	f1a3 0041 	sub.w	r0, r3, #65	; 0x41
 800412c:	2819      	cmp	r0, #25
 800412e:	d81e      	bhi.n	800416e <follow_path+0xd2>
				b |= 2;
 8004130:	f04c 0c02 	orr.w	ip, ip, #2
			sfn[i++] = c;
 8004134:	55d3      	strb	r3, [r2, r7]
		c = (BYTE)p[si++];
 8004136:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 800413a:	2b20      	cmp	r3, #32
			sfn[i++] = c;
 800413c:	f107 0701 	add.w	r7, r7, #1
		c = (BYTE)p[si++];
 8004140:	f104 0401 	add.w	r4, r4, #1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 8004144:	d8dc      	bhi.n	8004100 <follow_path+0x64>
	*path = &p[si];						/* Return pointer to the next segment */
 8004146:	190b      	adds	r3, r1, r4
 8004148:	469a      	mov	sl, r3
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 800414a:	2304      	movs	r3, #4
	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 800414c:	bb9f      	cbnz	r7, 80041b6 <follow_path+0x11a>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 800414e:	f04f 0b06 	mov.w	fp, #6
}
 8004152:	4658      	mov	r0, fp
 8004154:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 8004158:	f1b8 0f08 	cmp.w	r8, #8
 800415c:	d1f7      	bne.n	800414e <follow_path+0xb2>
			b <<= 2; continue;
 800415e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
			i = 8; ni = 11;
 8004162:	4647      	mov	r7, r8
			b <<= 2; continue;
 8004164:	fa5f fc8c 	uxtb.w	ip, ip
			i = 8; ni = 11;
 8004168:	f04f 080b 	mov.w	r8, #11
 800416c:	e7c2      	b.n	80040f4 <follow_path+0x58>
				if (IsLower(c)) {		/* ASCII small capital? */
 800416e:	f1a3 0061 	sub.w	r0, r3, #97	; 0x61
 8004172:	2819      	cmp	r0, #25
 8004174:	d8de      	bhi.n	8004134 <follow_path+0x98>
					b |= 1; c -= 0x20;
 8004176:	3b20      	subs	r3, #32
 8004178:	b2db      	uxtb	r3, r3
 800417a:	f04c 0c01 	orr.w	ip, ip, #1
 800417e:	e7d9      	b.n	8004134 <follow_path+0x98>
			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
 8004180:	3b80      	subs	r3, #128	; 0x80
 8004182:	488a      	ldr	r0, [pc, #552]	; (80043ac <follow_path+0x310>)
			b |= 3;						/* Eliminate NT flag */
 8004184:	f04c 0c03 	orr.w	ip, ip, #3
			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
 8004188:	5cc3      	ldrb	r3, [r0, r3]
 800418a:	e7c3      	b.n	8004114 <follow_path+0x78>
	*path = &p[si];						/* Return pointer to the next segment */
 800418c:	190b      	adds	r3, r1, r4
 800418e:	469a      	mov	sl, r3
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004190:	2300      	movs	r3, #0
	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 8004192:	2f00      	cmp	r7, #0
 8004194:	d0db      	beq.n	800414e <follow_path+0xb2>
 8004196:	e00e      	b.n	80041b6 <follow_path+0x11a>
		path++;
 8004198:	3401      	adds	r4, #1
	dj->sclust = 0;						/* Start from the root dir */
 800419a:	2500      	movs	r5, #0
 800419c:	60b5      	str	r5, [r6, #8]
	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
 800419e:	7823      	ldrb	r3, [r4, #0]
 80041a0:	2b1f      	cmp	r3, #31
 80041a2:	d889      	bhi.n	80040b8 <follow_path+0x1c>
		res = dir_sdi(dj, 0);
 80041a4:	4629      	mov	r1, r5
 80041a6:	4630      	mov	r0, r6
 80041a8:	f7ff f9fa 	bl	80035a0 <dir_sdi>
 80041ac:	4683      	mov	fp, r0
		dj->dir = 0;
 80041ae:	6175      	str	r5, [r6, #20]
}
 80041b0:	4658      	mov	r0, fp
 80041b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
 80041b6:	7811      	ldrb	r1, [r2, #0]
 80041b8:	29e5      	cmp	r1, #229	; 0xe5
 80041ba:	bf04      	itt	eq
 80041bc:	2105      	moveq	r1, #5
 80041be:	7011      	strbeq	r1, [r2, #0]
	if (ni == 8) b <<= 2;
 80041c0:	f1b8 0f08 	cmp.w	r8, #8
 80041c4:	bf04      	itt	eq
 80041c6:	ea4f 0c8c 	moveq.w	ip, ip, lsl #2
 80041ca:	fa5f fc8c 	uxtbeq.w	ip, ip
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 80041ce:	f00c 0103 	and.w	r1, ip, #3
 80041d2:	2901      	cmp	r1, #1
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 80041d4:	f00c 0c0c 	and.w	ip, ip, #12
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 80041d8:	bf08      	it	eq
 80041da:	f043 0310 	orreq.w	r3, r3, #16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 80041de:	f1bc 0f04 	cmp.w	ip, #4
 80041e2:	bf08      	it	eq
 80041e4:	f043 0308 	orreq.w	r3, r3, #8
	sfn[NS] = c;		/* Store NT flag, File name is created */
 80041e8:	72d3      	strb	r3, [r2, #11]
	res = dir_sdi(dj, 0);			/* Rewind directory object */
 80041ea:	2100      	movs	r1, #0
 80041ec:	4630      	mov	r0, r6
 80041ee:	f7ff f9d7 	bl	80035a0 <dir_sdi>
	if (res != FR_OK) return res;
 80041f2:	4683      	mov	fp, r0
 80041f4:	2800      	cmp	r0, #0
 80041f6:	f040 80d1 	bne.w	800439c <follow_path+0x300>
 80041fa:	6837      	ldr	r7, [r6, #0]
 80041fc:	6934      	ldr	r4, [r6, #16]
	if (sector != fs->winsect) {	/* Changed current window */
 80041fe:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 8004200:	42a5      	cmp	r5, r4
 8004202:	d00d      	beq.n	8004220 <follow_path+0x184>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004204:	793b      	ldrb	r3, [r7, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004206:	f107 0834 	add.w	r8, r7, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800420a:	2b00      	cmp	r3, #0
 800420c:	d15b      	bne.n	80042c6 <follow_path+0x22a>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800420e:	4641      	mov	r1, r8
 8004210:	2301      	movs	r3, #1
 8004212:	4622      	mov	r2, r4
 8004214:	7878      	ldrb	r0, [r7, #1]
 8004216:	f7fe fad1 	bl	80027bc <disk_read>
 800421a:	2800      	cmp	r0, #0
 800421c:	d140      	bne.n	80042a0 <follow_path+0x204>
		fs->winsect = sector;
 800421e:	633c      	str	r4, [r7, #48]	; 0x30
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 8004220:	6973      	ldr	r3, [r6, #20]
		c = dir[DIR_Name];
 8004222:	7819      	ldrb	r1, [r3, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004224:	2900      	cmp	r1, #0
 8004226:	d032      	beq.n	800428e <follow_path+0x1f2>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 8004228:	7ad8      	ldrb	r0, [r3, #11]
 800422a:	0702      	lsls	r2, r0, #28
 800422c:	d42b      	bmi.n	8004286 <follow_path+0x1ea>
 800422e:	69b2      	ldr	r2, [r6, #24]
	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8004230:	7814      	ldrb	r4, [r2, #0]
 8004232:	428c      	cmp	r4, r1
 8004234:	d127      	bne.n	8004286 <follow_path+0x1ea>
 8004236:	785c      	ldrb	r4, [r3, #1]
 8004238:	7851      	ldrb	r1, [r2, #1]
 800423a:	428c      	cmp	r4, r1
 800423c:	d123      	bne.n	8004286 <follow_path+0x1ea>
 800423e:	789c      	ldrb	r4, [r3, #2]
 8004240:	7891      	ldrb	r1, [r2, #2]
 8004242:	428c      	cmp	r4, r1
 8004244:	d11f      	bne.n	8004286 <follow_path+0x1ea>
 8004246:	78d4      	ldrb	r4, [r2, #3]
 8004248:	78d9      	ldrb	r1, [r3, #3]
 800424a:	428c      	cmp	r4, r1
 800424c:	d11b      	bne.n	8004286 <follow_path+0x1ea>
 800424e:	791c      	ldrb	r4, [r3, #4]
 8004250:	7911      	ldrb	r1, [r2, #4]
 8004252:	428c      	cmp	r4, r1
 8004254:	d117      	bne.n	8004286 <follow_path+0x1ea>
 8004256:	795c      	ldrb	r4, [r3, #5]
 8004258:	7951      	ldrb	r1, [r2, #5]
 800425a:	428c      	cmp	r4, r1
 800425c:	d113      	bne.n	8004286 <follow_path+0x1ea>
 800425e:	799c      	ldrb	r4, [r3, #6]
 8004260:	7991      	ldrb	r1, [r2, #6]
 8004262:	428c      	cmp	r4, r1
 8004264:	d10f      	bne.n	8004286 <follow_path+0x1ea>
 8004266:	79dc      	ldrb	r4, [r3, #7]
 8004268:	79d1      	ldrb	r1, [r2, #7]
 800426a:	428c      	cmp	r4, r1
 800426c:	d10b      	bne.n	8004286 <follow_path+0x1ea>
 800426e:	7a1c      	ldrb	r4, [r3, #8]
 8004270:	7a11      	ldrb	r1, [r2, #8]
 8004272:	428c      	cmp	r4, r1
 8004274:	d107      	bne.n	8004286 <follow_path+0x1ea>
 8004276:	7a5c      	ldrb	r4, [r3, #9]
 8004278:	7a51      	ldrb	r1, [r2, #9]
 800427a:	428c      	cmp	r4, r1
 800427c:	d103      	bne.n	8004286 <follow_path+0x1ea>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 800427e:	7a9c      	ldrb	r4, [r3, #10]
 8004280:	7a91      	ldrb	r1, [r2, #10]
 8004282:	428c      	cmp	r4, r1
 8004284:	d043      	beq.n	800430e <follow_path+0x272>
	i = dj->index + 1;
 8004286:	88f5      	ldrh	r5, [r6, #6]
 8004288:	3501      	adds	r5, #1
 800428a:	b2ad      	uxth	r5, r5
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 800428c:	b96d      	cbnz	r5, 80042aa <follow_path+0x20e>
			ns = *(dj->fn+NS);
 800428e:	69b3      	ldr	r3, [r6, #24]
 8004290:	7adb      	ldrb	r3, [r3, #11]
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
 8004292:	075c      	lsls	r4, r3, #29
 8004294:	d47f      	bmi.n	8004396 <follow_path+0x2fa>
 8004296:	f04f 0b05 	mov.w	fp, #5
}
 800429a:	4658      	mov	r0, fp
 800429c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (*str && *str != chr) str++;
 80042a0:	f04f 0b01 	mov.w	fp, #1
}
 80042a4:	4658      	mov	r0, fp
 80042a6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 80042aa:	6934      	ldr	r4, [r6, #16]
 80042ac:	2c00      	cmp	r4, #0
 80042ae:	d0ee      	beq.n	800428e <follow_path+0x1f2>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 80042b0:	f015 080f 	ands.w	r8, r5, #15
 80042b4:	d03b      	beq.n	800432e <follow_path+0x292>
 80042b6:	6837      	ldr	r7, [r6, #0]
	dj->index = i;
 80042b8:	80f5      	strh	r5, [r6, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 80042ba:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80042be:	eb03 1348 	add.w	r3, r3, r8, lsl #5
 80042c2:	6173      	str	r3, [r6, #20]
 80042c4:	e79b      	b.n	80041fe <follow_path+0x162>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80042c6:	4641      	mov	r1, r8
 80042c8:	2301      	movs	r3, #1
 80042ca:	462a      	mov	r2, r5
 80042cc:	7878      	ldrb	r0, [r7, #1]
 80042ce:	f7fe fa97 	bl	8002800 <disk_write>
 80042d2:	2800      	cmp	r0, #0
 80042d4:	d1e4      	bne.n	80042a0 <follow_path+0x204>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80042d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
		fs->wflag = 0;
 80042d8:	7138      	strb	r0, [r7, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80042da:	4295      	cmp	r5, r2
 80042dc:	d397      	bcc.n	800420e <follow_path+0x172>
 80042de:	69fb      	ldr	r3, [r7, #28]
 80042e0:	441a      	add	r2, r3
 80042e2:	4295      	cmp	r5, r2
 80042e4:	d293      	bcs.n	800420e <follow_path+0x172>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80042e6:	f897 9003 	ldrb.w	r9, [r7, #3]
 80042ea:	f1b9 0f01 	cmp.w	r9, #1
 80042ee:	d801      	bhi.n	80042f4 <follow_path+0x258>
 80042f0:	e78d      	b.n	800420e <follow_path+0x172>
 80042f2:	69fb      	ldr	r3, [r7, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80042f4:	7878      	ldrb	r0, [r7, #1]
				wsect += fs->fsize;
 80042f6:	441d      	add	r5, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80042f8:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80042fc:	462a      	mov	r2, r5
 80042fe:	2301      	movs	r3, #1
 8004300:	4641      	mov	r1, r8
 8004302:	f7fe fa7d 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004306:	f1b9 0f01 	cmp.w	r9, #1
 800430a:	d1f2      	bne.n	80042f2 <follow_path+0x256>
 800430c:	e77f      	b.n	800420e <follow_path+0x172>
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
 800430e:	7ad1      	ldrb	r1, [r2, #11]
 8004310:	0749      	lsls	r1, r1, #29
 8004312:	f53f af1e 	bmi.w	8004152 <follow_path+0xb6>
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
 8004316:	06c0      	lsls	r0, r0, #27
 8004318:	d5bd      	bpl.n	8004296 <follow_path+0x1fa>
	if (fs->fs_type == FS_FAT32)
 800431a:	6831      	ldr	r1, [r6, #0]
	cl = LD_WORD(dir+DIR_FstClusLO);
 800431c:	7edd      	ldrb	r5, [r3, #27]
	if (fs->fs_type == FS_FAT32)
 800431e:	7808      	ldrb	r0, [r1, #0]
	cl = LD_WORD(dir+DIR_FstClusLO);
 8004320:	7e99      	ldrb	r1, [r3, #26]
	if (fs->fs_type == FS_FAT32)
 8004322:	2803      	cmp	r0, #3
	cl = LD_WORD(dir+DIR_FstClusLO);
 8004324:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
	if (fs->fs_type == FS_FAT32)
 8004328:	d00a      	beq.n	8004340 <follow_path+0x2a4>
			dj->sclust = ld_clust(dj->fs, dir);
 800432a:	60b1      	str	r1, [r6, #8]
			res = create_name(dj, &path);	/* Get a segment */
 800432c:	e6c6      	b.n	80040bc <follow_path+0x20>
		if (dj->clust == 0) {	/* Static table */
 800432e:	68f1      	ldr	r1, [r6, #12]
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8004330:	6837      	ldr	r7, [r6, #0]
		dj->sect++;					/* Next sector */
 8004332:	3401      	adds	r4, #1
 8004334:	6134      	str	r4, [r6, #16]
		if (dj->clust == 0) {	/* Static table */
 8004336:	b951      	cbnz	r1, 800434e <follow_path+0x2b2>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8004338:	893b      	ldrh	r3, [r7, #8]
 800433a:	42ab      	cmp	r3, r5
 800433c:	d9a7      	bls.n	800428e <follow_path+0x1f2>
 800433e:	e7bb      	b.n	80042b8 <follow_path+0x21c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 8004340:	7d58      	ldrb	r0, [r3, #21]
 8004342:	7d1b      	ldrb	r3, [r3, #20]
 8004344:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8004348:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800434c:	e7ed      	b.n	800432a <follow_path+0x28e>
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 800434e:	78bb      	ldrb	r3, [r7, #2]
 8004350:	3b01      	subs	r3, #1
 8004352:	ea13 1315 	ands.w	r3, r3, r5, lsr #4
 8004356:	d1af      	bne.n	80042b8 <follow_path+0x21c>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8004358:	2901      	cmp	r1, #1
 800435a:	d902      	bls.n	8004362 <follow_path+0x2c6>
 800435c:	69bb      	ldr	r3, [r7, #24]
 800435e:	4299      	cmp	r1, r3
 8004360:	d302      	bcc.n	8004368 <follow_path+0x2cc>
	while (*str && *str != chr) str++;
 8004362:	f04f 0b02 	mov.w	fp, #2
 8004366:	e6f4      	b.n	8004152 <follow_path+0xb6>
 8004368:	4638      	mov	r0, r7
 800436a:	f7fe ffdf 	bl	800332c <get_fat.part.6>
				if (clst <= 1) return FR_INT_ERR;
 800436e:	2801      	cmp	r0, #1
 8004370:	d9f7      	bls.n	8004362 <follow_path+0x2c6>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8004372:	1c47      	adds	r7, r0, #1
 8004374:	d094      	beq.n	80042a0 <follow_path+0x204>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 8004376:	6837      	ldr	r7, [r6, #0]
 8004378:	69bb      	ldr	r3, [r7, #24]
 800437a:	4298      	cmp	r0, r3
 800437c:	d287      	bcs.n	800428e <follow_path+0x1f2>
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800437e:	3b02      	subs	r3, #2
	clst -= 2;
 8004380:	1e82      	subs	r2, r0, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8004382:	429a      	cmp	r2, r3
				dj->clust = clst;				/* Initialize data for new cluster */
 8004384:	60f0      	str	r0, [r6, #12]
	return clst * fs->csize + fs->database;
 8004386:	bf3b      	ittet	cc
 8004388:	78bc      	ldrbcc	r4, [r7, #2]
 800438a:	6afb      	ldrcc	r3, [r7, #44]	; 0x2c
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800438c:	2400      	movcs	r4, #0
	return clst * fs->csize + fs->database;
 800438e:	fb02 3404 	mlacc	r4, r2, r4, r3
				dj->sect = clust2sect(dj->fs, clst);
 8004392:	6134      	str	r4, [r6, #16]
 8004394:	e790      	b.n	80042b8 <follow_path+0x21c>
 8004396:	f04f 0b04 	mov.w	fp, #4
 800439a:	e6da      	b.n	8004152 <follow_path+0xb6>
			ns = *(dj->fn+NS);
 800439c:	69b3      	ldr	r3, [r6, #24]
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
 800439e:	2804      	cmp	r0, #4
			ns = *(dj->fn+NS);
 80043a0:	7adb      	ldrb	r3, [r3, #11]
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
 80043a2:	f47f aed6 	bne.w	8004152 <follow_path+0xb6>
 80043a6:	e774      	b.n	8004292 <follow_path+0x1f6>
 80043a8:	08017a99 	.word	0x08017a99
 80043ac:	08014650 	.word	0x08014650

080043b0 <dir_register>:
{
 80043b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dj, 0);
 80043b4:	2100      	movs	r1, #0
{
 80043b6:	b083      	sub	sp, #12
 80043b8:	4606      	mov	r6, r0
	res = dir_sdi(dj, 0);
 80043ba:	f7ff f8f1 	bl	80035a0 <dir_sdi>
	if (res == FR_OK) {
 80043be:	4607      	mov	r7, r0
 80043c0:	2800      	cmp	r0, #0
 80043c2:	d160      	bne.n	8004486 <dir_register+0xd6>
 80043c4:	6835      	ldr	r5, [r6, #0]
 80043c6:	f8d6 9010 	ldr.w	r9, [r6, #16]
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80043ca:	f04f 0801 	mov.w	r8, #1
	if (sector != fs->winsect) {	/* Changed current window */
 80043ce:	6b2c      	ldr	r4, [r5, #48]	; 0x30
 80043d0:	454c      	cmp	r4, r9
 80043d2:	d010      	beq.n	80043f6 <dir_register+0x46>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80043d4:	792b      	ldrb	r3, [r5, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80043d6:	f105 0a34 	add.w	sl, r5, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80043da:	2b00      	cmp	r3, #0
 80043dc:	f040 80a5 	bne.w	800452a <dir_register+0x17a>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80043e0:	4651      	mov	r1, sl
 80043e2:	2301      	movs	r3, #1
 80043e4:	464a      	mov	r2, r9
 80043e6:	7868      	ldrb	r0, [r5, #1]
 80043e8:	f7fe f9e8 	bl	80027bc <disk_read>
 80043ec:	2800      	cmp	r0, #0
 80043ee:	f040 8084 	bne.w	80044fa <dir_register+0x14a>
		fs->winsect = sector;
 80043f2:	f8c5 9030 	str.w	r9, [r5, #48]	; 0x30
			if (dj->dir[0] == DDE || dj->dir[0] == 0) {	/* Is it a blank entry? */
 80043f6:	6970      	ldr	r0, [r6, #20]
 80043f8:	7803      	ldrb	r3, [r0, #0]
 80043fa:	2be5      	cmp	r3, #229	; 0xe5
 80043fc:	d001      	beq.n	8004402 <dir_register+0x52>
 80043fe:	2b00      	cmp	r3, #0
 8004400:	d13b      	bne.n	800447a <dir_register+0xca>
		res = move_window(dj->fs, dj->sect);
 8004402:	6834      	ldr	r4, [r6, #0]
 8004404:	f8d6 8010 	ldr.w	r8, [r6, #16]
	if (sector != fs->winsect) {	/* Changed current window */
 8004408:	6b25      	ldr	r5, [r4, #48]	; 0x30
 800440a:	45a8      	cmp	r8, r5
 800440c:	d010      	beq.n	8004430 <dir_register+0x80>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800440e:	7923      	ldrb	r3, [r4, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004410:	f104 0934 	add.w	r9, r4, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004414:	2b00      	cmp	r3, #0
 8004416:	f040 80c2 	bne.w	800459e <dir_register+0x1ee>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800441a:	4649      	mov	r1, r9
 800441c:	2301      	movs	r3, #1
 800441e:	4642      	mov	r2, r8
 8004420:	7860      	ldrb	r0, [r4, #1]
 8004422:	f7fe f9cb 	bl	80027bc <disk_read>
 8004426:	2800      	cmp	r0, #0
 8004428:	d167      	bne.n	80044fa <dir_register+0x14a>
 800442a:	6970      	ldr	r0, [r6, #20]
		fs->winsect = sector;
 800442c:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
 8004430:	2220      	movs	r2, #32
 8004432:	2100      	movs	r1, #0
 8004434:	f010 f8e3 	bl	80145fe <memset>
			mem_cpy(dj->dir, dj->fn, 11);	/* Put SFN */
 8004438:	6971      	ldr	r1, [r6, #20]
 800443a:	69b0      	ldr	r0, [r6, #24]
 800443c:	f101 0308 	add.w	r3, r1, #8
 8004440:	f100 0208 	add.w	r2, r0, #8
 8004444:	4298      	cmp	r0, r3
 8004446:	bf38      	it	cc
 8004448:	4291      	cmpcc	r1, r2
 800444a:	f0c0 80ce 	bcc.w	80045ea <dir_register+0x23a>
 800444e:	ea40 0301 	orr.w	r3, r0, r1
 8004452:	075b      	lsls	r3, r3, #29
 8004454:	f040 80c9 	bne.w	80045ea <dir_register+0x23a>
		*d++ = *s++;
 8004458:	e9d0 2300 	ldrd	r2, r3, [r0]
 800445c:	e9c1 2300 	strd	r2, r3, [r1]
 8004460:	7a03      	ldrb	r3, [r0, #8]
 8004462:	720b      	strb	r3, [r1, #8]
 8004464:	7a43      	ldrb	r3, [r0, #9]
 8004466:	724b      	strb	r3, [r1, #9]
 8004468:	7a83      	ldrb	r3, [r0, #10]
 800446a:	728b      	strb	r3, [r1, #10]
			dj->fs->wflag = 1;
 800446c:	6833      	ldr	r3, [r6, #0]
 800446e:	2201      	movs	r2, #1
}
 8004470:	4638      	mov	r0, r7
			dj->fs->wflag = 1;
 8004472:	711a      	strb	r2, [r3, #4]
}
 8004474:	b003      	add	sp, #12
 8004476:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	i = dj->index + 1;
 800447a:	88f4      	ldrh	r4, [r6, #6]
 800447c:	3401      	adds	r4, #1
 800447e:	b2a4      	uxth	r4, r4
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8004480:	2c00      	cmp	r4, #0
 8004482:	d13f      	bne.n	8004504 <dir_register+0x154>
		return FR_NO_FILE;
 8004484:	2704      	movs	r7, #4
}
 8004486:	4638      	mov	r0, r7
 8004488:	b003      	add	sp, #12
 800448a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (clst == 1) return FR_INT_ERR;
 800448e:	2801      	cmp	r0, #1
 8004490:	f000 8083 	beq.w	800459a <dir_register+0x1ea>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8004494:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004498:	d02f      	beq.n	80044fa <dir_register+0x14a>
					if (sync_window(dj->fs)) return FR_DISK_ERR;	/* Flush active window */
 800449a:	6830      	ldr	r0, [r6, #0]
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800449c:	7903      	ldrb	r3, [r0, #4]
 800449e:	2b00      	cmp	r3, #0
 80044a0:	f040 80dd 	bne.w	800465e <dir_register+0x2ae>
 80044a4:	f44f 7200 	mov.w	r2, #512	; 0x200
 80044a8:	3034      	adds	r0, #52	; 0x34
 80044aa:	2100      	movs	r1, #0
 80044ac:	f010 f8a7 	bl	80145fe <memset>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 80044b0:	6835      	ldr	r5, [r6, #0]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80044b2:	69ab      	ldr	r3, [r5, #24]
 80044b4:	78aa      	ldrb	r2, [r5, #2]
 80044b6:	3b02      	subs	r3, #2
	clst -= 2;
 80044b8:	f1a9 0b02 	sub.w	fp, r9, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80044bc:	459b      	cmp	fp, r3
	return clst * fs->csize + fs->database;
 80044be:	bf36      	itet	cc
 80044c0:	6aeb      	ldrcc	r3, [r5, #44]	; 0x2c
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80044c2:	2300      	movcs	r3, #0
	return clst * fs->csize + fs->database;
 80044c4:	fb0b 3302 	mlacc	r3, fp, r2, r3
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 80044c8:	632b      	str	r3, [r5, #48]	; 0x30
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80044ca:	2a00      	cmp	r2, #0
 80044cc:	f000 80ce 	beq.w	800466c <dir_register+0x2bc>
 80044d0:	2200      	movs	r2, #0
 80044d2:	e007      	b.n	80044e4 <dir_register+0x134>
						dj->fs->winsect++;
 80044d4:	6835      	ldr	r5, [r6, #0]
 80044d6:	6b2b      	ldr	r3, [r5, #48]	; 0x30
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80044d8:	78a9      	ldrb	r1, [r5, #2]
						dj->fs->winsect++;
 80044da:	3301      	adds	r3, #1
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80044dc:	4291      	cmp	r1, r2
						dj->fs->winsect++;
 80044de:	632b      	str	r3, [r5, #48]	; 0x30
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80044e0:	f240 80c4 	bls.w	800466c <dir_register+0x2bc>
						dj->fs->wflag = 1;
 80044e4:	f885 8004 	strb.w	r8, [r5, #4]
 80044e8:	4628      	mov	r0, r5
 80044ea:	9201      	str	r2, [sp, #4]
 80044ec:	f7fe fa4e 	bl	800298c <sync_window.part.4>
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80044f0:	9a01      	ldr	r2, [sp, #4]
 80044f2:	3201      	adds	r2, #1
 80044f4:	b2d2      	uxtb	r2, r2
						if (sync_window(dj->fs)) return FR_DISK_ERR;
 80044f6:	2800      	cmp	r0, #0
 80044f8:	d0ec      	beq.n	80044d4 <dir_register+0x124>
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80044fa:	2701      	movs	r7, #1
}
 80044fc:	4638      	mov	r0, r7
 80044fe:	b003      	add	sp, #12
 8004500:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8004504:	f8d6 9010 	ldr.w	r9, [r6, #16]
 8004508:	f1b9 0f00 	cmp.w	r9, #0
 800450c:	d0ba      	beq.n	8004484 <dir_register+0xd4>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 800450e:	f014 0a0f 	ands.w	sl, r4, #15
 8004512:	d130      	bne.n	8004576 <dir_register+0x1c6>
		if (dj->clust == 0) {	/* Static table */
 8004514:	68f1      	ldr	r1, [r6, #12]
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8004516:	6835      	ldr	r5, [r6, #0]
		dj->sect++;					/* Next sector */
 8004518:	f109 0901 	add.w	r9, r9, #1
 800451c:	f8c6 9010 	str.w	r9, [r6, #16]
		if (dj->clust == 0) {	/* Static table */
 8004520:	bb89      	cbnz	r1, 8004586 <dir_register+0x1d6>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8004522:	892b      	ldrh	r3, [r5, #8]
 8004524:	42a3      	cmp	r3, r4
 8004526:	d9ad      	bls.n	8004484 <dir_register+0xd4>
 8004528:	e026      	b.n	8004578 <dir_register+0x1c8>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800452a:	4651      	mov	r1, sl
 800452c:	2301      	movs	r3, #1
 800452e:	4622      	mov	r2, r4
 8004530:	7868      	ldrb	r0, [r5, #1]
 8004532:	f7fe f965 	bl	8002800 <disk_write>
 8004536:	2800      	cmp	r0, #0
 8004538:	d1df      	bne.n	80044fa <dir_register+0x14a>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800453a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 800453c:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800453e:	4294      	cmp	r4, r2
 8004540:	f4ff af4e 	bcc.w	80043e0 <dir_register+0x30>
 8004544:	69eb      	ldr	r3, [r5, #28]
 8004546:	441a      	add	r2, r3
 8004548:	4294      	cmp	r4, r2
 800454a:	f4bf af49 	bcs.w	80043e0 <dir_register+0x30>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800454e:	f895 b003 	ldrb.w	fp, [r5, #3]
 8004552:	f1bb 0f01 	cmp.w	fp, #1
 8004556:	d801      	bhi.n	800455c <dir_register+0x1ac>
 8004558:	e742      	b.n	80043e0 <dir_register+0x30>
 800455a:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800455c:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 800455e:	441c      	add	r4, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004560:	f10b 3bff 	add.w	fp, fp, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8004564:	4622      	mov	r2, r4
 8004566:	2301      	movs	r3, #1
 8004568:	4651      	mov	r1, sl
 800456a:	f7fe f949 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800456e:	f1bb 0f01 	cmp.w	fp, #1
 8004572:	d1f2      	bne.n	800455a <dir_register+0x1aa>
 8004574:	e734      	b.n	80043e0 <dir_register+0x30>
 8004576:	6835      	ldr	r5, [r6, #0]
	dj->index = i;
 8004578:	80f4      	strh	r4, [r6, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 800457a:	f105 0334 	add.w	r3, r5, #52	; 0x34
 800457e:	eb03 134a 	add.w	r3, r3, sl, lsl #5
 8004582:	6173      	str	r3, [r6, #20]
 8004584:	e723      	b.n	80043ce <dir_register+0x1e>
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8004586:	78ab      	ldrb	r3, [r5, #2]
 8004588:	3b01      	subs	r3, #1
 800458a:	ea13 1314 	ands.w	r3, r3, r4, lsr #4
 800458e:	d1f3      	bne.n	8004578 <dir_register+0x1c8>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8004590:	2901      	cmp	r1, #1
 8004592:	d902      	bls.n	800459a <dir_register+0x1ea>
 8004594:	69ab      	ldr	r3, [r5, #24]
 8004596:	4299      	cmp	r1, r3
 8004598:	d338      	bcc.n	800460c <dir_register+0x25c>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800459a:	2702      	movs	r7, #2
 800459c:	e773      	b.n	8004486 <dir_register+0xd6>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800459e:	4649      	mov	r1, r9
 80045a0:	2301      	movs	r3, #1
 80045a2:	462a      	mov	r2, r5
 80045a4:	7860      	ldrb	r0, [r4, #1]
 80045a6:	f7fe f92b 	bl	8002800 <disk_write>
 80045aa:	2800      	cmp	r0, #0
 80045ac:	d1a5      	bne.n	80044fa <dir_register+0x14a>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80045ae:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 80045b0:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80045b2:	4295      	cmp	r5, r2
 80045b4:	f4ff af31 	bcc.w	800441a <dir_register+0x6a>
 80045b8:	69e3      	ldr	r3, [r4, #28]
 80045ba:	441a      	add	r2, r3
 80045bc:	4295      	cmp	r5, r2
 80045be:	f4bf af2c 	bcs.w	800441a <dir_register+0x6a>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80045c2:	f894 a003 	ldrb.w	sl, [r4, #3]
 80045c6:	f1ba 0f01 	cmp.w	sl, #1
 80045ca:	d801      	bhi.n	80045d0 <dir_register+0x220>
 80045cc:	e725      	b.n	800441a <dir_register+0x6a>
 80045ce:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80045d0:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80045d2:	441d      	add	r5, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80045d4:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80045d8:	462a      	mov	r2, r5
 80045da:	2301      	movs	r3, #1
 80045dc:	4649      	mov	r1, r9
 80045de:	f7fe f90f 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80045e2:	f1ba 0f01 	cmp.w	sl, #1
 80045e6:	d1f2      	bne.n	80045ce <dir_register+0x21e>
 80045e8:	e717      	b.n	800441a <dir_register+0x6a>
		*d++ = *s++;
 80045ea:	7803      	ldrb	r3, [r0, #0]
 80045ec:	700b      	strb	r3, [r1, #0]
 80045ee:	7843      	ldrb	r3, [r0, #1]
 80045f0:	704b      	strb	r3, [r1, #1]
 80045f2:	7883      	ldrb	r3, [r0, #2]
 80045f4:	708b      	strb	r3, [r1, #2]
 80045f6:	78c3      	ldrb	r3, [r0, #3]
 80045f8:	70cb      	strb	r3, [r1, #3]
 80045fa:	7903      	ldrb	r3, [r0, #4]
 80045fc:	710b      	strb	r3, [r1, #4]
 80045fe:	7943      	ldrb	r3, [r0, #5]
 8004600:	714b      	strb	r3, [r1, #5]
 8004602:	7983      	ldrb	r3, [r0, #6]
 8004604:	718b      	strb	r3, [r1, #6]
 8004606:	79c3      	ldrb	r3, [r0, #7]
 8004608:	71cb      	strb	r3, [r1, #7]
 800460a:	e729      	b.n	8004460 <dir_register+0xb0>
 800460c:	4628      	mov	r0, r5
 800460e:	f7fe fe8d 	bl	800332c <get_fat.part.6>
				if (clst <= 1) return FR_INT_ERR;
 8004612:	2801      	cmp	r0, #1
 8004614:	4681      	mov	r9, r0
 8004616:	d9c0      	bls.n	800459a <dir_register+0x1ea>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8004618:	f1b0 3fff 	cmp.w	r0, #4294967295
 800461c:	f43f af6d 	beq.w	80044fa <dir_register+0x14a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 8004620:	6835      	ldr	r5, [r6, #0]
 8004622:	69ab      	ldr	r3, [r5, #24]
 8004624:	4298      	cmp	r0, r3
 8004626:	d210      	bcs.n	800464a <dir_register+0x29a>
 8004628:	f1a0 0b02 	sub.w	fp, r0, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800462c:	3b02      	subs	r3, #2
 800462e:	455b      	cmp	r3, fp
				dj->clust = clst;				/* Initialize data for new cluster */
 8004630:	f8c6 900c 	str.w	r9, [r6, #12]
	return clst * fs->csize + fs->database;
 8004634:	bf85      	ittet	hi
 8004636:	f895 9002 	ldrbhi.w	r9, [r5, #2]
 800463a:	6aeb      	ldrhi	r3, [r5, #44]	; 0x2c
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800463c:	f04f 0900 	movls.w	r9, #0
	return clst * fs->csize + fs->database;
 8004640:	fb0b 3909 	mlahi	r9, fp, r9, r3
				dj->sect = clust2sect(dj->fs, clst);
 8004644:	f8c6 9010 	str.w	r9, [r6, #16]
 8004648:	e796      	b.n	8004578 <dir_register+0x1c8>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
 800464a:	4628      	mov	r0, r5
 800464c:	68f1      	ldr	r1, [r6, #12]
 800464e:	f7fe fffb 	bl	8003648 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8004652:	4681      	mov	r9, r0
 8004654:	2800      	cmp	r0, #0
 8004656:	f47f af1a 	bne.w	800448e <dir_register+0xde>
 800465a:	2707      	movs	r7, #7
	return res;
 800465c:	e713      	b.n	8004486 <dir_register+0xd6>
 800465e:	f7fe f995 	bl	800298c <sync_window.part.4>
					if (sync_window(dj->fs)) return FR_DISK_ERR;	/* Flush active window */
 8004662:	2800      	cmp	r0, #0
 8004664:	f47f af49 	bne.w	80044fa <dir_register+0x14a>
 8004668:	6830      	ldr	r0, [r6, #0]
 800466a:	e71b      	b.n	80044a4 <dir_register+0xf4>
					dj->fs->winsect -= c;						/* Rewind window address */
 800466c:	1a9a      	subs	r2, r3, r2
 800466e:	632a      	str	r2, [r5, #48]	; 0x30
 8004670:	69ab      	ldr	r3, [r5, #24]
 8004672:	e7db      	b.n	800462c <dir_register+0x27c>

08004674 <clust2sect>:
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8004674:	6983      	ldr	r3, [r0, #24]
	clst -= 2;
 8004676:	3902      	subs	r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8004678:	3b02      	subs	r3, #2
 800467a:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
 800467c:	bf3d      	ittte	cc
 800467e:	7883      	ldrbcc	r3, [r0, #2]
 8004680:	6ac0      	ldrcc	r0, [r0, #44]	; 0x2c
 8004682:	fb01 0003 	mlacc	r0, r1, r3, r0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8004686:	2000      	movcs	r0, #0
}
 8004688:	4770      	bx	lr
 800468a:	bf00      	nop

0800468c <get_fat>:
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 800468c:	2901      	cmp	r1, #1
 800468e:	d957      	bls.n	8004740 <get_fat+0xb4>
{
 8004690:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8004694:	6983      	ldr	r3, [r0, #24]
 8004696:	4299      	cmp	r1, r3
 8004698:	d20c      	bcs.n	80046b4 <get_fat+0x28>
	switch (fs->fs_type) {
 800469a:	7803      	ldrb	r3, [r0, #0]
 800469c:	2b02      	cmp	r3, #2
 800469e:	4604      	mov	r4, r0
 80046a0:	460d      	mov	r5, r1
 80046a2:	d07a      	beq.n	800479a <get_fat+0x10e>
 80046a4:	2b03      	cmp	r3, #3
 80046a6:	d04d      	beq.n	8004744 <get_fat+0xb8>
 80046a8:	2b01      	cmp	r3, #1
 80046aa:	d006      	beq.n	80046ba <get_fat+0x2e>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 80046ac:	f04f 30ff 	mov.w	r0, #4294967295
 80046b0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return 1;
 80046b4:	2001      	movs	r0, #1
 80046b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 80046ba:	6a42      	ldr	r2, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 80046bc:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
		bc = (UINT)clst; bc += bc / 2;
 80046c0:	eb01 0651 	add.w	r6, r1, r1, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 80046c4:	eb02 2956 	add.w	r9, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 80046c8:	45c1      	cmp	r9, r8
 80046ca:	d011      	beq.n	80046f0 <get_fat+0x64>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80046cc:	7902      	ldrb	r2, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80046ce:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80046d2:	2a00      	cmp	r2, #0
 80046d4:	f040 80cd 	bne.w	8004872 <get_fat+0x1e6>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80046d8:	4639      	mov	r1, r7
 80046da:	2301      	movs	r3, #1
 80046dc:	464a      	mov	r2, r9
 80046de:	7860      	ldrb	r0, [r4, #1]
 80046e0:	f7fe f86c 	bl	80027bc <disk_read>
 80046e4:	2800      	cmp	r0, #0
 80046e6:	d1e1      	bne.n	80046ac <get_fat+0x20>
 80046e8:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->winsect = sector;
 80046ea:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
 80046ee:	46c8      	mov	r8, r9
		wc = fs->win[bc % SS(fs)]; bc++;
 80046f0:	f3c6 0308 	ubfx	r3, r6, #0, #9
 80046f4:	f106 0a01 	add.w	sl, r6, #1
 80046f8:	4423      	add	r3, r4
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 80046fa:	eb02 295a 	add.w	r9, r2, sl, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 80046fe:	45c1      	cmp	r9, r8
		wc = fs->win[bc % SS(fs)]; bc++;
 8004700:	f893 6034 	ldrb.w	r6, [r3, #52]	; 0x34
	if (sector != fs->winsect) {	/* Changed current window */
 8004704:	d00f      	beq.n	8004726 <get_fat+0x9a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004706:	7923      	ldrb	r3, [r4, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004708:	f104 0734 	add.w	r7, r4, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800470c:	2b00      	cmp	r3, #0
 800470e:	f040 80d6 	bne.w	80048be <get_fat+0x232>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8004712:	4639      	mov	r1, r7
 8004714:	2301      	movs	r3, #1
 8004716:	464a      	mov	r2, r9
 8004718:	7860      	ldrb	r0, [r4, #1]
 800471a:	f7fe f84f 	bl	80027bc <disk_read>
 800471e:	2800      	cmp	r0, #0
 8004720:	d1c4      	bne.n	80046ac <get_fat+0x20>
		fs->winsect = sector;
 8004722:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
		wc |= fs->win[bc % SS(fs)] << 8;
 8004726:	f3ca 0a08 	ubfx	sl, sl, #0, #9
 800472a:	4454      	add	r4, sl
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800472c:	07eb      	lsls	r3, r5, #31
		wc |= fs->win[bc % SS(fs)] << 8;
 800472e:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 8004732:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8004736:	f140 80e9 	bpl.w	800490c <get_fat+0x280>
 800473a:	0900      	lsrs	r0, r0, #4
 800473c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return 1;
 8004740:	2001      	movs	r0, #1
 8004742:	4770      	bx	lr
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 8004744:	6a46      	ldr	r6, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8004746:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 800474a:	eb06 16d1 	add.w	r6, r6, r1, lsr #7
	if (sector != fs->winsect) {	/* Changed current window */
 800474e:	4546      	cmp	r6, r8
 8004750:	d00d      	beq.n	800476e <get_fat+0xe2>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004752:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004754:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004758:	2b00      	cmp	r3, #0
 800475a:	d140      	bne.n	80047de <get_fat+0x152>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800475c:	4639      	mov	r1, r7
 800475e:	2301      	movs	r3, #1
 8004760:	4632      	mov	r2, r6
 8004762:	7860      	ldrb	r0, [r4, #1]
 8004764:	f7fe f82a 	bl	80027bc <disk_read>
 8004768:	2800      	cmp	r0, #0
 800476a:	d19f      	bne.n	80046ac <get_fat+0x20>
		fs->winsect = sector;
 800476c:	6326      	str	r6, [r4, #48]	; 0x30
		p = &fs->win[clst * 4 % SS(fs)];
 800476e:	00a9      	lsls	r1, r5, #2
 8004770:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 8004774:	f101 0334 	add.w	r3, r1, #52	; 0x34
 8004778:	4423      	add	r3, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
 800477a:	440c      	add	r4, r1
 800477c:	7898      	ldrb	r0, [r3, #2]
 800477e:	78d9      	ldrb	r1, [r3, #3]
 8004780:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8004784:	785b      	ldrb	r3, [r3, #1]
 8004786:	0400      	lsls	r0, r0, #16
 8004788:	ea40 6001 	orr.w	r0, r0, r1, lsl #24
 800478c:	4310      	orrs	r0, r2
 800478e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8004792:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 8004796:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 800479a:	6a46      	ldr	r6, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 800479c:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 80047a0:	eb06 2611 	add.w	r6, r6, r1, lsr #8
	if (sector != fs->winsect) {	/* Changed current window */
 80047a4:	4546      	cmp	r6, r8
 80047a6:	d00e      	beq.n	80047c6 <get_fat+0x13a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80047a8:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80047aa:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80047ae:	2b00      	cmp	r3, #0
 80047b0:	d13a      	bne.n	8004828 <get_fat+0x19c>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80047b2:	4639      	mov	r1, r7
 80047b4:	2301      	movs	r3, #1
 80047b6:	4632      	mov	r2, r6
 80047b8:	7860      	ldrb	r0, [r4, #1]
 80047ba:	f7fd ffff 	bl	80027bc <disk_read>
 80047be:	2800      	cmp	r0, #0
 80047c0:	f47f af74 	bne.w	80046ac <get_fat+0x20>
		fs->winsect = sector;
 80047c4:	6326      	str	r6, [r4, #48]	; 0x30
		p = &fs->win[clst * 2 % SS(fs)];
 80047c6:	0069      	lsls	r1, r5, #1
 80047c8:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
		return LD_WORD(p);
 80047cc:	440c      	add	r4, r1
 80047ce:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 80047d2:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 80047d6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 80047da:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80047de:	4639      	mov	r1, r7
 80047e0:	2301      	movs	r3, #1
 80047e2:	4642      	mov	r2, r8
 80047e4:	7840      	ldrb	r0, [r0, #1]
 80047e6:	f7fe f80b 	bl	8002800 <disk_write>
 80047ea:	2800      	cmp	r0, #0
 80047ec:	f47f af5e 	bne.w	80046ac <get_fat+0x20>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80047f0:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 80047f2:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80047f4:	4590      	cmp	r8, r2
 80047f6:	d3b1      	bcc.n	800475c <get_fat+0xd0>
 80047f8:	69e3      	ldr	r3, [r4, #28]
 80047fa:	441a      	add	r2, r3
 80047fc:	4590      	cmp	r8, r2
 80047fe:	d2ad      	bcs.n	800475c <get_fat+0xd0>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004800:	f894 9003 	ldrb.w	r9, [r4, #3]
 8004804:	f1b9 0f01 	cmp.w	r9, #1
 8004808:	d801      	bhi.n	800480e <get_fat+0x182>
 800480a:	e7a7      	b.n	800475c <get_fat+0xd0>
 800480c:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 800480e:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 8004810:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004812:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8004816:	4642      	mov	r2, r8
 8004818:	2301      	movs	r3, #1
 800481a:	4639      	mov	r1, r7
 800481c:	f7fd fff0 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004820:	f1b9 0f01 	cmp.w	r9, #1
 8004824:	d1f2      	bne.n	800480c <get_fat+0x180>
 8004826:	e799      	b.n	800475c <get_fat+0xd0>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004828:	4639      	mov	r1, r7
 800482a:	2301      	movs	r3, #1
 800482c:	4642      	mov	r2, r8
 800482e:	7840      	ldrb	r0, [r0, #1]
 8004830:	f7fd ffe6 	bl	8002800 <disk_write>
 8004834:	2800      	cmp	r0, #0
 8004836:	f47f af39 	bne.w	80046ac <get_fat+0x20>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800483a:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 800483c:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800483e:	4590      	cmp	r8, r2
 8004840:	d3b7      	bcc.n	80047b2 <get_fat+0x126>
 8004842:	69e3      	ldr	r3, [r4, #28]
 8004844:	441a      	add	r2, r3
 8004846:	4590      	cmp	r8, r2
 8004848:	d2b3      	bcs.n	80047b2 <get_fat+0x126>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800484a:	f894 9003 	ldrb.w	r9, [r4, #3]
 800484e:	f1b9 0f01 	cmp.w	r9, #1
 8004852:	d801      	bhi.n	8004858 <get_fat+0x1cc>
 8004854:	e7ad      	b.n	80047b2 <get_fat+0x126>
 8004856:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8004858:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 800485a:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800485c:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8004860:	4642      	mov	r2, r8
 8004862:	2301      	movs	r3, #1
 8004864:	4639      	mov	r1, r7
 8004866:	f7fd ffcb 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800486a:	f1b9 0f01 	cmp.w	r9, #1
 800486e:	d1f2      	bne.n	8004856 <get_fat+0x1ca>
 8004870:	e79f      	b.n	80047b2 <get_fat+0x126>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004872:	4639      	mov	r1, r7
 8004874:	4642      	mov	r2, r8
 8004876:	7840      	ldrb	r0, [r0, #1]
 8004878:	f7fd ffc2 	bl	8002800 <disk_write>
 800487c:	2800      	cmp	r0, #0
 800487e:	f47f af15 	bne.w	80046ac <get_fat+0x20>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004882:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 8004884:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004886:	4590      	cmp	r8, r2
 8004888:	f4ff af26 	bcc.w	80046d8 <get_fat+0x4c>
 800488c:	69e3      	ldr	r3, [r4, #28]
 800488e:	441a      	add	r2, r3
 8004890:	4590      	cmp	r8, r2
 8004892:	f4bf af21 	bcs.w	80046d8 <get_fat+0x4c>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004896:	f894 a003 	ldrb.w	sl, [r4, #3]
 800489a:	f1ba 0f01 	cmp.w	sl, #1
 800489e:	d801      	bhi.n	80048a4 <get_fat+0x218>
 80048a0:	e71a      	b.n	80046d8 <get_fat+0x4c>
 80048a2:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80048a4:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80048a6:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80048a8:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80048ac:	4642      	mov	r2, r8
 80048ae:	2301      	movs	r3, #1
 80048b0:	4639      	mov	r1, r7
 80048b2:	f7fd ffa5 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80048b6:	f1ba 0f01 	cmp.w	sl, #1
 80048ba:	d1f2      	bne.n	80048a2 <get_fat+0x216>
 80048bc:	e70c      	b.n	80046d8 <get_fat+0x4c>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80048be:	4639      	mov	r1, r7
 80048c0:	2301      	movs	r3, #1
 80048c2:	4642      	mov	r2, r8
 80048c4:	7860      	ldrb	r0, [r4, #1]
 80048c6:	f7fd ff9b 	bl	8002800 <disk_write>
 80048ca:	2800      	cmp	r0, #0
 80048cc:	f47f aeee 	bne.w	80046ac <get_fat+0x20>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80048d0:	6a62      	ldr	r2, [r4, #36]	; 0x24
		fs->wflag = 0;
 80048d2:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80048d4:	4590      	cmp	r8, r2
 80048d6:	f4ff af1c 	bcc.w	8004712 <get_fat+0x86>
 80048da:	69e3      	ldr	r3, [r4, #28]
 80048dc:	441a      	add	r2, r3
 80048de:	4590      	cmp	r8, r2
 80048e0:	f4bf af17 	bcs.w	8004712 <get_fat+0x86>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80048e4:	f894 b003 	ldrb.w	fp, [r4, #3]
 80048e8:	f1bb 0f01 	cmp.w	fp, #1
 80048ec:	d801      	bhi.n	80048f2 <get_fat+0x266>
 80048ee:	e710      	b.n	8004712 <get_fat+0x86>
 80048f0:	69e3      	ldr	r3, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80048f2:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80048f4:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80048f6:	f10b 3bff 	add.w	fp, fp, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80048fa:	4642      	mov	r2, r8
 80048fc:	2301      	movs	r3, #1
 80048fe:	4639      	mov	r1, r7
 8004900:	f7fd ff7e 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004904:	f1bb 0f01 	cmp.w	fp, #1
 8004908:	d1f2      	bne.n	80048f0 <get_fat+0x264>
 800490a:	e702      	b.n	8004712 <get_fat+0x86>
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800490c:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8004910:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004914 <put_fat>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004914:	2901      	cmp	r1, #1
 8004916:	d907      	bls.n	8004928 <put_fat+0x14>
{
 8004918:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800491c:	6983      	ldr	r3, [r0, #24]
 800491e:	4299      	cmp	r1, r3
 8004920:	d304      	bcc.n	800492c <put_fat+0x18>
		res = FR_INT_ERR;
 8004922:	2002      	movs	r0, #2
	return res;
 8004924:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		res = FR_INT_ERR;
 8004928:	2002      	movs	r0, #2
 800492a:	4770      	bx	lr
		switch (fs->fs_type) {
 800492c:	7803      	ldrb	r3, [r0, #0]
 800492e:	2b02      	cmp	r3, #2
 8004930:	4616      	mov	r6, r2
 8004932:	4605      	mov	r5, r0
 8004934:	460c      	mov	r4, r1
 8004936:	d009      	beq.n	800494c <put_fat+0x38>
 8004938:	2b03      	cmp	r3, #3
 800493a:	f000 8097 	beq.w	8004a6c <put_fat+0x158>
 800493e:	2b01      	cmp	r3, #1
 8004940:	d028      	beq.n	8004994 <put_fat+0x80>
			res = FR_INT_ERR;
 8004942:	2002      	movs	r0, #2
		fs->wflag = 1;
 8004944:	2301      	movs	r3, #1
 8004946:	712b      	strb	r3, [r5, #4]
 8004948:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800494c:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 800494e:	f8d0 9030 	ldr.w	r9, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8004952:	eb03 2811 	add.w	r8, r3, r1, lsr #8
	if (sector != fs->winsect) {	/* Changed current window */
 8004956:	45c8      	cmp	r8, r9
 8004958:	d00e      	beq.n	8004978 <put_fat+0x64>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800495a:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800495c:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004960:	2b00      	cmp	r3, #0
 8004962:	f040 8112 	bne.w	8004b8a <put_fat+0x276>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8004966:	4639      	mov	r1, r7
 8004968:	2301      	movs	r3, #1
 800496a:	4642      	mov	r2, r8
 800496c:	7868      	ldrb	r0, [r5, #1]
 800496e:	f7fd ff25 	bl	80027bc <disk_read>
 8004972:	b968      	cbnz	r0, 8004990 <put_fat+0x7c>
		fs->winsect = sector;
 8004974:	f8c5 8030 	str.w	r8, [r5, #48]	; 0x30
			p = &fs->win[clst * 2 % SS(fs)];
 8004978:	0063      	lsls	r3, r4, #1
 800497a:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
 800497e:	442b      	add	r3, r5
 8004980:	f3c6 2207 	ubfx	r2, r6, #8, #8
 8004984:	f883 6034 	strb.w	r6, [r3, #52]	; 0x34
 8004988:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800498c:	2000      	movs	r0, #0
 800498e:	e7d9      	b.n	8004944 <put_fat+0x30>
			res = FR_INT_ERR;
 8004990:	2001      	movs	r0, #1
 8004992:	e7d7      	b.n	8004944 <put_fat+0x30>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8004994:	6a47      	ldr	r7, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8004996:	f8d0 8030 	ldr.w	r8, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 800499a:	eb01 0951 	add.w	r9, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800499e:	eb07 2a59 	add.w	sl, r7, r9, lsr #9
	if (sector != fs->winsect) {	/* Changed current window */
 80049a2:	45c2      	cmp	sl, r8
 80049a4:	d011      	beq.n	80049ca <put_fat+0xb6>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80049a6:	7902      	ldrb	r2, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80049a8:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80049ac:	2a00      	cmp	r2, #0
 80049ae:	f040 80a1 	bne.w	8004af4 <put_fat+0x1e0>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80049b2:	4639      	mov	r1, r7
 80049b4:	2301      	movs	r3, #1
 80049b6:	4652      	mov	r2, sl
 80049b8:	7868      	ldrb	r0, [r5, #1]
 80049ba:	f7fd feff 	bl	80027bc <disk_read>
 80049be:	2800      	cmp	r0, #0
 80049c0:	d1e6      	bne.n	8004990 <put_fat+0x7c>
 80049c2:	6a6f      	ldr	r7, [r5, #36]	; 0x24
		fs->winsect = sector;
 80049c4:	f8c5 a030 	str.w	sl, [r5, #48]	; 0x30
 80049c8:	46d0      	mov	r8, sl
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80049ca:	f014 0401 	ands.w	r4, r4, #1
			p = &fs->win[bc % SS(fs)];
 80049ce:	f3c9 0308 	ubfx	r3, r9, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80049d2:	d079      	beq.n	8004ac8 <put_fat+0x1b4>
 80049d4:	442b      	add	r3, r5
			bc++;
 80049d6:	f109 0901 	add.w	r9, r9, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80049da:	f893 1034 	ldrb.w	r1, [r3, #52]	; 0x34
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80049de:	eb07 2759 	add.w	r7, r7, r9, lsr #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80049e2:	f001 010f 	and.w	r1, r1, #15
 80049e6:	ea41 1206 	orr.w	r2, r1, r6, lsl #4
	if (sector != fs->winsect) {	/* Changed current window */
 80049ea:	4547      	cmp	r7, r8
			fs->wflag = 1;
 80049ec:	f04f 0101 	mov.w	r1, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80049f0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
			fs->wflag = 1;
 80049f4:	7129      	strb	r1, [r5, #4]
	if (sector != fs->winsect) {	/* Changed current window */
 80049f6:	f000 80ef 	beq.w	8004bd8 <put_fat+0x2c4>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80049fa:	f105 0b34 	add.w	fp, r5, #52	; 0x34
 80049fe:	4659      	mov	r1, fp
 8004a00:	2301      	movs	r3, #1
 8004a02:	4642      	mov	r2, r8
 8004a04:	7868      	ldrb	r0, [r5, #1]
 8004a06:	f7fd fefb 	bl	8002800 <disk_write>
 8004a0a:	2800      	cmp	r0, #0
 8004a0c:	d1c0      	bne.n	8004990 <put_fat+0x7c>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004a0e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 8004a10:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004a12:	4542      	cmp	r2, r8
 8004a14:	d816      	bhi.n	8004a44 <put_fat+0x130>
 8004a16:	69eb      	ldr	r3, [r5, #28]
 8004a18:	441a      	add	r2, r3
 8004a1a:	4542      	cmp	r2, r8
 8004a1c:	d912      	bls.n	8004a44 <put_fat+0x130>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004a1e:	f895 a003 	ldrb.w	sl, [r5, #3]
 8004a22:	f1ba 0f01 	cmp.w	sl, #1
 8004a26:	d801      	bhi.n	8004a2c <put_fat+0x118>
 8004a28:	e00c      	b.n	8004a44 <put_fat+0x130>
 8004a2a:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8004a2c:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 8004a2e:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004a30:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8004a34:	4642      	mov	r2, r8
 8004a36:	2301      	movs	r3, #1
 8004a38:	4659      	mov	r1, fp
 8004a3a:	f7fd fee1 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004a3e:	f1ba 0f01 	cmp.w	sl, #1
 8004a42:	d1f2      	bne.n	8004a2a <put_fat+0x116>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8004a44:	4659      	mov	r1, fp
 8004a46:	2301      	movs	r3, #1
 8004a48:	463a      	mov	r2, r7
 8004a4a:	7868      	ldrb	r0, [r5, #1]
 8004a4c:	f7fd feb6 	bl	80027bc <disk_read>
 8004a50:	2800      	cmp	r0, #0
 8004a52:	d19d      	bne.n	8004990 <put_fat+0x7c>
		fs->winsect = sector;
 8004a54:	632f      	str	r7, [r5, #48]	; 0x30
			p = &fs->win[bc % SS(fs)];
 8004a56:	f3c9 0308 	ubfx	r3, r9, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8004a5a:	2c00      	cmp	r4, #0
 8004a5c:	d041      	beq.n	8004ae2 <put_fat+0x1ce>
 8004a5e:	f3c6 1207 	ubfx	r2, r6, #4, #8
 8004a62:	442b      	add	r3, r5
 8004a64:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 8004a68:	2000      	movs	r0, #0
 8004a6a:	e76b      	b.n	8004944 <put_fat+0x30>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8004a6c:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Changed current window */
 8004a6e:	f8d0 9030 	ldr.w	r9, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8004a72:	eb03 18d1 	add.w	r8, r3, r1, lsr #7
	if (sector != fs->winsect) {	/* Changed current window */
 8004a76:	45c8      	cmp	r8, r9
 8004a78:	d00f      	beq.n	8004a9a <put_fat+0x186>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004a7a:	7903      	ldrb	r3, [r0, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004a7c:	f100 0734 	add.w	r7, r0, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004a80:	2b00      	cmp	r3, #0
 8004a82:	d15d      	bne.n	8004b40 <put_fat+0x22c>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8004a84:	4639      	mov	r1, r7
 8004a86:	2301      	movs	r3, #1
 8004a88:	4642      	mov	r2, r8
 8004a8a:	7868      	ldrb	r0, [r5, #1]
 8004a8c:	f7fd fe96 	bl	80027bc <disk_read>
 8004a90:	2800      	cmp	r0, #0
 8004a92:	f47f af7d 	bne.w	8004990 <put_fat+0x7c>
		fs->winsect = sector;
 8004a96:	f8c5 8030 	str.w	r8, [r5, #48]	; 0x30
			p = &fs->win[clst * 4 % SS(fs)];
 8004a9a:	00a1      	lsls	r1, r4, #2
 8004a9c:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 8004aa0:	f101 0334 	add.w	r3, r1, #52	; 0x34
 8004aa4:	442b      	add	r3, r5
			val |= LD_DWORD(p) & 0xF0000000;
 8004aa6:	4429      	add	r1, r5
 8004aa8:	78da      	ldrb	r2, [r3, #3]
 8004aaa:	0612      	lsls	r2, r2, #24
 8004aac:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8004ab0:	4332      	orrs	r2, r6
			ST_DWORD(p, val);
 8004ab2:	f3c2 2707 	ubfx	r7, r2, #8, #8
 8004ab6:	0c16      	lsrs	r6, r2, #16
 8004ab8:	0e14      	lsrs	r4, r2, #24
 8004aba:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
 8004abe:	2000      	movs	r0, #0
 8004ac0:	705f      	strb	r7, [r3, #1]
 8004ac2:	709e      	strb	r6, [r3, #2]
 8004ac4:	70dc      	strb	r4, [r3, #3]
 8004ac6:	e73d      	b.n	8004944 <put_fat+0x30>
			bc++;
 8004ac8:	f109 0901 	add.w	r9, r9, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8004acc:	442b      	add	r3, r5
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8004ace:	eb07 2759 	add.w	r7, r7, r9, lsr #9
			fs->wflag = 1;
 8004ad2:	2201      	movs	r2, #1
	if (sector != fs->winsect) {	/* Changed current window */
 8004ad4:	45b8      	cmp	r8, r7
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8004ad6:	f883 6034 	strb.w	r6, [r3, #52]	; 0x34
			fs->wflag = 1;
 8004ada:	712a      	strb	r2, [r5, #4]
	if (sector != fs->winsect) {	/* Changed current window */
 8004adc:	d18d      	bne.n	80049fa <put_fat+0xe6>
			p = &fs->win[bc % SS(fs)];
 8004ade:	f3c9 0308 	ubfx	r3, r9, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8004ae2:	442b      	add	r3, r5
 8004ae4:	f3c6 2603 	ubfx	r6, r6, #8, #4
 8004ae8:	f893 2034 	ldrb.w	r2, [r3, #52]	; 0x34
 8004aec:	f022 020f 	bic.w	r2, r2, #15
 8004af0:	4332      	orrs	r2, r6
 8004af2:	e7b7      	b.n	8004a64 <put_fat+0x150>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004af4:	4639      	mov	r1, r7
 8004af6:	4642      	mov	r2, r8
 8004af8:	7840      	ldrb	r0, [r0, #1]
 8004afa:	f7fd fe81 	bl	8002800 <disk_write>
 8004afe:	2800      	cmp	r0, #0
 8004b00:	f47f af46 	bne.w	8004990 <put_fat+0x7c>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004b04:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 8004b06:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004b08:	4590      	cmp	r8, r2
 8004b0a:	f4ff af52 	bcc.w	80049b2 <put_fat+0x9e>
 8004b0e:	69eb      	ldr	r3, [r5, #28]
 8004b10:	441a      	add	r2, r3
 8004b12:	4590      	cmp	r8, r2
 8004b14:	f4bf af4d 	bcs.w	80049b2 <put_fat+0x9e>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004b18:	f895 b003 	ldrb.w	fp, [r5, #3]
 8004b1c:	f1bb 0f01 	cmp.w	fp, #1
 8004b20:	d801      	bhi.n	8004b26 <put_fat+0x212>
 8004b22:	e746      	b.n	80049b2 <put_fat+0x9e>
 8004b24:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8004b26:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 8004b28:	4498      	add	r8, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004b2a:	f10b 3bff 	add.w	fp, fp, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8004b2e:	4642      	mov	r2, r8
 8004b30:	2301      	movs	r3, #1
 8004b32:	4639      	mov	r1, r7
 8004b34:	f7fd fe64 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004b38:	f1bb 0f01 	cmp.w	fp, #1
 8004b3c:	d1f2      	bne.n	8004b24 <put_fat+0x210>
 8004b3e:	e738      	b.n	80049b2 <put_fat+0x9e>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004b40:	4639      	mov	r1, r7
 8004b42:	2301      	movs	r3, #1
 8004b44:	464a      	mov	r2, r9
 8004b46:	7840      	ldrb	r0, [r0, #1]
 8004b48:	f7fd fe5a 	bl	8002800 <disk_write>
 8004b4c:	2800      	cmp	r0, #0
 8004b4e:	f47f af1f 	bne.w	8004990 <put_fat+0x7c>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004b52:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 8004b54:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004b56:	4591      	cmp	r9, r2
 8004b58:	d394      	bcc.n	8004a84 <put_fat+0x170>
 8004b5a:	69eb      	ldr	r3, [r5, #28]
 8004b5c:	441a      	add	r2, r3
 8004b5e:	4591      	cmp	r9, r2
 8004b60:	d290      	bcs.n	8004a84 <put_fat+0x170>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004b62:	f895 a003 	ldrb.w	sl, [r5, #3]
 8004b66:	f1ba 0f01 	cmp.w	sl, #1
 8004b6a:	d801      	bhi.n	8004b70 <put_fat+0x25c>
 8004b6c:	e78a      	b.n	8004a84 <put_fat+0x170>
 8004b6e:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8004b70:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 8004b72:	4499      	add	r9, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004b74:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8004b78:	464a      	mov	r2, r9
 8004b7a:	2301      	movs	r3, #1
 8004b7c:	4639      	mov	r1, r7
 8004b7e:	f7fd fe3f 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004b82:	f1ba 0f01 	cmp.w	sl, #1
 8004b86:	d1f2      	bne.n	8004b6e <put_fat+0x25a>
 8004b88:	e77c      	b.n	8004a84 <put_fat+0x170>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004b8a:	4639      	mov	r1, r7
 8004b8c:	2301      	movs	r3, #1
 8004b8e:	464a      	mov	r2, r9
 8004b90:	7840      	ldrb	r0, [r0, #1]
 8004b92:	f7fd fe35 	bl	8002800 <disk_write>
 8004b96:	2800      	cmp	r0, #0
 8004b98:	f47f aefa 	bne.w	8004990 <put_fat+0x7c>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004b9c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 8004b9e:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004ba0:	4591      	cmp	r9, r2
 8004ba2:	f4ff aee0 	bcc.w	8004966 <put_fat+0x52>
 8004ba6:	69eb      	ldr	r3, [r5, #28]
 8004ba8:	441a      	add	r2, r3
 8004baa:	4591      	cmp	r9, r2
 8004bac:	f4bf aedb 	bcs.w	8004966 <put_fat+0x52>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004bb0:	f895 a003 	ldrb.w	sl, [r5, #3]
 8004bb4:	f1ba 0f01 	cmp.w	sl, #1
 8004bb8:	d801      	bhi.n	8004bbe <put_fat+0x2aa>
 8004bba:	e6d4      	b.n	8004966 <put_fat+0x52>
 8004bbc:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8004bbe:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 8004bc0:	4499      	add	r9, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004bc2:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8004bc6:	464a      	mov	r2, r9
 8004bc8:	2301      	movs	r3, #1
 8004bca:	4639      	mov	r1, r7
 8004bcc:	f7fd fe18 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004bd0:	f1ba 0f01 	cmp.w	sl, #1
 8004bd4:	d1f2      	bne.n	8004bbc <put_fat+0x2a8>
 8004bd6:	e6c6      	b.n	8004966 <put_fat+0x52>
			p = &fs->win[bc % SS(fs)];
 8004bd8:	f3c9 0308 	ubfx	r3, r9, #0, #9
 8004bdc:	e73f      	b.n	8004a5e <put_fat+0x14a>
 8004bde:	bf00      	nop

08004be0 <f_mount>:
	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
 8004be0:	b108      	cbz	r0, 8004be6 <f_mount+0x6>
		return FR_INVALID_DRIVE;
 8004be2:	200b      	movs	r0, #11
}
 8004be4:	4770      	bx	lr
	rfs = FatFs[vol];			/* Get current fs object */
 8004be6:	4b05      	ldr	r3, [pc, #20]	; (8004bfc <f_mount+0x1c>)
 8004be8:	681a      	ldr	r2, [r3, #0]
	if (rfs) {
 8004bea:	b102      	cbz	r2, 8004bee <f_mount+0xe>
		rfs->fs_type = 0;		/* Clear old fs object */
 8004bec:	7010      	strb	r0, [r2, #0]
	if (fs) {
 8004bee:	b109      	cbz	r1, 8004bf4 <f_mount+0x14>
		fs->fs_type = 0;		/* Clear new fs object */
 8004bf0:	2200      	movs	r2, #0
 8004bf2:	700a      	strb	r2, [r1, #0]
	FatFs[vol] = fs;			/* Register new fs object */
 8004bf4:	6019      	str	r1, [r3, #0]
	return FR_OK;
 8004bf6:	2000      	movs	r0, #0
 8004bf8:	4770      	bx	lr
 8004bfa:	bf00      	nop
 8004bfc:	20002128 	.word	0x20002128

08004c00 <f_open>:
	if (!fp) return FR_INVALID_OBJECT;
 8004c00:	b378      	cbz	r0, 8004c62 <f_open+0x62>
{
 8004c02:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	fp->fs = 0;			/* Clear file object */
 8004c06:	2300      	movs	r3, #0
 8004c08:	6003      	str	r3, [r0, #0]
	vol = p[0] - '0';					/* Is there a drive number? */
 8004c0a:	780b      	ldrb	r3, [r1, #0]
 8004c0c:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8004c0e:	2b09      	cmp	r3, #9
{
 8004c10:	b08d      	sub	sp, #52	; 0x34
 8004c12:	460d      	mov	r5, r1
 8004c14:	4616      	mov	r6, r2
 8004c16:	4604      	mov	r4, r0
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8004c18:	d919      	bls.n	8004c4e <f_open+0x4e>
	fs = FatFs[vol];					/* Get corresponding file system object */
 8004c1a:	f8df 836c 	ldr.w	r8, [pc, #876]	; 8004f88 <f_open+0x388>
 8004c1e:	f8d8 7000 	ldr.w	r7, [r8]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8004c22:	2f00      	cmp	r7, #0
 8004c24:	f000 8151 	beq.w	8004eca <f_open+0x2ca>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
 8004c28:	9705      	str	r7, [sp, #20]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8004c2a:	783b      	ldrb	r3, [r7, #0]
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
 8004c2c:	f006 091e 	and.w	r9, r6, #30
	if (fs->fs_type) {					/* If the volume has been mounted */
 8004c30:	b1cb      	cbz	r3, 8004c66 <f_open+0x66>
		stat = disk_status(fs->drv);
 8004c32:	7878      	ldrb	r0, [r7, #1]
 8004c34:	f7fd fda8 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 8004c38:	07c3      	lsls	r3, r0, #31
 8004c3a:	d414      	bmi.n	8004c66 <f_open+0x66>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8004c3c:	f1b9 0f00 	cmp.w	r9, #0
 8004c40:	f000 80f3 	beq.w	8004e2a <f_open+0x22a>
 8004c44:	0740      	lsls	r0, r0, #29
 8004c46:	f140 80f0 	bpl.w	8004e2a <f_open+0x22a>
				return FR_WRITE_PROTECTED;
 8004c4a:	200a      	movs	r0, #10
 8004c4c:	e006      	b.n	8004c5c <f_open+0x5c>
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8004c4e:	784a      	ldrb	r2, [r1, #1]
 8004c50:	2a3a      	cmp	r2, #58	; 0x3a
 8004c52:	d1e2      	bne.n	8004c1a <f_open+0x1a>
		return FR_INVALID_DRIVE;
 8004c54:	200b      	movs	r0, #11
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 8004c56:	2b00      	cmp	r3, #0
 8004c58:	f000 81e0 	beq.w	800501c <f_open+0x41c>
}
 8004c5c:	b00d      	add	sp, #52	; 0x34
 8004c5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!fp) return FR_INVALID_OBJECT;
 8004c62:	2009      	movs	r0, #9
 8004c64:	4770      	bx	lr
	fs->fs_type = 0;					/* Clear the file system object */
 8004c66:	2000      	movs	r0, #0
 8004c68:	7038      	strb	r0, [r7, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8004c6a:	7078      	strb	r0, [r7, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8004c6c:	f7fd fd72 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8004c70:	07c1      	lsls	r1, r0, #31
 8004c72:	f140 8133 	bpl.w	8004edc <f_open+0x2dc>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8004c76:	2003      	movs	r0, #3
 8004c78:	e7f0      	b.n	8004c5c <f_open+0x5c>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8004c7a:	f8d7 306a 	ldr.w	r3, [r7, #106]	; 0x6a
 8004c7e:	4ac0      	ldr	r2, [pc, #768]	; (8004f80 <f_open+0x380>)
 8004c80:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004c84:	4293      	cmp	r3, r2
 8004c86:	f000 81c7 	beq.w	8005018 <f_open+0x418>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8004c8a:	f8d7 3086 	ldr.w	r3, [r7, #134]	; 0x86
 8004c8e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004c92:	4293      	cmp	r3, r2
 8004c94:	f000 81c0 	beq.w	8005018 <f_open+0x418>
		if (tbl[4]) {						/* Is the partition existing? */
 8004c98:	f897 31f6 	ldrb.w	r3, [r7, #502]	; 0x1f6
 8004c9c:	2b00      	cmp	r3, #0
 8004c9e:	f000 8166 	beq.w	8004f6e <f_open+0x36e>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 8004ca2:	f8d7 91fa 	ldr.w	r9, [r7, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8004ca6:	7878      	ldrb	r0, [r7, #1]
 8004ca8:	464a      	mov	r2, r9
 8004caa:	2301      	movs	r3, #1
 8004cac:	4651      	mov	r1, sl
 8004cae:	f7fd fd85 	bl	80027bc <disk_read>
 8004cb2:	2800      	cmp	r0, #0
 8004cb4:	f040 8121 	bne.w	8004efa <f_open+0x2fa>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8004cb8:	f897 2233 	ldrb.w	r2, [r7, #563]	; 0x233
 8004cbc:	f897 3232 	ldrb.w	r3, [r7, #562]	; 0x232
 8004cc0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004cc4:	b21b      	sxth	r3, r3
 8004cc6:	455b      	cmp	r3, fp
 8004cc8:	f040 8151 	bne.w	8004f6e <f_open+0x36e>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8004ccc:	f8d7 306a 	ldr.w	r3, [r7, #106]	; 0x6a
 8004cd0:	4aab      	ldr	r2, [pc, #684]	; (8004f80 <f_open+0x380>)
 8004cd2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004cd6:	4293      	cmp	r3, r2
 8004cd8:	d006      	beq.n	8004ce8 <f_open+0xe8>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8004cda:	f8d7 3086 	ldr.w	r3, [r7, #134]	; 0x86
 8004cde:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8004ce2:	4293      	cmp	r3, r2
 8004ce4:	f040 8143 	bne.w	8004f6e <f_open+0x36e>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8004ce8:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8004cec:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8004cf0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004cf4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004cf8:	f040 8139 	bne.w	8004f6e <f_open+0x36e>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8004cfc:	f897 004b 	ldrb.w	r0, [r7, #75]	; 0x4b
 8004d00:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 8004d04:	f897 c044 	ldrb.w	ip, [r7, #68]	; 0x44
 8004d08:	f887 c003 	strb.w	ip, [r7, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8004d0c:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8004d10:	bf18      	it	ne
 8004d12:	4618      	movne	r0, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8004d14:	f10c 33ff 	add.w	r3, ip, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8004d18:	bf08      	it	eq
 8004d1a:	6db8      	ldreq	r0, [r7, #88]	; 0x58
	fs->fsize = fasize;
 8004d1c:	61f8      	str	r0, [r7, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8004d1e:	2b01      	cmp	r3, #1
 8004d20:	f200 8125 	bhi.w	8004f6e <f_open+0x36e>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 8004d24:	f897 b041 	ldrb.w	fp, [r7, #65]	; 0x41
 8004d28:	f887 b002 	strb.w	fp, [r7, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8004d2c:	f1bb 0f00 	cmp.w	fp, #0
 8004d30:	f000 811d 	beq.w	8004f6e <f_open+0x36e>
 8004d34:	f10b 33ff 	add.w	r3, fp, #4294967295
 8004d38:	ea13 0f0b 	tst.w	r3, fp
 8004d3c:	f040 8117 	bne.w	8004f6e <f_open+0x36e>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8004d40:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 8004d44:	f897 e045 	ldrb.w	lr, [r7, #69]	; 0x45
 8004d48:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8004d4c:	f01e 0f0f 	tst.w	lr, #15
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8004d50:	f8a7 e008 	strh.w	lr, [r7, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8004d54:	f040 810b 	bne.w	8004f6e <f_open+0x36e>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8004d58:	f897 2048 	ldrb.w	r2, [r7, #72]	; 0x48
 8004d5c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8004d60:	f897 1043 	ldrb.w	r1, [r7, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8004d64:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8004d68:	f897 2042 	ldrb.w	r2, [r7, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8004d6c:	bf08      	it	eq
 8004d6e:	6d7b      	ldreq	r3, [r7, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 8004d70:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8004d74:	f000 80fb 	beq.w	8004f6e <f_open+0x36e>
	fasize *= b;										/* Number of sectors for FAT area */
 8004d78:	fb00 fc0c 	mul.w	ip, r0, ip
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8004d7c:	eb02 111e 	add.w	r1, r2, lr, lsr #4
 8004d80:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8004d82:	4299      	cmp	r1, r3
 8004d84:	f200 80f3 	bhi.w	8004f6e <f_open+0x36e>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8004d88:	1a5b      	subs	r3, r3, r1
 8004d8a:	fbb3 f3fb 	udiv	r3, r3, fp
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8004d8e:	2b00      	cmp	r3, #0
 8004d90:	f000 80ed 	beq.w	8004f6e <f_open+0x36e>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8004d94:	f640 7bf5 	movw	fp, #4085	; 0xff5
 8004d98:	455b      	cmp	r3, fp
 8004d9a:	f240 8173 	bls.w	8005084 <f_open+0x484>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8004d9e:	f64f 7bf5 	movw	fp, #65525	; 0xfff5
 8004da2:	455b      	cmp	r3, fp
 8004da4:	f240 8153 	bls.w	800504e <f_open+0x44e>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004da8:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8004daa:	444a      	add	r2, r9
	fs->database = bsect + sysect;						/* Data start sector */
 8004dac:	4449      	add	r1, r9
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004dae:	61bb      	str	r3, [r7, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8004db0:	627a      	str	r2, [r7, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8004db2:	62f9      	str	r1, [r7, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8004db4:	f8c7 9020 	str.w	r9, [r7, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8004db8:	f1be 0f00 	cmp.w	lr, #0
 8004dbc:	f040 80d7 	bne.w	8004f6e <f_open+0x36e>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 8004dc0:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8004dc2:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8004dc6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8004dc8:	62ba      	str	r2, [r7, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8004dca:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 8004dce:	f0c0 80ce 	bcc.w	8004f6e <f_open+0x36e>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8004dd2:	f897 3065 	ldrb.w	r3, [r7, #101]	; 0x65
 8004dd6:	f897 2064 	ldrb.w	r2, [r7, #100]	; 0x64
	fs->last_clust = 0;
 8004dda:	f8c7 e00c 	str.w	lr, [r7, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8004dde:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8004de2:	444a      	add	r2, r9
	fs->free_clust = 0xFFFFFFFF;
 8004de4:	f04f 33ff 	mov.w	r3, #4294967295
 8004de8:	613b      	str	r3, [r7, #16]
	 	fs->fsi_flag = 0;
 8004dea:	f887 e005 	strb.w	lr, [r7, #5]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8004dee:	4651      	mov	r1, sl
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8004df0:	617a      	str	r2, [r7, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8004df2:	2301      	movs	r3, #1
 8004df4:	7878      	ldrb	r0, [r7, #1]
 8004df6:	f7fd fce1 	bl	80027bc <disk_read>
 8004dfa:	b950      	cbnz	r0, 8004e12 <f_open+0x212>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8004dfc:	f897 2233 	ldrb.w	r2, [r7, #563]	; 0x233
 8004e00:	f897 3232 	ldrb.w	r3, [r7, #562]	; 0x232
 8004e04:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8004e08:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8004e0c:	4293      	cmp	r3, r2
 8004e0e:	f000 8107 	beq.w	8005020 <f_open+0x420>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8004e12:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 8004e14:	f8b8 2004 	ldrh.w	r2, [r8, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 8004e18:	703b      	strb	r3, [r7, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8004e1a:	1c53      	adds	r3, r2, #1
 8004e1c:	b29b      	uxth	r3, r3
	fs->winsect = 0;		/* Invalidate sector cache */
 8004e1e:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* File system mount ID */
 8004e20:	f8a8 3004 	strh.w	r3, [r8, #4]
 8004e24:	80fb      	strh	r3, [r7, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 8004e26:	633a      	str	r2, [r7, #48]	; 0x30
	fs->wflag = 0;
 8004e28:	713a      	strb	r2, [r7, #4]
		res = follow_path(&dj, path);	/* Follow the file path */
 8004e2a:	4629      	mov	r1, r5
		INIT_BUF(dj);
 8004e2c:	ab02      	add	r3, sp, #8
		res = follow_path(&dj, path);	/* Follow the file path */
 8004e2e:	a805      	add	r0, sp, #20
		INIT_BUF(dj);
 8004e30:	930b      	str	r3, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
 8004e32:	f7ff f933 	bl	800409c <follow_path>
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 8004e36:	f006 071f 	and.w	r7, r6, #31
		dir = dj.dir;
 8004e3a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
		if (res == FR_OK) {
 8004e3c:	b960      	cbnz	r0, 8004e58 <f_open+0x258>
			if (!dir)	/* Current dir itself */
 8004e3e:	2d00      	cmp	r5, #0
 8004e40:	d05f      	beq.n	8004f02 <f_open+0x302>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8004e42:	f016 0f1c 	tst.w	r6, #28
 8004e46:	d031      	beq.n	8004eac <f_open+0x2ac>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8004e48:	7aeb      	ldrb	r3, [r5, #11]
 8004e4a:	f013 0f11 	tst.w	r3, #17
 8004e4e:	d134      	bne.n	8004eba <f_open+0x2ba>
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 8004e50:	0773      	lsls	r3, r6, #29
 8004e52:	d511      	bpl.n	8004e78 <f_open+0x278>
						res = FR_EXIST;
 8004e54:	2008      	movs	r0, #8
 8004e56:	e701      	b.n	8004c5c <f_open+0x5c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8004e58:	f016 0f1c 	tst.w	r6, #28
 8004e5c:	f43f aefe 	beq.w	8004c5c <f_open+0x5c>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 8004e60:	2804      	cmp	r0, #4
 8004e62:	f47f aefb 	bne.w	8004c5c <f_open+0x5c>
					res = dir_register(&dj);
 8004e66:	a805      	add	r0, sp, #20
 8004e68:	f7ff faa2 	bl	80043b0 <dir_register>
 8004e6c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8004e6e:	2800      	cmp	r0, #0
 8004e70:	f47f aef4 	bne.w	8004c5c <f_open+0x5c>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 8004e74:	f047 0708 	orr.w	r7, r7, #8
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8004e78:	073e      	lsls	r6, r7, #28
 8004e7a:	d444      	bmi.n	8004f06 <f_open+0x306>
 8004e7c:	9e05      	ldr	r6, [sp, #20]
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
 8004e7e:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8004e80:	61e3      	str	r3, [r4, #28]
			fp->dir_ptr = dir;
 8004e82:	6225      	str	r5, [r4, #32]
			fp->flag = mode;					/* File access mode */
 8004e84:	71a7      	strb	r7, [r4, #6]
	if (fs->fs_type == FS_FAT32)
 8004e86:	7832      	ldrb	r2, [r6, #0]
	cl = LD_WORD(dir+DIR_FstClusLO);
 8004e88:	7ee9      	ldrb	r1, [r5, #27]
 8004e8a:	7eab      	ldrb	r3, [r5, #26]
	if (fs->fs_type == FS_FAT32)
 8004e8c:	2a03      	cmp	r2, #3
	cl = LD_WORD(dir+DIR_FstClusLO);
 8004e8e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (fs->fs_type == FS_FAT32)
 8004e92:	d01c      	beq.n	8004ece <f_open+0x2ce>
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8004e94:	6123      	str	r3, [r4, #16]
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 8004e96:	69ea      	ldr	r2, [r5, #28]
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 8004e98:	88f3      	ldrh	r3, [r6, #6]
 8004e9a:	80a3      	strh	r3, [r4, #4]
			fp->fptr = 0;						/* File pointer */
 8004e9c:	2000      	movs	r0, #0
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 8004e9e:	60e2      	str	r2, [r4, #12]
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 8004ea0:	6026      	str	r6, [r4, #0]
			fp->fptr = 0;						/* File pointer */
 8004ea2:	60a0      	str	r0, [r4, #8]
			fp->dsect = 0;
 8004ea4:	61a0      	str	r0, [r4, #24]
}
 8004ea6:	b00d      	add	sp, #52	; 0x34
 8004ea8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
 8004eac:	7aeb      	ldrb	r3, [r5, #11]
 8004eae:	06d8      	lsls	r0, r3, #27
 8004eb0:	d425      	bmi.n	8004efe <f_open+0x2fe>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 8004eb2:	07b1      	lsls	r1, r6, #30
 8004eb4:	d503      	bpl.n	8004ebe <f_open+0x2be>
 8004eb6:	07da      	lsls	r2, r3, #31
 8004eb8:	d501      	bpl.n	8004ebe <f_open+0x2be>
					res = FR_DENIED;
 8004eba:	2007      	movs	r0, #7
 8004ebc:	e6ce      	b.n	8004c5c <f_open+0x5c>
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
 8004ebe:	0733      	lsls	r3, r6, #28
 8004ec0:	d5dc      	bpl.n	8004e7c <f_open+0x27c>
 8004ec2:	9e05      	ldr	r6, [sp, #20]
				mode |= FA__WRITTEN;
 8004ec4:	f047 0720 	orr.w	r7, r7, #32
 8004ec8:	e7d9      	b.n	8004e7e <f_open+0x27e>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8004eca:	200c      	movs	r0, #12
 8004ecc:	e6c6      	b.n	8004c5c <f_open+0x5c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 8004ece:	7d69      	ldrb	r1, [r5, #21]
 8004ed0:	7d2a      	ldrb	r2, [r5, #20]
 8004ed2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8004ed6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8004eda:	e7db      	b.n	8004e94 <f_open+0x294>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8004edc:	f1b9 0f00 	cmp.w	r9, #0
 8004ee0:	d002      	beq.n	8004ee8 <f_open+0x2e8>
 8004ee2:	0742      	lsls	r2, r0, #29
 8004ee4:	f53f aeb1 	bmi.w	8004c4a <f_open+0x4a>
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8004ee8:	f107 0a34 	add.w	sl, r7, #52	; 0x34
 8004eec:	4651      	mov	r1, sl
 8004eee:	2301      	movs	r3, #1
 8004ef0:	2200      	movs	r2, #0
 8004ef2:	7878      	ldrb	r0, [r7, #1]
 8004ef4:	f7fd fc62 	bl	80027bc <disk_read>
 8004ef8:	b368      	cbz	r0, 8004f56 <f_open+0x356>
			return FR_DISK_ERR;
 8004efa:	2001      	movs	r0, #1
 8004efc:	e6ae      	b.n	8004c5c <f_open+0x5c>
					res = FR_NO_FILE;
 8004efe:	2004      	movs	r0, #4
 8004f00:	e6ac      	b.n	8004c5c <f_open+0x5c>
				res = FR_INVALID_NAME;
 8004f02:	2006      	movs	r0, #6
 8004f04:	e6aa      	b.n	8004c5c <f_open+0x5c>
				dw = get_fattime();					/* Created time */
 8004f06:	f7fd fc9d 	bl	8002844 <get_fattime>
				dir[DIR_Attr] = 0;					/* Reset attribute */
 8004f0a:	2300      	movs	r3, #0
				ST_DWORD(dir+DIR_CrtTime, dw);
 8004f0c:	0c01      	lsrs	r1, r0, #16
 8004f0e:	0e02      	lsrs	r2, r0, #24
 8004f10:	f3c0 2e07 	ubfx	lr, r0, #8, #8
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
 8004f14:	9e05      	ldr	r6, [sp, #20]
				ST_DWORD(dir+DIR_CrtTime, dw);
 8004f16:	7429      	strb	r1, [r5, #16]
 8004f18:	746a      	strb	r2, [r5, #17]
 8004f1a:	73a8      	strb	r0, [r5, #14]
 8004f1c:	f885 e00f 	strb.w	lr, [r5, #15]
				dir[DIR_Attr] = 0;					/* Reset attribute */
 8004f20:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
 8004f22:	61eb      	str	r3, [r5, #28]
	if (fs->fs_type == FS_FAT32)
 8004f24:	7833      	ldrb	r3, [r6, #0]
	cl = LD_WORD(dir+DIR_FstClusLO);
 8004f26:	7ee9      	ldrb	r1, [r5, #27]
 8004f28:	7eaa      	ldrb	r2, [r5, #26]
	if (fs->fs_type == FS_FAT32)
 8004f2a:	2b03      	cmp	r3, #3
	cl = LD_WORD(dir+DIR_FstClusLO);
 8004f2c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	if (fs->fs_type == FS_FAT32)
 8004f30:	d01f      	beq.n	8004f72 <f_open+0x372>
	ST_WORD(dir+DIR_FstClusLO, cl);
 8004f32:	2100      	movs	r1, #0
				dj.fs->wflag = 1;
 8004f34:	f04f 0801 	mov.w	r8, #1
	ST_WORD(dir+DIR_FstClusLO, cl);
 8004f38:	76a9      	strb	r1, [r5, #26]
 8004f3a:	76e9      	strb	r1, [r5, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8004f3c:	7529      	strb	r1, [r5, #20]
 8004f3e:	7569      	strb	r1, [r5, #21]
				dj.fs->wflag = 1;
 8004f40:	f886 8004 	strb.w	r8, [r6, #4]
				if (cl) {							/* Remove the cluster chain if exist */
 8004f44:	2a00      	cmp	r2, #0
 8004f46:	d0bd      	beq.n	8004ec4 <f_open+0x2c4>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004f48:	4542      	cmp	r2, r8
 8004f4a:	d002      	beq.n	8004f52 <f_open+0x352>
 8004f4c:	69b3      	ldr	r3, [r6, #24]
 8004f4e:	429a      	cmp	r2, r3
 8004f50:	d31c      	bcc.n	8004f8c <f_open+0x38c>
 8004f52:	2002      	movs	r0, #2
 8004f54:	e682      	b.n	8004c5c <f_open+0x5c>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8004f56:	f897 2233 	ldrb.w	r2, [r7, #563]	; 0x233
 8004f5a:	f897 b232 	ldrb.w	fp, [r7, #562]	; 0x232
 8004f5e:	4b09      	ldr	r3, [pc, #36]	; (8004f84 <f_open+0x384>)
 8004f60:	ea4b 2b02 	orr.w	fp, fp, r2, lsl #8
 8004f64:	fa0f fb8b 	sxth.w	fp, fp
 8004f68:	459b      	cmp	fp, r3
 8004f6a:	f43f ae86 	beq.w	8004c7a <f_open+0x7a>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8004f6e:	200d      	movs	r0, #13
 8004f70:	e674      	b.n	8004c5c <f_open+0x5c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 8004f72:	7d69      	ldrb	r1, [r5, #21]
 8004f74:	7d2b      	ldrb	r3, [r5, #20]
 8004f76:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8004f7a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8004f7e:	e7d8      	b.n	8004f32 <f_open+0x332>
 8004f80:	00544146 	.word	0x00544146
 8004f84:	ffffaa55 	.word	0xffffaa55
 8004f88:	20002128 	.word	0x20002128
 8004f8c:	4611      	mov	r1, r2
 8004f8e:	4630      	mov	r0, r6
 8004f90:	9201      	str	r2, [sp, #4]
					dw = dj.fs->winsect;
 8004f92:	f8d6 9030 	ldr.w	r9, [r6, #48]	; 0x30
 8004f96:	f7fe f871 	bl	800307c <remove_chain.part.10>
					if (res == FR_OK) {
 8004f9a:	2800      	cmp	r0, #0
 8004f9c:	f47f ae5e 	bne.w	8004c5c <f_open+0x5c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8004fa0:	9e05      	ldr	r6, [sp, #20]
 8004fa2:	9a01      	ldr	r2, [sp, #4]
	if (sector != fs->winsect) {	/* Changed current window */
 8004fa4:	f8d6 a030 	ldr.w	sl, [r6, #48]	; 0x30
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8004fa8:	3a01      	subs	r2, #1
	if (sector != fs->winsect) {	/* Changed current window */
 8004faa:	45d1      	cmp	r9, sl
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8004fac:	60f2      	str	r2, [r6, #12]
	if (sector != fs->winsect) {	/* Changed current window */
 8004fae:	d089      	beq.n	8004ec4 <f_open+0x2c4>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004fb0:	7933      	ldrb	r3, [r6, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004fb2:	f106 0b34 	add.w	fp, r6, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004fb6:	b95b      	cbnz	r3, 8004fd0 <f_open+0x3d0>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8004fb8:	4659      	mov	r1, fp
 8004fba:	2301      	movs	r3, #1
 8004fbc:	464a      	mov	r2, r9
 8004fbe:	7870      	ldrb	r0, [r6, #1]
 8004fc0:	f7fd fbfc 	bl	80027bc <disk_read>
 8004fc4:	2800      	cmp	r0, #0
 8004fc6:	d198      	bne.n	8004efa <f_open+0x2fa>
		fs->winsect = sector;
 8004fc8:	f8c6 9030 	str.w	r9, [r6, #48]	; 0x30
 8004fcc:	9e05      	ldr	r6, [sp, #20]
 8004fce:	e779      	b.n	8004ec4 <f_open+0x2c4>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8004fd0:	4643      	mov	r3, r8
 8004fd2:	4659      	mov	r1, fp
 8004fd4:	4652      	mov	r2, sl
 8004fd6:	7870      	ldrb	r0, [r6, #1]
 8004fd8:	f7fd fc12 	bl	8002800 <disk_write>
 8004fdc:	2800      	cmp	r0, #0
 8004fde:	d18c      	bne.n	8004efa <f_open+0x2fa>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004fe0:	6a73      	ldr	r3, [r6, #36]	; 0x24
		fs->wflag = 0;
 8004fe2:	7130      	strb	r0, [r6, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8004fe4:	459a      	cmp	sl, r3
 8004fe6:	d3e7      	bcc.n	8004fb8 <f_open+0x3b8>
 8004fe8:	69f2      	ldr	r2, [r6, #28]
 8004fea:	4413      	add	r3, r2
 8004fec:	459a      	cmp	sl, r3
 8004fee:	d2e3      	bcs.n	8004fb8 <f_open+0x3b8>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004ff0:	f896 8003 	ldrb.w	r8, [r6, #3]
 8004ff4:	f1b8 0f01 	cmp.w	r8, #1
 8004ff8:	d801      	bhi.n	8004ffe <f_open+0x3fe>
 8004ffa:	e7dd      	b.n	8004fb8 <f_open+0x3b8>
 8004ffc:	69f2      	ldr	r2, [r6, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8004ffe:	7870      	ldrb	r0, [r6, #1]
				wsect += fs->fsize;
 8005000:	4492      	add	sl, r2
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8005002:	f108 38ff 	add.w	r8, r8, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 8005006:	4652      	mov	r2, sl
 8005008:	2301      	movs	r3, #1
 800500a:	4659      	mov	r1, fp
 800500c:	f7fd fbf8 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8005010:	f1b8 0f01 	cmp.w	r8, #1
 8005014:	d1f2      	bne.n	8004ffc <f_open+0x3fc>
 8005016:	e7cf      	b.n	8004fb8 <f_open+0x3b8>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 8005018:	4681      	mov	r9, r0
 800501a:	e665      	b.n	8004ce8 <f_open+0xe8>
		p += 2; *path = p;				/* Return pointer to the path name */
 800501c:	3502      	adds	r5, #2
 800501e:	e5fc      	b.n	8004c1a <f_open+0x1a>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8005020:	4b29      	ldr	r3, [pc, #164]	; (80050c8 <f_open+0x4c8>)
 8005022:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8005024:	429a      	cmp	r2, r3
 8005026:	f47f aef4 	bne.w	8004e12 <f_open+0x212>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 800502a:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 800502e:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8005032:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 8005036:	3320      	adds	r3, #32
 8005038:	429a      	cmp	r2, r3
 800503a:	f47f aeea 	bne.w	8004e12 <f_open+0x212>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800503e:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8005042:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8005046:	613b      	str	r3, [r7, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8005048:	60fa      	str	r2, [r7, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800504a:	2303      	movs	r3, #3
 800504c:	e6e2      	b.n	8004e14 <f_open+0x214>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800504e:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005050:	444a      	add	r2, r9
	fs->database = bsect + sysect;						/* Data start sector */
 8005052:	4449      	add	r1, r9
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005054:	61bb      	str	r3, [r7, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005056:	627a      	str	r2, [r7, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8005058:	62f9      	str	r1, [r7, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 800505a:	f8c7 9020 	str.w	r9, [r7, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800505e:	f1be 0f00 	cmp.w	lr, #0
 8005062:	d084      	beq.n	8004f6e <f_open+0x36e>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005064:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005066:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800506a:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800506c:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005070:	62ba      	str	r2, [r7, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005072:	f4ff af7c 	bcc.w	8004f6e <f_open+0x36e>
	fs->last_clust = 0;
 8005076:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8005078:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 800507c:	60fb      	str	r3, [r7, #12]
	fs->free_clust = 0xFFFFFFFF;
 800507e:	613a      	str	r2, [r7, #16]
	fs->last_clust = 0;
 8005080:	2302      	movs	r3, #2
 8005082:	e6c7      	b.n	8004e14 <f_open+0x214>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005084:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005086:	444a      	add	r2, r9
	fs->database = bsect + sysect;						/* Data start sector */
 8005088:	4449      	add	r1, r9
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800508a:	61bb      	str	r3, [r7, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800508c:	627a      	str	r2, [r7, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 800508e:	62f9      	str	r1, [r7, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8005090:	f8c7 9020 	str.w	r9, [r7, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8005094:	f1be 0f00 	cmp.w	lr, #0
 8005098:	f43f af69 	beq.w	8004f6e <f_open+0x36e>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800509c:	f003 0101 	and.w	r1, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80050a0:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 80050a4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80050a8:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 80050ac:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80050ae:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 80050b2:	62ba      	str	r2, [r7, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80050b4:	f4ff af5b 	bcc.w	8004f6e <f_open+0x36e>
	fs->last_clust = 0;
 80050b8:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 80050ba:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 80050be:	60fb      	str	r3, [r7, #12]
	fs->free_clust = 0xFFFFFFFF;
 80050c0:	613a      	str	r2, [r7, #16]
	fs->last_clust = 0;
 80050c2:	2301      	movs	r3, #1
 80050c4:	e6a6      	b.n	8004e14 <f_open+0x214>
 80050c6:	bf00      	nop
 80050c8:	41615252 	.word	0x41615252

080050cc <f_read>:
{
 80050cc:	b570      	push	{r4, r5, r6, lr}
	*br = 0;	/* Clear read byte counter */
 80050ce:	2400      	movs	r4, #0
{
 80050d0:	b084      	sub	sp, #16
	*br = 0;	/* Clear read byte counter */
 80050d2:	601c      	str	r4, [r3, #0]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80050d4:	b118      	cbz	r0, 80050de <f_read+0x12>
 80050d6:	6805      	ldr	r5, [r0, #0]
 80050d8:	b10d      	cbz	r5, 80050de <f_read+0x12>
 80050da:	782c      	ldrb	r4, [r5, #0]
 80050dc:	b914      	cbnz	r4, 80050e4 <f_read+0x18>
		return FR_INVALID_OBJECT;
 80050de:	2009      	movs	r0, #9
}
 80050e0:	b004      	add	sp, #16
 80050e2:	bd70      	pop	{r4, r5, r6, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80050e4:	88ee      	ldrh	r6, [r5, #6]
 80050e6:	8884      	ldrh	r4, [r0, #4]
 80050e8:	42a6      	cmp	r6, r4
 80050ea:	d1f8      	bne.n	80050de <f_read+0x12>
 80050ec:	4604      	mov	r4, r0
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 80050ee:	7868      	ldrb	r0, [r5, #1]
 80050f0:	9203      	str	r2, [sp, #12]
 80050f2:	9102      	str	r1, [sp, #8]
 80050f4:	9301      	str	r3, [sp, #4]
 80050f6:	f7fd fb47 	bl	8002788 <disk_status>
 80050fa:	f010 0f01 	tst.w	r0, #1
 80050fe:	9b01      	ldr	r3, [sp, #4]
 8005100:	9902      	ldr	r1, [sp, #8]
 8005102:	9a03      	ldr	r2, [sp, #12]
 8005104:	d001      	beq.n	800510a <f_read+0x3e>
		return FR_NOT_READY;
 8005106:	2003      	movs	r0, #3
 8005108:	e7ea      	b.n	80050e0 <f_read+0x14>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
 800510a:	79a0      	ldrb	r0, [r4, #6]
 800510c:	0605      	lsls	r5, r0, #24
 800510e:	d404      	bmi.n	800511a <f_read+0x4e>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 8005110:	07c6      	lsls	r6, r0, #31
 8005112:	d405      	bmi.n	8005120 <f_read+0x54>
		LEAVE_FF(fp->fs, FR_DENIED);
 8005114:	2007      	movs	r0, #7
}
 8005116:	b004      	add	sp, #16
 8005118:	bd70      	pop	{r4, r5, r6, pc}
		LEAVE_FF(fp->fs, FR_INT_ERR);
 800511a:	2002      	movs	r0, #2
}
 800511c:	b004      	add	sp, #16
 800511e:	bd70      	pop	{r4, r5, r6, pc}
 8005120:	4620      	mov	r0, r4
 8005122:	b004      	add	sp, #16
 8005124:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8005128:	f7fe be0c 	b.w	8003d44 <f_read.part.11>

0800512c <f_write>:
{
 800512c:	b570      	push	{r4, r5, r6, lr}
	*bw = 0;	/* Clear write byte counter */
 800512e:	2400      	movs	r4, #0
{
 8005130:	b084      	sub	sp, #16
	*bw = 0;	/* Clear write byte counter */
 8005132:	601c      	str	r4, [r3, #0]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8005134:	b118      	cbz	r0, 800513e <f_write+0x12>
 8005136:	6805      	ldr	r5, [r0, #0]
 8005138:	b10d      	cbz	r5, 800513e <f_write+0x12>
 800513a:	782c      	ldrb	r4, [r5, #0]
 800513c:	b914      	cbnz	r4, 8005144 <f_write+0x18>
		return FR_INVALID_OBJECT;
 800513e:	2009      	movs	r0, #9
}
 8005140:	b004      	add	sp, #16
 8005142:	bd70      	pop	{r4, r5, r6, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8005144:	88ee      	ldrh	r6, [r5, #6]
 8005146:	8884      	ldrh	r4, [r0, #4]
 8005148:	42a6      	cmp	r6, r4
 800514a:	d1f8      	bne.n	800513e <f_write+0x12>
 800514c:	4604      	mov	r4, r0
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 800514e:	7868      	ldrb	r0, [r5, #1]
 8005150:	9203      	str	r2, [sp, #12]
 8005152:	9102      	str	r1, [sp, #8]
 8005154:	9301      	str	r3, [sp, #4]
 8005156:	f7fd fb17 	bl	8002788 <disk_status>
 800515a:	f010 0f01 	tst.w	r0, #1
 800515e:	9b01      	ldr	r3, [sp, #4]
 8005160:	9902      	ldr	r1, [sp, #8]
 8005162:	9a03      	ldr	r2, [sp, #12]
 8005164:	d001      	beq.n	800516a <f_write+0x3e>
		return FR_NOT_READY;
 8005166:	2003      	movs	r0, #3
 8005168:	e7ea      	b.n	8005140 <f_write+0x14>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 800516a:	79a0      	ldrb	r0, [r4, #6]
 800516c:	0605      	lsls	r5, r0, #24
 800516e:	d404      	bmi.n	800517a <f_write+0x4e>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8005170:	0786      	lsls	r6, r0, #30
 8005172:	d405      	bmi.n	8005180 <f_write+0x54>
		LEAVE_FF(fp->fs, FR_DENIED);
 8005174:	2007      	movs	r0, #7
}
 8005176:	b004      	add	sp, #16
 8005178:	bd70      	pop	{r4, r5, r6, pc}
		LEAVE_FF(fp->fs, FR_INT_ERR);
 800517a:	2002      	movs	r0, #2
}
 800517c:	b004      	add	sp, #16
 800517e:	bd70      	pop	{r4, r5, r6, pc}
 8005180:	4620      	mov	r0, r4
 8005182:	b004      	add	sp, #16
 8005184:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8005188:	f7fe bbf6 	b.w	8003978 <f_write.part.12>

0800518c <f_sync>:
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 800518c:	b140      	cbz	r0, 80051a0 <f_sync+0x14>
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
 800518e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8005192:	6803      	ldr	r3, [r0, #0]
 8005194:	b10b      	cbz	r3, 800519a <f_sync+0xe>
 8005196:	781a      	ldrb	r2, [r3, #0]
 8005198:	b922      	cbnz	r2, 80051a4 <f_sync+0x18>
		return FR_INVALID_OBJECT;
 800519a:	2009      	movs	r0, #9
 800519c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80051a0:	2009      	movs	r0, #9
 80051a2:	4770      	bx	lr
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80051a4:	88d9      	ldrh	r1, [r3, #6]
 80051a6:	8882      	ldrh	r2, [r0, #4]
 80051a8:	4291      	cmp	r1, r2
 80051aa:	d1f6      	bne.n	800519a <f_sync+0xe>
 80051ac:	4604      	mov	r4, r0
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 80051ae:	7858      	ldrb	r0, [r3, #1]
 80051b0:	f7fd faea 	bl	8002788 <disk_status>
 80051b4:	07c2      	lsls	r2, r0, #31
 80051b6:	d502      	bpl.n	80051be <f_sync+0x32>
		return FR_NOT_READY;
 80051b8:	2003      	movs	r0, #3
 80051ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 80051be:	79a3      	ldrb	r3, [r4, #6]
 80051c0:	f013 0020 	ands.w	r0, r3, #32
 80051c4:	d051      	beq.n	800526a <f_sync+0xde>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
 80051c6:	065b      	lsls	r3, r3, #25
 80051c8:	d50d      	bpl.n	80051e6 <f_sync+0x5a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 80051ca:	6823      	ldr	r3, [r4, #0]
 80051cc:	69a2      	ldr	r2, [r4, #24]
 80051ce:	7858      	ldrb	r0, [r3, #1]
 80051d0:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80051d4:	2301      	movs	r3, #1
 80051d6:	f7fd fb13 	bl	8002800 <disk_write>
 80051da:	2800      	cmp	r0, #0
 80051dc:	d147      	bne.n	800526e <f_sync+0xe2>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 80051de:	79a3      	ldrb	r3, [r4, #6]
 80051e0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80051e4:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 80051e6:	6825      	ldr	r5, [r4, #0]
 80051e8:	69e7      	ldr	r7, [r4, #28]
	if (sector != fs->winsect) {	/* Changed current window */
 80051ea:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 80051ec:	42b7      	cmp	r7, r6
 80051ee:	d00c      	beq.n	800520a <f_sync+0x7e>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80051f0:	792b      	ldrb	r3, [r5, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80051f2:	f105 0834 	add.w	r8, r5, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80051f6:	2b00      	cmp	r3, #0
 80051f8:	d13c      	bne.n	8005274 <f_sync+0xe8>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80051fa:	4641      	mov	r1, r8
 80051fc:	2301      	movs	r3, #1
 80051fe:	463a      	mov	r2, r7
 8005200:	7868      	ldrb	r0, [r5, #1]
 8005202:	f7fd fadb 	bl	80027bc <disk_read>
 8005206:	bb90      	cbnz	r0, 800526e <f_sync+0xe2>
		fs->winsect = sector;
 8005208:	632f      	str	r7, [r5, #48]	; 0x30
			if (res == FR_OK) {
				dir = fp->dir_ptr;
 800520a:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 800520c:	7aeb      	ldrb	r3, [r5, #11]
 800520e:	f043 0320 	orr.w	r3, r3, #32
 8005212:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 8005214:	68e3      	ldr	r3, [r4, #12]
 8005216:	772b      	strb	r3, [r5, #28]
 8005218:	89a3      	ldrh	r3, [r4, #12]
 800521a:	0a1b      	lsrs	r3, r3, #8
 800521c:	776b      	strb	r3, [r5, #29]
 800521e:	89e3      	ldrh	r3, [r4, #14]
 8005220:	77ab      	strb	r3, [r5, #30]
 8005222:	7be3      	ldrb	r3, [r4, #15]
 8005224:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
 8005226:	6923      	ldr	r3, [r4, #16]
	ST_WORD(dir+DIR_FstClusLO, cl);
 8005228:	76ab      	strb	r3, [r5, #26]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800522a:	0c1a      	lsrs	r2, r3, #16
 800522c:	0a11      	lsrs	r1, r2, #8
	ST_WORD(dir+DIR_FstClusLO, cl);
 800522e:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8005232:	76eb      	strb	r3, [r5, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8005234:	752a      	strb	r2, [r5, #20]
 8005236:	7569      	strb	r1, [r5, #21]
				tm = get_fattime();							/* Update updated time */
 8005238:	f7fd fb04 	bl	8002844 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
 800523c:	2300      	movs	r3, #0
				ST_DWORD(dir+DIR_WrtTime, tm);
 800523e:	f3c0 2607 	ubfx	r6, r0, #8, #8
 8005242:	0c01      	lsrs	r1, r0, #16
 8005244:	0e02      	lsrs	r2, r0, #24
 8005246:	75a8      	strb	r0, [r5, #22]
 8005248:	7629      	strb	r1, [r5, #24]
 800524a:	75ee      	strb	r6, [r5, #23]
 800524c:	766a      	strb	r2, [r5, #25]
				ST_WORD(dir+DIR_LstAccDate, 0);
 800524e:	74ab      	strb	r3, [r5, #18]
 8005250:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
 8005252:	79a3      	ldrb	r3, [r4, #6]
				fp->fs->wflag = 1;
 8005254:	6822      	ldr	r2, [r4, #0]
				fp->flag &= ~FA__WRITTEN;
 8005256:	f023 0320 	bic.w	r3, r3, #32
				fp->fs->wflag = 1;
 800525a:	2101      	movs	r1, #1
				fp->flag &= ~FA__WRITTEN;
 800525c:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
 800525e:	7111      	strb	r1, [r2, #4]
				res = sync_fs(fp->fs);
 8005260:	4610      	mov	r0, r2
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 8005262:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
				res = sync_fs(fp->fs);
 8005266:	f7fd bd33 	b.w	8002cd0 <sync_fs>
 800526a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 800526e:	2001      	movs	r0, #1
 8005270:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8005274:	4641      	mov	r1, r8
 8005276:	2301      	movs	r3, #1
 8005278:	4632      	mov	r2, r6
 800527a:	7868      	ldrb	r0, [r5, #1]
 800527c:	f7fd fac0 	bl	8002800 <disk_write>
 8005280:	2800      	cmp	r0, #0
 8005282:	d1f4      	bne.n	800526e <f_sync+0xe2>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8005284:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 8005286:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8005288:	4296      	cmp	r6, r2
 800528a:	d3b6      	bcc.n	80051fa <f_sync+0x6e>
 800528c:	69eb      	ldr	r3, [r5, #28]
 800528e:	441a      	add	r2, r3
 8005290:	4296      	cmp	r6, r2
 8005292:	d2b2      	bcs.n	80051fa <f_sync+0x6e>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8005294:	f895 9003 	ldrb.w	r9, [r5, #3]
 8005298:	f1b9 0f01 	cmp.w	r9, #1
 800529c:	d801      	bhi.n	80052a2 <f_sync+0x116>
 800529e:	e7ac      	b.n	80051fa <f_sync+0x6e>
 80052a0:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80052a2:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 80052a4:	441e      	add	r6, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80052a6:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80052aa:	4632      	mov	r2, r6
 80052ac:	2301      	movs	r3, #1
 80052ae:	4641      	mov	r1, r8
 80052b0:	f7fd faa6 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80052b4:	f1b9 0f01 	cmp.w	r9, #1
 80052b8:	d1f2      	bne.n	80052a0 <f_sync+0x114>
 80052ba:	e79e      	b.n	80051fa <f_sync+0x6e>

080052bc <f_close>:
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80052bc:	b140      	cbz	r0, 80052d0 <f_close+0x14>
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 80052be:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80052c2:	6803      	ldr	r3, [r0, #0]
 80052c4:	b10b      	cbz	r3, 80052ca <f_close+0xe>
 80052c6:	781a      	ldrb	r2, [r3, #0]
 80052c8:	b922      	cbnz	r2, 80052d4 <f_close+0x18>
		return FR_INVALID_OBJECT;
 80052ca:	2009      	movs	r0, #9
 80052cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80052d0:	2009      	movs	r0, #9
 80052d2:	4770      	bx	lr
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80052d4:	88d9      	ldrh	r1, [r3, #6]
 80052d6:	8882      	ldrh	r2, [r0, #4]
 80052d8:	4291      	cmp	r1, r2
 80052da:	d1f6      	bne.n	80052ca <f_close+0xe>
 80052dc:	4604      	mov	r4, r0
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 80052de:	7858      	ldrb	r0, [r3, #1]
 80052e0:	f7fd fa52 	bl	8002788 <disk_status>
 80052e4:	07c0      	lsls	r0, r0, #31
 80052e6:	d502      	bpl.n	80052ee <f_close+0x32>
		return FR_NOT_READY;
 80052e8:	2003      	movs	r0, #3
 80052ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 80052ee:	79a3      	ldrb	r3, [r4, #6]
 80052f0:	069a      	lsls	r2, r3, #26
 80052f2:	d551      	bpl.n	8005398 <f_close+0xdc>
			if (fp->flag & FA__DIRTY) {
 80052f4:	0659      	lsls	r1, r3, #25
 80052f6:	d50d      	bpl.n	8005314 <f_close+0x58>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 80052f8:	6823      	ldr	r3, [r4, #0]
 80052fa:	69a2      	ldr	r2, [r4, #24]
 80052fc:	7858      	ldrb	r0, [r3, #1]
 80052fe:	f104 0124 	add.w	r1, r4, #36	; 0x24
 8005302:	2301      	movs	r3, #1
 8005304:	f7fd fa7c 	bl	8002800 <disk_write>
 8005308:	2800      	cmp	r0, #0
 800530a:	d14b      	bne.n	80053a4 <f_close+0xe8>
				fp->flag &= ~FA__DIRTY;
 800530c:	79a3      	ldrb	r3, [r4, #6]
 800530e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005312:	71a3      	strb	r3, [r4, #6]
			res = move_window(fp->fs, fp->dir_sect);
 8005314:	6825      	ldr	r5, [r4, #0]
 8005316:	69e7      	ldr	r7, [r4, #28]
	if (sector != fs->winsect) {	/* Changed current window */
 8005318:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 800531a:	42b7      	cmp	r7, r6
 800531c:	d00d      	beq.n	800533a <f_close+0x7e>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800531e:	792b      	ldrb	r3, [r5, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8005320:	f105 0834 	add.w	r8, r5, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8005324:	2b00      	cmp	r3, #0
 8005326:	d140      	bne.n	80053aa <f_close+0xee>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8005328:	4641      	mov	r1, r8
 800532a:	2301      	movs	r3, #1
 800532c:	463a      	mov	r2, r7
 800532e:	7868      	ldrb	r0, [r5, #1]
 8005330:	f7fd fa44 	bl	80027bc <disk_read>
 8005334:	2800      	cmp	r0, #0
 8005336:	d135      	bne.n	80053a4 <f_close+0xe8>
		fs->winsect = sector;
 8005338:	632f      	str	r7, [r5, #48]	; 0x30
				dir = fp->dir_ptr;
 800533a:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 800533c:	7aeb      	ldrb	r3, [r5, #11]
 800533e:	f043 0320 	orr.w	r3, r3, #32
 8005342:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 8005344:	68e3      	ldr	r3, [r4, #12]
 8005346:	772b      	strb	r3, [r5, #28]
 8005348:	89a3      	ldrh	r3, [r4, #12]
 800534a:	0a1b      	lsrs	r3, r3, #8
 800534c:	776b      	strb	r3, [r5, #29]
 800534e:	89e3      	ldrh	r3, [r4, #14]
 8005350:	77ab      	strb	r3, [r5, #30]
 8005352:	7be3      	ldrb	r3, [r4, #15]
 8005354:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
 8005356:	6923      	ldr	r3, [r4, #16]
	ST_WORD(dir+DIR_FstClusLO, cl);
 8005358:	76ab      	strb	r3, [r5, #26]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800535a:	0c1a      	lsrs	r2, r3, #16
 800535c:	0a11      	lsrs	r1, r2, #8
	ST_WORD(dir+DIR_FstClusLO, cl);
 800535e:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8005362:	76eb      	strb	r3, [r5, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8005364:	752a      	strb	r2, [r5, #20]
 8005366:	7569      	strb	r1, [r5, #21]
				tm = get_fattime();							/* Update updated time */
 8005368:	f7fd fa6c 	bl	8002844 <get_fattime>
				ST_WORD(dir+DIR_LstAccDate, 0);
 800536c:	2300      	movs	r3, #0
				ST_DWORD(dir+DIR_WrtTime, tm);
 800536e:	0c01      	lsrs	r1, r0, #16
 8005370:	0e02      	lsrs	r2, r0, #24
 8005372:	f3c0 2607 	ubfx	r6, r0, #8, #8
 8005376:	75a8      	strb	r0, [r5, #22]
 8005378:	7629      	strb	r1, [r5, #24]
 800537a:	75ee      	strb	r6, [r5, #23]
 800537c:	766a      	strb	r2, [r5, #25]
				ST_WORD(dir+DIR_LstAccDate, 0);
 800537e:	74ab      	strb	r3, [r5, #18]
 8005380:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
 8005382:	79a3      	ldrb	r3, [r4, #6]
				fp->fs->wflag = 1;
 8005384:	6822      	ldr	r2, [r4, #0]
				fp->flag &= ~FA__WRITTEN;
 8005386:	f023 0320 	bic.w	r3, r3, #32
				fp->fs->wflag = 1;
 800538a:	2101      	movs	r1, #1
				fp->flag &= ~FA__WRITTEN;
 800538c:	71a3      	strb	r3, [r4, #6]
				res = sync_fs(fp->fs);
 800538e:	4610      	mov	r0, r2
				fp->fs->wflag = 1;
 8005390:	7111      	strb	r1, [r2, #4]
				res = sync_fs(fp->fs);
 8005392:	f7fd fc9d 	bl	8002cd0 <sync_fs>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 8005396:	b918      	cbnz	r0, 80053a0 <f_close+0xe4>
 8005398:	2000      	movs	r0, #0
 800539a:	6020      	str	r0, [r4, #0]
 800539c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return res;
#endif
}
 80053a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 80053a4:	2001      	movs	r0, #1
 80053a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80053aa:	4641      	mov	r1, r8
 80053ac:	2301      	movs	r3, #1
 80053ae:	4632      	mov	r2, r6
 80053b0:	7868      	ldrb	r0, [r5, #1]
 80053b2:	f7fd fa25 	bl	8002800 <disk_write>
 80053b6:	2800      	cmp	r0, #0
 80053b8:	d1f4      	bne.n	80053a4 <f_close+0xe8>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80053ba:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 80053bc:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80053be:	4296      	cmp	r6, r2
 80053c0:	d3b2      	bcc.n	8005328 <f_close+0x6c>
 80053c2:	69eb      	ldr	r3, [r5, #28]
 80053c4:	441a      	add	r2, r3
 80053c6:	4296      	cmp	r6, r2
 80053c8:	d2ae      	bcs.n	8005328 <f_close+0x6c>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80053ca:	f895 9003 	ldrb.w	r9, [r5, #3]
 80053ce:	f1b9 0f01 	cmp.w	r9, #1
 80053d2:	d801      	bhi.n	80053d8 <f_close+0x11c>
 80053d4:	e7a8      	b.n	8005328 <f_close+0x6c>
 80053d6:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80053d8:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 80053da:	441e      	add	r6, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80053dc:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80053e0:	4632      	mov	r2, r6
 80053e2:	2301      	movs	r3, #1
 80053e4:	4641      	mov	r1, r8
 80053e6:	f7fd fa0b 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80053ea:	f1b9 0f01 	cmp.w	r9, #1
 80053ee:	d1f2      	bne.n	80053d6 <f_close+0x11a>
 80053f0:	e79a      	b.n	8005328 <f_close+0x6c>
 80053f2:	bf00      	nop

080053f4 <f_lseek>:
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80053f4:	b138      	cbz	r0, 8005406 <f_lseek+0x12>

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
 80053f6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80053f8:	6803      	ldr	r3, [r0, #0]
 80053fa:	4604      	mov	r4, r0
 80053fc:	b10b      	cbz	r3, 8005402 <f_lseek+0xe>
 80053fe:	781a      	ldrb	r2, [r3, #0]
 8005400:	b91a      	cbnz	r2, 800540a <f_lseek+0x16>
		return FR_INVALID_OBJECT;
 8005402:	2009      	movs	r0, #9
 8005404:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005406:	2009      	movs	r0, #9
 8005408:	4770      	bx	lr
 800540a:	460d      	mov	r5, r1
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 800540c:	8882      	ldrh	r2, [r0, #4]
 800540e:	88d9      	ldrh	r1, [r3, #6]
 8005410:	4291      	cmp	r1, r2
 8005412:	d1f6      	bne.n	8005402 <f_lseek+0xe>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8005414:	7858      	ldrb	r0, [r3, #1]
 8005416:	f7fd f9b7 	bl	8002788 <disk_status>
 800541a:	07c0      	lsls	r0, r0, #31
 800541c:	d501      	bpl.n	8005422 <f_lseek+0x2e>
		return FR_NOT_READY;
 800541e:	2003      	movs	r0, #3
 8005420:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
 8005422:	79a3      	ldrb	r3, [r4, #6]
 8005424:	061a      	lsls	r2, r3, #24
 8005426:	d452      	bmi.n	80054ce <f_lseek+0xda>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 8005428:	68e2      	ldr	r2, [r4, #12]
 800542a:	42aa      	cmp	r2, r5
 800542c:	d203      	bcs.n	8005436 <f_lseek+0x42>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
 800542e:	f013 0f02 	tst.w	r3, #2
 8005432:	bf08      	it	eq
 8005434:	4615      	moveq	r5, r2
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
 8005436:	2200      	movs	r2, #0
		ifptr = fp->fptr;
 8005438:	68a3      	ldr	r3, [r4, #8]
		fp->fptr = nsect = 0;
 800543a:	60a2      	str	r2, [r4, #8]
		if (ofs) {
 800543c:	2d00      	cmp	r5, #0
 800543e:	d048      	beq.n	80054d2 <f_lseek+0xde>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 8005440:	6820      	ldr	r0, [r4, #0]
 8005442:	7887      	ldrb	r7, [r0, #2]
 8005444:	027f      	lsls	r7, r7, #9
			if (ifptr > 0 &&
 8005446:	2b00      	cmp	r3, #0
 8005448:	d045      	beq.n	80054d6 <f_lseek+0xe2>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 800544a:	3b01      	subs	r3, #1
 800544c:	1e6a      	subs	r2, r5, #1
 800544e:	fbb3 f1f7 	udiv	r1, r3, r7
 8005452:	fbb2 f2f7 	udiv	r2, r2, r7
			if (ifptr > 0 &&
 8005456:	428a      	cmp	r2, r1
 8005458:	d33d      	bcc.n	80054d6 <f_lseek+0xe2>
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 800545a:	427a      	negs	r2, r7
 800545c:	4013      	ands	r3, r2
				ofs -= fp->fptr;
				clst = fp->clust;
 800545e:	6966      	ldr	r6, [r4, #20]
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 8005460:	60a3      	str	r3, [r4, #8]
				ofs -= fp->fptr;
 8005462:	1aed      	subs	r5, r5, r3
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
 8005464:	bb1e      	cbnz	r6, 80054ae <f_lseek+0xba>
 8005466:	68a3      	ldr	r3, [r4, #8]
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 8005468:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800546c:	2a00      	cmp	r2, #0
 800546e:	f000 8085 	beq.w	800557c <f_lseek+0x188>
 8005472:	69a2      	ldr	r2, [r4, #24]
 8005474:	4296      	cmp	r6, r2
 8005476:	f000 8081 	beq.w	800557c <f_lseek+0x188>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
 800547a:	79a3      	ldrb	r3, [r4, #6]
 800547c:	0659      	lsls	r1, r3, #25
 800547e:	d464      	bmi.n	800554a <f_lseek+0x156>
 8005480:	f104 0524 	add.w	r5, r4, #36	; 0x24
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
 8005484:	6823      	ldr	r3, [r4, #0]
 8005486:	4629      	mov	r1, r5
 8005488:	7858      	ldrb	r0, [r3, #1]
 800548a:	4632      	mov	r2, r6
 800548c:	2301      	movs	r3, #1
 800548e:	f7fd f995 	bl	80027bc <disk_read>
 8005492:	2800      	cmp	r0, #0
 8005494:	d151      	bne.n	800553a <f_lseek+0x146>
 8005496:	68a3      	ldr	r3, [r4, #8]
 8005498:	68e2      	ldr	r2, [r4, #12]
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
 800549a:	61a6      	str	r6, [r4, #24]
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
 800549c:	429a      	cmp	r2, r3
 800549e:	d218      	bcs.n	80054d2 <f_lseek+0xde>
			fp->fsize = fp->fptr;
			fp->flag |= FA__WRITTEN;
 80054a0:	79a2      	ldrb	r2, [r4, #6]
			fp->fsize = fp->fptr;
 80054a2:	60e3      	str	r3, [r4, #12]
			fp->flag |= FA__WRITTEN;
 80054a4:	f042 0320 	orr.w	r3, r2, #32
 80054a8:	71a3      	strb	r3, [r4, #6]
 80054aa:	2000      	movs	r0, #0
 80054ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				while (ofs > bcs) {						/* Cluster following loop */
 80054ae:	42bd      	cmp	r5, r7
 80054b0:	d969      	bls.n	8005586 <f_lseek+0x192>
 80054b2:	6820      	ldr	r0, [r4, #0]
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 80054b4:	79a3      	ldrb	r3, [r4, #6]
 80054b6:	079a      	lsls	r2, r3, #30
					ofs -= bcs;
 80054b8:	eba5 0507 	sub.w	r5, r5, r7
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 80054bc:	d410      	bmi.n	80054e0 <f_lseek+0xec>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 80054be:	2e01      	cmp	r6, #1
 80054c0:	d902      	bls.n	80054c8 <f_lseek+0xd4>
 80054c2:	6982      	ldr	r2, [r0, #24]
 80054c4:	42b2      	cmp	r2, r6
 80054c6:	d833      	bhi.n	8005530 <f_lseek+0x13c>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 80054c8:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80054cc:	71a3      	strb	r3, [r4, #6]
 80054ce:	2002      	movs	r0, #2
 80054d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80054d2:	2000      	movs	r0, #0
 80054d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				clst = fp->sclust;						/* start from the first cluster */
 80054d6:	6926      	ldr	r6, [r4, #16]
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 80054d8:	2e00      	cmp	r6, #0
 80054da:	d045      	beq.n	8005568 <f_lseek+0x174>
				fp->clust = clst;
 80054dc:	6166      	str	r6, [r4, #20]
 80054de:	e7c1      	b.n	8005464 <f_lseek+0x70>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 80054e0:	4631      	mov	r1, r6
 80054e2:	f7fe f8b1 	bl	8003648 <create_chain>
						if (clst == 0) {				/* When disk gets full, clip file size */
 80054e6:	4606      	mov	r6, r0
 80054e8:	2800      	cmp	r0, #0
 80054ea:	d04b      	beq.n	8005584 <f_lseek+0x190>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 80054ec:	1c70      	adds	r0, r6, #1
 80054ee:	d024      	beq.n	800553a <f_lseek+0x146>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 80054f0:	2e01      	cmp	r6, #1
 80054f2:	d928      	bls.n	8005546 <f_lseek+0x152>
 80054f4:	6820      	ldr	r0, [r4, #0]
 80054f6:	6983      	ldr	r3, [r0, #24]
 80054f8:	429e      	cmp	r6, r3
 80054fa:	d224      	bcs.n	8005546 <f_lseek+0x152>
					fp->fptr += bcs;
 80054fc:	68a3      	ldr	r3, [r4, #8]
					fp->clust = clst;
 80054fe:	6166      	str	r6, [r4, #20]
					fp->fptr += bcs;
 8005500:	443b      	add	r3, r7
				while (ofs > bcs) {						/* Cluster following loop */
 8005502:	42af      	cmp	r7, r5
					fp->fptr += bcs;
 8005504:	60a3      	str	r3, [r4, #8]
				while (ofs > bcs) {						/* Cluster following loop */
 8005506:	d3d5      	bcc.n	80054b4 <f_lseek+0xc0>
				fp->fptr += ofs;
 8005508:	442b      	add	r3, r5
				if (ofs % SS(fp->fs)) {
 800550a:	f3c5 0208 	ubfx	r2, r5, #0, #9
				fp->fptr += ofs;
 800550e:	60a3      	str	r3, [r4, #8]
				if (ofs % SS(fp->fs)) {
 8005510:	2a00      	cmp	r2, #0
 8005512:	d035      	beq.n	8005580 <f_lseek+0x18c>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
 8005514:	6821      	ldr	r1, [r4, #0]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005516:	698a      	ldr	r2, [r1, #24]
	clst -= 2;
 8005518:	3e02      	subs	r6, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800551a:	3a02      	subs	r2, #2
 800551c:	4296      	cmp	r6, r2
 800551e:	d212      	bcs.n	8005546 <f_lseek+0x152>
	return clst * fs->csize + fs->database;
 8005520:	788a      	ldrb	r2, [r1, #2]
 8005522:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8005524:	fb06 1602 	mla	r6, r6, r2, r1
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 8005528:	b16e      	cbz	r6, 8005546 <f_lseek+0x152>
					nsect += ofs / SS(fp->fs);
 800552a:	eb06 2655 	add.w	r6, r6, r5, lsr #9
 800552e:	e79b      	b.n	8005468 <f_lseek+0x74>
 8005530:	4631      	mov	r1, r6
 8005532:	f7fd fefb 	bl	800332c <get_fat.part.6>
 8005536:	4606      	mov	r6, r0
 8005538:	e7d8      	b.n	80054ec <f_lseek+0xf8>
				ABORT(fp->fs, FR_DISK_ERR);
 800553a:	79a3      	ldrb	r3, [r4, #6]
 800553c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8005540:	71a3      	strb	r3, [r4, #6]
 8005542:	2001      	movs	r0, #1
 8005544:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 8005546:	79a3      	ldrb	r3, [r4, #6]
 8005548:	e7be      	b.n	80054c8 <f_lseek+0xd4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 800554a:	6823      	ldr	r3, [r4, #0]
 800554c:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8005550:	7858      	ldrb	r0, [r3, #1]
 8005552:	4629      	mov	r1, r5
 8005554:	2301      	movs	r3, #1
 8005556:	f7fd f953 	bl	8002800 <disk_write>
					ABORT(fp->fs, FR_DISK_ERR);
 800555a:	79a3      	ldrb	r3, [r4, #6]
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 800555c:	2800      	cmp	r0, #0
 800555e:	d1ed      	bne.n	800553c <f_lseek+0x148>
				fp->flag &= ~FA__DIRTY;
 8005560:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005564:	71a3      	strb	r3, [r4, #6]
 8005566:	e78d      	b.n	8005484 <f_lseek+0x90>
					clst = create_chain(fp->fs, 0);
 8005568:	4631      	mov	r1, r6
 800556a:	f7fe f86d 	bl	8003648 <create_chain>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 800556e:	2801      	cmp	r0, #1
					clst = create_chain(fp->fs, 0);
 8005570:	4606      	mov	r6, r0
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 8005572:	d0e8      	beq.n	8005546 <f_lseek+0x152>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8005574:	1c41      	adds	r1, r0, #1
 8005576:	d0e0      	beq.n	800553a <f_lseek+0x146>
					fp->sclust = clst;
 8005578:	6120      	str	r0, [r4, #16]
 800557a:	e7af      	b.n	80054dc <f_lseek+0xe8>
 800557c:	68e2      	ldr	r2, [r4, #12]
 800557e:	e78d      	b.n	800549c <f_lseek+0xa8>
		fp->fptr = nsect = 0;
 8005580:	4616      	mov	r6, r2
 8005582:	e771      	b.n	8005468 <f_lseek+0x74>
						if (clst == 0) {				/* When disk gets full, clip file size */
 8005584:	463d      	mov	r5, r7
 8005586:	68a3      	ldr	r3, [r4, #8]
 8005588:	e7be      	b.n	8005508 <f_lseek+0x114>
 800558a:	bf00      	nop

0800558c <f_opendir>:
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
 800558c:	2800      	cmp	r0, #0
 800558e:	d044      	beq.n	800561a <f_opendir+0x8e>
{
 8005590:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	vol = p[0] - '0';					/* Is there a drive number? */
 8005594:	780b      	ldrb	r3, [r1, #0]
 8005596:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8005598:	2b09      	cmp	r3, #9
{
 800559a:	b085      	sub	sp, #20
 800559c:	460d      	mov	r5, r1
 800559e:	4604      	mov	r4, r0
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 80055a0:	d92d      	bls.n	80055fe <f_opendir+0x72>
	*rfs = 0;
 80055a2:	2300      	movs	r3, #0
 80055a4:	6023      	str	r3, [r4, #0]
	fs = FatFs[vol];					/* Get corresponding file system object */
 80055a6:	4fba      	ldr	r7, [pc, #744]	; (8005890 <f_opendir+0x304>)
 80055a8:	683e      	ldr	r6, [r7, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80055aa:	2e00      	cmp	r6, #0
 80055ac:	d045      	beq.n	800563a <f_opendir+0xae>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
 80055ae:	6026      	str	r6, [r4, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 80055b0:	7833      	ldrb	r3, [r6, #0]
 80055b2:	2b00      	cmp	r3, #0
 80055b4:	d037      	beq.n	8005626 <f_opendir+0x9a>
		stat = disk_status(fs->drv);
 80055b6:	7870      	ldrb	r0, [r6, #1]
 80055b8:	f7fd f8e6 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 80055bc:	07c1      	lsls	r1, r0, #31
 80055be:	d432      	bmi.n	8005626 <f_opendir+0x9a>

	res = chk_mounted(&path, &dj->fs, 0);
	fs = dj->fs;
	if (res == FR_OK) {
		INIT_BUF(*dj);
 80055c0:	ab01      	add	r3, sp, #4
		res = follow_path(dj, path);			/* Follow the path to the directory */
 80055c2:	4629      	mov	r1, r5
		INIT_BUF(*dj);
 80055c4:	61a3      	str	r3, [r4, #24]
		res = follow_path(dj, path);			/* Follow the path to the directory */
 80055c6:	4620      	mov	r0, r4
	fs = dj->fs;
 80055c8:	6825      	ldr	r5, [r4, #0]
		res = follow_path(dj, path);			/* Follow the path to the directory */
 80055ca:	f7fe fd67 	bl	800409c <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
 80055ce:	bb30      	cbnz	r0, 800561e <f_opendir+0x92>
			if (dj->dir) {						/* It is not the root dir */
 80055d0:	6963      	ldr	r3, [r4, #20]
 80055d2:	b153      	cbz	r3, 80055ea <f_opendir+0x5e>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 80055d4:	7ada      	ldrb	r2, [r3, #11]
 80055d6:	06d2      	lsls	r2, r2, #27
 80055d8:	d523      	bpl.n	8005622 <f_opendir+0x96>
	if (fs->fs_type == FS_FAT32)
 80055da:	7829      	ldrb	r1, [r5, #0]
	cl = LD_WORD(dir+DIR_FstClusLO);
 80055dc:	7ed8      	ldrb	r0, [r3, #27]
 80055de:	7e9a      	ldrb	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32)
 80055e0:	2903      	cmp	r1, #3
	cl = LD_WORD(dir+DIR_FstClusLO);
 80055e2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32)
 80055e6:	d041      	beq.n	800566c <f_opendir+0xe0>
					dj->sclust = ld_clust(fs, dj->dir);
 80055e8:	60a2      	str	r2, [r4, #8]
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
 80055ea:	88eb      	ldrh	r3, [r5, #6]
 80055ec:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dj, 0);			/* Rewind dir */
 80055ee:	2100      	movs	r1, #0
 80055f0:	4620      	mov	r0, r4
 80055f2:	f7fd ffd5 	bl	80035a0 <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 80055f6:	2804      	cmp	r0, #4
 80055f8:	d013      	beq.n	8005622 <f_opendir+0x96>
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
 80055fa:	b158      	cbz	r0, 8005614 <f_opendir+0x88>
 80055fc:	e008      	b.n	8005610 <f_opendir+0x84>
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 80055fe:	784a      	ldrb	r2, [r1, #1]
 8005600:	2a3a      	cmp	r2, #58	; 0x3a
 8005602:	d1ce      	bne.n	80055a2 <f_opendir+0x16>
	*rfs = 0;
 8005604:	2200      	movs	r2, #0
 8005606:	6002      	str	r2, [r0, #0]
		return FR_INVALID_DRIVE;
 8005608:	200b      	movs	r0, #11
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 800560a:	2b00      	cmp	r3, #0
 800560c:	f000 811d 	beq.w	800584a <f_opendir+0x2be>
	} else {
		dj->fs = 0;
 8005610:	2300      	movs	r3, #0
 8005612:	6023      	str	r3, [r4, #0]
	}

	LEAVE_FF(fs, res);
}
 8005614:	b005      	add	sp, #20
 8005616:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!dj) return FR_INVALID_OBJECT;
 800561a:	2009      	movs	r0, #9
 800561c:	4770      	bx	lr
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800561e:	2804      	cmp	r0, #4
 8005620:	d1f6      	bne.n	8005610 <f_opendir+0x84>
					res = FR_NO_PATH;
 8005622:	2005      	movs	r0, #5
 8005624:	e7f4      	b.n	8005610 <f_opendir+0x84>
	fs->fs_type = 0;					/* Clear the file system object */
 8005626:	2000      	movs	r0, #0
 8005628:	7030      	strb	r0, [r6, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800562a:	7070      	strb	r0, [r6, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 800562c:	f7fd f892 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8005630:	f010 0201 	ands.w	r2, r0, #1
 8005634:	d003      	beq.n	800563e <f_opendir+0xb2>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8005636:	2003      	movs	r0, #3
 8005638:	e7ea      	b.n	8005610 <f_opendir+0x84>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800563a:	200c      	movs	r0, #12
 800563c:	e7e8      	b.n	8005610 <f_opendir+0x84>
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 800563e:	f106 0834 	add.w	r8, r6, #52	; 0x34
 8005642:	4641      	mov	r1, r8
 8005644:	2301      	movs	r3, #1
 8005646:	7870      	ldrb	r0, [r6, #1]
 8005648:	f7fd f8b8 	bl	80027bc <disk_read>
 800564c:	b108      	cbz	r0, 8005652 <f_opendir+0xc6>
	if (fmt == 3) return FR_DISK_ERR;
 800564e:	2001      	movs	r0, #1
 8005650:	e7de      	b.n	8005610 <f_opendir+0x84>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8005652:	f896 2233 	ldrb.w	r2, [r6, #563]	; 0x233
 8005656:	f896 9232 	ldrb.w	r9, [r6, #562]	; 0x232
 800565a:	4b8e      	ldr	r3, [pc, #568]	; (8005894 <f_opendir+0x308>)
 800565c:	ea49 2902 	orr.w	r9, r9, r2, lsl #8
 8005660:	fa0f f989 	sxth.w	r9, r9
 8005664:	4599      	cmp	r9, r3
 8005666:	d008      	beq.n	800567a <f_opendir+0xee>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8005668:	200d      	movs	r0, #13
 800566a:	e7d1      	b.n	8005610 <f_opendir+0x84>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 800566c:	7d59      	ldrb	r1, [r3, #21]
 800566e:	7d1b      	ldrb	r3, [r3, #20]
 8005670:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8005674:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8005678:	e7b6      	b.n	80055e8 <f_opendir+0x5c>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 800567a:	f8d6 306a 	ldr.w	r3, [r6, #106]	; 0x6a
 800567e:	f8df a218 	ldr.w	sl, [pc, #536]	; 8005898 <f_opendir+0x30c>
 8005682:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005686:	4553      	cmp	r3, sl
 8005688:	f000 80c1 	beq.w	800580e <f_opendir+0x282>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 800568c:	f8d6 3086 	ldr.w	r3, [r6, #134]	; 0x86
 8005690:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005694:	4553      	cmp	r3, sl
 8005696:	f000 80ba 	beq.w	800580e <f_opendir+0x282>
		if (tbl[4]) {						/* Is the partition existing? */
 800569a:	f896 31f6 	ldrb.w	r3, [r6, #502]	; 0x1f6
 800569e:	2b00      	cmp	r3, #0
 80056a0:	d0e2      	beq.n	8005668 <f_opendir+0xdc>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 80056a2:	f8d6 b1fa 	ldr.w	fp, [r6, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 80056a6:	7870      	ldrb	r0, [r6, #1]
 80056a8:	465a      	mov	r2, fp
 80056aa:	2301      	movs	r3, #1
 80056ac:	4641      	mov	r1, r8
 80056ae:	f7fd f885 	bl	80027bc <disk_read>
 80056b2:	2800      	cmp	r0, #0
 80056b4:	d1cb      	bne.n	800564e <f_opendir+0xc2>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 80056b6:	f896 2233 	ldrb.w	r2, [r6, #563]	; 0x233
 80056ba:	f896 3232 	ldrb.w	r3, [r6, #562]	; 0x232
 80056be:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80056c2:	b21b      	sxth	r3, r3
 80056c4:	454b      	cmp	r3, r9
 80056c6:	d1cf      	bne.n	8005668 <f_opendir+0xdc>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 80056c8:	f8d6 306a 	ldr.w	r3, [r6, #106]	; 0x6a
 80056cc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80056d0:	4553      	cmp	r3, sl
 80056d2:	d005      	beq.n	80056e0 <f_opendir+0x154>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 80056d4:	f8d6 3086 	ldr.w	r3, [r6, #134]	; 0x86
 80056d8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 80056dc:	4553      	cmp	r3, sl
 80056de:	d1c3      	bne.n	8005668 <f_opendir+0xdc>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 80056e0:	f896 2040 	ldrb.w	r2, [r6, #64]	; 0x40
 80056e4:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
 80056e8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80056ec:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80056f0:	d1ba      	bne.n	8005668 <f_opendir+0xdc>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 80056f2:	f896 004b 	ldrb.w	r0, [r6, #75]	; 0x4b
 80056f6:	f896 304a 	ldrb.w	r3, [r6, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 80056fa:	f896 c044 	ldrb.w	ip, [r6, #68]	; 0x44
 80056fe:	f886 c003 	strb.w	ip, [r6, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8005702:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8005706:	bf18      	it	ne
 8005708:	4618      	movne	r0, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 800570a:	f10c 33ff 	add.w	r3, ip, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 800570e:	bf08      	it	eq
 8005710:	6db0      	ldreq	r0, [r6, #88]	; 0x58
	fs->fsize = fasize;
 8005712:	61f0      	str	r0, [r6, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8005714:	2b01      	cmp	r3, #1
 8005716:	d8a7      	bhi.n	8005668 <f_opendir+0xdc>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 8005718:	f896 9041 	ldrb.w	r9, [r6, #65]	; 0x41
 800571c:	f886 9002 	strb.w	r9, [r6, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8005720:	f1b9 0f00 	cmp.w	r9, #0
 8005724:	d0a0      	beq.n	8005668 <f_opendir+0xdc>
 8005726:	f109 33ff 	add.w	r3, r9, #4294967295
 800572a:	ea13 0f09 	tst.w	r3, r9
 800572e:	d19b      	bne.n	8005668 <f_opendir+0xdc>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8005730:	f896 3046 	ldrb.w	r3, [r6, #70]	; 0x46
 8005734:	f896 e045 	ldrb.w	lr, [r6, #69]	; 0x45
 8005738:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 800573c:	f01e 0f0f 	tst.w	lr, #15
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8005740:	f8a6 e008 	strh.w	lr, [r6, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8005744:	d190      	bne.n	8005668 <f_opendir+0xdc>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8005746:	f896 2048 	ldrb.w	r2, [r6, #72]	; 0x48
 800574a:	f896 3047 	ldrb.w	r3, [r6, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 800574e:	f896 1043 	ldrb.w	r1, [r6, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8005752:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8005756:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 800575a:	bf08      	it	eq
 800575c:	6d73      	ldreq	r3, [r6, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 800575e:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8005762:	d081      	beq.n	8005668 <f_opendir+0xdc>
	fasize *= b;										/* Number of sectors for FAT area */
 8005764:	fb00 fc0c 	mul.w	ip, r0, ip
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8005768:	eb02 111e 	add.w	r1, r2, lr, lsr #4
 800576c:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800576e:	4299      	cmp	r1, r3
 8005770:	f63f af7a 	bhi.w	8005668 <f_opendir+0xdc>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8005774:	1a5b      	subs	r3, r3, r1
 8005776:	fbb3 f3f9 	udiv	r3, r3, r9
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 800577a:	2b00      	cmp	r3, #0
 800577c:	f43f af74 	beq.w	8005668 <f_opendir+0xdc>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8005780:	f640 79f5 	movw	r9, #4085	; 0xff5
 8005784:	454b      	cmp	r3, r9
 8005786:	d962      	bls.n	800584e <f_opendir+0x2c2>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8005788:	f64f 79f5 	movw	r9, #65525	; 0xfff5
 800578c:	454b      	cmp	r3, r9
 800578e:	d940      	bls.n	8005812 <f_opendir+0x286>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005790:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005792:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8005794:	4459      	add	r1, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005796:	61b3      	str	r3, [r6, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005798:	6272      	str	r2, [r6, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 800579a:	62f1      	str	r1, [r6, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 800579c:	f8c6 b020 	str.w	fp, [r6, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 80057a0:	f1be 0f00 	cmp.w	lr, #0
 80057a4:	f47f af60 	bne.w	8005668 <f_opendir+0xdc>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 80057a8:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80057aa:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 80057ae:	6e32      	ldr	r2, [r6, #96]	; 0x60
 80057b0:	62b2      	str	r2, [r6, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80057b2:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 80057b6:	f4ff af57 	bcc.w	8005668 <f_opendir+0xdc>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 80057ba:	f896 3065 	ldrb.w	r3, [r6, #101]	; 0x65
 80057be:	f896 2064 	ldrb.w	r2, [r6, #100]	; 0x64
	fs->last_clust = 0;
 80057c2:	f8c6 e00c 	str.w	lr, [r6, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 80057c6:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 80057ca:	445a      	add	r2, fp
	fs->free_clust = 0xFFFFFFFF;
 80057cc:	f04f 33ff 	mov.w	r3, #4294967295
 80057d0:	6133      	str	r3, [r6, #16]
	 	fs->fsi_flag = 0;
 80057d2:	f886 e005 	strb.w	lr, [r6, #5]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 80057d6:	4641      	mov	r1, r8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 80057d8:	6172      	str	r2, [r6, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 80057da:	2301      	movs	r3, #1
 80057dc:	7870      	ldrb	r0, [r6, #1]
 80057de:	f7fc ffed 	bl	80027bc <disk_read>
 80057e2:	b948      	cbnz	r0, 80057f8 <f_opendir+0x26c>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 80057e4:	f896 1233 	ldrb.w	r1, [r6, #563]	; 0x233
 80057e8:	f896 3232 	ldrb.w	r3, [r6, #562]	; 0x232
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 80057ec:	f64a 2255 	movw	r2, #43605	; 0xaa55
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 80057f0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 80057f4:	4293      	cmp	r3, r2
 80057f6:	d051      	beq.n	800589c <f_opendir+0x310>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 80057f8:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 80057fa:	88ba      	ldrh	r2, [r7, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 80057fc:	7033      	strb	r3, [r6, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 80057fe:	1c53      	adds	r3, r2, #1
 8005800:	b29b      	uxth	r3, r3
	fs->winsect = 0;		/* Invalidate sector cache */
 8005802:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* File system mount ID */
 8005804:	80bb      	strh	r3, [r7, #4]
 8005806:	80f3      	strh	r3, [r6, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 8005808:	6332      	str	r2, [r6, #48]	; 0x30
	fs->wflag = 0;
 800580a:	7132      	strb	r2, [r6, #4]
 800580c:	e6d8      	b.n	80055c0 <f_opendir+0x34>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 800580e:	4683      	mov	fp, r0
 8005810:	e766      	b.n	80056e0 <f_opendir+0x154>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005812:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005814:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8005816:	4459      	add	r1, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005818:	61b3      	str	r3, [r6, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800581a:	6272      	str	r2, [r6, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 800581c:	62f1      	str	r1, [r6, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 800581e:	f8c6 b020 	str.w	fp, [r6, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8005822:	f1be 0f00 	cmp.w	lr, #0
 8005826:	f43f af1f 	beq.w	8005668 <f_opendir+0xdc>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800582a:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800582c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005830:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005832:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005836:	62b2      	str	r2, [r6, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005838:	f4ff af16 	bcc.w	8005668 <f_opendir+0xdc>
	fs->last_clust = 0;
 800583c:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 800583e:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8005842:	60f3      	str	r3, [r6, #12]
	fs->free_clust = 0xFFFFFFFF;
 8005844:	6132      	str	r2, [r6, #16]
	fs->last_clust = 0;
 8005846:	2302      	movs	r3, #2
 8005848:	e7d7      	b.n	80057fa <f_opendir+0x26e>
		p += 2; *path = p;				/* Return pointer to the path name */
 800584a:	3502      	adds	r5, #2
 800584c:	e6ab      	b.n	80055a6 <f_opendir+0x1a>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800584e:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005850:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8005852:	4459      	add	r1, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005854:	61b3      	str	r3, [r6, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005856:	6272      	str	r2, [r6, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8005858:	62f1      	str	r1, [r6, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 800585a:	f8c6 b020 	str.w	fp, [r6, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800585e:	f1be 0f00 	cmp.w	lr, #0
 8005862:	f43f af01 	beq.w	8005668 <f_opendir+0xdc>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005866:	f003 0101 	and.w	r1, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800586a:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800586e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005872:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005876:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005878:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800587c:	62b2      	str	r2, [r6, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800587e:	f4ff aef3 	bcc.w	8005668 <f_opendir+0xdc>
	fs->last_clust = 0;
 8005882:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8005884:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8005888:	60f3      	str	r3, [r6, #12]
	fs->free_clust = 0xFFFFFFFF;
 800588a:	6132      	str	r2, [r6, #16]
	fmt = FS_FAT12;
 800588c:	2301      	movs	r3, #1
 800588e:	e7b4      	b.n	80057fa <f_opendir+0x26e>
 8005890:	20002128 	.word	0x20002128
 8005894:	ffffaa55 	.word	0xffffaa55
 8005898:	00544146 	.word	0x00544146
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 800589c:	4b0a      	ldr	r3, [pc, #40]	; (80058c8 <f_opendir+0x33c>)
 800589e:	6b72      	ldr	r2, [r6, #52]	; 0x34
 80058a0:	429a      	cmp	r2, r3
 80058a2:	d1a9      	bne.n	80057f8 <f_opendir+0x26c>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 80058a4:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 80058a8:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 80058ac:	f8d6 2218 	ldr.w	r2, [r6, #536]	; 0x218
 80058b0:	3320      	adds	r3, #32
 80058b2:	429a      	cmp	r2, r3
 80058b4:	d1a0      	bne.n	80057f8 <f_opendir+0x26c>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80058b6:	f8d6 321c 	ldr.w	r3, [r6, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80058ba:	f8d6 2220 	ldr.w	r2, [r6, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80058be:	6133      	str	r3, [r6, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80058c0:	60f2      	str	r2, [r6, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80058c2:	2303      	movs	r3, #3
 80058c4:	e799      	b.n	80057fa <f_opendir+0x26e>
 80058c6:	bf00      	nop
 80058c8:	41615252 	.word	0x41615252

080058cc <f_readdir>:
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80058cc:	b118      	cbz	r0, 80058d6 <f_readdir+0xa>
 80058ce:	6803      	ldr	r3, [r0, #0]
 80058d0:	b10b      	cbz	r3, 80058d6 <f_readdir+0xa>
 80058d2:	781a      	ldrb	r2, [r3, #0]
 80058d4:	b90a      	cbnz	r2, 80058da <f_readdir+0xe>
		return FR_INVALID_OBJECT;
 80058d6:	2009      	movs	r0, #9
 80058d8:	4770      	bx	lr

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 80058da:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80058de:	8882      	ldrh	r2, [r0, #4]
 80058e0:	88dc      	ldrh	r4, [r3, #6]
 80058e2:	4294      	cmp	r4, r2
{
 80058e4:	b084      	sub	sp, #16
		return FR_INVALID_OBJECT;
 80058e6:	bf18      	it	ne
 80058e8:	2009      	movne	r0, #9
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80058ea:	d002      	beq.n	80058f2 <f_readdir+0x26>
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
 80058ec:	b004      	add	sp, #16
 80058ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80058f2:	4606      	mov	r6, r0
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 80058f4:	7858      	ldrb	r0, [r3, #1]
 80058f6:	460f      	mov	r7, r1
 80058f8:	f7fc ff46 	bl	8002788 <disk_status>
 80058fc:	07c1      	lsls	r1, r0, #31
 80058fe:	d501      	bpl.n	8005904 <f_readdir+0x38>
		return FR_NOT_READY;
 8005900:	2003      	movs	r0, #3
 8005902:	e7f3      	b.n	80058ec <f_readdir+0x20>
		if (!fno) {
 8005904:	2f00      	cmp	r7, #0
 8005906:	f000 80ac 	beq.w	8005a62 <f_readdir+0x196>
	while (dj->sect) {
 800590a:	6934      	ldr	r4, [r6, #16]
			INIT_BUF(*dj);
 800590c:	ab01      	add	r3, sp, #4
 800590e:	61b3      	str	r3, [r6, #24]
	while (dj->sect) {
 8005910:	b344      	cbz	r4, 8005964 <f_readdir+0x98>
 8005912:	f8d6 8000 	ldr.w	r8, [r6]
	if (sector != fs->winsect) {	/* Changed current window */
 8005916:	f8d8 5030 	ldr.w	r5, [r8, #48]	; 0x30
 800591a:	42a5      	cmp	r5, r4
 800591c:	d00f      	beq.n	800593e <f_readdir+0x72>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800591e:	f898 3004 	ldrb.w	r3, [r8, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8005922:	f108 0934 	add.w	r9, r8, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8005926:	2b00      	cmp	r3, #0
 8005928:	d143      	bne.n	80059b2 <f_readdir+0xe6>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800592a:	4649      	mov	r1, r9
 800592c:	2301      	movs	r3, #1
 800592e:	4622      	mov	r2, r4
 8005930:	f898 0001 	ldrb.w	r0, [r8, #1]
 8005934:	f7fc ff42 	bl	80027bc <disk_read>
 8005938:	bb30      	cbnz	r0, 8005988 <f_readdir+0xbc>
		fs->winsect = sector;
 800593a:	f8c8 4030 	str.w	r4, [r8, #48]	; 0x30
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 800593e:	6972      	ldr	r2, [r6, #20]
		c = dir[DIR_Name];
 8005940:	7813      	ldrb	r3, [r2, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8005942:	b17b      	cbz	r3, 8005964 <f_readdir+0x98>
		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid entry? */
 8005944:	2be5      	cmp	r3, #229	; 0xe5
 8005946:	d009      	beq.n	800595c <f_readdir+0x90>
 8005948:	2b2e      	cmp	r3, #46	; 0x2e
 800594a:	d007      	beq.n	800595c <f_readdir+0x90>
		a = dir[DIR_Attr] & AM_MASK;
 800594c:	7ad3      	ldrb	r3, [r2, #11]
 800594e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid entry? */
 8005952:	2b0f      	cmp	r3, #15
 8005954:	d002      	beq.n	800595c <f_readdir+0x90>
 8005956:	2b08      	cmp	r3, #8
 8005958:	f040 8088 	bne.w	8005a6c <f_readdir+0x1a0>
	i = dj->index + 1;
 800595c:	88f5      	ldrh	r5, [r6, #6]
 800595e:	3501      	adds	r5, #1
 8005960:	b2ad      	uxth	r5, r5
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8005962:	b9bd      	cbnz	r5, 8005994 <f_readdir+0xc8>
	if (res != FR_OK) dj->sect = 0;
 8005964:	2400      	movs	r4, #0
 8005966:	6134      	str	r4, [r6, #16]
				get_fileinfo(dj, fno);		/* Get the object information */
 8005968:	4620      	mov	r0, r4
 800596a:	463a      	mov	r2, r7
 800596c:	f106 0114 	add.w	r1, r6, #20
 8005970:	f7fc ff8e 	bl	8002890 <get_fileinfo.isra.2>
	i = dj->index + 1;
 8005974:	88f4      	ldrh	r4, [r6, #6]
 8005976:	3401      	adds	r4, #1
 8005978:	b2a4      	uxth	r4, r4
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 800597a:	2c00      	cmp	r4, #0
 800597c:	d163      	bne.n	8005a46 <f_readdir+0x17a>
					dj->sect = 0;
 800597e:	2000      	movs	r0, #0
 8005980:	6130      	str	r0, [r6, #16]
}
 8005982:	b004      	add	sp, #16
 8005984:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return FR_INVALID_OBJECT;
 8005988:	2001      	movs	r0, #1
	if (res != FR_OK) dj->sect = 0;
 800598a:	2300      	movs	r3, #0
 800598c:	6133      	str	r3, [r6, #16]
}
 800598e:	b004      	add	sp, #16
 8005990:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8005994:	6934      	ldr	r4, [r6, #16]
 8005996:	2c00      	cmp	r4, #0
 8005998:	d0e4      	beq.n	8005964 <f_readdir+0x98>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 800599a:	f015 020f 	ands.w	r2, r5, #15
 800599e:	d032      	beq.n	8005a06 <f_readdir+0x13a>
 80059a0:	f8d6 8000 	ldr.w	r8, [r6]
	dj->index = i;
 80059a4:	80f5      	strh	r5, [r6, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 80059a6:	f108 0334 	add.w	r3, r8, #52	; 0x34
 80059aa:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80059ae:	6173      	str	r3, [r6, #20]
 80059b0:	e7b1      	b.n	8005916 <f_readdir+0x4a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80059b2:	4649      	mov	r1, r9
 80059b4:	2301      	movs	r3, #1
 80059b6:	462a      	mov	r2, r5
 80059b8:	f898 0001 	ldrb.w	r0, [r8, #1]
 80059bc:	f7fc ff20 	bl	8002800 <disk_write>
 80059c0:	2800      	cmp	r0, #0
 80059c2:	d1e1      	bne.n	8005988 <f_readdir+0xbc>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80059c4:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
		fs->wflag = 0;
 80059c8:	f888 0004 	strb.w	r0, [r8, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80059cc:	4295      	cmp	r5, r2
 80059ce:	d3ac      	bcc.n	800592a <f_readdir+0x5e>
 80059d0:	f8d8 301c 	ldr.w	r3, [r8, #28]
 80059d4:	441a      	add	r2, r3
 80059d6:	4295      	cmp	r5, r2
 80059d8:	d2a7      	bcs.n	800592a <f_readdir+0x5e>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80059da:	f898 a003 	ldrb.w	sl, [r8, #3]
 80059de:	f1ba 0f01 	cmp.w	sl, #1
 80059e2:	d802      	bhi.n	80059ea <f_readdir+0x11e>
 80059e4:	e7a1      	b.n	800592a <f_readdir+0x5e>
 80059e6:	f8d8 301c 	ldr.w	r3, [r8, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80059ea:	f898 0001 	ldrb.w	r0, [r8, #1]
				wsect += fs->fsize;
 80059ee:	441d      	add	r5, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80059f0:	f10a 3aff 	add.w	sl, sl, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80059f4:	462a      	mov	r2, r5
 80059f6:	2301      	movs	r3, #1
 80059f8:	4649      	mov	r1, r9
 80059fa:	f7fc ff01 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80059fe:	f1ba 0f01 	cmp.w	sl, #1
 8005a02:	d1f0      	bne.n	80059e6 <f_readdir+0x11a>
 8005a04:	e791      	b.n	800592a <f_readdir+0x5e>
		if (dj->clust == 0) {	/* Static table */
 8005a06:	68f1      	ldr	r1, [r6, #12]
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8005a08:	f8d6 8000 	ldr.w	r8, [r6]
		dj->sect++;					/* Next sector */
 8005a0c:	3401      	adds	r4, #1
 8005a0e:	6134      	str	r4, [r6, #16]
		if (dj->clust == 0) {	/* Static table */
 8005a10:	b959      	cbnz	r1, 8005a2a <f_readdir+0x15e>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8005a12:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 8005a16:	42ab      	cmp	r3, r5
 8005a18:	d9a4      	bls.n	8005964 <f_readdir+0x98>
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 8005a1a:	f108 0334 	add.w	r3, r8, #52	; 0x34
	dj->index = i;
 8005a1e:	80f5      	strh	r5, [r6, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 8005a20:	6173      	str	r3, [r6, #20]
	while (dj->sect) {
 8005a22:	2c00      	cmp	r4, #0
 8005a24:	f47f af77 	bne.w	8005916 <f_readdir+0x4a>
 8005a28:	e79e      	b.n	8005968 <f_readdir+0x9c>
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8005a2a:	f898 3002 	ldrb.w	r3, [r8, #2]
 8005a2e:	3b01      	subs	r3, #1
 8005a30:	ea13 1315 	ands.w	r3, r3, r5, lsr #4
 8005a34:	d1f1      	bne.n	8005a1a <f_readdir+0x14e>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8005a36:	2901      	cmp	r1, #1
 8005a38:	d903      	bls.n	8005a42 <f_readdir+0x176>
 8005a3a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8005a3e:	4299      	cmp	r1, r3
 8005a40:	d316      	bcc.n	8005a70 <f_readdir+0x1a4>
		return FR_INVALID_OBJECT;
 8005a42:	2002      	movs	r0, #2
 8005a44:	e7a1      	b.n	800598a <f_readdir+0xbe>
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8005a46:	6933      	ldr	r3, [r6, #16]
 8005a48:	2b00      	cmp	r3, #0
 8005a4a:	d098      	beq.n	800597e <f_readdir+0xb2>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 8005a4c:	f014 050f 	ands.w	r5, r4, #15
 8005a50:	d02a      	beq.n	8005aa8 <f_readdir+0x1dc>
 8005a52:	6833      	ldr	r3, [r6, #0]
	dj->index = i;
 8005a54:	80f4      	strh	r4, [r6, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 8005a56:	3334      	adds	r3, #52	; 0x34
 8005a58:	eb03 1345 	add.w	r3, r3, r5, lsl #5
 8005a5c:	6173      	str	r3, [r6, #20]
	return FR_OK;
 8005a5e:	2000      	movs	r0, #0
 8005a60:	e744      	b.n	80058ec <f_readdir+0x20>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
 8005a62:	4639      	mov	r1, r7
 8005a64:	4630      	mov	r0, r6
 8005a66:	f7fd fd9b 	bl	80035a0 <dir_sdi>
 8005a6a:	e73f      	b.n	80058ec <f_readdir+0x20>
 8005a6c:	6934      	ldr	r4, [r6, #16]
 8005a6e:	e77b      	b.n	8005968 <f_readdir+0x9c>
 8005a70:	4640      	mov	r0, r8
 8005a72:	f7fd fc5b 	bl	800332c <get_fat.part.6>
				if (clst <= 1) return FR_INT_ERR;
 8005a76:	2801      	cmp	r0, #1
 8005a78:	d9e3      	bls.n	8005a42 <f_readdir+0x176>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8005a7a:	1c42      	adds	r2, r0, #1
 8005a7c:	d084      	beq.n	8005988 <f_readdir+0xbc>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 8005a7e:	f8d6 8000 	ldr.w	r8, [r6]
 8005a82:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8005a86:	4298      	cmp	r0, r3
 8005a88:	f4bf af6c 	bcs.w	8005964 <f_readdir+0x98>
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005a8c:	3b02      	subs	r3, #2
	clst -= 2;
 8005a8e:	1e82      	subs	r2, r0, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005a90:	429a      	cmp	r2, r3
				dj->clust = clst;				/* Initialize data for new cluster */
 8005a92:	60f0      	str	r0, [r6, #12]
	return clst * fs->csize + fs->database;
 8005a94:	bf3b      	ittet	cc
 8005a96:	f898 4002 	ldrbcc.w	r4, [r8, #2]
 8005a9a:	f8d8 302c 	ldrcc.w	r3, [r8, #44]	; 0x2c
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005a9e:	2400      	movcs	r4, #0
	return clst * fs->csize + fs->database;
 8005aa0:	fb02 3404 	mlacc	r4, r2, r4, r3
				dj->sect = clust2sect(dj->fs, clst);
 8005aa4:	6134      	str	r4, [r6, #16]
 8005aa6:	e7b8      	b.n	8005a1a <f_readdir+0x14e>
		if (dj->clust == 0) {	/* Static table */
 8005aa8:	68f1      	ldr	r1, [r6, #12]
		dj->sect++;					/* Next sector */
 8005aaa:	3301      	adds	r3, #1
 8005aac:	6133      	str	r3, [r6, #16]
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8005aae:	6833      	ldr	r3, [r6, #0]
		if (dj->clust == 0) {	/* Static table */
 8005ab0:	b921      	cbnz	r1, 8005abc <f_readdir+0x1f0>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8005ab2:	891a      	ldrh	r2, [r3, #8]
 8005ab4:	42a2      	cmp	r2, r4
 8005ab6:	f67f af62 	bls.w	800597e <f_readdir+0xb2>
 8005aba:	e7cb      	b.n	8005a54 <f_readdir+0x188>
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8005abc:	789a      	ldrb	r2, [r3, #2]
 8005abe:	3a01      	subs	r2, #1
 8005ac0:	ea12 1214 	ands.w	r2, r2, r4, lsr #4
 8005ac4:	d1c6      	bne.n	8005a54 <f_readdir+0x188>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8005ac6:	2901      	cmp	r1, #1
 8005ac8:	d902      	bls.n	8005ad0 <f_readdir+0x204>
 8005aca:	699a      	ldr	r2, [r3, #24]
 8005acc:	4291      	cmp	r1, r2
 8005ace:	d301      	bcc.n	8005ad4 <f_readdir+0x208>
				if (clst <= 1) return FR_INT_ERR;
 8005ad0:	2002      	movs	r0, #2
 8005ad2:	e70b      	b.n	80058ec <f_readdir+0x20>
 8005ad4:	4618      	mov	r0, r3
 8005ad6:	f7fd fc29 	bl	800332c <get_fat.part.6>
 8005ada:	2801      	cmp	r0, #1
 8005adc:	d9f8      	bls.n	8005ad0 <f_readdir+0x204>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8005ade:	1c43      	adds	r3, r0, #1
 8005ae0:	d010      	beq.n	8005b04 <f_readdir+0x238>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 8005ae2:	6833      	ldr	r3, [r6, #0]
 8005ae4:	699a      	ldr	r2, [r3, #24]
 8005ae6:	4290      	cmp	r0, r2
 8005ae8:	f4bf af49 	bcs.w	800597e <f_readdir+0xb2>
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005aec:	3a02      	subs	r2, #2
	clst -= 2;
 8005aee:	1e81      	subs	r1, r0, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005af0:	4291      	cmp	r1, r2
				dj->clust = clst;				/* Initialize data for new cluster */
 8005af2:	60f0      	str	r0, [r6, #12]
	return clst * fs->csize + fs->database;
 8005af4:	bf3b      	ittet	cc
 8005af6:	789a      	ldrbcc	r2, [r3, #2]
 8005af8:	6ad8      	ldrcc	r0, [r3, #44]	; 0x2c
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005afa:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
 8005afc:	fb01 0202 	mlacc	r2, r1, r2, r0
				dj->sect = clust2sect(dj->fs, clst);
 8005b00:	6132      	str	r2, [r6, #16]
 8005b02:	e7a7      	b.n	8005a54 <f_readdir+0x188>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8005b04:	2001      	movs	r0, #1
 8005b06:	e6f1      	b.n	80058ec <f_readdir+0x20>

08005b08 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 8005b08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	vol = p[0] - '0';					/* Is there a drive number? */
 8005b0c:	7803      	ldrb	r3, [r0, #0]
 8005b0e:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8005b10:	2b09      	cmp	r3, #9
{
 8005b12:	b08b      	sub	sp, #44	; 0x2c
 8005b14:	4604      	mov	r4, r0
 8005b16:	460e      	mov	r6, r1
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8005b18:	d91d      	bls.n	8005b56 <f_stat+0x4e>
	fs = FatFs[vol];					/* Get corresponding file system object */
 8005b1a:	4fb9      	ldr	r7, [pc, #740]	; (8005e00 <f_stat+0x2f8>)
 8005b1c:	683d      	ldr	r5, [r7, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8005b1e:	b395      	cbz	r5, 8005b86 <f_stat+0x7e>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
 8005b20:	9503      	str	r5, [sp, #12]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8005b22:	782b      	ldrb	r3, [r5, #0]
 8005b24:	b313      	cbz	r3, 8005b6c <f_stat+0x64>
		stat = disk_status(fs->drv);
 8005b26:	7868      	ldrb	r0, [r5, #1]
 8005b28:	f7fc fe2e 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 8005b2c:	07c3      	lsls	r3, r0, #31
 8005b2e:	d41d      	bmi.n	8005b6c <f_stat+0x64>


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
 8005b30:	4621      	mov	r1, r4
 8005b32:	a803      	add	r0, sp, #12
		INIT_BUF(dj);
 8005b34:	f8cd d024 	str.w	sp, [sp, #36]	; 0x24
		res = follow_path(&dj, path);	/* Follow the file path */
 8005b38:	f7fe fab0 	bl	800409c <follow_path>
		if (res == FR_OK) {				/* Follow completed */
 8005b3c:	4604      	mov	r4, r0
 8005b3e:	b988      	cbnz	r0, 8005b64 <f_stat+0x5c>
			if (dj.dir)		/* Found an object */
 8005b40:	9b08      	ldr	r3, [sp, #32]
 8005b42:	b313      	cbz	r3, 8005b8a <f_stat+0x82>
				get_fileinfo(&dj, fno);
 8005b44:	9807      	ldr	r0, [sp, #28]
 8005b46:	4632      	mov	r2, r6
 8005b48:	a908      	add	r1, sp, #32
 8005b4a:	f7fc fea1 	bl	8002890 <get_fileinfo.isra.2>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
 8005b4e:	4620      	mov	r0, r4
 8005b50:	b00b      	add	sp, #44	; 0x2c
 8005b52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8005b56:	7842      	ldrb	r2, [r0, #1]
 8005b58:	2a3a      	cmp	r2, #58	; 0x3a
 8005b5a:	d1de      	bne.n	8005b1a <f_stat+0x12>
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 8005b5c:	2b00      	cmp	r3, #0
 8005b5e:	f000 8117 	beq.w	8005d90 <f_stat+0x288>
		return FR_INVALID_DRIVE;
 8005b62:	240b      	movs	r4, #11
}
 8005b64:	4620      	mov	r0, r4
 8005b66:	b00b      	add	sp, #44	; 0x2c
 8005b68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 8005b6c:	2000      	movs	r0, #0
 8005b6e:	7028      	strb	r0, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8005b70:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8005b72:	f7fc fdef 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8005b76:	f010 0201 	ands.w	r2, r0, #1
 8005b7a:	d00b      	beq.n	8005b94 <f_stat+0x8c>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8005b7c:	2403      	movs	r4, #3
}
 8005b7e:	4620      	mov	r0, r4
 8005b80:	b00b      	add	sp, #44	; 0x2c
 8005b82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8005b86:	240c      	movs	r4, #12
 8005b88:	e7ec      	b.n	8005b64 <f_stat+0x5c>
				res = FR_INVALID_NAME;
 8005b8a:	2406      	movs	r4, #6
}
 8005b8c:	4620      	mov	r0, r4
 8005b8e:	b00b      	add	sp, #44	; 0x2c
 8005b90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8005b94:	f105 0834 	add.w	r8, r5, #52	; 0x34
 8005b98:	4641      	mov	r1, r8
 8005b9a:	2301      	movs	r3, #1
 8005b9c:	7868      	ldrb	r0, [r5, #1]
 8005b9e:	f7fc fe0d 	bl	80027bc <disk_read>
 8005ba2:	b108      	cbz	r0, 8005ba8 <f_stat+0xa0>
	if (fmt == 3) return FR_DISK_ERR;
 8005ba4:	2401      	movs	r4, #1
 8005ba6:	e7dd      	b.n	8005b64 <f_stat+0x5c>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8005ba8:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8005bac:	f895 9232 	ldrb.w	r9, [r5, #562]	; 0x232
 8005bb0:	4b94      	ldr	r3, [pc, #592]	; (8005e04 <f_stat+0x2fc>)
 8005bb2:	ea49 2902 	orr.w	r9, r9, r2, lsl #8
 8005bb6:	fa0f f989 	sxth.w	r9, r9
 8005bba:	4599      	cmp	r9, r3
 8005bbc:	d001      	beq.n	8005bc2 <f_stat+0xba>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8005bbe:	240d      	movs	r4, #13
	LEAVE_FF(dj.fs, res);
 8005bc0:	e7d0      	b.n	8005b64 <f_stat+0x5c>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8005bc2:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 8005bc6:	f8df a244 	ldr.w	sl, [pc, #580]	; 8005e0c <f_stat+0x304>
 8005bca:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005bce:	4553      	cmp	r3, sl
 8005bd0:	f000 80c0 	beq.w	8005d54 <f_stat+0x24c>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8005bd4:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
 8005bd8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005bdc:	4553      	cmp	r3, sl
 8005bde:	f000 80b9 	beq.w	8005d54 <f_stat+0x24c>
		if (tbl[4]) {						/* Is the partition existing? */
 8005be2:	f895 31f6 	ldrb.w	r3, [r5, #502]	; 0x1f6
 8005be6:	2b00      	cmp	r3, #0
 8005be8:	d0e9      	beq.n	8005bbe <f_stat+0xb6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 8005bea:	f8d5 b1fa 	ldr.w	fp, [r5, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8005bee:	7868      	ldrb	r0, [r5, #1]
 8005bf0:	465a      	mov	r2, fp
 8005bf2:	2301      	movs	r3, #1
 8005bf4:	4641      	mov	r1, r8
 8005bf6:	f7fc fde1 	bl	80027bc <disk_read>
 8005bfa:	2800      	cmp	r0, #0
 8005bfc:	d1d2      	bne.n	8005ba4 <f_stat+0x9c>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8005bfe:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8005c02:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
 8005c06:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005c0a:	b21b      	sxth	r3, r3
 8005c0c:	454b      	cmp	r3, r9
 8005c0e:	d1d6      	bne.n	8005bbe <f_stat+0xb6>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8005c10:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 8005c14:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005c18:	4553      	cmp	r3, sl
 8005c1a:	d005      	beq.n	8005c28 <f_stat+0x120>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8005c1c:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
 8005c20:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8005c24:	4553      	cmp	r3, sl
 8005c26:	d1ca      	bne.n	8005bbe <f_stat+0xb6>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8005c28:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
 8005c2c:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
 8005c30:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005c34:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005c38:	d1c1      	bne.n	8005bbe <f_stat+0xb6>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8005c3a:	f895 104b 	ldrb.w	r1, [r5, #75]	; 0x4b
 8005c3e:	f895 304a 	ldrb.w	r3, [r5, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 8005c42:	f895 e044 	ldrb.w	lr, [r5, #68]	; 0x44
 8005c46:	f885 e003 	strb.w	lr, [r5, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8005c4a:	ea53 2301 	orrs.w	r3, r3, r1, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8005c4e:	bf18      	it	ne
 8005c50:	4619      	movne	r1, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8005c52:	f10e 33ff 	add.w	r3, lr, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8005c56:	bf08      	it	eq
 8005c58:	6da9      	ldreq	r1, [r5, #88]	; 0x58
	fs->fsize = fasize;
 8005c5a:	61e9      	str	r1, [r5, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8005c5c:	2b01      	cmp	r3, #1
 8005c5e:	d8ae      	bhi.n	8005bbe <f_stat+0xb6>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 8005c60:	f895 9041 	ldrb.w	r9, [r5, #65]	; 0x41
 8005c64:	f885 9002 	strb.w	r9, [r5, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8005c68:	f1b9 0f00 	cmp.w	r9, #0
 8005c6c:	d0a7      	beq.n	8005bbe <f_stat+0xb6>
 8005c6e:	f109 33ff 	add.w	r3, r9, #4294967295
 8005c72:	ea13 0f09 	tst.w	r3, r9
 8005c76:	d1a2      	bne.n	8005bbe <f_stat+0xb6>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8005c78:	f895 3046 	ldrb.w	r3, [r5, #70]	; 0x46
 8005c7c:	f895 c045 	ldrb.w	ip, [r5, #69]	; 0x45
 8005c80:	ea4c 2c03 	orr.w	ip, ip, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8005c84:	f01c 0f0f 	tst.w	ip, #15
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8005c88:	f8a5 c008 	strh.w	ip, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8005c8c:	d197      	bne.n	8005bbe <f_stat+0xb6>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8005c8e:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 8005c92:	f895 3047 	ldrb.w	r3, [r5, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8005c96:	f895 0043 	ldrb.w	r0, [r5, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8005c9a:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8005c9e:	f895 2042 	ldrb.w	r2, [r5, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8005ca2:	bf08      	it	eq
 8005ca4:	6d6b      	ldreq	r3, [r5, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 8005ca6:	ea52 2200 	orrs.w	r2, r2, r0, lsl #8
 8005caa:	d088      	beq.n	8005bbe <f_stat+0xb6>
	fasize *= b;										/* Number of sectors for FAT area */
 8005cac:	fb01 fe0e 	mul.w	lr, r1, lr
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8005cb0:	eb02 101c 	add.w	r0, r2, ip, lsr #4
 8005cb4:	4470      	add	r0, lr
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8005cb6:	4298      	cmp	r0, r3
 8005cb8:	d881      	bhi.n	8005bbe <f_stat+0xb6>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8005cba:	1a1b      	subs	r3, r3, r0
 8005cbc:	fbb3 f3f9 	udiv	r3, r3, r9
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8005cc0:	2b00      	cmp	r3, #0
 8005cc2:	f43f af7c 	beq.w	8005bbe <f_stat+0xb6>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8005cc6:	f640 79f5 	movw	r9, #4085	; 0xff5
 8005cca:	454b      	cmp	r3, r9
 8005ccc:	d962      	bls.n	8005d94 <f_stat+0x28c>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8005cce:	f64f 79f5 	movw	r9, #65525	; 0xfff5
 8005cd2:	454b      	cmp	r3, r9
 8005cd4:	d940      	bls.n	8005d58 <f_stat+0x250>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005cd6:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005cd8:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8005cda:	4458      	add	r0, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005cdc:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005cde:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8005ce0:	62e8      	str	r0, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8005ce2:	f8c5 b020 	str.w	fp, [r5, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8005ce6:	f1bc 0f00 	cmp.w	ip, #0
 8005cea:	f47f af68 	bne.w	8005bbe <f_stat+0xb6>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 8005cee:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005cf0:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8005cf4:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 8005cf6:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005cf8:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
 8005cfc:	f4ff af5f 	bcc.w	8005bbe <f_stat+0xb6>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8005d00:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 8005d04:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
	fs->last_clust = 0;
 8005d08:	f8c5 c00c 	str.w	ip, [r5, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8005d0c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8005d10:	445a      	add	r2, fp
	fs->free_clust = 0xFFFFFFFF;
 8005d12:	f04f 33ff 	mov.w	r3, #4294967295
 8005d16:	612b      	str	r3, [r5, #16]
	 	fs->fsi_flag = 0;
 8005d18:	f885 c005 	strb.w	ip, [r5, #5]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8005d1c:	4641      	mov	r1, r8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8005d1e:	616a      	str	r2, [r5, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8005d20:	2301      	movs	r3, #1
 8005d22:	7868      	ldrb	r0, [r5, #1]
 8005d24:	f7fc fd4a 	bl	80027bc <disk_read>
 8005d28:	b948      	cbnz	r0, 8005d3e <f_stat+0x236>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8005d2a:	f895 1233 	ldrb.w	r1, [r5, #563]	; 0x233
 8005d2e:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8005d32:	f64a 2255 	movw	r2, #43605	; 0xaa55
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8005d36:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8005d3a:	4293      	cmp	r3, r2
 8005d3c:	d04b      	beq.n	8005dd6 <f_stat+0x2ce>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8005d3e:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 8005d40:	88ba      	ldrh	r2, [r7, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 8005d42:	702b      	strb	r3, [r5, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8005d44:	1c53      	adds	r3, r2, #1
 8005d46:	b29b      	uxth	r3, r3
	fs->winsect = 0;		/* Invalidate sector cache */
 8005d48:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* File system mount ID */
 8005d4a:	80bb      	strh	r3, [r7, #4]
 8005d4c:	80eb      	strh	r3, [r5, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 8005d4e:	632a      	str	r2, [r5, #48]	; 0x30
	fs->wflag = 0;
 8005d50:	712a      	strb	r2, [r5, #4]
 8005d52:	e6ed      	b.n	8005b30 <f_stat+0x28>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 8005d54:	4683      	mov	fp, r0
 8005d56:	e767      	b.n	8005c28 <f_stat+0x120>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005d58:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005d5a:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8005d5c:	4458      	add	r0, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005d5e:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005d60:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8005d62:	62e8      	str	r0, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8005d64:	f8c5 b020 	str.w	fp, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8005d68:	f1bc 0f00 	cmp.w	ip, #0
 8005d6c:	f43f af27 	beq.w	8005bbe <f_stat+0xb6>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005d70:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005d72:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005d76:	4472      	add	r2, lr
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005d78:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005d7c:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005d7e:	f4ff af1e 	bcc.w	8005bbe <f_stat+0xb6>
	fs->last_clust = 0;
 8005d82:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8005d84:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8005d88:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 8005d8a:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 8005d8c:	2302      	movs	r3, #2
 8005d8e:	e7d7      	b.n	8005d40 <f_stat+0x238>
		p += 2; *path = p;				/* Return pointer to the path name */
 8005d90:	3402      	adds	r4, #2
 8005d92:	e6c2      	b.n	8005b1a <f_stat+0x12>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005d94:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005d96:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8005d98:	4458      	add	r0, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005d9a:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005d9c:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8005d9e:	62e8      	str	r0, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8005da0:	f8c5 b020 	str.w	fp, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8005da4:	f1bc 0f00 	cmp.w	ip, #0
 8005da8:	f43f af09 	beq.w	8005bbe <f_stat+0xb6>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005dac:	f003 0001 	and.w	r0, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005db0:	f200 10ff 	addw	r0, r0, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005db4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005db8:	eb00 0353 	add.w	r3, r0, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005dbc:	4472      	add	r2, lr
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005dbe:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005dc2:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8005dc4:	f4ff aefb 	bcc.w	8005bbe <f_stat+0xb6>
	fs->last_clust = 0;
 8005dc8:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8005dca:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8005dce:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 8005dd0:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 8005dd2:	2301      	movs	r3, #1
 8005dd4:	e7b4      	b.n	8005d40 <f_stat+0x238>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8005dd6:	4b0c      	ldr	r3, [pc, #48]	; (8005e08 <f_stat+0x300>)
 8005dd8:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8005dda:	429a      	cmp	r2, r3
 8005ddc:	d1af      	bne.n	8005d3e <f_stat+0x236>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8005dde:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 8005de2:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8005de6:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
 8005dea:	3320      	adds	r3, #32
 8005dec:	429a      	cmp	r2, r3
 8005dee:	d1a6      	bne.n	8005d3e <f_stat+0x236>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8005df0:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8005df4:	f8d5 2220 	ldr.w	r2, [r5, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8005df8:	612b      	str	r3, [r5, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8005dfa:	60ea      	str	r2, [r5, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8005dfc:	2303      	movs	r3, #3
 8005dfe:	e79f      	b.n	8005d40 <f_stat+0x238>
 8005e00:	20002128 	.word	0x20002128
 8005e04:	ffffaa55 	.word	0xffffaa55
 8005e08:	41615252 	.word	0x41615252
 8005e0c:	00544146 	.word	0x00544146

08005e10 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Path name of the logical drive number */
	DWORD *nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
 8005e10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005e14:	b085      	sub	sp, #20
 8005e16:	ab04      	add	r3, sp, #16
 8005e18:	9101      	str	r1, [sp, #4]
 8005e1a:	f843 0d04 	str.w	r0, [r3, #-4]!
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
 8005e1e:	4611      	mov	r1, r2
{
 8005e20:	4614      	mov	r4, r2
	res = chk_mounted(&path, fatfs, 0);
 8005e22:	4618      	mov	r0, r3
 8005e24:	2200      	movs	r2, #0
 8005e26:	f7fc fdd9 	bl	80029dc <chk_mounted>
	fs = *fatfs;
	if (res == FR_OK) {
 8005e2a:	4683      	mov	fp, r0
 8005e2c:	bb68      	cbnz	r0, 8005e8a <f_getfree+0x7a>
	fs = *fatfs;
 8005e2e:	6826      	ldr	r6, [r4, #0]
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
 8005e30:	69b4      	ldr	r4, [r6, #24]
 8005e32:	6933      	ldr	r3, [r6, #16]
 8005e34:	1ea2      	subs	r2, r4, #2
 8005e36:	4293      	cmp	r3, r2
 8005e38:	d92b      	bls.n	8005e92 <f_getfree+0x82>
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
 8005e3a:	f896 8000 	ldrb.w	r8, [r6]
			n = 0;
			if (fat == FS_FAT12) {
 8005e3e:	f1b8 0f01 	cmp.w	r8, #1
 8005e42:	d072      	beq.n	8005f2a <f_getfree+0x11a>
 8005e44:	f106 0234 	add.w	r2, r6, #52	; 0x34
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
 8005e48:	f8d6 a024 	ldr.w	sl, [r6, #36]	; 0x24
 8005e4c:	9002      	str	r0, [sp, #8]
				i = 0; p = 0;
 8005e4e:	4603      	mov	r3, r0
 8005e50:	4605      	mov	r5, r0
 8005e52:	4681      	mov	r9, r0
 8005e54:	4693      	mov	fp, r2
				do {
					if (!i) {
 8005e56:	b315      	cbz	r5, 8005e9e <f_getfree+0x8e>
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
 8005e58:	f1b8 0f02 	cmp.w	r8, #2
 8005e5c:	d038      	beq.n	8005ed0 <f_getfree+0xc0>
						if (LD_WORD(p) == 0) n++;
						p += 2; i -= 2;
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 8005e5e:	681a      	ldr	r2, [r3, #0]
 8005e60:	f032 4270 	bics.w	r2, r2, #4026531840	; 0xf0000000
 8005e64:	bf08      	it	eq
 8005e66:	f109 0901 	addeq.w	r9, r9, #1
						p += 4; i -= 4;
 8005e6a:	3304      	adds	r3, #4
 8005e6c:	3d04      	subs	r5, #4
					}
				} while (--clst);
 8005e6e:	3c01      	subs	r4, #1
 8005e70:	d1f1      	bne.n	8005e56 <f_getfree+0x46>
 8005e72:	f8dd b008 	ldr.w	fp, [sp, #8]
 8005e76:	464f      	mov	r7, r9
			}
			fs->free_clust = n;
			if (fat == FS_FAT32) fs->fsi_flag = 1;
 8005e78:	f1b8 0f03 	cmp.w	r8, #3
 8005e7c:	bf08      	it	eq
 8005e7e:	2301      	moveq	r3, #1
			fs->free_clust = n;
 8005e80:	6137      	str	r7, [r6, #16]
			if (fat == FS_FAT32) fs->fsi_flag = 1;
 8005e82:	bf08      	it	eq
 8005e84:	7173      	strbeq	r3, [r6, #5]
			*nclst = n;
 8005e86:	9b01      	ldr	r3, [sp, #4]
 8005e88:	601f      	str	r7, [r3, #0]
		}
	}
	LEAVE_FF(fs, res);
}
 8005e8a:	4658      	mov	r0, fp
 8005e8c:	b005      	add	sp, #20
 8005e8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			*nclst = fs->free_clust;
 8005e92:	9a01      	ldr	r2, [sp, #4]
}
 8005e94:	4658      	mov	r0, fp
			*nclst = fs->free_clust;
 8005e96:	6013      	str	r3, [r2, #0]
}
 8005e98:	b005      	add	sp, #20
 8005e9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (sector != fs->winsect) {	/* Changed current window */
 8005e9e:	6b37      	ldr	r7, [r6, #48]	; 0x30
						res = move_window(fs, sect++);
 8005ea0:	f10a 0301 	add.w	r3, sl, #1
	if (sector != fs->winsect) {	/* Changed current window */
 8005ea4:	45ba      	cmp	sl, r7
						res = move_window(fs, sect++);
 8005ea6:	9300      	str	r3, [sp, #0]
	if (sector != fs->winsect) {	/* Changed current window */
 8005ea8:	d00a      	beq.n	8005ec0 <f_getfree+0xb0>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8005eaa:	7933      	ldrb	r3, [r6, #4]
 8005eac:	b9d3      	cbnz	r3, 8005ee4 <f_getfree+0xd4>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8005eae:	2301      	movs	r3, #1
 8005eb0:	4652      	mov	r2, sl
 8005eb2:	4659      	mov	r1, fp
 8005eb4:	7870      	ldrb	r0, [r6, #1]
 8005eb6:	f7fc fc81 	bl	80027bc <disk_read>
 8005eba:	b9d0      	cbnz	r0, 8005ef2 <f_getfree+0xe2>
		fs->winsect = sector;
 8005ebc:	f8c6 a030 	str.w	sl, [r6, #48]	; 0x30
					if (fat == FS_FAT16) {
 8005ec0:	f1b8 0f02 	cmp.w	r8, #2
						res = move_window(fs, sect++);
 8005ec4:	f8dd a000 	ldr.w	sl, [sp]
						p = fs->win;
 8005ec8:	465b      	mov	r3, fp
						i = SS(fs);
 8005eca:	f44f 7500 	mov.w	r5, #512	; 0x200
					if (fat == FS_FAT16) {
 8005ece:	d1c6      	bne.n	8005e5e <f_getfree+0x4e>
						if (LD_WORD(p) == 0) n++;
 8005ed0:	7859      	ldrb	r1, [r3, #1]
 8005ed2:	781a      	ldrb	r2, [r3, #0]
 8005ed4:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8005ed8:	bf08      	it	eq
 8005eda:	f109 0901 	addeq.w	r9, r9, #1
						p += 2; i -= 2;
 8005ede:	3302      	adds	r3, #2
 8005ee0:	3d02      	subs	r5, #2
 8005ee2:	e7c4      	b.n	8005e6e <f_getfree+0x5e>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8005ee4:	2301      	movs	r3, #1
 8005ee6:	463a      	mov	r2, r7
 8005ee8:	4659      	mov	r1, fp
 8005eea:	7870      	ldrb	r0, [r6, #1]
 8005eec:	f7fc fc88 	bl	8002800 <disk_write>
 8005ef0:	b118      	cbz	r0, 8005efa <f_getfree+0xea>
 8005ef2:	464f      	mov	r7, r9
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 8005ef4:	f04f 0b01 	mov.w	fp, #1
 8005ef8:	e7be      	b.n	8005e78 <f_getfree+0x68>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8005efa:	6a72      	ldr	r2, [r6, #36]	; 0x24
		fs->wflag = 0;
 8005efc:	7135      	strb	r5, [r6, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8005efe:	4297      	cmp	r7, r2
 8005f00:	d3d5      	bcc.n	8005eae <f_getfree+0x9e>
 8005f02:	69f3      	ldr	r3, [r6, #28]
 8005f04:	441a      	add	r2, r3
 8005f06:	4297      	cmp	r7, r2
 8005f08:	d2d1      	bcs.n	8005eae <f_getfree+0x9e>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8005f0a:	78f5      	ldrb	r5, [r6, #3]
 8005f0c:	2d01      	cmp	r5, #1
 8005f0e:	d801      	bhi.n	8005f14 <f_getfree+0x104>
 8005f10:	e7cd      	b.n	8005eae <f_getfree+0x9e>
 8005f12:	69f3      	ldr	r3, [r6, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8005f14:	7870      	ldrb	r0, [r6, #1]
				wsect += fs->fsize;
 8005f16:	441f      	add	r7, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8005f18:	3d01      	subs	r5, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 8005f1a:	463a      	mov	r2, r7
 8005f1c:	2301      	movs	r3, #1
 8005f1e:	4659      	mov	r1, fp
 8005f20:	f7fc fc6e 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8005f24:	2d01      	cmp	r5, #1
 8005f26:	d1f4      	bne.n	8005f12 <f_getfree+0x102>
 8005f28:	e7c1      	b.n	8005eae <f_getfree+0x9e>
 8005f2a:	2502      	movs	r5, #2
 8005f2c:	4607      	mov	r7, r0
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8005f2e:	42a5      	cmp	r5, r4
 8005f30:	4629      	mov	r1, r5
 8005f32:	4630      	mov	r0, r6
				} while (++clst < fs->n_fatent);
 8005f34:	f105 0501 	add.w	r5, r5, #1
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8005f38:	d20c      	bcs.n	8005f54 <f_getfree+0x144>
 8005f3a:	f7fd f9f7 	bl	800332c <get_fat.part.6>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 8005f3e:	1c43      	adds	r3, r0, #1
 8005f40:	d00c      	beq.n	8005f5c <f_getfree+0x14c>
					if (stat == 1) { res = FR_INT_ERR; break; }
 8005f42:	2801      	cmp	r0, #1
 8005f44:	d006      	beq.n	8005f54 <f_getfree+0x144>
					if (stat == 0) n++;
 8005f46:	b900      	cbnz	r0, 8005f4a <f_getfree+0x13a>
 8005f48:	3701      	adds	r7, #1
				} while (++clst < fs->n_fatent);
 8005f4a:	69b4      	ldr	r4, [r6, #24]
 8005f4c:	42a5      	cmp	r5, r4
 8005f4e:	d203      	bcs.n	8005f58 <f_getfree+0x148>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8005f50:	2d01      	cmp	r5, #1
 8005f52:	d8ec      	bhi.n	8005f2e <f_getfree+0x11e>
					if (stat == 1) { res = FR_INT_ERR; break; }
 8005f54:	f04f 0b02 	mov.w	fp, #2
			fs->free_clust = n;
 8005f58:	6137      	str	r7, [r6, #16]
 8005f5a:	e794      	b.n	8005e86 <f_getfree+0x76>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 8005f5c:	f04f 0b01 	mov.w	fp, #1
 8005f60:	e7fa      	b.n	8005f58 <f_getfree+0x148>
 8005f62:	bf00      	nop

08005f64 <f_truncate>:
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8005f64:	b130      	cbz	r0, 8005f74 <f_truncate+0x10>
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
 8005f66:	b538      	push	{r3, r4, r5, lr}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8005f68:	6803      	ldr	r3, [r0, #0]
 8005f6a:	b10b      	cbz	r3, 8005f70 <f_truncate+0xc>
 8005f6c:	781a      	ldrb	r2, [r3, #0]
 8005f6e:	b91a      	cbnz	r2, 8005f78 <f_truncate+0x14>
		return FR_INVALID_OBJECT;
 8005f70:	2009      	movs	r0, #9
 8005f72:	bd38      	pop	{r3, r4, r5, pc}
 8005f74:	2009      	movs	r0, #9
 8005f76:	4770      	bx	lr
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8005f78:	88d9      	ldrh	r1, [r3, #6]
 8005f7a:	8882      	ldrh	r2, [r0, #4]
 8005f7c:	4291      	cmp	r1, r2
 8005f7e:	d1f7      	bne.n	8005f70 <f_truncate+0xc>
 8005f80:	4604      	mov	r4, r0
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8005f82:	7858      	ldrb	r0, [r3, #1]
 8005f84:	f7fc fc00 	bl	8002788 <disk_status>
 8005f88:	07c5      	lsls	r5, r0, #31
 8005f8a:	d501      	bpl.n	8005f90 <f_truncate+0x2c>
		return FR_NOT_READY;
 8005f8c:	2003      	movs	r0, #3
 8005f8e:	bd38      	pop	{r3, r4, r5, pc}
	DWORD ncl;


	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
 8005f90:	79a3      	ldrb	r3, [r4, #6]
 8005f92:	061a      	lsls	r2, r3, #24
 8005f94:	d42a      	bmi.n	8005fec <f_truncate+0x88>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
 8005f96:	0798      	lsls	r0, r3, #30
 8005f98:	d401      	bmi.n	8005f9e <f_truncate+0x3a>
				res = FR_DENIED;
 8005f9a:	2007      	movs	r0, #7
 8005f9c:	bd38      	pop	{r3, r4, r5, pc}
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
 8005f9e:	68a2      	ldr	r2, [r4, #8]
 8005fa0:	68e1      	ldr	r1, [r4, #12]
 8005fa2:	4291      	cmp	r1, r2
 8005fa4:	d914      	bls.n	8005fd0 <f_truncate+0x6c>
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
			fp->flag |= FA__WRITTEN;
 8005fa6:	f043 0320 	orr.w	r3, r3, #32
 8005faa:	71a3      	strb	r3, [r4, #6]
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 8005fac:	60e2      	str	r2, [r4, #12]
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 8005fae:	b98a      	cbnz	r2, 8005fd4 <f_truncate+0x70>
				res = remove_chain(fp->fs, fp->sclust);
 8005fb0:	6921      	ldr	r1, [r4, #16]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8005fb2:	2901      	cmp	r1, #1
 8005fb4:	d903      	bls.n	8005fbe <f_truncate+0x5a>
				res = remove_chain(fp->fs, fp->sclust);
 8005fb6:	6820      	ldr	r0, [r4, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8005fb8:	6983      	ldr	r3, [r0, #24]
 8005fba:	4299      	cmp	r1, r3
 8005fbc:	d320      	bcc.n	8006000 <f_truncate+0x9c>
		res = FR_INT_ERR;
 8005fbe:	2002      	movs	r0, #2
				fp->sclust = 0;
 8005fc0:	2300      	movs	r3, #0
 8005fc2:	6123      	str	r3, [r4, #16]
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
 8005fc4:	b120      	cbz	r0, 8005fd0 <f_truncate+0x6c>
 8005fc6:	79a3      	ldrb	r3, [r4, #6]
 8005fc8:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8005fcc:	71a3      	strb	r3, [r4, #6]
 8005fce:	bd38      	pop	{r3, r4, r5, pc}
		return FR_NOT_READY;
 8005fd0:	2000      	movs	r0, #0
 8005fd2:	bd38      	pop	{r3, r4, r5, pc}
				ncl = get_fat(fp->fs, fp->clust);
 8005fd4:	6961      	ldr	r1, [r4, #20]
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8005fd6:	2901      	cmp	r1, #1
 8005fd8:	d903      	bls.n	8005fe2 <f_truncate+0x7e>
				ncl = get_fat(fp->fs, fp->clust);
 8005fda:	6820      	ldr	r0, [r4, #0]
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8005fdc:	6982      	ldr	r2, [r0, #24]
 8005fde:	4291      	cmp	r1, r2
 8005fe0:	d306      	bcc.n	8005ff0 <f_truncate+0x8c>
		if (res != FR_OK) fp->flag |= FA__ERROR;
 8005fe2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8005fe6:	71a3      	strb	r3, [r4, #6]
				if (ncl == 1) res = FR_INT_ERR;
 8005fe8:	2002      	movs	r0, #2
 8005fea:	bd38      	pop	{r3, r4, r5, pc}
			res = FR_INT_ERR;
 8005fec:	2002      	movs	r0, #2
	}

	LEAVE_FF(fp->fs, res);
 8005fee:	bd38      	pop	{r3, r4, r5, pc}
 8005ff0:	f7fd f99c 	bl	800332c <get_fat.part.6>
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8005ff4:	1c41      	adds	r1, r0, #1
 8005ff6:	4605      	mov	r5, r0
 8005ff8:	d105      	bne.n	8006006 <f_truncate+0xa2>
 8005ffa:	79a3      	ldrb	r3, [r4, #6]
 8005ffc:	2001      	movs	r0, #1
 8005ffe:	e7e3      	b.n	8005fc8 <f_truncate+0x64>
 8006000:	f7fd f83c 	bl	800307c <remove_chain.part.10>
 8006004:	e7dc      	b.n	8005fc0 <f_truncate+0x5c>
				if (ncl == 1) res = FR_INT_ERR;
 8006006:	2801      	cmp	r0, #1
 8006008:	d008      	beq.n	800601c <f_truncate+0xb8>
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
 800600a:	6820      	ldr	r0, [r4, #0]
 800600c:	6983      	ldr	r3, [r0, #24]
 800600e:	42ab      	cmp	r3, r5
 8006010:	d9de      	bls.n	8005fd0 <f_truncate+0x6c>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
 8006012:	6961      	ldr	r1, [r4, #20]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8006014:	2901      	cmp	r1, #1
 8006016:	d901      	bls.n	800601c <f_truncate+0xb8>
 8006018:	428b      	cmp	r3, r1
 800601a:	d802      	bhi.n	8006022 <f_truncate+0xbe>
 800601c:	79a3      	ldrb	r3, [r4, #6]
		res = FR_INT_ERR;
 800601e:	2002      	movs	r0, #2
 8006020:	e7d2      	b.n	8005fc8 <f_truncate+0x64>
 8006022:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8006026:	f7fc fec5 	bl	8002db4 <put_fat.part.8>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 800602a:	2800      	cmp	r0, #0
 800602c:	d1cb      	bne.n	8005fc6 <f_truncate+0x62>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800602e:	2d01      	cmp	r5, #1
 8006030:	d9f4      	bls.n	800601c <f_truncate+0xb8>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 8006032:	6820      	ldr	r0, [r4, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8006034:	6983      	ldr	r3, [r0, #24]
 8006036:	429d      	cmp	r5, r3
 8006038:	d2f0      	bcs.n	800601c <f_truncate+0xb8>
 800603a:	4629      	mov	r1, r5
 800603c:	f7fd f81e 	bl	800307c <remove_chain.part.10>
 8006040:	e7c0      	b.n	8005fc4 <f_truncate+0x60>
 8006042:	bf00      	nop

08006044 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
 8006044:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	vol = p[0] - '0';					/* Is there a drive number? */
 8006048:	7803      	ldrb	r3, [r0, #0]
 800604a:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 800604c:	2b09      	cmp	r3, #9
{
 800604e:	b092      	sub	sp, #72	; 0x48
 8006050:	4604      	mov	r4, r0
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006052:	d90f      	bls.n	8006074 <f_unlink+0x30>
	fs = FatFs[vol];					/* Get corresponding file system object */
 8006054:	4ebf      	ldr	r6, [pc, #764]	; (8006354 <f_unlink+0x310>)
 8006056:	6835      	ldr	r5, [r6, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8006058:	b315      	cbz	r5, 80060a0 <f_unlink+0x5c>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
 800605a:	9504      	str	r5, [sp, #16]
	if (fs->fs_type) {					/* If the volume has been mounted */
 800605c:	782b      	ldrb	r3, [r5, #0]
 800605e:	b19b      	cbz	r3, 8006088 <f_unlink+0x44>
		stat = disk_status(fs->drv);
 8006060:	7868      	ldrb	r0, [r5, #1]
 8006062:	f7fc fb91 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 8006066:	07c7      	lsls	r7, r0, #31
 8006068:	d40e      	bmi.n	8006088 <f_unlink+0x44>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 800606a:	0740      	lsls	r0, r0, #29
 800606c:	f140 80f0 	bpl.w	8006250 <f_unlink+0x20c>
				return FR_WRITE_PROTECTED;
 8006070:	200a      	movs	r0, #10
 8006072:	e006      	b.n	8006082 <f_unlink+0x3e>
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006074:	7842      	ldrb	r2, [r0, #1]
 8006076:	2a3a      	cmp	r2, #58	; 0x3a
 8006078:	d1ec      	bne.n	8006054 <f_unlink+0x10>
		return FR_INVALID_DRIVE;
 800607a:	200b      	movs	r0, #11
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 800607c:	2b00      	cmp	r3, #0
 800607e:	f000 824f 	beq.w	8006520 <f_unlink+0x4dc>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
 8006082:	b012      	add	sp, #72	; 0x48
 8006084:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 8006088:	2000      	movs	r0, #0
 800608a:	7028      	strb	r0, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800608c:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 800608e:	f7fc fb61 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8006092:	07c1      	lsls	r1, r0, #31
 8006094:	f140 8169 	bpl.w	800636a <f_unlink+0x326>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8006098:	2003      	movs	r0, #3
}
 800609a:	b012      	add	sp, #72	; 0x48
 800609c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80060a0:	200c      	movs	r0, #12
 80060a2:	e7ee      	b.n	8006082 <f_unlink+0x3e>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 80060a4:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 80060a8:	f8df a2ac 	ldr.w	sl, [pc, #684]	; 8006358 <f_unlink+0x314>
 80060ac:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80060b0:	4553      	cmp	r3, sl
 80060b2:	f000 821a 	beq.w	80064ea <f_unlink+0x4a6>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 80060b6:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
 80060ba:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80060be:	4553      	cmp	r3, sl
 80060c0:	f000 8213 	beq.w	80064ea <f_unlink+0x4a6>
		if (tbl[4]) {						/* Is the partition existing? */
 80060c4:	f895 31f6 	ldrb.w	r3, [r5, #502]	; 0x1f6
 80060c8:	2b00      	cmp	r3, #0
 80060ca:	f000 81e6 	beq.w	800649a <f_unlink+0x456>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 80060ce:	f8d5 71fa 	ldr.w	r7, [r5, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 80060d2:	7868      	ldrb	r0, [r5, #1]
 80060d4:	463a      	mov	r2, r7
 80060d6:	2301      	movs	r3, #1
 80060d8:	4641      	mov	r1, r8
 80060da:	f7fc fb6f 	bl	80027bc <disk_read>
 80060de:	2800      	cmp	r0, #0
 80060e0:	f040 8150 	bne.w	8006384 <f_unlink+0x340>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 80060e4:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 80060e8:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
 80060ec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80060f0:	b21b      	sxth	r3, r3
 80060f2:	454b      	cmp	r3, r9
 80060f4:	f040 81d1 	bne.w	800649a <f_unlink+0x456>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 80060f8:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 80060fc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8006100:	4553      	cmp	r3, sl
 8006102:	d007      	beq.n	8006114 <f_unlink+0xd0>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8006104:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8006108:	4a93      	ldr	r2, [pc, #588]	; (8006358 <f_unlink+0x314>)
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 800610a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 800610e:	4293      	cmp	r3, r2
 8006110:	f040 81c3 	bne.w	800649a <f_unlink+0x456>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8006114:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
 8006118:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
 800611c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006120:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006124:	f040 81b9 	bne.w	800649a <f_unlink+0x456>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8006128:	f895 004b 	ldrb.w	r0, [r5, #75]	; 0x4b
 800612c:	f895 304a 	ldrb.w	r3, [r5, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 8006130:	f895 c044 	ldrb.w	ip, [r5, #68]	; 0x44
 8006134:	f885 c003 	strb.w	ip, [r5, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8006138:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 800613c:	bf18      	it	ne
 800613e:	4618      	movne	r0, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8006140:	f10c 33ff 	add.w	r3, ip, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8006144:	bf08      	it	eq
 8006146:	6da8      	ldreq	r0, [r5, #88]	; 0x58
	fs->fsize = fasize;
 8006148:	61e8      	str	r0, [r5, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 800614a:	2b01      	cmp	r3, #1
 800614c:	f200 81a5 	bhi.w	800649a <f_unlink+0x456>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 8006150:	f895 9041 	ldrb.w	r9, [r5, #65]	; 0x41
 8006154:	f885 9002 	strb.w	r9, [r5, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8006158:	f1b9 0f00 	cmp.w	r9, #0
 800615c:	f000 819d 	beq.w	800649a <f_unlink+0x456>
 8006160:	f109 33ff 	add.w	r3, r9, #4294967295
 8006164:	ea13 0f09 	tst.w	r3, r9
 8006168:	f040 8197 	bne.w	800649a <f_unlink+0x456>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 800616c:	f895 3046 	ldrb.w	r3, [r5, #70]	; 0x46
 8006170:	f895 e045 	ldrb.w	lr, [r5, #69]	; 0x45
 8006174:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8006178:	f01e 0f0f 	tst.w	lr, #15
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 800617c:	f8a5 e008 	strh.w	lr, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8006180:	f040 818b 	bne.w	800649a <f_unlink+0x456>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8006184:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 8006188:	f895 3047 	ldrb.w	r3, [r5, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 800618c:	f895 1043 	ldrb.w	r1, [r5, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8006190:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8006194:	f895 2042 	ldrb.w	r2, [r5, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8006198:	bf08      	it	eq
 800619a:	6d6b      	ldreq	r3, [r5, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 800619c:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 80061a0:	f000 817b 	beq.w	800649a <f_unlink+0x456>
	fasize *= b;										/* Number of sectors for FAT area */
 80061a4:	fb00 fc0c 	mul.w	ip, r0, ip
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 80061a8:	eb02 111e 	add.w	r1, r2, lr, lsr #4
 80061ac:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 80061ae:	4299      	cmp	r1, r3
 80061b0:	f200 8173 	bhi.w	800649a <f_unlink+0x456>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 80061b4:	1a5b      	subs	r3, r3, r1
 80061b6:	fbb3 f3f9 	udiv	r3, r3, r9
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 80061ba:	2b00      	cmp	r3, #0
 80061bc:	f000 816d 	beq.w	800649a <f_unlink+0x456>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 80061c0:	f640 79f5 	movw	r9, #4085	; 0xff5
 80061c4:	454b      	cmp	r3, r9
 80061c6:	f240 81ad 	bls.w	8006524 <f_unlink+0x4e0>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 80061ca:	f64f 79f5 	movw	r9, #65525	; 0xfff5
 80061ce:	454b      	cmp	r3, r9
 80061d0:	f240 818d 	bls.w	80064ee <f_unlink+0x4aa>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80061d4:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80061d6:	443a      	add	r2, r7
	fs->database = bsect + sysect;						/* Data start sector */
 80061d8:	4439      	add	r1, r7
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80061da:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80061dc:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 80061de:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 80061e0:	622f      	str	r7, [r5, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 80061e2:	f1be 0f00 	cmp.w	lr, #0
 80061e6:	f040 8158 	bne.w	800649a <f_unlink+0x456>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 80061ea:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80061ec:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 80061f0:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 80061f2:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 80061f4:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 80061f8:	f0c0 814f 	bcc.w	800649a <f_unlink+0x456>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 80061fc:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 8006200:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
	fs->last_clust = 0;
 8006204:	f8c5 e00c 	str.w	lr, [r5, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8006208:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 800620c:	443a      	add	r2, r7
	fs->free_clust = 0xFFFFFFFF;
 800620e:	f04f 33ff 	mov.w	r3, #4294967295
 8006212:	612b      	str	r3, [r5, #16]
	 	fs->fsi_flag = 0;
 8006214:	f885 e005 	strb.w	lr, [r5, #5]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006218:	4641      	mov	r1, r8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 800621a:	616a      	str	r2, [r5, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 800621c:	2301      	movs	r3, #1
 800621e:	7868      	ldrb	r0, [r5, #1]
 8006220:	f7fc facc 	bl	80027bc <disk_read>
 8006224:	b950      	cbnz	r0, 800623c <f_unlink+0x1f8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006226:	f895 1233 	ldrb.w	r1, [r5, #563]	; 0x233
 800622a:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 800622e:	f64a 2255 	movw	r2, #43605	; 0xaa55
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006232:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006236:	4293      	cmp	r3, r2
 8006238:	f000 8192 	beq.w	8006560 <f_unlink+0x51c>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 800623c:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 800623e:	88b2      	ldrh	r2, [r6, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 8006240:	702b      	strb	r3, [r5, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8006242:	1c53      	adds	r3, r2, #1
 8006244:	b29b      	uxth	r3, r3
	fs->winsect = 0;		/* Invalidate sector cache */
 8006246:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* File system mount ID */
 8006248:	80b3      	strh	r3, [r6, #4]
 800624a:	80eb      	strh	r3, [r5, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 800624c:	632a      	str	r2, [r5, #48]	; 0x30
	fs->wflag = 0;
 800624e:	712a      	strb	r2, [r5, #4]
		INIT_BUF(dj);
 8006250:	ab01      	add	r3, sp, #4
		res = follow_path(&dj, path);		/* Follow the file path */
 8006252:	4621      	mov	r1, r4
 8006254:	a804      	add	r0, sp, #16
		INIT_BUF(dj);
 8006256:	930a      	str	r3, [sp, #40]	; 0x28
		res = follow_path(&dj, path);		/* Follow the file path */
 8006258:	f7fd ff20 	bl	800409c <follow_path>
		if (res == FR_OK) {					/* The object is accessible */
 800625c:	2800      	cmp	r0, #0
 800625e:	f47f af10 	bne.w	8006082 <f_unlink+0x3e>
			dir = dj.dir;
 8006262:	9b09      	ldr	r3, [sp, #36]	; 0x24
			if (!dir) {
 8006264:	2b00      	cmp	r3, #0
 8006266:	f000 80a0 	beq.w	80063aa <f_unlink+0x366>
				if (dir[DIR_Attr] & AM_RDO)
 800626a:	7ada      	ldrb	r2, [r3, #11]
					res = FR_DENIED;		/* Cannot remove R/O object */
 800626c:	f012 0f01 	tst.w	r2, #1
 8006270:	bf18      	it	ne
 8006272:	2007      	movne	r0, #7
	if (fs->fs_type == FS_FAT32)
 8006274:	9a04      	ldr	r2, [sp, #16]
	cl = LD_WORD(dir+DIR_FstClusLO);
 8006276:	7ed9      	ldrb	r1, [r3, #27]
	if (fs->fs_type == FS_FAT32)
 8006278:	7812      	ldrb	r2, [r2, #0]
	cl = LD_WORD(dir+DIR_FstClusLO);
 800627a:	7e9c      	ldrb	r4, [r3, #26]
	if (fs->fs_type == FS_FAT32)
 800627c:	2a03      	cmp	r2, #3
	cl = LD_WORD(dir+DIR_FstClusLO);
 800627e:	ea44 2401 	orr.w	r4, r4, r1, lsl #8
	if (fs->fs_type == FS_FAT32)
 8006282:	d06b      	beq.n	800635c <f_unlink+0x318>
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
 8006284:	2800      	cmp	r0, #0
 8006286:	f47f aefc 	bne.w	8006082 <f_unlink+0x3e>
 800628a:	7adb      	ldrb	r3, [r3, #11]
 800628c:	06da      	lsls	r2, r3, #27
 800628e:	d53c      	bpl.n	800630a <f_unlink+0x2c6>
				if (dclst < 2) {
 8006290:	2c01      	cmp	r4, #1
 8006292:	d979      	bls.n	8006388 <f_unlink+0x344>
 8006294:	ae04      	add	r6, sp, #16
 8006296:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8006298:	ad0b      	add	r5, sp, #44	; 0x2c
 800629a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800629c:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 80062a0:	e885 0007 	stmia.w	r5, {r0, r1, r2}
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 80062a4:	2102      	movs	r1, #2
 80062a6:	a80b      	add	r0, sp, #44	; 0x2c
					sdj.sclust = dclst;
 80062a8:	940d      	str	r4, [sp, #52]	; 0x34
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 80062aa:	f7fd f979 	bl	80035a0 <dir_sdi>
					if (res == FR_OK) {
 80062ae:	2800      	cmp	r0, #0
 80062b0:	f47f aee7 	bne.w	8006082 <f_unlink+0x3e>
	while (dj->sect) {
 80062b4:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 80062b6:	b337      	cbz	r7, 8006306 <f_unlink+0x2c2>
 80062b8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
	if (sector != fs->winsect) {	/* Changed current window */
 80062ba:	6b35      	ldr	r5, [r6, #48]	; 0x30
 80062bc:	42bd      	cmp	r5, r7
 80062be:	d00d      	beq.n	80062dc <f_unlink+0x298>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80062c0:	7933      	ldrb	r3, [r6, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80062c2:	f106 0834 	add.w	r8, r6, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80062c6:	2b00      	cmp	r3, #0
 80062c8:	d171      	bne.n	80063ae <f_unlink+0x36a>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80062ca:	4641      	mov	r1, r8
 80062cc:	2301      	movs	r3, #1
 80062ce:	463a      	mov	r2, r7
 80062d0:	7870      	ldrb	r0, [r6, #1]
 80062d2:	f7fc fa73 	bl	80027bc <disk_read>
 80062d6:	2800      	cmp	r0, #0
 80062d8:	d154      	bne.n	8006384 <f_unlink+0x340>
		fs->winsect = sector;
 80062da:	6337      	str	r7, [r6, #48]	; 0x30
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 80062dc:	9a10      	ldr	r2, [sp, #64]	; 0x40
		c = dir[DIR_Name];
 80062de:	7813      	ldrb	r3, [r2, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80062e0:	b18b      	cbz	r3, 8006306 <f_unlink+0x2c2>
		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid entry? */
 80062e2:	2be5      	cmp	r3, #229	; 0xe5
 80062e4:	d009      	beq.n	80062fa <f_unlink+0x2b6>
 80062e6:	2b2e      	cmp	r3, #46	; 0x2e
 80062e8:	d007      	beq.n	80062fa <f_unlink+0x2b6>
		a = dir[DIR_Attr] & AM_MASK;
 80062ea:	7ad3      	ldrb	r3, [r2, #11]
 80062ec:	f003 033f 	and.w	r3, r3, #63	; 0x3f
		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid entry? */
 80062f0:	2b0f      	cmp	r3, #15
 80062f2:	d002      	beq.n	80062fa <f_unlink+0x2b6>
 80062f4:	2b08      	cmp	r3, #8
 80062f6:	f040 80c2 	bne.w	800647e <f_unlink+0x43a>
	i = dj->index + 1;
 80062fa:	f8bd 5032 	ldrh.w	r5, [sp, #50]	; 0x32
 80062fe:	3501      	adds	r5, #1
 8006300:	b2ad      	uxth	r5, r5
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8006302:	2d00      	cmp	r5, #0
 8006304:	d142      	bne.n	800638c <f_unlink+0x348>
	if (res != FR_OK) dj->sect = 0;
 8006306:	2300      	movs	r3, #0
 8006308:	930f      	str	r3, [sp, #60]	; 0x3c
	res = dir_sdi(dj, dj->index);
 800630a:	a804      	add	r0, sp, #16
 800630c:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 8006310:	f7fd f946 	bl	80035a0 <dir_sdi>
	if (res == FR_OK) {
 8006314:	2800      	cmp	r0, #0
 8006316:	f47f aeb4 	bne.w	8006082 <f_unlink+0x3e>
		res = move_window(dj->fs, dj->sect);
 800631a:	9d04      	ldr	r5, [sp, #16]
 800631c:	9f08      	ldr	r7, [sp, #32]
	if (sector != fs->winsect) {	/* Changed current window */
 800631e:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 8006320:	42b7      	cmp	r7, r6
 8006322:	d00c      	beq.n	800633e <f_unlink+0x2fa>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8006324:	792b      	ldrb	r3, [r5, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8006326:	f105 0834 	add.w	r8, r5, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800632a:	2b00      	cmp	r3, #0
 800632c:	d171      	bne.n	8006412 <f_unlink+0x3ce>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800632e:	4641      	mov	r1, r8
 8006330:	2301      	movs	r3, #1
 8006332:	463a      	mov	r2, r7
 8006334:	7868      	ldrb	r0, [r5, #1]
 8006336:	f7fc fa41 	bl	80027bc <disk_read>
 800633a:	bb18      	cbnz	r0, 8006384 <f_unlink+0x340>
		fs->winsect = sector;
 800633c:	632f      	str	r7, [r5, #48]	; 0x30
			*dj->dir = DDE;			/* Mark the entry "deleted" */
 800633e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006340:	22e5      	movs	r2, #229	; 0xe5
 8006342:	701a      	strb	r2, [r3, #0]
			dj->fs->wflag = 1;
 8006344:	9804      	ldr	r0, [sp, #16]
 8006346:	2301      	movs	r3, #1
 8006348:	7103      	strb	r3, [r0, #4]
					if (dclst)				/* Remove the cluster chain if exist */
 800634a:	2c00      	cmp	r4, #0
 800634c:	d154      	bne.n	80063f8 <f_unlink+0x3b4>
					if (res == FR_OK) res = sync_fs(dj.fs);
 800634e:	f7fc fcbf 	bl	8002cd0 <sync_fs>
 8006352:	e696      	b.n	8006082 <f_unlink+0x3e>
 8006354:	20002128 	.word	0x20002128
 8006358:	00544146 	.word	0x00544146
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 800635c:	7d59      	ldrb	r1, [r3, #21]
 800635e:	7d1a      	ldrb	r2, [r3, #20]
 8006360:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8006364:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8006368:	e78c      	b.n	8006284 <f_unlink+0x240>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 800636a:	f010 0204 	ands.w	r2, r0, #4
 800636e:	f47f ae7f 	bne.w	8006070 <f_unlink+0x2c>
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8006372:	f105 0834 	add.w	r8, r5, #52	; 0x34
 8006376:	4641      	mov	r1, r8
 8006378:	2301      	movs	r3, #1
 800637a:	7868      	ldrb	r0, [r5, #1]
 800637c:	f7fc fa1e 	bl	80027bc <disk_read>
 8006380:	2800      	cmp	r0, #0
 8006382:	d07e      	beq.n	8006482 <f_unlink+0x43e>
						) res = FR_DENIED;
 8006384:	2001      	movs	r0, #1
	LEAVE_FF(dj.fs, res);
 8006386:	e67c      	b.n	8006082 <f_unlink+0x3e>
						) res = FR_DENIED;
 8006388:	2002      	movs	r0, #2
 800638a:	e67a      	b.n	8006082 <f_unlink+0x3e>
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 800638c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800638e:	2f00      	cmp	r7, #0
 8006390:	d0b9      	beq.n	8006306 <f_unlink+0x2c2>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 8006392:	f015 020f 	ands.w	r2, r5, #15
 8006396:	d061      	beq.n	800645c <f_unlink+0x418>
 8006398:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
	dj->index = i;
 800639a:	f8ad 5032 	strh.w	r5, [sp, #50]	; 0x32
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 800639e:	f106 0334 	add.w	r3, r6, #52	; 0x34
 80063a2:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80063a6:	9310      	str	r3, [sp, #64]	; 0x40
 80063a8:	e787      	b.n	80062ba <f_unlink+0x276>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
 80063aa:	2006      	movs	r0, #6
 80063ac:	e762      	b.n	8006274 <f_unlink+0x230>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80063ae:	4641      	mov	r1, r8
 80063b0:	2301      	movs	r3, #1
 80063b2:	462a      	mov	r2, r5
 80063b4:	7870      	ldrb	r0, [r6, #1]
 80063b6:	f7fc fa23 	bl	8002800 <disk_write>
 80063ba:	2800      	cmp	r0, #0
 80063bc:	d1e2      	bne.n	8006384 <f_unlink+0x340>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80063be:	6a72      	ldr	r2, [r6, #36]	; 0x24
		fs->wflag = 0;
 80063c0:	7130      	strb	r0, [r6, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80063c2:	4295      	cmp	r5, r2
 80063c4:	d381      	bcc.n	80062ca <f_unlink+0x286>
 80063c6:	69f3      	ldr	r3, [r6, #28]
 80063c8:	441a      	add	r2, r3
 80063ca:	4295      	cmp	r5, r2
 80063cc:	f4bf af7d 	bcs.w	80062ca <f_unlink+0x286>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80063d0:	f896 9003 	ldrb.w	r9, [r6, #3]
 80063d4:	f1b9 0f01 	cmp.w	r9, #1
 80063d8:	d801      	bhi.n	80063de <f_unlink+0x39a>
 80063da:	e776      	b.n	80062ca <f_unlink+0x286>
 80063dc:	69f3      	ldr	r3, [r6, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80063de:	7870      	ldrb	r0, [r6, #1]
				wsect += fs->fsize;
 80063e0:	441d      	add	r5, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80063e2:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 80063e6:	462a      	mov	r2, r5
 80063e8:	2301      	movs	r3, #1
 80063ea:	4641      	mov	r1, r8
 80063ec:	f7fc fa08 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80063f0:	f1b9 0f01 	cmp.w	r9, #1
 80063f4:	d1f2      	bne.n	80063dc <f_unlink+0x398>
 80063f6:	e768      	b.n	80062ca <f_unlink+0x286>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 80063f8:	2c01      	cmp	r4, #1
 80063fa:	d0c5      	beq.n	8006388 <f_unlink+0x344>
 80063fc:	6983      	ldr	r3, [r0, #24]
 80063fe:	429c      	cmp	r4, r3
 8006400:	d2c2      	bcs.n	8006388 <f_unlink+0x344>
 8006402:	4621      	mov	r1, r4
 8006404:	f7fc fe3a 	bl	800307c <remove_chain.part.10>
					if (res == FR_OK) res = sync_fs(dj.fs);
 8006408:	2800      	cmp	r0, #0
 800640a:	f47f ae3a 	bne.w	8006082 <f_unlink+0x3e>
 800640e:	9804      	ldr	r0, [sp, #16]
 8006410:	e79d      	b.n	800634e <f_unlink+0x30a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8006412:	4641      	mov	r1, r8
 8006414:	2301      	movs	r3, #1
 8006416:	4632      	mov	r2, r6
 8006418:	7868      	ldrb	r0, [r5, #1]
 800641a:	f7fc f9f1 	bl	8002800 <disk_write>
 800641e:	2800      	cmp	r0, #0
 8006420:	d1b0      	bne.n	8006384 <f_unlink+0x340>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8006422:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 8006424:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 8006426:	4296      	cmp	r6, r2
 8006428:	d381      	bcc.n	800632e <f_unlink+0x2ea>
 800642a:	69eb      	ldr	r3, [r5, #28]
 800642c:	441a      	add	r2, r3
 800642e:	4296      	cmp	r6, r2
 8006430:	f4bf af7d 	bcs.w	800632e <f_unlink+0x2ea>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8006434:	f895 9003 	ldrb.w	r9, [r5, #3]
 8006438:	f1b9 0f01 	cmp.w	r9, #1
 800643c:	d801      	bhi.n	8006442 <f_unlink+0x3fe>
 800643e:	e776      	b.n	800632e <f_unlink+0x2ea>
 8006440:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 8006442:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 8006444:	441e      	add	r6, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8006446:	f109 39ff 	add.w	r9, r9, #4294967295
				disk_write(fs->drv, fs->win, wsect, 1);
 800644a:	4632      	mov	r2, r6
 800644c:	2301      	movs	r3, #1
 800644e:	4641      	mov	r1, r8
 8006450:	f7fc f9d6 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8006454:	f1b9 0f01 	cmp.w	r9, #1
 8006458:	d1f2      	bne.n	8006440 <f_unlink+0x3fc>
 800645a:	e768      	b.n	800632e <f_unlink+0x2ea>
		if (dj->clust == 0) {	/* Static table */
 800645c:	990e      	ldr	r1, [sp, #56]	; 0x38
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 800645e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
		dj->sect++;					/* Next sector */
 8006460:	3701      	adds	r7, #1
 8006462:	970f      	str	r7, [sp, #60]	; 0x3c
		if (dj->clust == 0) {	/* Static table */
 8006464:	b9d9      	cbnz	r1, 800649e <f_unlink+0x45a>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8006466:	8933      	ldrh	r3, [r6, #8]
 8006468:	42ab      	cmp	r3, r5
 800646a:	f67f af4c 	bls.w	8006306 <f_unlink+0x2c2>
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 800646e:	f106 0334 	add.w	r3, r6, #52	; 0x34
	dj->index = i;
 8006472:	f8ad 5032 	strh.w	r5, [sp, #50]	; 0x32
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 8006476:	9310      	str	r3, [sp, #64]	; 0x40
	while (dj->sect) {
 8006478:	2f00      	cmp	r7, #0
 800647a:	f47f af1e 	bne.w	80062ba <f_unlink+0x276>
						) res = FR_DENIED;
 800647e:	2007      	movs	r0, #7
 8006480:	e5ff      	b.n	8006082 <f_unlink+0x3e>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8006482:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8006486:	f895 9232 	ldrb.w	r9, [r5, #562]	; 0x232
 800648a:	4b41      	ldr	r3, [pc, #260]	; (8006590 <f_unlink+0x54c>)
 800648c:	ea49 2902 	orr.w	r9, r9, r2, lsl #8
 8006490:	fa0f f989 	sxth.w	r9, r9
 8006494:	4599      	cmp	r9, r3
 8006496:	f43f ae05 	beq.w	80060a4 <f_unlink+0x60>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 800649a:	200d      	movs	r0, #13
 800649c:	e5f1      	b.n	8006082 <f_unlink+0x3e>
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 800649e:	78b3      	ldrb	r3, [r6, #2]
 80064a0:	3b01      	subs	r3, #1
 80064a2:	ea13 1315 	ands.w	r3, r3, r5, lsr #4
 80064a6:	d1e2      	bne.n	800646e <f_unlink+0x42a>
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 80064a8:	2901      	cmp	r1, #1
 80064aa:	f67f af6d 	bls.w	8006388 <f_unlink+0x344>
 80064ae:	69b3      	ldr	r3, [r6, #24]
 80064b0:	4299      	cmp	r1, r3
 80064b2:	f4bf af69 	bcs.w	8006388 <f_unlink+0x344>
 80064b6:	4630      	mov	r0, r6
 80064b8:	f7fc ff38 	bl	800332c <get_fat.part.6>
				if (clst <= 1) return FR_INT_ERR;
 80064bc:	2801      	cmp	r0, #1
 80064be:	f67f af63 	bls.w	8006388 <f_unlink+0x344>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 80064c2:	1c43      	adds	r3, r0, #1
 80064c4:	f43f af5e 	beq.w	8006384 <f_unlink+0x340>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 80064c8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 80064ca:	69b3      	ldr	r3, [r6, #24]
 80064cc:	4298      	cmp	r0, r3
 80064ce:	f4bf af1a 	bcs.w	8006306 <f_unlink+0x2c2>
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80064d2:	3b02      	subs	r3, #2
	clst -= 2;
 80064d4:	1e82      	subs	r2, r0, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80064d6:	429a      	cmp	r2, r3
				dj->clust = clst;				/* Initialize data for new cluster */
 80064d8:	900e      	str	r0, [sp, #56]	; 0x38
	return clst * fs->csize + fs->database;
 80064da:	bf3b      	ittet	cc
 80064dc:	78b7      	ldrbcc	r7, [r6, #2]
 80064de:	6af3      	ldrcc	r3, [r6, #44]	; 0x2c
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80064e0:	2700      	movcs	r7, #0
	return clst * fs->csize + fs->database;
 80064e2:	fb02 3707 	mlacc	r7, r2, r7, r3
				dj->sect = clust2sect(dj->fs, clst);
 80064e6:	970f      	str	r7, [sp, #60]	; 0x3c
 80064e8:	e7c1      	b.n	800646e <f_unlink+0x42a>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 80064ea:	4607      	mov	r7, r0
 80064ec:	e612      	b.n	8006114 <f_unlink+0xd0>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80064ee:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80064f0:	443a      	add	r2, r7
	fs->database = bsect + sysect;						/* Data start sector */
 80064f2:	4439      	add	r1, r7
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80064f4:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80064f6:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 80064f8:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 80064fa:	622f      	str	r7, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 80064fc:	f1be 0f00 	cmp.w	lr, #0
 8006500:	d0cb      	beq.n	800649a <f_unlink+0x456>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006502:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006504:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006508:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800650a:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800650e:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006510:	d3c3      	bcc.n	800649a <f_unlink+0x456>
	fs->last_clust = 0;
 8006512:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8006514:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8006518:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 800651a:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 800651c:	2302      	movs	r3, #2
 800651e:	e68e      	b.n	800623e <f_unlink+0x1fa>
		p += 2; *path = p;				/* Return pointer to the path name */
 8006520:	3402      	adds	r4, #2
 8006522:	e597      	b.n	8006054 <f_unlink+0x10>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006524:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006526:	443a      	add	r2, r7
	fs->database = bsect + sysect;						/* Data start sector */
 8006528:	4439      	add	r1, r7
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800652a:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800652c:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 800652e:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8006530:	622f      	str	r7, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8006532:	f1be 0f00 	cmp.w	lr, #0
 8006536:	d0b0      	beq.n	800649a <f_unlink+0x456>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006538:	f003 0101 	and.w	r1, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800653c:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006540:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006544:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006548:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800654a:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800654e:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006550:	d3a3      	bcc.n	800649a <f_unlink+0x456>
	fs->last_clust = 0;
 8006552:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8006554:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8006558:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 800655a:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 800655c:	2301      	movs	r3, #1
 800655e:	e66e      	b.n	800623e <f_unlink+0x1fa>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006560:	4b0c      	ldr	r3, [pc, #48]	; (8006594 <f_unlink+0x550>)
 8006562:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8006564:	429a      	cmp	r2, r3
 8006566:	f47f ae69 	bne.w	800623c <f_unlink+0x1f8>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 800656a:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 800656e:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8006572:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
 8006576:	3320      	adds	r3, #32
 8006578:	429a      	cmp	r2, r3
 800657a:	f47f ae5f 	bne.w	800623c <f_unlink+0x1f8>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800657e:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8006582:	f8d5 2220 	ldr.w	r2, [r5, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8006586:	612b      	str	r3, [r5, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8006588:	60ea      	str	r2, [r5, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800658a:	2303      	movs	r3, #3
 800658c:	e657      	b.n	800623e <f_unlink+0x1fa>
 800658e:	bf00      	nop
 8006590:	ffffaa55 	.word	0xffffaa55
 8006594:	41615252 	.word	0x41615252

08006598 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
 8006598:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800659c:	b095      	sub	sp, #84	; 0x54
 800659e:	9009      	str	r0, [sp, #36]	; 0x24
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = get_fattime();
 80065a0:	f7fc f950 	bl	8002844 <get_fattime>
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
 80065a4:	a90d      	add	r1, sp, #52	; 0x34
	DWORD dsc, dcl, pcl, tm = get_fattime();
 80065a6:	4605      	mov	r5, r0
	res = chk_mounted(&path, &dj.fs, 1);
 80065a8:	2201      	movs	r2, #1
 80065aa:	a809      	add	r0, sp, #36	; 0x24
 80065ac:	f7fc fa16 	bl	80029dc <chk_mounted>
 80065b0:	4604      	mov	r4, r0
	if (res == FR_OK) {
 80065b2:	b118      	cbz	r0, 80065bc <f_mkdir+0x24>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
 80065b4:	4620      	mov	r0, r4
 80065b6:	b015      	add	sp, #84	; 0x54
 80065b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		INIT_BUF(dj);
 80065bc:	ab0a      	add	r3, sp, #40	; 0x28
 80065be:	4606      	mov	r6, r0
		res = follow_path(&dj, path);			/* Follow the file path */
 80065c0:	9909      	ldr	r1, [sp, #36]	; 0x24
		INIT_BUF(dj);
 80065c2:	9313      	str	r3, [sp, #76]	; 0x4c
		res = follow_path(&dj, path);			/* Follow the file path */
 80065c4:	a80d      	add	r0, sp, #52	; 0x34
 80065c6:	f7fd fd69 	bl	800409c <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 80065ca:	4604      	mov	r4, r0
 80065cc:	b158      	cbz	r0, 80065e6 <f_mkdir+0x4e>
		if (res == FR_NO_FILE) {				/* Can create a new directory */
 80065ce:	2804      	cmp	r0, #4
 80065d0:	d1f0      	bne.n	80065b4 <f_mkdir+0x1c>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
 80065d2:	4631      	mov	r1, r6
 80065d4:	980d      	ldr	r0, [sp, #52]	; 0x34
 80065d6:	f7fd f837 	bl	8003648 <create_chain>
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 80065da:	9000      	str	r0, [sp, #0]
 80065dc:	b140      	cbz	r0, 80065f0 <f_mkdir+0x58>
			if (dcl == 1) res = FR_INT_ERR;
 80065de:	2801      	cmp	r0, #1
 80065e0:	d108      	bne.n	80065f4 <f_mkdir+0x5c>
 80065e2:	2402      	movs	r4, #2
 80065e4:	e7e6      	b.n	80065b4 <f_mkdir+0x1c>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 80065e6:	2408      	movs	r4, #8
}
 80065e8:	4620      	mov	r0, r4
 80065ea:	b015      	add	sp, #84	; 0x54
 80065ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 80065f0:	2407      	movs	r4, #7
 80065f2:	e7df      	b.n	80065b4 <f_mkdir+0x1c>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 80065f4:	1c43      	adds	r3, r0, #1
 80065f6:	bf08      	it	eq
 80065f8:	2401      	moveq	r4, #1
 80065fa:	d0db      	beq.n	80065b4 <f_mkdir+0x1c>
				res = sync_window(dj.fs);
 80065fc:	9e0d      	ldr	r6, [sp, #52]	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80065fe:	7933      	ldrb	r3, [r6, #4]
 8006600:	2b00      	cmp	r3, #0
 8006602:	f040 8159 	bne.w	80068b8 <f_mkdir+0x320>
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8006606:	69b3      	ldr	r3, [r6, #24]
	clst -= 2;
 8006608:	9a00      	ldr	r2, [sp, #0]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800660a:	3b02      	subs	r3, #2
	clst -= 2;
 800660c:	1e94      	subs	r4, r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800660e:	429c      	cmp	r4, r3
 8006610:	f0c0 813b 	bcc.w	800688a <f_mkdir+0x2f2>
 8006614:	2400      	movs	r4, #0
				dir = dj.fs->win;
 8006616:	f106 0a34 	add.w	sl, r6, #52	; 0x34
 800661a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800661e:	2100      	movs	r1, #0
 8006620:	4650      	mov	r0, sl
 8006622:	f00d ffec 	bl	80145fe <memset>
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006626:	9f00      	ldr	r7, [sp, #0]
 8006628:	0c3b      	lsrs	r3, r7, #16
 800662a:	b2d9      	uxtb	r1, r3
 800662c:	0a1b      	lsrs	r3, r3, #8
				ST_DWORD(dir+DIR_WrtTime, tm);
 800662e:	f3c5 2e07 	ubfx	lr, r5, #8, #8
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006632:	9306      	str	r3, [sp, #24]
				ST_DWORD(dir+DIR_WrtTime, tm);
 8006634:	b2eb      	uxtb	r3, r5
 8006636:	f04f 3220 	mov.w	r2, #538976288	; 0x20202020
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800663a:	9105      	str	r1, [sp, #20]
				ST_DWORD(dir+DIR_WrtTime, tm);
 800663c:	9301      	str	r3, [sp, #4]
				dir[DIR_Attr] = AM_DIR;
 800663e:	2110      	movs	r1, #16
				ST_DWORD(dir+DIR_WrtTime, tm);
 8006640:	f8cd e008 	str.w	lr, [sp, #8]
 8006644:	f3c5 4e07 	ubfx	lr, r5, #16, #8
 8006648:	6372      	str	r2, [r6, #52]	; 0x34
 800664a:	f8cd e00c 	str.w	lr, [sp, #12]
 800664e:	f8ca 2004 	str.w	r2, [sl, #4]
	ST_WORD(dir+DIR_FstClusLO, cl);
 8006652:	46be      	mov	lr, r7
 8006654:	f8ca 2007 	str.w	r2, [sl, #7]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006658:	f89d 2014 	ldrb.w	r2, [sp, #20]
				dir[DIR_Attr] = AM_DIR;
 800665c:	f886 103f 	strb.w	r1, [r6, #63]	; 0x3f
				ST_DWORD(dir+DIR_WrtTime, tm);
 8006660:	f89d 1004 	ldrb.w	r1, [sp, #4]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006664:	f886 2048 	strb.w	r2, [r6, #72]	; 0x48
	ST_WORD(dir+DIR_FstClusLO, cl);
 8006668:	f3ce 2e07 	ubfx	lr, lr, #8, #8
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800666c:	f89d 2018 	ldrb.w	r2, [sp, #24]
				ST_DWORD(dir+DIR_WrtTime, tm);
 8006670:	f886 104a 	strb.w	r1, [r6, #74]	; 0x4a
 8006674:	f89d 1008 	ldrb.w	r1, [sp, #8]
	ST_WORD(dir+DIR_FstClusLO, cl);
 8006678:	f8cd e010 	str.w	lr, [sp, #16]
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
 800667c:	f106 0354 	add.w	r3, r6, #84	; 0x54
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006680:	f886 2049 	strb.w	r2, [r6, #73]	; 0x49
				ST_DWORD(dir+DIR_WrtTime, tm);
 8006684:	f886 104b 	strb.w	r1, [r6, #75]	; 0x4b
 8006688:	f106 0238 	add.w	r2, r6, #56	; 0x38
 800668c:	f89d 100c 	ldrb.w	r1, [sp, #12]
 8006690:	f886 104c 	strb.w	r1, [r6, #76]	; 0x4c
 8006694:	0e2d      	lsrs	r5, r5, #24
	ST_WORD(dir+DIR_FstClusLO, cl);
 8006696:	b2ff      	uxtb	r7, r7
				dir[DIR_Name] = '.';
 8006698:	202e      	movs	r0, #46	; 0x2e
	ST_WORD(dir+DIR_FstClusLO, cl);
 800669a:	f89d 1010 	ldrb.w	r1, [sp, #16]
				ST_DWORD(dir+DIR_WrtTime, tm);
 800669e:	9507      	str	r5, [sp, #28]
 80066a0:	4293      	cmp	r3, r2
	ST_WORD(dir+DIR_FstClusLO, cl);
 80066a2:	9708      	str	r7, [sp, #32]
				dir[DIR_Name] = '.';
 80066a4:	f886 0034 	strb.w	r0, [r6, #52]	; 0x34
				ST_DWORD(dir+DIR_WrtTime, tm);
 80066a8:	f886 504d 	strb.w	r5, [r6, #77]	; 0x4d
	ST_WORD(dir+DIR_FstClusLO, cl);
 80066ac:	f886 704e 	strb.w	r7, [r6, #78]	; 0x4e
 80066b0:	f886 104f 	strb.w	r1, [r6, #79]	; 0x4f
 80066b4:	d204      	bcs.n	80066c0 <f_mkdir+0x128>
 80066b6:	f106 0258 	add.w	r2, r6, #88	; 0x58
 80066ba:	4592      	cmp	sl, r2
 80066bc:	f0c0 8120 	bcc.w	8006900 <f_mkdir+0x368>
 80066c0:	f1ca 0000 	rsb	r0, sl, #0
 80066c4:	f010 0003 	ands.w	r0, r0, #3
 80066c8:	f000 80ed 	beq.w	80068a6 <f_mkdir+0x30e>
		*d++ = *s++;
 80066cc:	f896 2034 	ldrb.w	r2, [r6, #52]	; 0x34
 80066d0:	f886 2054 	strb.w	r2, [r6, #84]	; 0x54
 80066d4:	2801      	cmp	r0, #1
 80066d6:	f106 0755 	add.w	r7, r6, #85	; 0x55
 80066da:	f106 0535 	add.w	r5, r6, #53	; 0x35
 80066de:	f000 811c 	beq.w	800691a <f_mkdir+0x382>
 80066e2:	f896 2035 	ldrb.w	r2, [r6, #53]	; 0x35
 80066e6:	f886 2055 	strb.w	r2, [r6, #85]	; 0x55
 80066ea:	2803      	cmp	r0, #3
 80066ec:	f106 0756 	add.w	r7, r6, #86	; 0x56
 80066f0:	f106 0536 	add.w	r5, r6, #54	; 0x36
 80066f4:	f040 810e 	bne.w	8006914 <f_mkdir+0x37c>
 80066f8:	f896 2036 	ldrb.w	r2, [r6, #54]	; 0x36
 80066fc:	f886 2056 	strb.w	r2, [r6, #86]	; 0x56
 8006700:	f106 0757 	add.w	r7, r6, #87	; 0x57
 8006704:	f106 0537 	add.w	r5, r6, #55	; 0x37
 8006708:	f04f 0e1d 	mov.w	lr, #29
 800670c:	f1c0 0c20 	rsb	ip, r0, #32
 8006710:	f04f 0807 	mov.w	r8, #7
 8006714:	221c      	movs	r2, #28
 8006716:	f100 0934 	add.w	r9, r0, #52	; 0x34
 800671a:	eb06 0109 	add.w	r1, r6, r9
 800671e:	f856 9009 	ldr.w	r9, [r6, r9]
 8006722:	f843 9000 	str.w	r9, [r3, r0]
 8006726:	4403      	add	r3, r0
 8006728:	6848      	ldr	r0, [r1, #4]
 800672a:	6058      	str	r0, [r3, #4]
 800672c:	6888      	ldr	r0, [r1, #8]
 800672e:	6098      	str	r0, [r3, #8]
 8006730:	68c8      	ldr	r0, [r1, #12]
 8006732:	60d8      	str	r0, [r3, #12]
 8006734:	6908      	ldr	r0, [r1, #16]
 8006736:	6118      	str	r0, [r3, #16]
 8006738:	6948      	ldr	r0, [r1, #20]
 800673a:	6158      	str	r0, [r3, #20]
 800673c:	6988      	ldr	r0, [r1, #24]
 800673e:	6198      	str	r0, [r3, #24]
 8006740:	f1b8 0f08 	cmp.w	r8, #8
 8006744:	d101      	bne.n	800674a <f_mkdir+0x1b2>
 8006746:	69c9      	ldr	r1, [r1, #28]
 8006748:	61d9      	str	r1, [r3, #28]
 800674a:	4562      	cmp	r2, ip
 800674c:	ebae 0e02 	sub.w	lr, lr, r2
 8006750:	eb07 0302 	add.w	r3, r7, r2
 8006754:	eb05 0102 	add.w	r1, r5, r2
 8006758:	d00b      	beq.n	8006772 <f_mkdir+0x1da>
 800675a:	5ca8      	ldrb	r0, [r5, r2]
 800675c:	54b8      	strb	r0, [r7, r2]
	while (cnt--)
 800675e:	f1be 0f01 	cmp.w	lr, #1
 8006762:	d006      	beq.n	8006772 <f_mkdir+0x1da>
		*d++ = *s++;
 8006764:	784a      	ldrb	r2, [r1, #1]
 8006766:	705a      	strb	r2, [r3, #1]
	while (cnt--)
 8006768:	f1be 0f02 	cmp.w	lr, #2
 800676c:	d001      	beq.n	8006772 <f_mkdir+0x1da>
		*d++ = *s++;
 800676e:	788a      	ldrb	r2, [r1, #2]
 8006770:	709a      	strb	r2, [r3, #2]
				dir[33] = '.'; pcl = dj.sclust;
 8006772:	232e      	movs	r3, #46	; 0x2e
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 8006774:	9d0d      	ldr	r5, [sp, #52]	; 0x34
				dir[33] = '.'; pcl = dj.sclust;
 8006776:	f886 3055 	strb.w	r3, [r6, #85]	; 0x55
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 800677a:	782b      	ldrb	r3, [r5, #0]
				dir[33] = '.'; pcl = dj.sclust;
 800677c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 800677e:	2b03      	cmp	r3, #3
 8006780:	f000 8088 	beq.w	8006894 <f_mkdir+0x2fc>
 8006784:	0c13      	lsrs	r3, r2, #16
 8006786:	b2d9      	uxtb	r1, r3
 8006788:	b2d0      	uxtb	r0, r2
 800678a:	0a1b      	lsrs	r3, r3, #8
 800678c:	f3c2 2207 	ubfx	r2, r2, #8, #8
	ST_WORD(dir+DIR_FstClusLO, cl);
 8006790:	f886 006e 	strb.w	r0, [r6, #110]	; 0x6e
 8006794:	f886 206f 	strb.w	r2, [r6, #111]	; 0x6f
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006798:	f886 1068 	strb.w	r1, [r6, #104]	; 0x68
 800679c:	f886 3069 	strb.w	r3, [r6, #105]	; 0x69
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 80067a0:	78ab      	ldrb	r3, [r5, #2]
 80067a2:	2b00      	cmp	r3, #0
 80067a4:	d045      	beq.n	8006832 <f_mkdir+0x29a>
 80067a6:	f103 39ff 	add.w	r9, r3, #4294967295
 80067aa:	fa5f f989 	uxtb.w	r9, r9
 80067ae:	f109 0901 	add.w	r9, r9, #1
 80067b2:	44a1      	add	r9, r4
					dj.fs->wflag = 1;
 80067b4:	f04f 0b01 	mov.w	fp, #1
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80067b8:	f105 0734 	add.w	r7, r5, #52	; 0x34
					dj.fs->winsect = dsc++;
 80067bc:	632c      	str	r4, [r5, #48]	; 0x30
					dj.fs->wflag = 1;
 80067be:	f885 b004 	strb.w	fp, [r5, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80067c2:	4639      	mov	r1, r7
 80067c4:	2301      	movs	r3, #1
 80067c6:	4622      	mov	r2, r4
 80067c8:	7868      	ldrb	r0, [r5, #1]
 80067ca:	f7fc f819 	bl	8002800 <disk_write>
					dj.fs->winsect = dsc++;
 80067ce:	f104 0801 	add.w	r8, r4, #1
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80067d2:	bb08      	cbnz	r0, 8006818 <f_mkdir+0x280>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80067d4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
		fs->wflag = 0;
 80067d6:	7128      	strb	r0, [r5, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80067d8:	42a2      	cmp	r2, r4
 80067da:	d812      	bhi.n	8006802 <f_mkdir+0x26a>
 80067dc:	69eb      	ldr	r3, [r5, #28]
 80067de:	441a      	add	r2, r3
 80067e0:	42a2      	cmp	r2, r4
 80067e2:	d90e      	bls.n	8006802 <f_mkdir+0x26a>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80067e4:	78ee      	ldrb	r6, [r5, #3]
 80067e6:	2e01      	cmp	r6, #1
 80067e8:	d801      	bhi.n	80067ee <f_mkdir+0x256>
 80067ea:	e00a      	b.n	8006802 <f_mkdir+0x26a>
 80067ec:	69eb      	ldr	r3, [r5, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80067ee:	7868      	ldrb	r0, [r5, #1]
				wsect += fs->fsize;
 80067f0:	441c      	add	r4, r3
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80067f2:	3e01      	subs	r6, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 80067f4:	4622      	mov	r2, r4
 80067f6:	2301      	movs	r3, #1
 80067f8:	4639      	mov	r1, r7
 80067fa:	f7fc f801 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80067fe:	2e01      	cmp	r6, #1
 8006800:	d1f4      	bne.n	80067ec <f_mkdir+0x254>
 8006802:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006806:	2100      	movs	r1, #0
 8006808:	4650      	mov	r0, sl
 800680a:	f00d fef8 	bl	80145fe <memset>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 800680e:	45c8      	cmp	r8, r9
 8006810:	d00f      	beq.n	8006832 <f_mkdir+0x29a>
 8006812:	4644      	mov	r4, r8
 8006814:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8006816:	e7cf      	b.n	80067b8 <f_mkdir+0x220>
			return FR_DISK_ERR;
 8006818:	2401      	movs	r4, #1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800681a:	9900      	ldr	r1, [sp, #0]
 800681c:	2901      	cmp	r1, #1
 800681e:	f67f aec9 	bls.w	80065b4 <f_mkdir+0x1c>
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
 8006822:	980d      	ldr	r0, [sp, #52]	; 0x34
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8006824:	6983      	ldr	r3, [r0, #24]
 8006826:	4299      	cmp	r1, r3
 8006828:	f4bf aec4 	bcs.w	80065b4 <f_mkdir+0x1c>
 800682c:	f7fc fc26 	bl	800307c <remove_chain.part.10>
 8006830:	e6c0      	b.n	80065b4 <f_mkdir+0x1c>
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
 8006832:	a80d      	add	r0, sp, #52	; 0x34
 8006834:	f7fd fdbc 	bl	80043b0 <dir_register>
			if (res != FR_OK) {
 8006838:	4604      	mov	r4, r0
 800683a:	2800      	cmp	r0, #0
 800683c:	d1ed      	bne.n	800681a <f_mkdir+0x282>
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800683e:	9a05      	ldr	r2, [sp, #20]
 8006840:	9802      	ldr	r0, [sp, #8]
				dj.fs->wflag = 1;
 8006842:	990d      	ldr	r1, [sp, #52]	; 0x34
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006844:	4623      	mov	r3, r4
 8006846:	f362 0407 	bfi	r4, r2, #0, #8
 800684a:	9a03      	ldr	r2, [sp, #12]
 800684c:	f362 0307 	bfi	r3, r2, #0, #8
 8006850:	9a06      	ldr	r2, [sp, #24]
 8006852:	f362 240f 	bfi	r4, r2, #8, #8
 8006856:	9a07      	ldr	r2, [sp, #28]
 8006858:	f362 230f 	bfi	r3, r2, #8, #8
 800685c:	9a01      	ldr	r2, [sp, #4]
 800685e:	f362 4417 	bfi	r4, r2, #16, #8
 8006862:	9a08      	ldr	r2, [sp, #32]
 8006864:	f360 641f 	bfi	r4, r0, #24, #8
 8006868:	9804      	ldr	r0, [sp, #16]
 800686a:	f362 4317 	bfi	r3, r2, #16, #8
				dir = dj.dir;
 800686e:	9a12      	ldr	r2, [sp, #72]	; 0x48
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006870:	f360 631f 	bfi	r3, r0, #24, #8
				dj.fs->wflag = 1;
 8006874:	2501      	movs	r5, #1
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 8006876:	2010      	movs	r0, #16
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8006878:	6154      	str	r4, [r2, #20]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 800687a:	72d0      	strb	r0, [r2, #11]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800687c:	6193      	str	r3, [r2, #24]
				res = sync_fs(dj.fs);
 800687e:	4608      	mov	r0, r1
				dj.fs->wflag = 1;
 8006880:	710d      	strb	r5, [r1, #4]
				res = sync_fs(dj.fs);
 8006882:	f7fc fa25 	bl	8002cd0 <sync_fs>
 8006886:	4604      	mov	r4, r0
 8006888:	e694      	b.n	80065b4 <f_mkdir+0x1c>
	return clst * fs->csize + fs->database;
 800688a:	78b2      	ldrb	r2, [r6, #2]
 800688c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800688e:	fb04 3402 	mla	r4, r4, r2, r3
 8006892:	e6c0      	b.n	8006616 <f_mkdir+0x7e>
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 8006894:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8006896:	429a      	cmp	r2, r3
 8006898:	f47f af74 	bne.w	8006784 <f_mkdir+0x1ec>
 800689c:	2300      	movs	r3, #0
 800689e:	4619      	mov	r1, r3
 80068a0:	461a      	mov	r2, r3
 80068a2:	4618      	mov	r0, r3
 80068a4:	e774      	b.n	8006790 <f_mkdir+0x1f8>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
 80068a6:	f04f 0c20 	mov.w	ip, #32
 80068aa:	46e6      	mov	lr, ip
 80068ac:	4662      	mov	r2, ip
	BYTE *d = (BYTE*)dst;
 80068ae:	461f      	mov	r7, r3
	const BYTE *s = (const BYTE*)src;
 80068b0:	4655      	mov	r5, sl
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
 80068b2:	f04f 0808 	mov.w	r8, #8
 80068b6:	e72e      	b.n	8006716 <f_mkdir+0x17e>
		wsect = fs->winsect;	/* Current sector number */
 80068b8:	6b34      	ldr	r4, [r6, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80068ba:	7870      	ldrb	r0, [r6, #1]
 80068bc:	f106 0834 	add.w	r8, r6, #52	; 0x34
 80068c0:	4622      	mov	r2, r4
 80068c2:	4641      	mov	r1, r8
 80068c4:	2301      	movs	r3, #1
 80068c6:	f7fb ff9b 	bl	8002800 <disk_write>
 80068ca:	2800      	cmp	r0, #0
 80068cc:	d1a4      	bne.n	8006818 <f_mkdir+0x280>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80068ce:	6a73      	ldr	r3, [r6, #36]	; 0x24
		fs->wflag = 0;
 80068d0:	7130      	strb	r0, [r6, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80068d2:	429c      	cmp	r4, r3
 80068d4:	d312      	bcc.n	80068fc <f_mkdir+0x364>
 80068d6:	69f2      	ldr	r2, [r6, #28]
 80068d8:	4413      	add	r3, r2
 80068da:	429c      	cmp	r4, r3
 80068dc:	d20e      	bcs.n	80068fc <f_mkdir+0x364>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80068de:	78f7      	ldrb	r7, [r6, #3]
 80068e0:	2f01      	cmp	r7, #1
 80068e2:	d801      	bhi.n	80068e8 <f_mkdir+0x350>
 80068e4:	e00a      	b.n	80068fc <f_mkdir+0x364>
 80068e6:	69f2      	ldr	r2, [r6, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80068e8:	7870      	ldrb	r0, [r6, #1]
				wsect += fs->fsize;
 80068ea:	4414      	add	r4, r2
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80068ec:	3f01      	subs	r7, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 80068ee:	4622      	mov	r2, r4
 80068f0:	2301      	movs	r3, #1
 80068f2:	4641      	mov	r1, r8
 80068f4:	f7fb ff84 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80068f8:	2f01      	cmp	r7, #1
 80068fa:	d1f4      	bne.n	80068e6 <f_mkdir+0x34e>
 80068fc:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80068fe:	e682      	b.n	8006606 <f_mkdir+0x6e>
 8006900:	f106 0153 	add.w	r1, r6, #83	; 0x53
	const BYTE *s = (const BYTE*)src;
 8006904:	4652      	mov	r2, sl
		*d++ = *s++;
 8006906:	f812 0b01 	ldrb.w	r0, [r2], #1
 800690a:	f801 0f01 	strb.w	r0, [r1, #1]!
	while (cnt--)
 800690e:	429a      	cmp	r2, r3
 8006910:	d1f9      	bne.n	8006906 <f_mkdir+0x36e>
 8006912:	e72e      	b.n	8006772 <f_mkdir+0x1da>
		*d++ = *s++;
 8006914:	f04f 0e1e 	mov.w	lr, #30
 8006918:	e6f8      	b.n	800670c <f_mkdir+0x174>
 800691a:	f04f 0e1f 	mov.w	lr, #31
 800691e:	e6f5      	b.n	800670c <f_mkdir+0x174>

08006920 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
 8006920:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	vol = p[0] - '0';					/* Is there a drive number? */
 8006924:	7803      	ldrb	r3, [r0, #0]
 8006926:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006928:	2b09      	cmp	r3, #9
{
 800692a:	b08b      	sub	sp, #44	; 0x2c
 800692c:	4604      	mov	r4, r0
 800692e:	460d      	mov	r5, r1
 8006930:	4617      	mov	r7, r2
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006932:	d911      	bls.n	8006958 <f_chmod+0x38>
	fs = FatFs[vol];					/* Get corresponding file system object */
 8006934:	f8df 8324 	ldr.w	r8, [pc, #804]	; 8006c5c <f_chmod+0x33c>
 8006938:	f8d8 6000 	ldr.w	r6, [r8]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800693c:	b316      	cbz	r6, 8006984 <f_chmod+0x64>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
 800693e:	9603      	str	r6, [sp, #12]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8006940:	7833      	ldrb	r3, [r6, #0]
 8006942:	b19b      	cbz	r3, 800696c <f_chmod+0x4c>
		stat = disk_status(fs->drv);
 8006944:	7870      	ldrb	r0, [r6, #1]
 8006946:	f7fb ff1f 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 800694a:	07c1      	lsls	r1, r0, #31
 800694c:	d40e      	bmi.n	800696c <f_chmod+0x4c>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 800694e:	0742      	lsls	r2, r0, #29
 8006950:	f140 80ef 	bpl.w	8006b32 <f_chmod+0x212>
				return FR_WRITE_PROTECTED;
 8006954:	200a      	movs	r0, #10
 8006956:	e006      	b.n	8006966 <f_chmod+0x46>
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006958:	7842      	ldrb	r2, [r0, #1]
 800695a:	2a3a      	cmp	r2, #58	; 0x3a
 800695c:	d1ea      	bne.n	8006934 <f_chmod+0x14>
		return FR_INVALID_DRIVE;
 800695e:	200b      	movs	r0, #11
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 8006960:	2b00      	cmp	r3, #0
 8006962:	f000 813d 	beq.w	8006be0 <f_chmod+0x2c0>
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
 8006966:	b00b      	add	sp, #44	; 0x2c
 8006968:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 800696c:	2000      	movs	r0, #0
 800696e:	7030      	strb	r0, [r6, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8006970:	7070      	strb	r0, [r6, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8006972:	f7fb feef 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8006976:	07c3      	lsls	r3, r0, #31
 8006978:	f140 80fa 	bpl.w	8006b70 <f_chmod+0x250>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800697c:	2003      	movs	r0, #3
}
 800697e:	b00b      	add	sp, #44	; 0x2c
 8006980:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8006984:	200c      	movs	r0, #12
 8006986:	e7ee      	b.n	8006966 <f_chmod+0x46>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8006988:	f8d6 306a 	ldr.w	r3, [r6, #106]	; 0x6a
 800698c:	4ab0      	ldr	r2, [pc, #704]	; (8006c50 <f_chmod+0x330>)
 800698e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8006992:	4293      	cmp	r3, r2
 8006994:	f000 8108 	beq.w	8006ba8 <f_chmod+0x288>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8006998:	f8d6 3086 	ldr.w	r3, [r6, #134]	; 0x86
 800699c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80069a0:	4293      	cmp	r3, r2
 80069a2:	f000 8101 	beq.w	8006ba8 <f_chmod+0x288>
		if (tbl[4]) {						/* Is the partition existing? */
 80069a6:	f896 31f6 	ldrb.w	r3, [r6, #502]	; 0x1f6
 80069aa:	2b00      	cmp	r3, #0
 80069ac:	f000 80fa 	beq.w	8006ba4 <f_chmod+0x284>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 80069b0:	f8d6 91fa 	ldr.w	r9, [r6, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 80069b4:	7870      	ldrb	r0, [r6, #1]
 80069b6:	464a      	mov	r2, r9
 80069b8:	2301      	movs	r3, #1
 80069ba:	4651      	mov	r1, sl
 80069bc:	f7fb fefe 	bl	80027bc <disk_read>
 80069c0:	2800      	cmp	r0, #0
 80069c2:	f040 80e1 	bne.w	8006b88 <f_chmod+0x268>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 80069c6:	f896 2233 	ldrb.w	r2, [r6, #563]	; 0x233
 80069ca:	f896 3232 	ldrb.w	r3, [r6, #562]	; 0x232
 80069ce:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80069d2:	b21b      	sxth	r3, r3
 80069d4:	455b      	cmp	r3, fp
 80069d6:	f040 80e5 	bne.w	8006ba4 <f_chmod+0x284>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 80069da:	f8d6 306a 	ldr.w	r3, [r6, #106]	; 0x6a
 80069de:	4a9c      	ldr	r2, [pc, #624]	; (8006c50 <f_chmod+0x330>)
 80069e0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80069e4:	4293      	cmp	r3, r2
 80069e6:	d006      	beq.n	80069f6 <f_chmod+0xd6>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 80069e8:	f8d6 3086 	ldr.w	r3, [r6, #134]	; 0x86
 80069ec:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 80069f0:	4293      	cmp	r3, r2
 80069f2:	f040 80d7 	bne.w	8006ba4 <f_chmod+0x284>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 80069f6:	f896 2040 	ldrb.w	r2, [r6, #64]	; 0x40
 80069fa:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
 80069fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006a02:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006a06:	f040 80cd 	bne.w	8006ba4 <f_chmod+0x284>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8006a0a:	f896 004b 	ldrb.w	r0, [r6, #75]	; 0x4b
 8006a0e:	f896 304a 	ldrb.w	r3, [r6, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 8006a12:	f896 c044 	ldrb.w	ip, [r6, #68]	; 0x44
 8006a16:	f886 c003 	strb.w	ip, [r6, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8006a1a:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8006a1e:	bf18      	it	ne
 8006a20:	4618      	movne	r0, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8006a22:	f10c 33ff 	add.w	r3, ip, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8006a26:	bf08      	it	eq
 8006a28:	6db0      	ldreq	r0, [r6, #88]	; 0x58
	fs->fsize = fasize;
 8006a2a:	61f0      	str	r0, [r6, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8006a2c:	2b01      	cmp	r3, #1
 8006a2e:	f200 80b9 	bhi.w	8006ba4 <f_chmod+0x284>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 8006a32:	f896 b041 	ldrb.w	fp, [r6, #65]	; 0x41
 8006a36:	f886 b002 	strb.w	fp, [r6, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8006a3a:	f1bb 0f00 	cmp.w	fp, #0
 8006a3e:	f000 80b1 	beq.w	8006ba4 <f_chmod+0x284>
 8006a42:	f10b 33ff 	add.w	r3, fp, #4294967295
 8006a46:	ea13 0f0b 	tst.w	r3, fp
 8006a4a:	f040 80ab 	bne.w	8006ba4 <f_chmod+0x284>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8006a4e:	f896 3046 	ldrb.w	r3, [r6, #70]	; 0x46
 8006a52:	f896 e045 	ldrb.w	lr, [r6, #69]	; 0x45
 8006a56:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8006a5a:	f01e 0f0f 	tst.w	lr, #15
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8006a5e:	f8a6 e008 	strh.w	lr, [r6, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8006a62:	f040 809f 	bne.w	8006ba4 <f_chmod+0x284>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8006a66:	f896 2048 	ldrb.w	r2, [r6, #72]	; 0x48
 8006a6a:	f896 3047 	ldrb.w	r3, [r6, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8006a6e:	f896 1043 	ldrb.w	r1, [r6, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8006a72:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8006a76:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8006a7a:	bf08      	it	eq
 8006a7c:	6d73      	ldreq	r3, [r6, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 8006a7e:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8006a82:	f000 808f 	beq.w	8006ba4 <f_chmod+0x284>
	fasize *= b;										/* Number of sectors for FAT area */
 8006a86:	fb00 fc0c 	mul.w	ip, r0, ip
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8006a8a:	eb02 111e 	add.w	r1, r2, lr, lsr #4
 8006a8e:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8006a90:	4299      	cmp	r1, r3
 8006a92:	f200 8087 	bhi.w	8006ba4 <f_chmod+0x284>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8006a96:	1a5b      	subs	r3, r3, r1
 8006a98:	fbb3 f3fb 	udiv	r3, r3, fp
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8006a9c:	2b00      	cmp	r3, #0
 8006a9e:	f000 8081 	beq.w	8006ba4 <f_chmod+0x284>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8006aa2:	f640 7bf5 	movw	fp, #4085	; 0xff5
 8006aa6:	455b      	cmp	r3, fp
 8006aa8:	f240 809c 	bls.w	8006be4 <f_chmod+0x2c4>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8006aac:	f64f 7bf5 	movw	fp, #65525	; 0xfff5
 8006ab0:	455b      	cmp	r3, fp
 8006ab2:	d97b      	bls.n	8006bac <f_chmod+0x28c>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006ab4:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006ab6:	444a      	add	r2, r9
	fs->database = bsect + sysect;						/* Data start sector */
 8006ab8:	4449      	add	r1, r9
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006aba:	61b3      	str	r3, [r6, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006abc:	6272      	str	r2, [r6, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8006abe:	62f1      	str	r1, [r6, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8006ac0:	f8c6 9020 	str.w	r9, [r6, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8006ac4:	f1be 0f00 	cmp.w	lr, #0
 8006ac8:	d16c      	bne.n	8006ba4 <f_chmod+0x284>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 8006aca:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006acc:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8006ad0:	6e32      	ldr	r2, [r6, #96]	; 0x60
 8006ad2:	62b2      	str	r2, [r6, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006ad4:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 8006ad8:	d364      	bcc.n	8006ba4 <f_chmod+0x284>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8006ada:	f896 3065 	ldrb.w	r3, [r6, #101]	; 0x65
 8006ade:	f896 2064 	ldrb.w	r2, [r6, #100]	; 0x64
	fs->last_clust = 0;
 8006ae2:	f8c6 e00c 	str.w	lr, [r6, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8006ae6:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8006aea:	444a      	add	r2, r9
	fs->free_clust = 0xFFFFFFFF;
 8006aec:	f04f 33ff 	mov.w	r3, #4294967295
 8006af0:	6133      	str	r3, [r6, #16]
	 	fs->fsi_flag = 0;
 8006af2:	f886 e005 	strb.w	lr, [r6, #5]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006af6:	4651      	mov	r1, sl
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8006af8:	6172      	str	r2, [r6, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006afa:	2301      	movs	r3, #1
 8006afc:	7870      	ldrb	r0, [r6, #1]
 8006afe:	f7fb fe5d 	bl	80027bc <disk_read>
 8006b02:	b950      	cbnz	r0, 8006b1a <f_chmod+0x1fa>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006b04:	f896 2233 	ldrb.w	r2, [r6, #563]	; 0x233
 8006b08:	f896 3232 	ldrb.w	r3, [r6, #562]	; 0x232
 8006b0c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006b10:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8006b14:	4293      	cmp	r3, r2
 8006b16:	f000 8084 	beq.w	8006c22 <f_chmod+0x302>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8006b1a:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 8006b1c:	f8b8 2004 	ldrh.w	r2, [r8, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 8006b20:	7033      	strb	r3, [r6, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8006b22:	1c53      	adds	r3, r2, #1
 8006b24:	b29b      	uxth	r3, r3
	fs->winsect = 0;		/* Invalidate sector cache */
 8006b26:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* File system mount ID */
 8006b28:	f8a8 3004 	strh.w	r3, [r8, #4]
 8006b2c:	80f3      	strh	r3, [r6, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 8006b2e:	6332      	str	r2, [r6, #48]	; 0x30
	fs->wflag = 0;
 8006b30:	7132      	strb	r2, [r6, #4]
		res = follow_path(&dj, path);		/* Follow the file path */
 8006b32:	4621      	mov	r1, r4
 8006b34:	a803      	add	r0, sp, #12
		INIT_BUF(dj);
 8006b36:	f8cd d024 	str.w	sp, [sp, #36]	; 0x24
		res = follow_path(&dj, path);		/* Follow the file path */
 8006b3a:	f7fd faaf 	bl	800409c <follow_path>
		if (res == FR_OK) {
 8006b3e:	2800      	cmp	r0, #0
 8006b40:	f47f af11 	bne.w	8006966 <f_chmod+0x46>
			dir = dj.dir;
 8006b44:	9b08      	ldr	r3, [sp, #32]
			if (!dir) {						/* Is it a root directory? */
 8006b46:	b17b      	cbz	r3, 8006b68 <f_chmod+0x248>
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 8006b48:	7ada      	ldrb	r2, [r3, #11]
				dj.fs->wflag = 1;
 8006b4a:	9903      	ldr	r1, [sp, #12]
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 8006b4c:	4055      	eors	r5, r2
 8006b4e:	402f      	ands	r7, r5
 8006b50:	f007 0727 	and.w	r7, r7, #39	; 0x27
 8006b54:	4057      	eors	r7, r2
				dj.fs->wflag = 1;
 8006b56:	2201      	movs	r2, #1
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 8006b58:	72df      	strb	r7, [r3, #11]
				res = sync_fs(dj.fs);
 8006b5a:	4608      	mov	r0, r1
				dj.fs->wflag = 1;
 8006b5c:	710a      	strb	r2, [r1, #4]
				res = sync_fs(dj.fs);
 8006b5e:	f7fc f8b7 	bl	8002cd0 <sync_fs>
}
 8006b62:	b00b      	add	sp, #44	; 0x2c
 8006b64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				res = FR_INVALID_NAME;
 8006b68:	2006      	movs	r0, #6
}
 8006b6a:	b00b      	add	sp, #44	; 0x2c
 8006b6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8006b70:	f010 0204 	ands.w	r2, r0, #4
 8006b74:	f47f aeee 	bne.w	8006954 <f_chmod+0x34>
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8006b78:	f106 0a34 	add.w	sl, r6, #52	; 0x34
 8006b7c:	4651      	mov	r1, sl
 8006b7e:	2301      	movs	r3, #1
 8006b80:	7870      	ldrb	r0, [r6, #1]
 8006b82:	f7fb fe1b 	bl	80027bc <disk_read>
 8006b86:	b108      	cbz	r0, 8006b8c <f_chmod+0x26c>
	if (fmt == 3) return FR_DISK_ERR;
 8006b88:	2001      	movs	r0, #1
 8006b8a:	e6ec      	b.n	8006966 <f_chmod+0x46>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8006b8c:	f896 2233 	ldrb.w	r2, [r6, #563]	; 0x233
 8006b90:	f896 b232 	ldrb.w	fp, [r6, #562]	; 0x232
 8006b94:	4b2f      	ldr	r3, [pc, #188]	; (8006c54 <f_chmod+0x334>)
 8006b96:	ea4b 2b02 	orr.w	fp, fp, r2, lsl #8
 8006b9a:	fa0f fb8b 	sxth.w	fp, fp
 8006b9e:	459b      	cmp	fp, r3
 8006ba0:	f43f aef2 	beq.w	8006988 <f_chmod+0x68>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8006ba4:	200d      	movs	r0, #13
	LEAVE_FF(dj.fs, res);
 8006ba6:	e6de      	b.n	8006966 <f_chmod+0x46>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 8006ba8:	4681      	mov	r9, r0
 8006baa:	e724      	b.n	80069f6 <f_chmod+0xd6>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006bac:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006bae:	444a      	add	r2, r9
	fs->database = bsect + sysect;						/* Data start sector */
 8006bb0:	4449      	add	r1, r9
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006bb2:	61b3      	str	r3, [r6, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006bb4:	6272      	str	r2, [r6, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8006bb6:	62f1      	str	r1, [r6, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8006bb8:	f8c6 9020 	str.w	r9, [r6, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8006bbc:	f1be 0f00 	cmp.w	lr, #0
 8006bc0:	d0f0      	beq.n	8006ba4 <f_chmod+0x284>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006bc2:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006bc4:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006bc8:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006bca:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006bce:	62b2      	str	r2, [r6, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006bd0:	d3e8      	bcc.n	8006ba4 <f_chmod+0x284>
	fs->last_clust = 0;
 8006bd2:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8006bd4:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8006bd8:	60f3      	str	r3, [r6, #12]
	fs->free_clust = 0xFFFFFFFF;
 8006bda:	6132      	str	r2, [r6, #16]
	fs->last_clust = 0;
 8006bdc:	2302      	movs	r3, #2
 8006bde:	e79d      	b.n	8006b1c <f_chmod+0x1fc>
		p += 2; *path = p;				/* Return pointer to the path name */
 8006be0:	3402      	adds	r4, #2
 8006be2:	e6a7      	b.n	8006934 <f_chmod+0x14>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006be4:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006be6:	444a      	add	r2, r9
	fs->database = bsect + sysect;						/* Data start sector */
 8006be8:	4449      	add	r1, r9
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006bea:	61b3      	str	r3, [r6, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006bec:	6272      	str	r2, [r6, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8006bee:	62f1      	str	r1, [r6, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8006bf0:	f8c6 9020 	str.w	r9, [r6, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8006bf4:	f1be 0f00 	cmp.w	lr, #0
 8006bf8:	d0d4      	beq.n	8006ba4 <f_chmod+0x284>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006bfa:	f003 0101 	and.w	r1, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006bfe:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006c02:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006c06:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006c0a:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006c0c:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006c10:	62b2      	str	r2, [r6, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006c12:	d3c7      	bcc.n	8006ba4 <f_chmod+0x284>
	fs->last_clust = 0;
 8006c14:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8006c16:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8006c1a:	60f3      	str	r3, [r6, #12]
	fs->free_clust = 0xFFFFFFFF;
 8006c1c:	6132      	str	r2, [r6, #16]
	fs->last_clust = 0;
 8006c1e:	2301      	movs	r3, #1
 8006c20:	e77c      	b.n	8006b1c <f_chmod+0x1fc>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006c22:	4b0d      	ldr	r3, [pc, #52]	; (8006c58 <f_chmod+0x338>)
 8006c24:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8006c26:	429a      	cmp	r2, r3
 8006c28:	f47f af77 	bne.w	8006b1a <f_chmod+0x1fa>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8006c2c:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 8006c30:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8006c34:	f8d6 2218 	ldr.w	r2, [r6, #536]	; 0x218
 8006c38:	3320      	adds	r3, #32
 8006c3a:	429a      	cmp	r2, r3
 8006c3c:	f47f af6d 	bne.w	8006b1a <f_chmod+0x1fa>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8006c40:	f8d6 321c 	ldr.w	r3, [r6, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8006c44:	f8d6 2220 	ldr.w	r2, [r6, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8006c48:	6133      	str	r3, [r6, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8006c4a:	60f2      	str	r2, [r6, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8006c4c:	2303      	movs	r3, #3
 8006c4e:	e765      	b.n	8006b1c <f_chmod+0x1fc>
 8006c50:	00544146 	.word	0x00544146
 8006c54:	ffffaa55 	.word	0xffffaa55
 8006c58:	41615252 	.word	0x41615252
 8006c5c:	20002128 	.word	0x20002128

08006c60 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
 8006c60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	vol = p[0] - '0';					/* Is there a drive number? */
 8006c64:	7803      	ldrb	r3, [r0, #0]
 8006c66:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006c68:	2b09      	cmp	r3, #9
{
 8006c6a:	b08b      	sub	sp, #44	; 0x2c
 8006c6c:	4604      	mov	r4, r0
 8006c6e:	460e      	mov	r6, r1
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006c70:	d90f      	bls.n	8006c92 <f_utime+0x32>
	fs = FatFs[vol];					/* Get corresponding file system object */
 8006c72:	4fc7      	ldr	r7, [pc, #796]	; (8006f90 <f_utime+0x330>)
 8006c74:	683d      	ldr	r5, [r7, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8006c76:	b315      	cbz	r5, 8006cbe <f_utime+0x5e>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
 8006c78:	9503      	str	r5, [sp, #12]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8006c7a:	782b      	ldrb	r3, [r5, #0]
 8006c7c:	b19b      	cbz	r3, 8006ca6 <f_utime+0x46>
		stat = disk_status(fs->drv);
 8006c7e:	7868      	ldrb	r0, [r5, #1]
 8006c80:	f7fb fd82 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 8006c84:	07c1      	lsls	r1, r0, #31
 8006c86:	d40e      	bmi.n	8006ca6 <f_utime+0x46>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8006c88:	0742      	lsls	r2, r0, #29
 8006c8a:	f140 80ee 	bpl.w	8006e6a <f_utime+0x20a>
				return FR_WRITE_PROTECTED;
 8006c8e:	200a      	movs	r0, #10
 8006c90:	e006      	b.n	8006ca0 <f_utime+0x40>
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006c92:	7842      	ldrb	r2, [r0, #1]
 8006c94:	2a3a      	cmp	r2, #58	; 0x3a
 8006c96:	d1ec      	bne.n	8006c72 <f_utime+0x12>
		return FR_INVALID_DRIVE;
 8006c98:	200b      	movs	r0, #11
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 8006c9a:	2b00      	cmp	r3, #0
 8006c9c:	f000 813f 	beq.w	8006f1e <f_utime+0x2be>
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
 8006ca0:	b00b      	add	sp, #44	; 0x2c
 8006ca2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 8006ca6:	2000      	movs	r0, #0
 8006ca8:	7028      	strb	r0, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8006caa:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8006cac:	f7fb fd52 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8006cb0:	07c3      	lsls	r3, r0, #31
 8006cb2:	f140 80fc 	bpl.w	8006eae <f_utime+0x24e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8006cb6:	2003      	movs	r0, #3
}
 8006cb8:	b00b      	add	sp, #44	; 0x2c
 8006cba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8006cbe:	200c      	movs	r0, #12
 8006cc0:	e7ee      	b.n	8006ca0 <f_utime+0x40>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8006cc2:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 8006cc6:	f8df a2cc 	ldr.w	sl, [pc, #716]	; 8006f94 <f_utime+0x334>
 8006cca:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8006cce:	4553      	cmp	r3, sl
 8006cd0:	f000 8109 	beq.w	8006ee6 <f_utime+0x286>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8006cd4:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
 8006cd8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8006cdc:	4553      	cmp	r3, sl
 8006cde:	f000 8102 	beq.w	8006ee6 <f_utime+0x286>
		if (tbl[4]) {						/* Is the partition existing? */
 8006ce2:	f895 31f6 	ldrb.w	r3, [r5, #502]	; 0x1f6
 8006ce6:	2b00      	cmp	r3, #0
 8006ce8:	f000 80fb 	beq.w	8006ee2 <f_utime+0x282>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 8006cec:	f8d5 b1fa 	ldr.w	fp, [r5, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8006cf0:	7868      	ldrb	r0, [r5, #1]
 8006cf2:	465a      	mov	r2, fp
 8006cf4:	2301      	movs	r3, #1
 8006cf6:	4641      	mov	r1, r8
 8006cf8:	f7fb fd60 	bl	80027bc <disk_read>
 8006cfc:	2800      	cmp	r0, #0
 8006cfe:	f040 80e2 	bne.w	8006ec6 <f_utime+0x266>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8006d02:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8006d06:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
 8006d0a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006d0e:	b21b      	sxth	r3, r3
 8006d10:	454b      	cmp	r3, r9
 8006d12:	f040 80e6 	bne.w	8006ee2 <f_utime+0x282>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8006d16:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 8006d1a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8006d1e:	4553      	cmp	r3, sl
 8006d20:	d007      	beq.n	8006d32 <f_utime+0xd2>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8006d22:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8006d26:	4a9b      	ldr	r2, [pc, #620]	; (8006f94 <f_utime+0x334>)
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8006d28:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8006d2c:	4293      	cmp	r3, r2
 8006d2e:	f040 80d8 	bne.w	8006ee2 <f_utime+0x282>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8006d32:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
 8006d36:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
 8006d3a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006d3e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006d42:	f040 80ce 	bne.w	8006ee2 <f_utime+0x282>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8006d46:	f895 004b 	ldrb.w	r0, [r5, #75]	; 0x4b
 8006d4a:	f895 304a 	ldrb.w	r3, [r5, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 8006d4e:	f895 c044 	ldrb.w	ip, [r5, #68]	; 0x44
 8006d52:	f885 c003 	strb.w	ip, [r5, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8006d56:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8006d5a:	bf18      	it	ne
 8006d5c:	4618      	movne	r0, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8006d5e:	f10c 33ff 	add.w	r3, ip, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8006d62:	bf08      	it	eq
 8006d64:	6da8      	ldreq	r0, [r5, #88]	; 0x58
	fs->fsize = fasize;
 8006d66:	61e8      	str	r0, [r5, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 8006d68:	2b01      	cmp	r3, #1
 8006d6a:	f200 80ba 	bhi.w	8006ee2 <f_utime+0x282>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 8006d6e:	f895 9041 	ldrb.w	r9, [r5, #65]	; 0x41
 8006d72:	f885 9002 	strb.w	r9, [r5, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8006d76:	f1b9 0f00 	cmp.w	r9, #0
 8006d7a:	f000 80b2 	beq.w	8006ee2 <f_utime+0x282>
 8006d7e:	f109 33ff 	add.w	r3, r9, #4294967295
 8006d82:	ea13 0f09 	tst.w	r3, r9
 8006d86:	f040 80ac 	bne.w	8006ee2 <f_utime+0x282>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8006d8a:	f895 3046 	ldrb.w	r3, [r5, #70]	; 0x46
 8006d8e:	f895 e045 	ldrb.w	lr, [r5, #69]	; 0x45
 8006d92:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8006d96:	f01e 0f0f 	tst.w	lr, #15
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8006d9a:	f8a5 e008 	strh.w	lr, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 8006d9e:	f040 80a0 	bne.w	8006ee2 <f_utime+0x282>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8006da2:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 8006da6:	f895 3047 	ldrb.w	r3, [r5, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8006daa:	f895 1043 	ldrb.w	r1, [r5, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8006dae:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8006db2:	f895 2042 	ldrb.w	r2, [r5, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8006db6:	bf08      	it	eq
 8006db8:	6d6b      	ldreq	r3, [r5, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 8006dba:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8006dbe:	f000 8090 	beq.w	8006ee2 <f_utime+0x282>
	fasize *= b;										/* Number of sectors for FAT area */
 8006dc2:	fb00 fc0c 	mul.w	ip, r0, ip
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8006dc6:	eb02 111e 	add.w	r1, r2, lr, lsr #4
 8006dca:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8006dcc:	4299      	cmp	r1, r3
 8006dce:	f200 8088 	bhi.w	8006ee2 <f_utime+0x282>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8006dd2:	1a5b      	subs	r3, r3, r1
 8006dd4:	fbb3 f3f9 	udiv	r3, r3, r9
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8006dd8:	2b00      	cmp	r3, #0
 8006dda:	f000 8082 	beq.w	8006ee2 <f_utime+0x282>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8006dde:	f640 79f5 	movw	r9, #4085	; 0xff5
 8006de2:	454b      	cmp	r3, r9
 8006de4:	f240 809d 	bls.w	8006f22 <f_utime+0x2c2>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8006de8:	f64f 79f5 	movw	r9, #65525	; 0xfff5
 8006dec:	454b      	cmp	r3, r9
 8006dee:	d97c      	bls.n	8006eea <f_utime+0x28a>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006df0:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006df2:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8006df4:	4459      	add	r1, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006df6:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006df8:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8006dfa:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8006dfc:	f8c5 b020 	str.w	fp, [r5, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8006e00:	f1be 0f00 	cmp.w	lr, #0
 8006e04:	d16d      	bne.n	8006ee2 <f_utime+0x282>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 8006e06:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006e08:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8006e0c:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 8006e0e:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006e10:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 8006e14:	d365      	bcc.n	8006ee2 <f_utime+0x282>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8006e16:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 8006e1a:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
	fs->last_clust = 0;
 8006e1e:	f8c5 e00c 	str.w	lr, [r5, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8006e22:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8006e26:	445a      	add	r2, fp
	fs->free_clust = 0xFFFFFFFF;
 8006e28:	f04f 33ff 	mov.w	r3, #4294967295
 8006e2c:	612b      	str	r3, [r5, #16]
	 	fs->fsi_flag = 0;
 8006e2e:	f885 e005 	strb.w	lr, [r5, #5]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006e32:	4641      	mov	r1, r8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8006e34:	616a      	str	r2, [r5, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006e36:	2301      	movs	r3, #1
 8006e38:	7868      	ldrb	r0, [r5, #1]
 8006e3a:	f7fb fcbf 	bl	80027bc <disk_read>
 8006e3e:	b950      	cbnz	r0, 8006e56 <f_utime+0x1f6>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006e40:	f895 1233 	ldrb.w	r1, [r5, #563]	; 0x233
 8006e44:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006e48:	f64a 2255 	movw	r2, #43605	; 0xaa55
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006e4c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8006e50:	4293      	cmp	r3, r2
 8006e52:	f000 8085 	beq.w	8006f60 <f_utime+0x300>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8006e56:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 8006e58:	88ba      	ldrh	r2, [r7, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 8006e5a:	702b      	strb	r3, [r5, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8006e5c:	1c53      	adds	r3, r2, #1
 8006e5e:	b29b      	uxth	r3, r3
	fs->winsect = 0;		/* Invalidate sector cache */
 8006e60:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* File system mount ID */
 8006e62:	80bb      	strh	r3, [r7, #4]
 8006e64:	80eb      	strh	r3, [r5, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 8006e66:	632a      	str	r2, [r5, #48]	; 0x30
	fs->wflag = 0;
 8006e68:	712a      	strb	r2, [r5, #4]
		res = follow_path(&dj, path);	/* Follow the file path */
 8006e6a:	4621      	mov	r1, r4
 8006e6c:	a803      	add	r0, sp, #12
		INIT_BUF(dj);
 8006e6e:	f8cd d024 	str.w	sp, [sp, #36]	; 0x24
		res = follow_path(&dj, path);	/* Follow the file path */
 8006e72:	f7fd f913 	bl	800409c <follow_path>
		if (res == FR_OK) {
 8006e76:	2800      	cmp	r0, #0
 8006e78:	f47f af12 	bne.w	8006ca0 <f_utime+0x40>
			dir = dj.dir;
 8006e7c:	9b08      	ldr	r3, [sp, #32]
			if (!dir) {					/* Root directory */
 8006e7e:	b193      	cbz	r3, 8006ea6 <f_utime+0x246>
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 8006e80:	88f2      	ldrh	r2, [r6, #6]
 8006e82:	759a      	strb	r2, [r3, #22]
 8006e84:	88f2      	ldrh	r2, [r6, #6]
				dj.fs->wflag = 1;
 8006e86:	9903      	ldr	r1, [sp, #12]
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 8006e88:	0a12      	lsrs	r2, r2, #8
 8006e8a:	75da      	strb	r2, [r3, #23]
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 8006e8c:	88b2      	ldrh	r2, [r6, #4]
 8006e8e:	761a      	strb	r2, [r3, #24]
 8006e90:	88b2      	ldrh	r2, [r6, #4]
				dj.fs->wflag = 1;
 8006e92:	2401      	movs	r4, #1
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 8006e94:	0a12      	lsrs	r2, r2, #8
 8006e96:	765a      	strb	r2, [r3, #25]
				res = sync_fs(dj.fs);
 8006e98:	4608      	mov	r0, r1
				dj.fs->wflag = 1;
 8006e9a:	710c      	strb	r4, [r1, #4]
				res = sync_fs(dj.fs);
 8006e9c:	f7fb ff18 	bl	8002cd0 <sync_fs>
}
 8006ea0:	b00b      	add	sp, #44	; 0x2c
 8006ea2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				res = FR_INVALID_NAME;
 8006ea6:	2006      	movs	r0, #6
}
 8006ea8:	b00b      	add	sp, #44	; 0x2c
 8006eaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8006eae:	f010 0204 	ands.w	r2, r0, #4
 8006eb2:	f47f aeec 	bne.w	8006c8e <f_utime+0x2e>
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8006eb6:	f105 0834 	add.w	r8, r5, #52	; 0x34
 8006eba:	4641      	mov	r1, r8
 8006ebc:	2301      	movs	r3, #1
 8006ebe:	7868      	ldrb	r0, [r5, #1]
 8006ec0:	f7fb fc7c 	bl	80027bc <disk_read>
 8006ec4:	b108      	cbz	r0, 8006eca <f_utime+0x26a>
	if (fmt == 3) return FR_DISK_ERR;
 8006ec6:	2001      	movs	r0, #1
 8006ec8:	e6ea      	b.n	8006ca0 <f_utime+0x40>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8006eca:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8006ece:	f895 9232 	ldrb.w	r9, [r5, #562]	; 0x232
 8006ed2:	4b31      	ldr	r3, [pc, #196]	; (8006f98 <f_utime+0x338>)
 8006ed4:	ea49 2902 	orr.w	r9, r9, r2, lsl #8
 8006ed8:	fa0f f989 	sxth.w	r9, r9
 8006edc:	4599      	cmp	r9, r3
 8006ede:	f43f aef0 	beq.w	8006cc2 <f_utime+0x62>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8006ee2:	200d      	movs	r0, #13
	LEAVE_FF(dj.fs, res);
 8006ee4:	e6dc      	b.n	8006ca0 <f_utime+0x40>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 8006ee6:	4683      	mov	fp, r0
 8006ee8:	e723      	b.n	8006d32 <f_utime+0xd2>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006eea:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006eec:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8006eee:	4459      	add	r1, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006ef0:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006ef2:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8006ef4:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8006ef6:	f8c5 b020 	str.w	fp, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8006efa:	f1be 0f00 	cmp.w	lr, #0
 8006efe:	d0f0      	beq.n	8006ee2 <f_utime+0x282>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006f00:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006f02:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006f06:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006f08:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006f0c:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006f0e:	d3e8      	bcc.n	8006ee2 <f_utime+0x282>
	fs->last_clust = 0;
 8006f10:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8006f12:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8006f16:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 8006f18:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 8006f1a:	2302      	movs	r3, #2
 8006f1c:	e79c      	b.n	8006e58 <f_utime+0x1f8>
		p += 2; *path = p;				/* Return pointer to the path name */
 8006f1e:	3402      	adds	r4, #2
 8006f20:	e6a7      	b.n	8006c72 <f_utime+0x12>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006f22:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006f24:	445a      	add	r2, fp
	fs->database = bsect + sysect;						/* Data start sector */
 8006f26:	4459      	add	r1, fp
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8006f28:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8006f2a:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 8006f2c:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8006f2e:	f8c5 b020 	str.w	fp, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8006f32:	f1be 0f00 	cmp.w	lr, #0
 8006f36:	d0d4      	beq.n	8006ee2 <f_utime+0x282>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006f38:	f003 0101 	and.w	r1, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006f3c:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8006f40:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006f44:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006f48:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006f4a:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8006f4e:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8006f50:	d3c7      	bcc.n	8006ee2 <f_utime+0x282>
	fs->last_clust = 0;
 8006f52:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8006f54:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 8006f58:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 8006f5a:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 8006f5c:	2301      	movs	r3, #1
 8006f5e:	e77b      	b.n	8006e58 <f_utime+0x1f8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8006f60:	4b0e      	ldr	r3, [pc, #56]	; (8006f9c <f_utime+0x33c>)
 8006f62:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8006f64:	429a      	cmp	r2, r3
 8006f66:	f47f af76 	bne.w	8006e56 <f_utime+0x1f6>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8006f6a:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 8006f6e:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8006f72:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
 8006f76:	3320      	adds	r3, #32
 8006f78:	429a      	cmp	r2, r3
 8006f7a:	f47f af6c 	bne.w	8006e56 <f_utime+0x1f6>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8006f7e:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8006f82:	f8d5 2220 	ldr.w	r2, [r5, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8006f86:	612b      	str	r3, [r5, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8006f88:	60ea      	str	r2, [r5, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8006f8a:	2303      	movs	r3, #3
 8006f8c:	e764      	b.n	8006e58 <f_utime+0x1f8>
 8006f8e:	bf00      	nop
 8006f90:	20002128 	.word	0x20002128
 8006f94:	00544146 	.word	0x00544146
 8006f98:	ffffaa55 	.word	0xffffaa55
 8006f9c:	41615252 	.word	0x41615252

08006fa0 <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
 8006fa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	vol = p[0] - '0';					/* Is there a drive number? */
 8006fa4:	7803      	ldrb	r3, [r0, #0]
 8006fa6:	3b30      	subs	r3, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006fa8:	2b09      	cmp	r3, #9
{
 8006faa:	b099      	sub	sp, #100	; 0x64
 8006fac:	4604      	mov	r4, r0
 8006fae:	460e      	mov	r6, r1
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006fb0:	d90f      	bls.n	8006fd2 <f_rename+0x32>
	fs = FatFs[vol];					/* Get corresponding file system object */
 8006fb2:	4fc1      	ldr	r7, [pc, #772]	; (80072b8 <f_rename+0x318>)
 8006fb4:	683d      	ldr	r5, [r7, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8006fb6:	b315      	cbz	r5, 8006ffe <f_rename+0x5e>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
 8006fb8:	950a      	str	r5, [sp, #40]	; 0x28
	if (fs->fs_type) {					/* If the volume has been mounted */
 8006fba:	782b      	ldrb	r3, [r5, #0]
 8006fbc:	b19b      	cbz	r3, 8006fe6 <f_rename+0x46>
		stat = disk_status(fs->drv);
 8006fbe:	7868      	ldrb	r0, [r5, #1]
 8006fc0:	f7fb fbe2 	bl	8002788 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 8006fc4:	07c3      	lsls	r3, r0, #31
 8006fc6:	d40e      	bmi.n	8006fe6 <f_rename+0x46>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8006fc8:	0741      	lsls	r1, r0, #29
 8006fca:	f140 80f1 	bpl.w	80071b0 <f_rename+0x210>
				return FR_WRITE_PROTECTED;
 8006fce:	200a      	movs	r0, #10
 8006fd0:	e006      	b.n	8006fe0 <f_rename+0x40>
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 8006fd2:	7842      	ldrb	r2, [r0, #1]
 8006fd4:	2a3a      	cmp	r2, #58	; 0x3a
 8006fd6:	d1ec      	bne.n	8006fb2 <f_rename+0x12>
		return FR_INVALID_DRIVE;
 8006fd8:	200b      	movs	r0, #11
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 8006fda:	2b00      	cmp	r3, #0
 8006fdc:	f000 8209 	beq.w	80073f2 <f_rename+0x452>
		}
		FREE_BUF();
	}

	LEAVE_FF(djo.fs, res);
}
 8006fe0:	b019      	add	sp, #100	; 0x64
 8006fe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 8006fe6:	2000      	movs	r0, #0
 8006fe8:	7028      	strb	r0, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8006fea:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8006fec:	f7fb fbb2 	bl	8002754 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8006ff0:	07c2      	lsls	r2, r0, #31
 8006ff2:	f140 81b9 	bpl.w	8007368 <f_rename+0x3c8>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8006ff6:	2003      	movs	r0, #3
}
 8006ff8:	b019      	add	sp, #100	; 0x64
 8006ffa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8006ffe:	200c      	movs	r0, #12
 8007000:	e7ee      	b.n	8006fe0 <f_rename+0x40>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8007002:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 8007006:	f8df b2b4 	ldr.w	fp, [pc, #692]	; 80072bc <f_rename+0x31c>
 800700a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800700e:	455b      	cmp	r3, fp
 8007010:	f000 822f 	beq.w	8007472 <f_rename+0x4d2>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8007014:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
 8007018:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800701c:	455b      	cmp	r3, fp
 800701e:	f000 8228 	beq.w	8007472 <f_rename+0x4d2>
		if (tbl[4]) {						/* Is the partition existing? */
 8007022:	f895 31f6 	ldrb.w	r3, [r5, #502]	; 0x1f6
 8007026:	2b00      	cmp	r3, #0
 8007028:	f000 81b8 	beq.w	800739c <f_rename+0x3fc>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 800702c:	f8d5 81fa 	ldr.w	r8, [r5, #506]	; 0x1fa
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8007030:	7868      	ldrb	r0, [r5, #1]
 8007032:	4642      	mov	r2, r8
 8007034:	2301      	movs	r3, #1
 8007036:	4649      	mov	r1, r9
 8007038:	f7fb fbc0 	bl	80027bc <disk_read>
 800703c:	2800      	cmp	r0, #0
 800703e:	f040 819f 	bne.w	8007380 <f_rename+0x3e0>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8007042:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8007046:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
 800704a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800704e:	b21b      	sxth	r3, r3
 8007050:	4553      	cmp	r3, sl
 8007052:	f040 81a3 	bne.w	800739c <f_rename+0x3fc>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8007056:	f8d5 306a 	ldr.w	r3, [r5, #106]	; 0x6a
 800705a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800705e:	455b      	cmp	r3, fp
 8007060:	d007      	beq.n	8007072 <f_rename+0xd2>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8007062:	f8d5 3086 	ldr.w	r3, [r5, #134]	; 0x86
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8007066:	4a95      	ldr	r2, [pc, #596]	; (80072bc <f_rename+0x31c>)
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8007068:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 800706c:	4293      	cmp	r3, r2
 800706e:	f040 8195 	bne.w	800739c <f_rename+0x3fc>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8007072:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
 8007076:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
 800707a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800707e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007082:	f040 818b 	bne.w	800739c <f_rename+0x3fc>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8007086:	f895 004b 	ldrb.w	r0, [r5, #75]	; 0x4b
 800708a:	f895 304a 	ldrb.w	r3, [r5, #74]	; 0x4a
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 800708e:	f895 c044 	ldrb.w	ip, [r5, #68]	; 0x44
 8007092:	f885 c003 	strb.w	ip, [r5, #3]
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8007096:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 800709a:	bf18      	it	ne
 800709c:	4618      	movne	r0, r3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 800709e:	f10c 33ff 	add.w	r3, ip, #4294967295
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 80070a2:	bf08      	it	eq
 80070a4:	6da8      	ldreq	r0, [r5, #88]	; 0x58
	fs->fsize = fasize;
 80070a6:	61e8      	str	r0, [r5, #28]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 80070a8:	2b01      	cmp	r3, #1
 80070aa:	f200 8177 	bhi.w	800739c <f_rename+0x3fc>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 80070ae:	f895 a041 	ldrb.w	sl, [r5, #65]	; 0x41
 80070b2:	f885 a002 	strb.w	sl, [r5, #2]
	fasize *= b;										/* Number of sectors for FAT area */
 80070b6:	fb00 fc0c 	mul.w	ip, r0, ip
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 80070ba:	f1ba 0f00 	cmp.w	sl, #0
 80070be:	f000 816d 	beq.w	800739c <f_rename+0x3fc>
 80070c2:	f10a 33ff 	add.w	r3, sl, #4294967295
 80070c6:	ea13 0f0a 	tst.w	r3, sl
 80070ca:	f040 8167 	bne.w	800739c <f_rename+0x3fc>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 80070ce:	f895 3046 	ldrb.w	r3, [r5, #70]	; 0x46
 80070d2:	f895 e045 	ldrb.w	lr, [r5, #69]	; 0x45
 80070d6:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 80070da:	f01e 0f0f 	tst.w	lr, #15
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 80070de:	f8a5 e008 	strh.w	lr, [r5, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 80070e2:	f040 815b 	bne.w	800739c <f_rename+0x3fc>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 80070e6:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 80070ea:	f895 3047 	ldrb.w	r3, [r5, #71]	; 0x47
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 80070ee:	f895 1043 	ldrb.w	r1, [r5, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 80070f2:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 80070f6:	f895 2042 	ldrb.w	r2, [r5, #66]	; 0x42
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 80070fa:	bf08      	it	eq
 80070fc:	6d6b      	ldreq	r3, [r5, #84]	; 0x54
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 80070fe:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8007102:	f000 814b 	beq.w	800739c <f_rename+0x3fc>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8007106:	eb02 111e 	add.w	r1, r2, lr, lsr #4
 800710a:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800710c:	4299      	cmp	r1, r3
 800710e:	f200 8145 	bhi.w	800739c <f_rename+0x3fc>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8007112:	1a5b      	subs	r3, r3, r1
 8007114:	fbb3 f3fa 	udiv	r3, r3, sl
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8007118:	2b00      	cmp	r3, #0
 800711a:	f000 813f 	beq.w	800739c <f_rename+0x3fc>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 800711e:	f640 7af5 	movw	sl, #4085	; 0xff5
 8007122:	4553      	cmp	r3, sl
 8007124:	f240 8186 	bls.w	8007434 <f_rename+0x494>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8007128:	f64f 7af5 	movw	sl, #65525	; 0xfff5
 800712c:	4553      	cmp	r3, sl
 800712e:	f240 8167 	bls.w	8007400 <f_rename+0x460>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8007132:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8007134:	4442      	add	r2, r8
	fs->database = bsect + sysect;						/* Data start sector */
 8007136:	4441      	add	r1, r8
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8007138:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800713a:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 800713c:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 800713e:	f8c5 8020 	str.w	r8, [r5, #32]
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8007142:	f1be 0f00 	cmp.w	lr, #0
 8007146:	f040 8129 	bne.w	800739c <f_rename+0x3fc>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 800714a:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800714c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8007150:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 8007152:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8007154:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 8007158:	f0c0 8120 	bcc.w	800739c <f_rename+0x3fc>
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 800715c:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 8007160:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
	fs->last_clust = 0;
 8007164:	f8c5 e00c 	str.w	lr, [r5, #12]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8007168:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 800716c:	4442      	add	r2, r8
	fs->free_clust = 0xFFFFFFFF;
 800716e:	f04f 33ff 	mov.w	r3, #4294967295
 8007172:	612b      	str	r3, [r5, #16]
	 	fs->fsi_flag = 0;
 8007174:	f885 e005 	strb.w	lr, [r5, #5]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8007178:	4649      	mov	r1, r9
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 800717a:	616a      	str	r2, [r5, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 800717c:	2301      	movs	r3, #1
 800717e:	7868      	ldrb	r0, [r5, #1]
 8007180:	f7fb fb1c 	bl	80027bc <disk_read>
 8007184:	b950      	cbnz	r0, 800719c <f_rename+0x1fc>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8007186:	f895 1233 	ldrb.w	r1, [r5, #563]	; 0x233
 800718a:	f895 3232 	ldrb.w	r3, [r5, #562]	; 0x232
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 800718e:	f64a 2255 	movw	r2, #43605	; 0xaa55
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8007192:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8007196:	4293      	cmp	r3, r2
 8007198:	f000 816d 	beq.w	8007476 <f_rename+0x4d6>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 800719c:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* File system mount ID */
 800719e:	88ba      	ldrh	r2, [r7, #4]
	fs->fs_type = fmt;		/* FAT sub-type */
 80071a0:	702b      	strb	r3, [r5, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 80071a2:	1c53      	adds	r3, r2, #1
 80071a4:	b29b      	uxth	r3, r3
	fs->winsect = 0;		/* Invalidate sector cache */
 80071a6:	2200      	movs	r2, #0
	fs->id = ++Fsid;		/* File system mount ID */
 80071a8:	80bb      	strh	r3, [r7, #4]
 80071aa:	80eb      	strh	r3, [r5, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 80071ac:	632a      	str	r2, [r5, #48]	; 0x30
	fs->wflag = 0;
 80071ae:	712a      	strb	r2, [r5, #4]
		djn.fs = djo.fs;
 80071b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80071b2:	9311      	str	r3, [sp, #68]	; 0x44
		res = follow_path(&djo, path_old);		/* Check old object */
 80071b4:	4621      	mov	r1, r4
		INIT_BUF(djo);
 80071b6:	ab01      	add	r3, sp, #4
		res = follow_path(&djo, path_old);		/* Check old object */
 80071b8:	a80a      	add	r0, sp, #40	; 0x28
		INIT_BUF(djo);
 80071ba:	9310      	str	r3, [sp, #64]	; 0x40
		res = follow_path(&djo, path_old);		/* Check old object */
 80071bc:	f7fc ff6e 	bl	800409c <follow_path>
		if (res == FR_OK) {						/* Old object is found */
 80071c0:	2800      	cmp	r0, #0
 80071c2:	f47f af0d 	bne.w	8006fe0 <f_rename+0x40>
			if (!djo.dir) {						/* Is root dir? */
 80071c6:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 80071c8:	2c00      	cmp	r4, #0
 80071ca:	f000 80cb 	beq.w	8007364 <f_rename+0x3c4>
 80071ce:	f854 0f0b 	ldr.w	r0, [r4, #11]!
 80071d2:	6861      	ldr	r1, [r4, #4]
 80071d4:	68a2      	ldr	r2, [r4, #8]
 80071d6:	68e3      	ldr	r3, [r4, #12]
 80071d8:	af04      	add	r7, sp, #16
 80071da:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80071dc:	ad0a      	add	r5, sp, #40	; 0x28
 80071de:	6920      	ldr	r0, [r4, #16]
 80071e0:	6038      	str	r0, [r7, #0]
 80071e2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80071e4:	7d24      	ldrb	r4, [r4, #20]
 80071e6:	713c      	strb	r4, [r7, #4]
 80071e8:	ac11      	add	r4, sp, #68	; 0x44
 80071ea:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80071ec:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80071f0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
				res = follow_path(&djn, path_new);
 80071f4:	4631      	mov	r1, r6
 80071f6:	a811      	add	r0, sp, #68	; 0x44
 80071f8:	f7fc ff50 	bl	800409c <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 80071fc:	2800      	cmp	r0, #0
 80071fe:	f000 80af 	beq.w	8007360 <f_rename+0x3c0>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
 8007202:	2804      	cmp	r0, #4
 8007204:	f47f aeec 	bne.w	8006fe0 <f_rename+0x40>
					res = dir_register(&djn);			/* Register the new entry */
 8007208:	a811      	add	r0, sp, #68	; 0x44
 800720a:	f7fd f8d1 	bl	80043b0 <dir_register>
					if (res == FR_OK) {
 800720e:	2800      	cmp	r0, #0
 8007210:	f47f aee6 	bne.w	8006fe0 <f_rename+0x40>
 8007214:	ab18      	add	r3, sp, #96	; 0x60
						dir = djn.dir;					/* Copy object information except for name */
 8007216:	9916      	ldr	r1, [sp, #88]	; 0x58
 8007218:	f853 6d4e 	ldr.w	r6, [r3, #-78]!
 800721c:	689c      	ldr	r4, [r3, #8]
 800721e:	68d8      	ldr	r0, [r3, #12]
 8007220:	685d      	ldr	r5, [r3, #4]
 8007222:	f8c1 5011 	str.w	r5, [r1, #17]
 8007226:	f8c1 600d 	str.w	r6, [r1, #13]
 800722a:	f8c1 4015 	str.w	r4, [r1, #21]
 800722e:	f8c1 0019 	str.w	r0, [r1, #25]
 8007232:	8a18      	ldrh	r0, [r3, #16]
 8007234:	7c9b      	ldrb	r3, [r3, #18]
 8007236:	77cb      	strb	r3, [r1, #31]
 8007238:	f8a1 001d 	strh.w	r0, [r1, #29]
						dir[DIR_Attr] = buf[0] | AM_ARC;
 800723c:	f89d 3010 	ldrb.w	r3, [sp, #16]
						djo.fs->wflag = 1;
 8007240:	9c0a      	ldr	r4, [sp, #40]	; 0x28
						dir[DIR_Attr] = buf[0] | AM_ARC;
 8007242:	f043 0320 	orr.w	r3, r3, #32
						djo.fs->wflag = 1;
 8007246:	2201      	movs	r2, #1
						dir[DIR_Attr] = buf[0] | AM_ARC;
 8007248:	72cb      	strb	r3, [r1, #11]
						djo.fs->wflag = 1;
 800724a:	7122      	strb	r2, [r4, #4]
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
 800724c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800724e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007250:	429a      	cmp	r2, r3
 8007252:	d060      	beq.n	8007316 <f_rename+0x376>
 8007254:	7acb      	ldrb	r3, [r1, #11]
 8007256:	06db      	lsls	r3, r3, #27
 8007258:	d55d      	bpl.n	8007316 <f_rename+0x376>
	if (fs->fs_type == FS_FAT32)
 800725a:	7822      	ldrb	r2, [r4, #0]
	cl = LD_WORD(dir+DIR_FstClusLO);
 800725c:	7ec8      	ldrb	r0, [r1, #27]
 800725e:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32)
 8007260:	2a03      	cmp	r2, #3
	cl = LD_WORD(dir+DIR_FstClusLO);
 8007262:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	if (fs->fs_type == FS_FAT32)
 8007266:	f000 809d 	beq.w	80073a4 <f_rename+0x404>
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800726a:	69a2      	ldr	r2, [r4, #24]
	clst -= 2;
 800726c:	3b02      	subs	r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800726e:	3a02      	subs	r2, #2
 8007270:	4293      	cmp	r3, r2
 8007272:	f080 8095 	bcs.w	80073a0 <f_rename+0x400>
	return clst * fs->csize + fs->database;
 8007276:	78a6      	ldrb	r6, [r4, #2]
 8007278:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800727a:	fb03 2606 	mla	r6, r3, r6, r2
							if (!dw) {
 800727e:	2e00      	cmp	r6, #0
 8007280:	f000 808e 	beq.w	80073a0 <f_rename+0x400>
	if (sector != fs->winsect) {	/* Changed current window */
 8007284:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8007286:	42ae      	cmp	r6, r5
 8007288:	d02f      	beq.n	80072ea <f_rename+0x34a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800728a:	f104 0834 	add.w	r8, r4, #52	; 0x34
 800728e:	4641      	mov	r1, r8
 8007290:	2301      	movs	r3, #1
 8007292:	462a      	mov	r2, r5
 8007294:	7860      	ldrb	r0, [r4, #1]
 8007296:	f7fb fab3 	bl	8002800 <disk_write>
 800729a:	2800      	cmp	r0, #0
 800729c:	d170      	bne.n	8007380 <f_rename+0x3e0>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 800729e:	6a63      	ldr	r3, [r4, #36]	; 0x24
		fs->wflag = 0;
 80072a0:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80072a2:	429d      	cmp	r5, r3
 80072a4:	d317      	bcc.n	80072d6 <f_rename+0x336>
 80072a6:	69e2      	ldr	r2, [r4, #28]
 80072a8:	4413      	add	r3, r2
 80072aa:	429d      	cmp	r5, r3
 80072ac:	d213      	bcs.n	80072d6 <f_rename+0x336>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80072ae:	78e7      	ldrb	r7, [r4, #3]
 80072b0:	2f01      	cmp	r7, #1
 80072b2:	d806      	bhi.n	80072c2 <f_rename+0x322>
 80072b4:	e00f      	b.n	80072d6 <f_rename+0x336>
 80072b6:	bf00      	nop
 80072b8:	20002128 	.word	0x20002128
 80072bc:	00544146 	.word	0x00544146
 80072c0:	69e2      	ldr	r2, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80072c2:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80072c4:	4415      	add	r5, r2
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80072c6:	3f01      	subs	r7, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 80072c8:	462a      	mov	r2, r5
 80072ca:	2301      	movs	r3, #1
 80072cc:	4641      	mov	r1, r8
 80072ce:	f7fb fa97 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80072d2:	2f01      	cmp	r7, #1
 80072d4:	d1f4      	bne.n	80072c0 <f_rename+0x320>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 80072d6:	4641      	mov	r1, r8
 80072d8:	2301      	movs	r3, #1
 80072da:	4632      	mov	r2, r6
 80072dc:	7860      	ldrb	r0, [r4, #1]
 80072de:	f7fb fa6d 	bl	80027bc <disk_read>
 80072e2:	2800      	cmp	r0, #0
 80072e4:	d14c      	bne.n	8007380 <f_rename+0x3e0>
		fs->winsect = sector;
 80072e6:	6326      	str	r6, [r4, #48]	; 0x30
 80072e8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
								if (res == FR_OK && dir[1] == '.') {
 80072ea:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
 80072ee:	2b2e      	cmp	r3, #46	; 0x2e
 80072f0:	d111      	bne.n	8007316 <f_rename+0x376>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 80072f2:	7823      	ldrb	r3, [r4, #0]
 80072f4:	2b03      	cmp	r3, #3
 80072f6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80072f8:	d07d      	beq.n	80073f6 <f_rename+0x456>
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 80072fa:	0c1a      	lsrs	r2, r3, #16
 80072fc:	0a15      	lsrs	r5, r2, #8
	ST_WORD(dir+DIR_FstClusLO, cl);
 80072fe:	f3c3 2007 	ubfx	r0, r3, #8, #8
									djo.fs->wflag = 1;
 8007302:	2101      	movs	r1, #1
	ST_WORD(dir+DIR_FstClusLO, cl);
 8007304:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8007308:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
 800730c:	f884 5069 	strb.w	r5, [r4, #105]	; 0x69
	ST_WORD(dir+DIR_FstClusLO, cl);
 8007310:	f884 006f 	strb.w	r0, [r4, #111]	; 0x6f
									djo.fs->wflag = 1;
 8007314:	7121      	strb	r1, [r4, #4]
	res = dir_sdi(dj, dj->index);
 8007316:	a80a      	add	r0, sp, #40	; 0x28
 8007318:	f8bd 102e 	ldrh.w	r1, [sp, #46]	; 0x2e
 800731c:	f7fc f940 	bl	80035a0 <dir_sdi>
	if (res == FR_OK) {
 8007320:	2800      	cmp	r0, #0
 8007322:	f47f ae5d 	bne.w	8006fe0 <f_rename+0x40>
		res = move_window(dj->fs, dj->sect);
 8007326:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8007328:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
	if (sector != fs->winsect) {	/* Changed current window */
 800732c:	6b25      	ldr	r5, [r4, #48]	; 0x30
 800732e:	45a8      	cmp	r8, r5
 8007330:	d00d      	beq.n	800734e <f_rename+0x3ae>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8007332:	7923      	ldrb	r3, [r4, #4]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 8007334:	f104 0634 	add.w	r6, r4, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8007338:	2b00      	cmp	r3, #0
 800733a:	d13a      	bne.n	80073b2 <f_rename+0x412>
		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800733c:	4631      	mov	r1, r6
 800733e:	2301      	movs	r3, #1
 8007340:	4642      	mov	r2, r8
 8007342:	7860      	ldrb	r0, [r4, #1]
 8007344:	f7fb fa3a 	bl	80027bc <disk_read>
 8007348:	b9d0      	cbnz	r0, 8007380 <f_rename+0x3e0>
		fs->winsect = sector;
 800734a:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
			*dj->dir = DDE;			/* Mark the entry "deleted" */
 800734e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007350:	22e5      	movs	r2, #229	; 0xe5
 8007352:	701a      	strb	r2, [r3, #0]
			dj->fs->wflag = 1;
 8007354:	980a      	ldr	r0, [sp, #40]	; 0x28
 8007356:	2301      	movs	r3, #1
 8007358:	7103      	strb	r3, [r0, #4]
								res = sync_fs(djo.fs);
 800735a:	f7fb fcb9 	bl	8002cd0 <sync_fs>
 800735e:	e63f      	b.n	8006fe0 <f_rename+0x40>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 8007360:	2008      	movs	r0, #8
 8007362:	e63d      	b.n	8006fe0 <f_rename+0x40>
				res = FR_NO_FILE;
 8007364:	2004      	movs	r0, #4
 8007366:	e63b      	b.n	8006fe0 <f_rename+0x40>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8007368:	f010 0204 	ands.w	r2, r0, #4
 800736c:	f47f ae2f 	bne.w	8006fce <f_rename+0x2e>
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 8007370:	f105 0934 	add.w	r9, r5, #52	; 0x34
 8007374:	4649      	mov	r1, r9
 8007376:	2301      	movs	r3, #1
 8007378:	7868      	ldrb	r0, [r5, #1]
 800737a:	f7fb fa1f 	bl	80027bc <disk_read>
 800737e:	b108      	cbz	r0, 8007384 <f_rename+0x3e4>
		return FR_INVALID_DRIVE;
 8007380:	2001      	movs	r0, #1
 8007382:	e62d      	b.n	8006fe0 <f_rename+0x40>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 8007384:	f895 2233 	ldrb.w	r2, [r5, #563]	; 0x233
 8007388:	f895 a232 	ldrb.w	sl, [r5, #562]	; 0x232
 800738c:	4b45      	ldr	r3, [pc, #276]	; (80074a4 <f_rename+0x504>)
 800738e:	ea4a 2a02 	orr.w	sl, sl, r2, lsl #8
 8007392:	fa0f fa8a 	sxth.w	sl, sl
 8007396:	459a      	cmp	sl, r3
 8007398:	f43f ae33 	beq.w	8007002 <f_rename+0x62>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 800739c:	200d      	movs	r0, #13
	LEAVE_FF(djo.fs, res);
 800739e:	e61f      	b.n	8006fe0 <f_rename+0x40>
								res = FR_INT_ERR;
 80073a0:	2002      	movs	r0, #2
 80073a2:	e61d      	b.n	8006fe0 <f_rename+0x40>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 80073a4:	7d48      	ldrb	r0, [r1, #21]
 80073a6:	7d0a      	ldrb	r2, [r1, #20]
 80073a8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80073ac:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80073b0:	e75b      	b.n	800726a <f_rename+0x2ca>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 80073b2:	4631      	mov	r1, r6
 80073b4:	2301      	movs	r3, #1
 80073b6:	462a      	mov	r2, r5
 80073b8:	7860      	ldrb	r0, [r4, #1]
 80073ba:	f7fb fa21 	bl	8002800 <disk_write>
 80073be:	2800      	cmp	r0, #0
 80073c0:	d1de      	bne.n	8007380 <f_rename+0x3e0>
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80073c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
		fs->wflag = 0;
 80073c4:	7120      	strb	r0, [r4, #4]
		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
 80073c6:	429d      	cmp	r5, r3
 80073c8:	d3b8      	bcc.n	800733c <f_rename+0x39c>
 80073ca:	69e2      	ldr	r2, [r4, #28]
 80073cc:	4413      	add	r3, r2
 80073ce:	429d      	cmp	r5, r3
 80073d0:	d2b4      	bcs.n	800733c <f_rename+0x39c>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80073d2:	78e7      	ldrb	r7, [r4, #3]
 80073d4:	2f01      	cmp	r7, #1
 80073d6:	d801      	bhi.n	80073dc <f_rename+0x43c>
 80073d8:	e7b0      	b.n	800733c <f_rename+0x39c>
 80073da:	69e2      	ldr	r2, [r4, #28]
				disk_write(fs->drv, fs->win, wsect, 1);
 80073dc:	7860      	ldrb	r0, [r4, #1]
				wsect += fs->fsize;
 80073de:	4415      	add	r5, r2
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80073e0:	3f01      	subs	r7, #1
				disk_write(fs->drv, fs->win, wsect, 1);
 80073e2:	462a      	mov	r2, r5
 80073e4:	2301      	movs	r3, #1
 80073e6:	4631      	mov	r1, r6
 80073e8:	f7fb fa0a 	bl	8002800 <disk_write>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80073ec:	2f01      	cmp	r7, #1
 80073ee:	d1f4      	bne.n	80073da <f_rename+0x43a>
 80073f0:	e7a4      	b.n	800733c <f_rename+0x39c>
		p += 2; *path = p;				/* Return pointer to the path name */
 80073f2:	3402      	adds	r4, #2
 80073f4:	e5dd      	b.n	8006fb2 <f_rename+0x12>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
 80073f6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80073f8:	4293      	cmp	r3, r2
 80073fa:	bf08      	it	eq
 80073fc:	2300      	moveq	r3, #0
 80073fe:	e77c      	b.n	80072fa <f_rename+0x35a>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8007400:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8007402:	4442      	add	r2, r8
	fs->database = bsect + sysect;						/* Data start sector */
 8007404:	4441      	add	r1, r8
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8007406:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8007408:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 800740a:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 800740c:	f8c5 8020 	str.w	r8, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8007410:	f1be 0f00 	cmp.w	lr, #0
 8007414:	d0c2      	beq.n	800739c <f_rename+0x3fc>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8007416:	005b      	lsls	r3, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8007418:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800741c:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800741e:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8007422:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8007424:	d3ba      	bcc.n	800739c <f_rename+0x3fc>
	fs->last_clust = 0;
 8007426:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8007428:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 800742c:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 800742e:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 8007430:	2302      	movs	r3, #2
 8007432:	e6b4      	b.n	800719e <f_rename+0x1fe>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8007434:	3302      	adds	r3, #2
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8007436:	4442      	add	r2, r8
	fs->database = bsect + sysect;						/* Data start sector */
 8007438:	4441      	add	r1, r8
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800743a:	61ab      	str	r3, [r5, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800743c:	626a      	str	r2, [r5, #36]	; 0x24
	fs->database = bsect + sysect;						/* Data start sector */
 800743e:	62e9      	str	r1, [r5, #44]	; 0x2c
	fs->volbase = bsect;								/* Volume start sector */
 8007440:	f8c5 8020 	str.w	r8, [r5, #32]
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8007444:	f1be 0f00 	cmp.w	lr, #0
 8007448:	d0a8      	beq.n	800739c <f_rename+0x3fc>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800744a:	f003 0101 	and.w	r1, r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800744e:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8007452:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8007456:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800745a:	4462      	add	r2, ip
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800745c:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8007460:	62aa      	str	r2, [r5, #40]	; 0x28
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8007462:	d39b      	bcc.n	800739c <f_rename+0x3fc>
	fs->last_clust = 0;
 8007464:	2300      	movs	r3, #0
	fs->free_clust = 0xFFFFFFFF;
 8007466:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
 800746a:	60eb      	str	r3, [r5, #12]
	fs->free_clust = 0xFFFFFFFF;
 800746c:	612a      	str	r2, [r5, #16]
	fs->last_clust = 0;
 800746e:	2301      	movs	r3, #1
 8007470:	e695      	b.n	800719e <f_rename+0x1fe>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 8007472:	4680      	mov	r8, r0
 8007474:	e5fd      	b.n	8007072 <f_rename+0xd2>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 8007476:	4b0c      	ldr	r3, [pc, #48]	; (80074a8 <f_rename+0x508>)
 8007478:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800747a:	429a      	cmp	r2, r3
 800747c:	f47f ae8e 	bne.w	800719c <f_rename+0x1fc>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8007480:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 8007484:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8007488:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
 800748c:	3320      	adds	r3, #32
 800748e:	429a      	cmp	r2, r3
 8007490:	f47f ae84 	bne.w	800719c <f_rename+0x1fc>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 8007494:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8007498:	f8d5 2220 	ldr.w	r2, [r5, #544]	; 0x220
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800749c:	612b      	str	r3, [r5, #16]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 800749e:	60ea      	str	r2, [r5, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80074a0:	2303      	movs	r3, #3
 80074a2:	e67c      	b.n	800719e <f_rename+0x1fe>
 80074a4:	ffffaa55 	.word	0xffffaa55
 80074a8:	41615252 	.word	0x41615252

080074ac <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fp			/* Pointer to the file object */
)
{
 80074ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int n = 0;
 80074b0:	2400      	movs	r4, #0
{
 80074b2:	b083      	sub	sp, #12
 80074b4:	4681      	mov	r9, r0
 80074b6:	4615      	mov	r5, r2
 80074b8:	1e4f      	subs	r7, r1, #1
	TCHAR c, *p = buff;
 80074ba:	4606      	mov	r6, r0
	*br = 0;	/* Clear read byte counter */
 80074bc:	46a0      	mov	r8, r4
 80074be:	42a7      	cmp	r7, r4
 80074c0:	dd06      	ble.n	80074d0 <f_gets+0x24>
 80074c2:	b12d      	cbz	r5, 80074d0 <f_gets+0x24>
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80074c4:	682b      	ldr	r3, [r5, #0]
	*br = 0;	/* Clear read byte counter */
 80074c6:	f8cd 8004 	str.w	r8, [sp, #4]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80074ca:	b10b      	cbz	r3, 80074d0 <f_gets+0x24>
 80074cc:	781a      	ldrb	r2, [r3, #0]
 80074ce:	b94a      	cbnz	r2, 80074e4 <f_gets+0x38>
		*p++ = c;
		n++;
		if (c == '\n') break;		/* Break on EOL */
	}
	*p = 0;
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
 80074d0:	2c00      	cmp	r4, #0
	*p = 0;
 80074d2:	f04f 0300 	mov.w	r3, #0
}
 80074d6:	bf14      	ite	ne
 80074d8:	4648      	movne	r0, r9
 80074da:	4618      	moveq	r0, r3
	*p = 0;
 80074dc:	7033      	strb	r3, [r6, #0]
}
 80074de:	b003      	add	sp, #12
 80074e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80074e4:	88d9      	ldrh	r1, [r3, #6]
 80074e6:	88aa      	ldrh	r2, [r5, #4]
 80074e8:	4291      	cmp	r1, r2
 80074ea:	d1f1      	bne.n	80074d0 <f_gets+0x24>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 80074ec:	7858      	ldrb	r0, [r3, #1]
 80074ee:	f7fb f94b 	bl	8002788 <disk_status>
 80074f2:	07c1      	lsls	r1, r0, #31
 80074f4:	d50d      	bpl.n	8007512 <f_gets+0x66>
		if (rc != 1) break;			/* Break on EOF or error */
 80074f6:	9b01      	ldr	r3, [sp, #4]
 80074f8:	2b01      	cmp	r3, #1
 80074fa:	d1e9      	bne.n	80074d0 <f_gets+0x24>
		c = s[0];
 80074fc:	f89d 3000 	ldrb.w	r3, [sp]
		if (c == '\r') continue;	/* Strip '\r' */
 8007500:	2b0d      	cmp	r3, #13
 8007502:	d0df      	beq.n	80074c4 <f_gets+0x18>
		if (c == '\n') break;		/* Break on EOL */
 8007504:	2b0a      	cmp	r3, #10
		*p++ = c;
 8007506:	f806 3b01 	strb.w	r3, [r6], #1
		n++;
 800750a:	f104 0401 	add.w	r4, r4, #1
		if (c == '\n') break;		/* Break on EOL */
 800750e:	d1d6      	bne.n	80074be <f_gets+0x12>
 8007510:	e7de      	b.n	80074d0 <f_gets+0x24>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
 8007512:	79ab      	ldrb	r3, [r5, #6]
 8007514:	061a      	lsls	r2, r3, #24
 8007516:	d4ee      	bmi.n	80074f6 <f_gets+0x4a>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 8007518:	07db      	lsls	r3, r3, #31
 800751a:	d5ec      	bpl.n	80074f6 <f_gets+0x4a>
 800751c:	ab01      	add	r3, sp, #4
 800751e:	2201      	movs	r2, #1
 8007520:	4669      	mov	r1, sp
 8007522:	4628      	mov	r0, r5
 8007524:	f7fc fc0e 	bl	8003d44 <f_read.part.11>
 8007528:	e7e5      	b.n	80074f6 <f_gets+0x4a>
 800752a:	bf00      	nop

0800752c <f_putc>:

int f_putc (
	TCHAR c,	/* A character to be output */
	FIL* fp		/* Pointer to the file object */
)
{
 800752c:	b530      	push	{r4, r5, lr}
	UINT bw, btw;
	BYTE s[3];


#if _USE_STRFUNC >= 2
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 800752e:	280a      	cmp	r0, #10
{
 8007530:	b083      	sub	sp, #12
 8007532:	4605      	mov	r5, r0
 8007534:	460c      	mov	r4, r1
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 8007536:	d019      	beq.n	800756c <f_putc+0x40>
	*bw = 0;	/* Clear write byte counter */
 8007538:	2300      	movs	r3, #0
			s[2] = (BYTE)(0x80 | (c & 0x3F));
			btw = 3;
		}
	}
#else				/* Write the character without conversion */
	s[0] = (BYTE)c;
 800753a:	f88d 5000 	strb.w	r5, [sp]
	*bw = 0;	/* Clear write byte counter */
 800753e:	9301      	str	r3, [sp, #4]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007540:	b11c      	cbz	r4, 800754a <f_putc+0x1e>
 8007542:	6823      	ldr	r3, [r4, #0]
 8007544:	b10b      	cbz	r3, 800754a <f_putc+0x1e>
 8007546:	781a      	ldrb	r2, [r3, #0]
 8007548:	b91a      	cbnz	r2, 8007552 <f_putc+0x26>
	btw = 1;
#endif
	f_write(fp, s, btw, &bw);		/* Write the char to the file */
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 800754a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800754e:	b003      	add	sp, #12
 8007550:	bd30      	pop	{r4, r5, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007552:	88d9      	ldrh	r1, [r3, #6]
 8007554:	88a2      	ldrh	r2, [r4, #4]
 8007556:	4291      	cmp	r1, r2
 8007558:	d1f7      	bne.n	800754a <f_putc+0x1e>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 800755a:	7858      	ldrb	r0, [r3, #1]
 800755c:	f7fb f914 	bl	8002788 <disk_status>
 8007560:	07c5      	lsls	r5, r0, #31
 8007562:	d525      	bpl.n	80075b0 <f_putc+0x84>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007564:	9801      	ldr	r0, [sp, #4]
 8007566:	2801      	cmp	r0, #1
 8007568:	d0f1      	beq.n	800754e <f_putc+0x22>
 800756a:	e7ee      	b.n	800754a <f_putc+0x1e>
	s[0] = (BYTE)c;
 800756c:	220d      	movs	r2, #13
	*bw = 0;	/* Clear write byte counter */
 800756e:	2300      	movs	r3, #0
	s[0] = (BYTE)c;
 8007570:	f88d 2000 	strb.w	r2, [sp]
	*bw = 0;	/* Clear write byte counter */
 8007574:	9301      	str	r3, [sp, #4]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007576:	2900      	cmp	r1, #0
 8007578:	d0de      	beq.n	8007538 <f_putc+0xc>
 800757a:	680b      	ldr	r3, [r1, #0]
 800757c:	2b00      	cmp	r3, #0
 800757e:	d0db      	beq.n	8007538 <f_putc+0xc>
 8007580:	781a      	ldrb	r2, [r3, #0]
 8007582:	2a00      	cmp	r2, #0
 8007584:	d0d8      	beq.n	8007538 <f_putc+0xc>
 8007586:	88d9      	ldrh	r1, [r3, #6]
 8007588:	88a2      	ldrh	r2, [r4, #4]
 800758a:	4291      	cmp	r1, r2
 800758c:	d1d4      	bne.n	8007538 <f_putc+0xc>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 800758e:	7858      	ldrb	r0, [r3, #1]
 8007590:	f7fb f8fa 	bl	8002788 <disk_status>
 8007594:	07c2      	lsls	r2, r0, #31
 8007596:	d4cf      	bmi.n	8007538 <f_putc+0xc>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007598:	79a3      	ldrb	r3, [r4, #6]
 800759a:	0619      	lsls	r1, r3, #24
 800759c:	d4cc      	bmi.n	8007538 <f_putc+0xc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 800759e:	079b      	lsls	r3, r3, #30
 80075a0:	d5ca      	bpl.n	8007538 <f_putc+0xc>
 80075a2:	ab01      	add	r3, sp, #4
 80075a4:	2201      	movs	r2, #1
 80075a6:	4669      	mov	r1, sp
 80075a8:	4620      	mov	r0, r4
 80075aa:	f7fc f9e5 	bl	8003978 <f_write.part.12>
 80075ae:	e7c3      	b.n	8007538 <f_putc+0xc>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 80075b0:	79a3      	ldrb	r3, [r4, #6]
 80075b2:	061a      	lsls	r2, r3, #24
 80075b4:	d4d6      	bmi.n	8007564 <f_putc+0x38>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 80075b6:	0798      	lsls	r0, r3, #30
 80075b8:	d5d4      	bpl.n	8007564 <f_putc+0x38>
 80075ba:	4620      	mov	r0, r4
 80075bc:	ab01      	add	r3, sp, #4
 80075be:	2201      	movs	r2, #1
 80075c0:	4669      	mov	r1, sp
 80075c2:	f7fc f9d9 	bl	8003978 <f_write.part.12>
 80075c6:	e7cd      	b.n	8007564 <f_putc+0x38>

080075c8 <f_puts>:

int f_puts (
	const TCHAR* str,	/* Pointer to the string to be output */
	FIL* fp				/* Pointer to the file object */
)
{
 80075c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int n;


	for (n = 0; *str; str++, n++) {
 80075cc:	7804      	ldrb	r4, [r0, #0]
{
 80075ce:	b083      	sub	sp, #12
	for (n = 0; *str; str++, n++) {
 80075d0:	2c00      	cmp	r4, #0
 80075d2:	d057      	beq.n	8007684 <f_puts+0xbc>
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 80075d4:	2c0a      	cmp	r4, #10
 80075d6:	460d      	mov	r5, r1
 80075d8:	4607      	mov	r7, r0
 80075da:	f100 0601 	add.w	r6, r0, #1
	s[0] = (BYTE)c;
 80075de:	f04f 090d 	mov.w	r9, #13
	*bw = 0;	/* Clear write byte counter */
 80075e2:	f04f 0800 	mov.w	r8, #0
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 80075e6:	d020      	beq.n	800762a <f_puts+0x62>
	s[0] = (BYTE)c;
 80075e8:	f88d 4000 	strb.w	r4, [sp]
	*bw = 0;	/* Clear write byte counter */
 80075ec:	f8cd 8004 	str.w	r8, [sp, #4]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80075f0:	b11d      	cbz	r5, 80075fa <f_puts+0x32>
 80075f2:	682b      	ldr	r3, [r5, #0]
 80075f4:	b10b      	cbz	r3, 80075fa <f_puts+0x32>
 80075f6:	781a      	ldrb	r2, [r3, #0]
 80075f8:	b922      	cbnz	r2, 8007604 <f_puts+0x3c>
		if (f_putc(*str, fp) == EOF) return EOF;
 80075fa:	f04f 30ff 	mov.w	r0, #4294967295
	}
	return n;
}
 80075fe:	b003      	add	sp, #12
 8007600:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007604:	88d9      	ldrh	r1, [r3, #6]
 8007606:	88aa      	ldrh	r2, [r5, #4]
 8007608:	4291      	cmp	r1, r2
 800760a:	d1f6      	bne.n	80075fa <f_puts+0x32>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 800760c:	7858      	ldrb	r0, [r3, #1]
 800760e:	f7fb f8bb 	bl	8002788 <disk_status>
 8007612:	07c4      	lsls	r4, r0, #31
 8007614:	d52a      	bpl.n	800766c <f_puts+0xa4>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007616:	9b01      	ldr	r3, [sp, #4]
 8007618:	2b01      	cmp	r3, #1
 800761a:	d1ee      	bne.n	80075fa <f_puts+0x32>
 800761c:	1bf0      	subs	r0, r6, r7
	for (n = 0; *str; str++, n++) {
 800761e:	f816 4b01 	ldrb.w	r4, [r6], #1
 8007622:	2c00      	cmp	r4, #0
 8007624:	d0eb      	beq.n	80075fe <f_puts+0x36>
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 8007626:	2c0a      	cmp	r4, #10
 8007628:	d1de      	bne.n	80075e8 <f_puts+0x20>
	s[0] = (BYTE)c;
 800762a:	f88d 9000 	strb.w	r9, [sp]
	*bw = 0;	/* Clear write byte counter */
 800762e:	f8cd 8004 	str.w	r8, [sp, #4]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007632:	2d00      	cmp	r5, #0
 8007634:	d0d8      	beq.n	80075e8 <f_puts+0x20>
 8007636:	682b      	ldr	r3, [r5, #0]
 8007638:	2b00      	cmp	r3, #0
 800763a:	d0d5      	beq.n	80075e8 <f_puts+0x20>
 800763c:	781a      	ldrb	r2, [r3, #0]
 800763e:	2a00      	cmp	r2, #0
 8007640:	d0d2      	beq.n	80075e8 <f_puts+0x20>
 8007642:	88d9      	ldrh	r1, [r3, #6]
 8007644:	88aa      	ldrh	r2, [r5, #4]
 8007646:	4291      	cmp	r1, r2
 8007648:	d1ce      	bne.n	80075e8 <f_puts+0x20>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 800764a:	7858      	ldrb	r0, [r3, #1]
 800764c:	f7fb f89c 	bl	8002788 <disk_status>
 8007650:	07c2      	lsls	r2, r0, #31
 8007652:	d4c9      	bmi.n	80075e8 <f_puts+0x20>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007654:	79ab      	ldrb	r3, [r5, #6]
 8007656:	0619      	lsls	r1, r3, #24
 8007658:	d4c6      	bmi.n	80075e8 <f_puts+0x20>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 800765a:	079b      	lsls	r3, r3, #30
 800765c:	d5c4      	bpl.n	80075e8 <f_puts+0x20>
 800765e:	ab01      	add	r3, sp, #4
 8007660:	2201      	movs	r2, #1
 8007662:	4669      	mov	r1, sp
 8007664:	4628      	mov	r0, r5
 8007666:	f7fc f987 	bl	8003978 <f_write.part.12>
 800766a:	e7bd      	b.n	80075e8 <f_puts+0x20>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 800766c:	79ab      	ldrb	r3, [r5, #6]
 800766e:	061a      	lsls	r2, r3, #24
 8007670:	d4d1      	bmi.n	8007616 <f_puts+0x4e>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007672:	0798      	lsls	r0, r3, #30
 8007674:	d5cf      	bpl.n	8007616 <f_puts+0x4e>
 8007676:	ab01      	add	r3, sp, #4
 8007678:	2201      	movs	r2, #1
 800767a:	4669      	mov	r1, sp
 800767c:	4628      	mov	r0, r5
 800767e:	f7fc f97b 	bl	8003978 <f_write.part.12>
 8007682:	e7c8      	b.n	8007616 <f_puts+0x4e>
	for (n = 0; *str; str++, n++) {
 8007684:	4620      	mov	r0, r4
 8007686:	e7ba      	b.n	80075fe <f_puts+0x36>

08007688 <f_printf>:
int f_printf (
	FIL* fp,			/* Pointer to the file object */
	const TCHAR* str,	/* Pointer to the format string */
	...					/* Optional arguments... */
)
{
 8007688:	b40e      	push	{r1, r2, r3}
 800768a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800768e:	b08c      	sub	sp, #48	; 0x30
 8007690:	ab15      	add	r3, sp, #84	; 0x54
	int res, chc, cc;


	va_start(arp, str);

	for (cc = res = 0; cc != EOF; res += cc) {
 8007692:	2200      	movs	r2, #0
{
 8007694:	f853 ab04 	ldr.w	sl, [r3], #4
	for (cc = res = 0; cc != EOF; res += cc) {
 8007698:	9201      	str	r2, [sp, #4]
	va_start(arp, str);
 800769a:	9306      	str	r3, [sp, #24]
{
 800769c:	4605      	mov	r5, r0
	*bw = 0;	/* Clear write byte counter */
 800769e:	4693      	mov	fp, r2
		c = *str++;
 80076a0:	f89a 4000 	ldrb.w	r4, [sl]
		if (c == 0) break;			/* End of string */
 80076a4:	b194      	cbz	r4, 80076cc <f_printf+0x44>
		if (c != '%') {				/* Non escape character */
 80076a6:	2c25      	cmp	r4, #37	; 0x25
 80076a8:	d016      	beq.n	80076d8 <f_printf+0x50>
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 80076aa:	2c0a      	cmp	r4, #10
 80076ac:	f000 8349 	beq.w	8007d42 <f_printf+0x6ba>
	s[0] = (BYTE)c;
 80076b0:	f88d 4014 	strb.w	r4, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 80076b4:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 80076b8:	b12d      	cbz	r5, 80076c6 <f_printf+0x3e>
 80076ba:	682b      	ldr	r3, [r5, #0]
 80076bc:	b11b      	cbz	r3, 80076c6 <f_printf+0x3e>
 80076be:	781a      	ldrb	r2, [r3, #0]
 80076c0:	2a00      	cmp	r2, #0
 80076c2:	f040 8329 	bne.w	8007d18 <f_printf+0x690>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 80076c6:	f04f 33ff 	mov.w	r3, #4294967295
 80076ca:	9301      	str	r3, [sp, #4]
		if (cc != EOF) cc = chc;
	}

	va_end(arp);
	return (cc == EOF) ? cc : res;
}
 80076cc:	9801      	ldr	r0, [sp, #4]
 80076ce:	b00c      	add	sp, #48	; 0x30
 80076d0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80076d4:	b003      	add	sp, #12
 80076d6:	4770      	bx	lr
		c = *str++;
 80076d8:	f89a 7001 	ldrb.w	r7, [sl, #1]
		if (c == '0') {				/* Flag: '0' padding */
 80076dc:	2f30      	cmp	r7, #48	; 0x30
 80076de:	f000 830b 	beq.w	8007cf8 <f_printf+0x670>
			if (c == '-') {			/* Flag: left justified */
 80076e2:	2f2d      	cmp	r7, #45	; 0x2d
 80076e4:	f000 8310 	beq.w	8007d08 <f_printf+0x680>
		c = *str++;
 80076e8:	2600      	movs	r6, #0
 80076ea:	f10a 0a02 	add.w	sl, sl, #2
		w = f = 0;
 80076ee:	4631      	mov	r1, r6
		c = *str++;
 80076f0:	2204      	movs	r2, #4
		while (IsDigit(c)) {		/* Precision */
 80076f2:	f1a7 0330 	sub.w	r3, r7, #48	; 0x30
 80076f6:	2b09      	cmp	r3, #9
 80076f8:	f04f 0400 	mov.w	r4, #0
 80076fc:	d80b      	bhi.n	8007716 <f_printf+0x8e>
			w = w * 10 + c - '0';
 80076fe:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8007702:	eb07 0444 	add.w	r4, r7, r4, lsl #1
			c = *str++;
 8007706:	f81a 7b01 	ldrb.w	r7, [sl], #1
		while (IsDigit(c)) {		/* Precision */
 800770a:	f1a7 0330 	sub.w	r3, r7, #48	; 0x30
 800770e:	2b09      	cmp	r3, #9
			w = w * 10 + c - '0';
 8007710:	f1a4 0430 	sub.w	r4, r4, #48	; 0x30
		while (IsDigit(c)) {		/* Precision */
 8007714:	d9f3      	bls.n	80076fe <f_printf+0x76>
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
 8007716:	f007 03df 	and.w	r3, r7, #223	; 0xdf
 800771a:	2b4c      	cmp	r3, #76	; 0x4c
 800771c:	f000 82db 	beq.w	8007cd6 <f_printf+0x64e>
 8007720:	2000      	movs	r0, #0
		if (!c) break;
 8007722:	2f00      	cmp	r7, #0
 8007724:	d0d2      	beq.n	80076cc <f_printf+0x44>
		if (IsLower(d)) d -= 0x20;
 8007726:	f1a7 0361 	sub.w	r3, r7, #97	; 0x61
 800772a:	2b19      	cmp	r3, #25
 800772c:	bf9a      	itte	ls
 800772e:	f1a7 0220 	subls.w	r2, r7, #32
 8007732:	b2d2      	uxtbls	r2, r2
 8007734:	463a      	movhi	r2, r7
		switch (d) {				/* Type is... */
 8007736:	f1a2 0342 	sub.w	r3, r2, #66	; 0x42
 800773a:	2b16      	cmp	r3, #22
 800773c:	f200 828f 	bhi.w	8007c5e <f_printf+0x5d6>
 8007740:	e8df f013 	tbh	[pc, r3, lsl #1]
 8007744:	02010227 	.word	0x02010227
 8007748:	028d01ea 	.word	0x028d01ea
 800774c:	028d028d 	.word	0x028d028d
 8007750:	028d028d 	.word	0x028d028d
 8007754:	028d028d 	.word	0x028d028d
 8007758:	028d028d 	.word	0x028d028d
 800775c:	0017028d 	.word	0x0017028d
 8007760:	028d028d 	.word	0x028d028d
 8007764:	022f028d 	.word	0x022f028d
 8007768:	01ea028d 	.word	0x01ea028d
 800776c:	028d028d 	.word	0x028d028d
 8007770:	022d      	.short	0x022d
 8007772:	2308      	movs	r3, #8
		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
 8007774:	2800      	cmp	r0, #0
 8007776:	f040 81d3 	bne.w	8007b20 <f_printf+0x498>
 800777a:	2a44      	cmp	r2, #68	; 0x44
 800777c:	f040 820a 	bne.w	8007b94 <f_printf+0x50c>
 8007780:	9a06      	ldr	r2, [sp, #24]
 8007782:	1d10      	adds	r0, r2, #4
 8007784:	9006      	str	r0, [sp, #24]
 8007786:	6810      	ldr	r0, [r2, #0]
		if (d == 'D' && (v & 0x80000000)) {
 8007788:	2800      	cmp	r0, #0
 800778a:	f2c0 81d5 	blt.w	8007b38 <f_printf+0x4b0>
			d = (TCHAR)(v % r); v /= r;
 800778e:	fbb0 f2f3 	udiv	r2, r0, r3
 8007792:	2f78      	cmp	r7, #120	; 0x78
 8007794:	fb03 0012 	mls	r0, r3, r2, r0
 8007798:	fa5f fe80 	uxtb.w	lr, r0
 800779c:	bf0c      	ite	eq
 800779e:	2727      	moveq	r7, #39	; 0x27
 80077a0:	2707      	movne	r7, #7
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 80077a2:	2809      	cmp	r0, #9
 80077a4:	bf84      	itt	hi
 80077a6:	44be      	addhi	lr, r7
 80077a8:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 80077ac:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80077b0:	f88d e020 	strb.w	lr, [sp, #32]
		} while (v && i < sizeof s / sizeof s[0]);
 80077b4:	2a00      	cmp	r2, #0
 80077b6:	f000 83b9 	beq.w	8007f2c <f_printf+0x8a4>
			d = (TCHAR)(v % r); v /= r;
 80077ba:	fbb2 f0f3 	udiv	r0, r2, r3
 80077be:	fb03 2210 	mls	r2, r3, r0, r2
 80077c2:	fa5f fe82 	uxtb.w	lr, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 80077c6:	2a09      	cmp	r2, #9
 80077c8:	bf84      	itt	hi
 80077ca:	44be      	addhi	lr, r7
 80077cc:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 80077d0:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80077d4:	f88d e021 	strb.w	lr, [sp, #33]	; 0x21
		} while (v && i < sizeof s / sizeof s[0]);
 80077d8:	2800      	cmp	r0, #0
 80077da:	f000 83b2 	beq.w	8007f42 <f_printf+0x8ba>
			d = (TCHAR)(v % r); v /= r;
 80077de:	fbb0 f2f3 	udiv	r2, r0, r3
 80077e2:	fb03 0012 	mls	r0, r3, r2, r0
 80077e6:	fa5f fe80 	uxtb.w	lr, r0
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 80077ea:	2809      	cmp	r0, #9
 80077ec:	bf84      	itt	hi
 80077ee:	44be      	addhi	lr, r7
 80077f0:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 80077f4:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80077f8:	f88d e022 	strb.w	lr, [sp, #34]	; 0x22
		} while (v && i < sizeof s / sizeof s[0]);
 80077fc:	2a00      	cmp	r2, #0
 80077fe:	f000 839c 	beq.w	8007f3a <f_printf+0x8b2>
			d = (TCHAR)(v % r); v /= r;
 8007802:	fbb2 f0f3 	udiv	r0, r2, r3
 8007806:	fb03 2210 	mls	r2, r3, r0, r2
 800780a:	fa5f fe82 	uxtb.w	lr, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 800780e:	2a09      	cmp	r2, #9
 8007810:	bf84      	itt	hi
 8007812:	44be      	addhi	lr, r7
 8007814:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 8007818:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800781c:	f88d e023 	strb.w	lr, [sp, #35]	; 0x23
		} while (v && i < sizeof s / sizeof s[0]);
 8007820:	2800      	cmp	r0, #0
 8007822:	f000 8392 	beq.w	8007f4a <f_printf+0x8c2>
			d = (TCHAR)(v % r); v /= r;
 8007826:	fbb0 f2f3 	udiv	r2, r0, r3
 800782a:	fb03 0012 	mls	r0, r3, r2, r0
 800782e:	fa5f fe80 	uxtb.w	lr, r0
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8007832:	2809      	cmp	r0, #9
 8007834:	bf84      	itt	hi
 8007836:	44be      	addhi	lr, r7
 8007838:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 800783c:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8007840:	f88d e024 	strb.w	lr, [sp, #36]	; 0x24
		} while (v && i < sizeof s / sizeof s[0]);
 8007844:	2a00      	cmp	r2, #0
 8007846:	f000 8384 	beq.w	8007f52 <f_printf+0x8ca>
			d = (TCHAR)(v % r); v /= r;
 800784a:	fbb2 f0f3 	udiv	r0, r2, r3
 800784e:	fb03 2210 	mls	r2, r3, r0, r2
 8007852:	fa5f fe82 	uxtb.w	lr, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8007856:	2a09      	cmp	r2, #9
 8007858:	bf84      	itt	hi
 800785a:	44be      	addhi	lr, r7
 800785c:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 8007860:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8007864:	f88d e025 	strb.w	lr, [sp, #37]	; 0x25
		} while (v && i < sizeof s / sizeof s[0]);
 8007868:	2800      	cmp	r0, #0
 800786a:	f000 8376 	beq.w	8007f5a <f_printf+0x8d2>
			d = (TCHAR)(v % r); v /= r;
 800786e:	fbb0 f2f3 	udiv	r2, r0, r3
 8007872:	fb03 0012 	mls	r0, r3, r2, r0
 8007876:	fa5f fe80 	uxtb.w	lr, r0
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 800787a:	2809      	cmp	r0, #9
 800787c:	bf84      	itt	hi
 800787e:	44be      	addhi	lr, r7
 8007880:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 8007884:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8007888:	f88d e026 	strb.w	lr, [sp, #38]	; 0x26
		} while (v && i < sizeof s / sizeof s[0]);
 800788c:	2a00      	cmp	r2, #0
 800788e:	f000 8368 	beq.w	8007f62 <f_printf+0x8da>
			d = (TCHAR)(v % r); v /= r;
 8007892:	fbb2 f0f3 	udiv	r0, r2, r3
 8007896:	fb03 2210 	mls	r2, r3, r0, r2
 800789a:	fa5f fe82 	uxtb.w	lr, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 800789e:	2a09      	cmp	r2, #9
 80078a0:	bf84      	itt	hi
 80078a2:	44be      	addhi	lr, r7
 80078a4:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 80078a8:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80078ac:	f88d e027 	strb.w	lr, [sp, #39]	; 0x27
		} while (v && i < sizeof s / sizeof s[0]);
 80078b0:	2800      	cmp	r0, #0
 80078b2:	f000 83b0 	beq.w	8008016 <f_printf+0x98e>
			d = (TCHAR)(v % r); v /= r;
 80078b6:	fbb0 f2f3 	udiv	r2, r0, r3
 80078ba:	fb03 0012 	mls	r0, r3, r2, r0
 80078be:	fa5f fe80 	uxtb.w	lr, r0
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 80078c2:	2809      	cmp	r0, #9
 80078c4:	bf84      	itt	hi
 80078c6:	44be      	addhi	lr, r7
 80078c8:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 80078cc:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80078d0:	f88d e028 	strb.w	lr, [sp, #40]	; 0x28
		} while (v && i < sizeof s / sizeof s[0]);
 80078d4:	2a00      	cmp	r2, #0
 80078d6:	f000 839a 	beq.w	800800e <f_printf+0x986>
			d = (TCHAR)(v % r); v /= r;
 80078da:	fbb2 f0f3 	udiv	r0, r2, r3
 80078de:	fb03 2210 	mls	r2, r3, r0, r2
 80078e2:	fa5f fe82 	uxtb.w	lr, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 80078e6:	2a09      	cmp	r2, #9
 80078e8:	bf84      	itt	hi
 80078ea:	44be      	addhi	lr, r7
 80078ec:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 80078f0:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 80078f4:	f88d e029 	strb.w	lr, [sp, #41]	; 0x29
		} while (v && i < sizeof s / sizeof s[0]);
 80078f8:	2800      	cmp	r0, #0
 80078fa:	f000 8390 	beq.w	800801e <f_printf+0x996>
			d = (TCHAR)(v % r); v /= r;
 80078fe:	fbb0 f2f3 	udiv	r2, r0, r3
 8007902:	fb03 0012 	mls	r0, r3, r2, r0
 8007906:	fa5f fe80 	uxtb.w	lr, r0
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 800790a:	2809      	cmp	r0, #9
 800790c:	bf84      	itt	hi
 800790e:	44be      	addhi	lr, r7
 8007910:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 8007914:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8007918:	f88d e02a 	strb.w	lr, [sp, #42]	; 0x2a
		} while (v && i < sizeof s / sizeof s[0]);
 800791c:	2a00      	cmp	r2, #0
 800791e:	f000 8390 	beq.w	8008042 <f_printf+0x9ba>
			d = (TCHAR)(v % r); v /= r;
 8007922:	fbb2 f0f3 	udiv	r0, r2, r3
 8007926:	fb03 2210 	mls	r2, r3, r0, r2
 800792a:	fa5f fe82 	uxtb.w	lr, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 800792e:	2a09      	cmp	r2, #9
 8007930:	bf84      	itt	hi
 8007932:	44be      	addhi	lr, r7
 8007934:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 8007938:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 800793c:	f88d e02b 	strb.w	lr, [sp, #43]	; 0x2b
		} while (v && i < sizeof s / sizeof s[0]);
 8007940:	2800      	cmp	r0, #0
 8007942:	f000 837a 	beq.w	800803a <f_printf+0x9b2>
			d = (TCHAR)(v % r); v /= r;
 8007946:	fbb0 f2f3 	udiv	r2, r0, r3
 800794a:	fb03 0012 	mls	r0, r3, r2, r0
 800794e:	fa5f fe80 	uxtb.w	lr, r0
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8007952:	2809      	cmp	r0, #9
 8007954:	bf84      	itt	hi
 8007956:	44be      	addhi	lr, r7
 8007958:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 800795c:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8007960:	f88d e02c 	strb.w	lr, [sp, #44]	; 0x2c
		} while (v && i < sizeof s / sizeof s[0]);
 8007964:	2a00      	cmp	r2, #0
 8007966:	f000 8370 	beq.w	800804a <f_printf+0x9c2>
			d = (TCHAR)(v % r); v /= r;
 800796a:	fbb2 f0f3 	udiv	r0, r2, r3
 800796e:	fb03 2210 	mls	r2, r3, r0, r2
 8007972:	fa5f fe82 	uxtb.w	lr, r2
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8007976:	2a09      	cmp	r2, #9
 8007978:	bf84      	itt	hi
 800797a:	44be      	addhi	lr, r7
 800797c:	fa5f fe8e 	uxtbhi.w	lr, lr
			s[i++] = d + '0';
 8007980:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
 8007984:	f88d e02d 	strb.w	lr, [sp, #45]	; 0x2d
		} while (v && i < sizeof s / sizeof s[0]);
 8007988:	2800      	cmp	r0, #0
 800798a:	f000 8366 	beq.w	800805a <f_printf+0x9d2>
			d = (TCHAR)(v % r); v /= r;
 800798e:	fbb0 fef3 	udiv	lr, r0, r3
 8007992:	fb03 001e 	mls	r0, r3, lr, r0
 8007996:	b2c2      	uxtb	r2, r0
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8007998:	2809      	cmp	r0, #9
 800799a:	bf84      	itt	hi
 800799c:	19d2      	addhi	r2, r2, r7
 800799e:	b2d2      	uxtbhi	r2, r2
			s[i++] = d + '0';
 80079a0:	3230      	adds	r2, #48	; 0x30
 80079a2:	f88d 202e 	strb.w	r2, [sp, #46]	; 0x2e
		} while (v && i < sizeof s / sizeof s[0]);
 80079a6:	f1be 0f00 	cmp.w	lr, #0
 80079aa:	f000 8352 	beq.w	8008052 <f_printf+0x9ca>
			d = (TCHAR)(v % r); v /= r;
 80079ae:	fbbe f2f3 	udiv	r2, lr, r3
 80079b2:	fb03 e312 	mls	r3, r3, r2, lr
 80079b6:	b2da      	uxtb	r2, r3
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 80079b8:	2b09      	cmp	r3, #9
 80079ba:	bf84      	itt	hi
 80079bc:	19d2      	addhi	r2, r2, r7
 80079be:	b2d2      	uxtbhi	r2, r2
			s[i++] = d + '0';
 80079c0:	3230      	adds	r2, #48	; 0x30
 80079c2:	2310      	movs	r3, #16
 80079c4:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
 80079c8:	9302      	str	r3, [sp, #8]
 80079ca:	220f      	movs	r2, #15
		if (f & 8) s[i++] = '-';
 80079cc:	0708      	lsls	r0, r1, #28
 80079ce:	d507      	bpl.n	80079e0 <f_printf+0x358>
 80079d0:	9b02      	ldr	r3, [sp, #8]
 80079d2:	a80c      	add	r0, sp, #48	; 0x30
 80079d4:	4403      	add	r3, r0
 80079d6:	3202      	adds	r2, #2
 80079d8:	202d      	movs	r0, #45	; 0x2d
 80079da:	9202      	str	r2, [sp, #8]
 80079dc:	f803 0c10 	strb.w	r0, [r3, #-16]
		j = i; d = (f & 1) ? '0' : ' ';
 80079e0:	f011 0f01 	tst.w	r1, #1
 80079e4:	bf14      	ite	ne
 80079e6:	f04f 0930 	movne.w	r9, #48	; 0x30
 80079ea:	f04f 0920 	moveq.w	r9, #32
		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
 80079ee:	2e00      	cmp	r6, #0
 80079f0:	f040 829f 	bne.w	8007f32 <f_printf+0x8aa>
 80079f4:	9b02      	ldr	r3, [sp, #8]
 80079f6:	42a3      	cmp	r3, r4
 80079f8:	f103 0701 	add.w	r7, r3, #1
 80079fc:	d225      	bcs.n	8007a4a <f_printf+0x3c2>
 80079fe:	f104 0801 	add.w	r8, r4, #1
 8007a02:	b935      	cbnz	r5, 8007a12 <f_printf+0x38a>
 8007a04:	e082      	b.n	8007b0c <f_printf+0x484>
 8007a06:	3701      	adds	r7, #1
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007a08:	f04f 33ff 	mov.w	r3, #4294967295
		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
 8007a0c:	4547      	cmp	r7, r8
 8007a0e:	441e      	add	r6, r3
 8007a10:	d01a      	beq.n	8007a48 <f_printf+0x3c0>
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007a12:	682b      	ldr	r3, [r5, #0]
	s[0] = (BYTE)c;
 8007a14:	f88d 9014 	strb.w	r9, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007a18:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007a1c:	2b00      	cmp	r3, #0
 8007a1e:	d0f2      	beq.n	8007a06 <f_printf+0x37e>
 8007a20:	781a      	ldrb	r2, [r3, #0]
 8007a22:	2a00      	cmp	r2, #0
 8007a24:	d0ef      	beq.n	8007a06 <f_printf+0x37e>
 8007a26:	88a9      	ldrh	r1, [r5, #4]
 8007a28:	88da      	ldrh	r2, [r3, #6]
 8007a2a:	4291      	cmp	r1, r2
 8007a2c:	d1eb      	bne.n	8007a06 <f_printf+0x37e>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007a2e:	7858      	ldrb	r0, [r3, #1]
 8007a30:	f7fa feaa 	bl	8002788 <disk_status>
 8007a34:	07c1      	lsls	r1, r0, #31
 8007a36:	f140 81dd 	bpl.w	8007df4 <f_printf+0x76c>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007a3a:	9b07      	ldr	r3, [sp, #28]
 8007a3c:	2b01      	cmp	r3, #1
 8007a3e:	d1e2      	bne.n	8007a06 <f_printf+0x37e>
		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
 8007a40:	3701      	adds	r7, #1
 8007a42:	4547      	cmp	r7, r8
 8007a44:	441e      	add	r6, r3
 8007a46:	d1e4      	bne.n	8007a12 <f_printf+0x38a>
 8007a48:	9b02      	ldr	r3, [sp, #8]
 8007a4a:	aa08      	add	r2, sp, #32
 8007a4c:	4413      	add	r3, r2
 8007a4e:	4698      	mov	r8, r3
 8007a50:	e005      	b.n	8007a5e <f_printf+0x3d6>
		do chc += (cc = f_putc(s[--i], fp)); while(i);
 8007a52:	aa08      	add	r2, sp, #32
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007a54:	f04f 33ff 	mov.w	r3, #4294967295
		do chc += (cc = f_putc(s[--i], fp)); while(i);
 8007a58:	4542      	cmp	r2, r8
 8007a5a:	441e      	add	r6, r3
 8007a5c:	d027      	beq.n	8007aae <f_printf+0x426>
 8007a5e:	f818 9d01 	ldrb.w	r9, [r8, #-1]!
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 8007a62:	f1b9 0f0a 	cmp.w	r9, #10
 8007a66:	f000 8105 	beq.w	8007c74 <f_printf+0x5ec>
	s[0] = (BYTE)c;
 8007a6a:	f88d 9014 	strb.w	r9, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007a6e:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007a72:	2d00      	cmp	r5, #0
 8007a74:	d0ed      	beq.n	8007a52 <f_printf+0x3ca>
 8007a76:	682b      	ldr	r3, [r5, #0]
 8007a78:	2b00      	cmp	r3, #0
 8007a7a:	d0ea      	beq.n	8007a52 <f_printf+0x3ca>
 8007a7c:	781a      	ldrb	r2, [r3, #0]
 8007a7e:	2a00      	cmp	r2, #0
 8007a80:	d0e7      	beq.n	8007a52 <f_printf+0x3ca>
 8007a82:	88d9      	ldrh	r1, [r3, #6]
 8007a84:	88aa      	ldrh	r2, [r5, #4]
 8007a86:	4291      	cmp	r1, r2
 8007a88:	d1e3      	bne.n	8007a52 <f_printf+0x3ca>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007a8a:	7858      	ldrb	r0, [r3, #1]
 8007a8c:	f7fa fe7c 	bl	8002788 <disk_status>
 8007a90:	07c3      	lsls	r3, r0, #31
 8007a92:	d405      	bmi.n	8007aa0 <f_printf+0x418>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007a94:	79ab      	ldrb	r3, [r5, #6]
 8007a96:	061a      	lsls	r2, r3, #24
 8007a98:	d402      	bmi.n	8007aa0 <f_printf+0x418>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007a9a:	0798      	lsls	r0, r3, #30
 8007a9c:	f100 8114 	bmi.w	8007cc8 <f_printf+0x640>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007aa0:	9b07      	ldr	r3, [sp, #28]
 8007aa2:	2b01      	cmp	r3, #1
 8007aa4:	d1d5      	bne.n	8007a52 <f_printf+0x3ca>
		do chc += (cc = f_putc(s[--i], fp)); while(i);
 8007aa6:	aa08      	add	r2, sp, #32
 8007aa8:	4542      	cmp	r2, r8
 8007aaa:	441e      	add	r6, r3
 8007aac:	d1d7      	bne.n	8007a5e <f_printf+0x3d6>
		while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007aae:	42a7      	cmp	r7, r4
 8007ab0:	f080 8118 	bcs.w	8007ce4 <f_printf+0x65c>
 8007ab4:	2d00      	cmp	r5, #0
 8007ab6:	f43f ae06 	beq.w	80076c6 <f_printf+0x3e>
 8007aba:	3702      	adds	r7, #2
	s[0] = (BYTE)c;
 8007abc:	f04f 0820 	mov.w	r8, #32
 8007ac0:	e007      	b.n	8007ad2 <f_printf+0x44a>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007ac2:	f04f 33ff 	mov.w	r3, #4294967295
		while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007ac6:	1e7a      	subs	r2, r7, #1
 8007ac8:	42a2      	cmp	r2, r4
 8007aca:	441e      	add	r6, r3
 8007acc:	f080 810a 	bcs.w	8007ce4 <f_printf+0x65c>
 8007ad0:	3701      	adds	r7, #1
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007ad2:	682b      	ldr	r3, [r5, #0]
	s[0] = (BYTE)c;
 8007ad4:	f88d 8014 	strb.w	r8, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007ad8:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007adc:	2b00      	cmp	r3, #0
 8007ade:	d0f0      	beq.n	8007ac2 <f_printf+0x43a>
 8007ae0:	781a      	ldrb	r2, [r3, #0]
 8007ae2:	2a00      	cmp	r2, #0
 8007ae4:	d0ed      	beq.n	8007ac2 <f_printf+0x43a>
 8007ae6:	88d9      	ldrh	r1, [r3, #6]
 8007ae8:	88aa      	ldrh	r2, [r5, #4]
 8007aea:	4291      	cmp	r1, r2
 8007aec:	d1e9      	bne.n	8007ac2 <f_printf+0x43a>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007aee:	7858      	ldrb	r0, [r3, #1]
 8007af0:	f7fa fe4a 	bl	8002788 <disk_status>
 8007af4:	07c1      	lsls	r1, r0, #31
 8007af6:	f140 818b 	bpl.w	8007e10 <f_printf+0x788>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007afa:	9b07      	ldr	r3, [sp, #28]
 8007afc:	2b01      	cmp	r3, #1
 8007afe:	d0e2      	beq.n	8007ac6 <f_printf+0x43e>
		while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007b00:	1e7b      	subs	r3, r7, #1
 8007b02:	42a3      	cmp	r3, r4
 8007b04:	f106 36ff 	add.w	r6, r6, #4294967295
 8007b08:	d3e2      	bcc.n	8007ad0 <f_printf+0x448>
 8007b0a:	e5dc      	b.n	80076c6 <f_printf+0x3e>
		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
 8007b0c:	3701      	adds	r7, #1
 8007b0e:	4547      	cmp	r7, r8
 8007b10:	d1fc      	bne.n	8007b0c <f_printf+0x484>
 8007b12:	9b02      	ldr	r3, [sp, #8]
 8007b14:	1b1e      	subs	r6, r3, r4
 8007b16:	e798      	b.n	8007a4a <f_printf+0x3c2>
		switch (d) {				/* Type is... */
 8007b18:	230a      	movs	r3, #10
		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
 8007b1a:	2800      	cmp	r0, #0
 8007b1c:	f43f ae2d 	beq.w	800777a <f_printf+0xf2>
 8007b20:	9806      	ldr	r0, [sp, #24]
		if (d == 'D' && (v & 0x80000000)) {
 8007b22:	2a44      	cmp	r2, #68	; 0x44
		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
 8007b24:	f100 0e04 	add.w	lr, r0, #4
 8007b28:	f8cd e018 	str.w	lr, [sp, #24]
 8007b2c:	6800      	ldr	r0, [r0, #0]
		if (d == 'D' && (v & 0x80000000)) {
 8007b2e:	f47f ae2e 	bne.w	800778e <f_printf+0x106>
 8007b32:	2800      	cmp	r0, #0
 8007b34:	f6bf ae2b 	bge.w	800778e <f_printf+0x106>
			f |= 8;
 8007b38:	f041 0208 	orr.w	r2, r1, #8
 8007b3c:	f001 0602 	and.w	r6, r1, #2
			v = 0 - v;
 8007b40:	4240      	negs	r0, r0
			f |= 8;
 8007b42:	b2d1      	uxtb	r1, r2
 8007b44:	e623      	b.n	800778e <f_printf+0x106>
			cc = f_putc((TCHAR)va_arg(arp, int), fp); continue;
 8007b46:	9b06      	ldr	r3, [sp, #24]
 8007b48:	781c      	ldrb	r4, [r3, #0]
 8007b4a:	3304      	adds	r3, #4
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 8007b4c:	2c0a      	cmp	r4, #10
			cc = f_putc((TCHAR)va_arg(arp, int), fp); continue;
 8007b4e:	9306      	str	r3, [sp, #24]
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 8007b50:	f000 8234 	beq.w	8007fbc <f_printf+0x934>
	s[0] = (BYTE)c;
 8007b54:	f88d 4014 	strb.w	r4, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007b58:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007b5c:	2d00      	cmp	r5, #0
 8007b5e:	f43f adb2 	beq.w	80076c6 <f_printf+0x3e>
 8007b62:	682b      	ldr	r3, [r5, #0]
 8007b64:	2b00      	cmp	r3, #0
 8007b66:	f43f adae 	beq.w	80076c6 <f_printf+0x3e>
 8007b6a:	781a      	ldrb	r2, [r3, #0]
 8007b6c:	2a00      	cmp	r2, #0
 8007b6e:	f43f adaa 	beq.w	80076c6 <f_printf+0x3e>
 8007b72:	88d9      	ldrh	r1, [r3, #6]
 8007b74:	88aa      	ldrh	r2, [r5, #4]
 8007b76:	4291      	cmp	r1, r2
 8007b78:	f47f ada5 	bne.w	80076c6 <f_printf+0x3e>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007b7c:	7858      	ldrb	r0, [r3, #1]
 8007b7e:	f7fa fe03 	bl	8002788 <disk_status>
 8007b82:	07c6      	lsls	r6, r0, #31
 8007b84:	f140 8280 	bpl.w	8008088 <f_printf+0xa00>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007b88:	9b07      	ldr	r3, [sp, #28]
 8007b8a:	2b01      	cmp	r3, #1
 8007b8c:	f000 80d5 	beq.w	8007d3a <f_printf+0x6b2>
 8007b90:	e599      	b.n	80076c6 <f_printf+0x3e>
		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
 8007b92:	2302      	movs	r3, #2
 8007b94:	9a06      	ldr	r2, [sp, #24]
 8007b96:	1d10      	adds	r0, r2, #4
 8007b98:	9006      	str	r0, [sp, #24]
 8007b9a:	6810      	ldr	r0, [r2, #0]
 8007b9c:	e5f7      	b.n	800778e <f_printf+0x106>
 8007b9e:	2310      	movs	r3, #16
 8007ba0:	e7f8      	b.n	8007b94 <f_printf+0x50c>
			p = va_arg(arp, TCHAR*);
 8007ba2:	9b06      	ldr	r3, [sp, #24]
 8007ba4:	681a      	ldr	r2, [r3, #0]
 8007ba6:	9202      	str	r2, [sp, #8]
			for (j = 0; p[j]; j++) ;
 8007ba8:	7810      	ldrb	r0, [r2, #0]
			p = va_arg(arp, TCHAR*);
 8007baa:	3304      	adds	r3, #4
 8007bac:	9306      	str	r3, [sp, #24]
			for (j = 0; p[j]; j++) ;
 8007bae:	4607      	mov	r7, r0
 8007bb0:	2800      	cmp	r0, #0
 8007bb2:	f000 8256 	beq.w	8008062 <f_printf+0x9da>
 8007bb6:	2300      	movs	r3, #0
 8007bb8:	e000      	b.n	8007bbc <f_printf+0x534>
 8007bba:	4643      	mov	r3, r8
 8007bbc:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8007bc0:	f103 0801 	add.w	r8, r3, #1
 8007bc4:	2900      	cmp	r1, #0
 8007bc6:	d1f8      	bne.n	8007bba <f_printf+0x532>
			if (!(f & 2)) {
 8007bc8:	2e00      	cmp	r6, #0
 8007bca:	f000 80e3 	beq.w	8007d94 <f_printf+0x70c>
 8007bce:	3302      	adds	r3, #2
 8007bd0:	9303      	str	r3, [sp, #12]
			chc = 0;
 8007bd2:	460e      	mov	r6, r1
 8007bd4:	9a02      	ldr	r2, [sp, #8]
 8007bd6:	9402      	str	r4, [sp, #8]
 8007bd8:	f102 0901 	add.w	r9, r2, #1
 8007bdc:	4614      	mov	r4, r2
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 8007bde:	2f0a      	cmp	r7, #10
 8007be0:	f000 8142 	beq.w	8007e68 <f_printf+0x7e0>
	s[0] = (BYTE)c;
 8007be4:	f88d 7014 	strb.w	r7, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007be8:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007bec:	2d00      	cmp	r5, #0
 8007bee:	f43f ad6a 	beq.w	80076c6 <f_printf+0x3e>
 8007bf2:	682b      	ldr	r3, [r5, #0]
 8007bf4:	b11b      	cbz	r3, 8007bfe <f_printf+0x576>
 8007bf6:	781a      	ldrb	r2, [r3, #0]
 8007bf8:	2a00      	cmp	r2, #0
 8007bfa:	f040 8117 	bne.w	8007e2c <f_printf+0x7a4>
 8007bfe:	9c02      	ldr	r4, [sp, #8]
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007c00:	45a0      	cmp	r8, r4
			chc += (cc = f_puts(p, fp));
 8007c02:	f106 36ff 	add.w	r6, r6, #4294967295
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007c06:	f4bf ad5e 	bcs.w	80076c6 <f_printf+0x3e>
 8007c0a:	9f03      	ldr	r7, [sp, #12]
	s[0] = (BYTE)c;
 8007c0c:	f04f 0820 	mov.w	r8, #32
 8007c10:	3701      	adds	r7, #1
 8007c12:	e007      	b.n	8007c24 <f_printf+0x59c>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007c14:	f04f 32ff 	mov.w	r2, #4294967295
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007c18:	1e7b      	subs	r3, r7, #1
 8007c1a:	42a3      	cmp	r3, r4
 8007c1c:	4416      	add	r6, r2
 8007c1e:	f080 811f 	bcs.w	8007e60 <f_printf+0x7d8>
 8007c22:	3701      	adds	r7, #1
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007c24:	682b      	ldr	r3, [r5, #0]
	s[0] = (BYTE)c;
 8007c26:	f88d 8014 	strb.w	r8, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007c2a:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007c2e:	2b00      	cmp	r3, #0
 8007c30:	d0f0      	beq.n	8007c14 <f_printf+0x58c>
 8007c32:	781a      	ldrb	r2, [r3, #0]
 8007c34:	2a00      	cmp	r2, #0
 8007c36:	d0ed      	beq.n	8007c14 <f_printf+0x58c>
 8007c38:	88d9      	ldrh	r1, [r3, #6]
 8007c3a:	88aa      	ldrh	r2, [r5, #4]
 8007c3c:	4291      	cmp	r1, r2
 8007c3e:	d1e9      	bne.n	8007c14 <f_printf+0x58c>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007c40:	7858      	ldrb	r0, [r3, #1]
 8007c42:	f7fa fda1 	bl	8002788 <disk_status>
 8007c46:	07c1      	lsls	r1, r0, #31
 8007c48:	f140 8162 	bpl.w	8007f10 <f_printf+0x888>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007c4c:	9a07      	ldr	r2, [sp, #28]
 8007c4e:	2a01      	cmp	r2, #1
 8007c50:	d0e2      	beq.n	8007c18 <f_printf+0x590>
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007c52:	1e7b      	subs	r3, r7, #1
 8007c54:	42a3      	cmp	r3, r4
 8007c56:	f106 36ff 	add.w	r6, r6, #4294967295
 8007c5a:	d3e2      	bcc.n	8007c22 <f_printf+0x59a>
 8007c5c:	e533      	b.n	80076c6 <f_printf+0x3e>
	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
 8007c5e:	2f0a      	cmp	r7, #10
 8007c60:	f000 8183 	beq.w	8007f6a <f_printf+0x8e2>
	s[0] = (BYTE)c;
 8007c64:	f88d 7014 	strb.w	r7, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007c68:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007c6c:	2d00      	cmp	r5, #0
 8007c6e:	f47f af78 	bne.w	8007b62 <f_printf+0x4da>
 8007c72:	e528      	b.n	80076c6 <f_printf+0x3e>
	s[0] = (BYTE)c;
 8007c74:	f04f 030d 	mov.w	r3, #13
 8007c78:	f88d 3014 	strb.w	r3, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007c7c:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007c80:	2d00      	cmp	r5, #0
 8007c82:	f43f aef2 	beq.w	8007a6a <f_printf+0x3e2>
 8007c86:	682b      	ldr	r3, [r5, #0]
 8007c88:	2b00      	cmp	r3, #0
 8007c8a:	f43f aeee 	beq.w	8007a6a <f_printf+0x3e2>
 8007c8e:	781a      	ldrb	r2, [r3, #0]
 8007c90:	2a00      	cmp	r2, #0
 8007c92:	f43f aeea 	beq.w	8007a6a <f_printf+0x3e2>
 8007c96:	88d9      	ldrh	r1, [r3, #6]
 8007c98:	88aa      	ldrh	r2, [r5, #4]
 8007c9a:	4291      	cmp	r1, r2
 8007c9c:	f47f aee5 	bne.w	8007a6a <f_printf+0x3e2>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007ca0:	7858      	ldrb	r0, [r3, #1]
 8007ca2:	f7fa fd71 	bl	8002788 <disk_status>
 8007ca6:	07c1      	lsls	r1, r0, #31
 8007ca8:	f53f aedf 	bmi.w	8007a6a <f_printf+0x3e2>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007cac:	79ab      	ldrb	r3, [r5, #6]
 8007cae:	0619      	lsls	r1, r3, #24
 8007cb0:	f53f aedb 	bmi.w	8007a6a <f_printf+0x3e2>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007cb4:	079a      	lsls	r2, r3, #30
 8007cb6:	f57f aed8 	bpl.w	8007a6a <f_printf+0x3e2>
 8007cba:	ab07      	add	r3, sp, #28
 8007cbc:	2201      	movs	r2, #1
 8007cbe:	a905      	add	r1, sp, #20
 8007cc0:	4628      	mov	r0, r5
 8007cc2:	f7fb fe59 	bl	8003978 <f_write.part.12>
 8007cc6:	e6d0      	b.n	8007a6a <f_printf+0x3e2>
 8007cc8:	ab07      	add	r3, sp, #28
 8007cca:	2201      	movs	r2, #1
 8007ccc:	a905      	add	r1, sp, #20
 8007cce:	4628      	mov	r0, r5
 8007cd0:	f7fb fe52 	bl	8003978 <f_write.part.12>
 8007cd4:	e6e4      	b.n	8007aa0 <f_printf+0x418>
			f |= 4; c = *str++;
 8007cd6:	f89a 7000 	ldrb.w	r7, [sl]
 8007cda:	4611      	mov	r1, r2
 8007cdc:	2004      	movs	r0, #4
 8007cde:	f10a 0a01 	add.w	sl, sl, #1
 8007ce2:	e51e      	b.n	8007722 <f_printf+0x9a>
		if (cc != EOF) cc = chc;
 8007ce4:	3301      	adds	r3, #1
 8007ce6:	f43f acee 	beq.w	80076c6 <f_printf+0x3e>
	for (cc = res = 0; cc != EOF; res += cc) {
 8007cea:	9b01      	ldr	r3, [sp, #4]
 8007cec:	4433      	add	r3, r6
 8007cee:	3601      	adds	r6, #1
 8007cf0:	9301      	str	r3, [sp, #4]
 8007cf2:	f47f acd5 	bne.w	80076a0 <f_printf+0x18>
 8007cf6:	e4e6      	b.n	80076c6 <f_printf+0x3e>
			f = 1; c = *str++;
 8007cf8:	f89a 7002 	ldrb.w	r7, [sl, #2]
 8007cfc:	2600      	movs	r6, #0
 8007cfe:	f10a 0a03 	add.w	sl, sl, #3
 8007d02:	2205      	movs	r2, #5
 8007d04:	2101      	movs	r1, #1
 8007d06:	e4f4      	b.n	80076f2 <f_printf+0x6a>
				f = 2; c = *str++;
 8007d08:	2602      	movs	r6, #2
 8007d0a:	f89a 7002 	ldrb.w	r7, [sl, #2]
 8007d0e:	4631      	mov	r1, r6
 8007d10:	2206      	movs	r2, #6
 8007d12:	f10a 0a03 	add.w	sl, sl, #3
 8007d16:	e4ec      	b.n	80076f2 <f_printf+0x6a>
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007d18:	88d9      	ldrh	r1, [r3, #6]
 8007d1a:	88aa      	ldrh	r2, [r5, #4]
 8007d1c:	4291      	cmp	r1, r2
 8007d1e:	f47f acd2 	bne.w	80076c6 <f_printf+0x3e>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007d22:	7858      	ldrb	r0, [r3, #1]
 8007d24:	f7fa fd30 	bl	8002788 <disk_status>
 8007d28:	07c1      	lsls	r1, r0, #31
 8007d2a:	f140 80e3 	bpl.w	8007ef4 <f_printf+0x86c>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007d2e:	9b07      	ldr	r3, [sp, #28]
 8007d30:	2b01      	cmp	r3, #1
 8007d32:	f47f acc8 	bne.w	80076c6 <f_printf+0x3e>
		c = *str++;
 8007d36:	f10a 0a01 	add.w	sl, sl, #1
	for (cc = res = 0; cc != EOF; res += cc) {
 8007d3a:	9b01      	ldr	r3, [sp, #4]
 8007d3c:	3301      	adds	r3, #1
 8007d3e:	9301      	str	r3, [sp, #4]
 8007d40:	e4ae      	b.n	80076a0 <f_printf+0x18>
	s[0] = (BYTE)c;
 8007d42:	230d      	movs	r3, #13
	*bw = 0;	/* Clear write byte counter */
 8007d44:	f8cd b01c 	str.w	fp, [sp, #28]
	s[0] = (BYTE)c;
 8007d48:	f88d 3014 	strb.w	r3, [sp, #20]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007d4c:	2d00      	cmp	r5, #0
 8007d4e:	f43f acaf 	beq.w	80076b0 <f_printf+0x28>
 8007d52:	682b      	ldr	r3, [r5, #0]
 8007d54:	2b00      	cmp	r3, #0
 8007d56:	f43f acab 	beq.w	80076b0 <f_printf+0x28>
 8007d5a:	781a      	ldrb	r2, [r3, #0]
 8007d5c:	2a00      	cmp	r2, #0
 8007d5e:	f43f aca7 	beq.w	80076b0 <f_printf+0x28>
 8007d62:	88d9      	ldrh	r1, [r3, #6]
 8007d64:	88aa      	ldrh	r2, [r5, #4]
 8007d66:	4291      	cmp	r1, r2
 8007d68:	f47f aca2 	bne.w	80076b0 <f_printf+0x28>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007d6c:	7858      	ldrb	r0, [r3, #1]
 8007d6e:	f7fa fd0b 	bl	8002788 <disk_status>
 8007d72:	07c6      	lsls	r6, r0, #31
 8007d74:	f53f ac9c 	bmi.w	80076b0 <f_printf+0x28>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007d78:	79ab      	ldrb	r3, [r5, #6]
 8007d7a:	0618      	lsls	r0, r3, #24
 8007d7c:	f53f ac98 	bmi.w	80076b0 <f_printf+0x28>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007d80:	0798      	lsls	r0, r3, #30
 8007d82:	f57f ac95 	bpl.w	80076b0 <f_printf+0x28>
 8007d86:	ab07      	add	r3, sp, #28
 8007d88:	2201      	movs	r2, #1
 8007d8a:	a905      	add	r1, sp, #20
 8007d8c:	4628      	mov	r0, r5
 8007d8e:	f7fb fdf3 	bl	8003978 <f_write.part.12>
 8007d92:	e48d      	b.n	80076b0 <f_printf+0x28>
 8007d94:	f103 0902 	add.w	r9, r3, #2
				while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007d98:	45a0      	cmp	r8, r4
 8007d9a:	f103 0303 	add.w	r3, r3, #3
 8007d9e:	9303      	str	r3, [sp, #12]
 8007da0:	bf28      	it	cs
 8007da2:	46c8      	movcs	r8, r9
 8007da4:	f4bf af16 	bcs.w	8007bd4 <f_printf+0x54c>
 8007da8:	2d00      	cmp	r5, #0
 8007daa:	f000 813c 	beq.w	8008026 <f_printf+0x99e>
 8007dae:	2600      	movs	r6, #0
	s[0] = (BYTE)c;
 8007db0:	2720      	movs	r7, #32
 8007db2:	e007      	b.n	8007dc4 <f_printf+0x73c>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007db4:	f04f 33ff 	mov.w	r3, #4294967295
				while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007db8:	45a1      	cmp	r9, r4
 8007dba:	441e      	add	r6, r3
 8007dbc:	f109 0801 	add.w	r8, r9, #1
 8007dc0:	d27c      	bcs.n	8007ebc <f_printf+0x834>
 8007dc2:	46c1      	mov	r9, r8
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007dc4:	682b      	ldr	r3, [r5, #0]
	s[0] = (BYTE)c;
 8007dc6:	f88d 7014 	strb.w	r7, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007dca:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007dce:	2b00      	cmp	r3, #0
 8007dd0:	d0f0      	beq.n	8007db4 <f_printf+0x72c>
 8007dd2:	781a      	ldrb	r2, [r3, #0]
 8007dd4:	2a00      	cmp	r2, #0
 8007dd6:	d0ed      	beq.n	8007db4 <f_printf+0x72c>
 8007dd8:	88a9      	ldrh	r1, [r5, #4]
 8007dda:	88da      	ldrh	r2, [r3, #6]
 8007ddc:	4291      	cmp	r1, r2
 8007dde:	d1e9      	bne.n	8007db4 <f_printf+0x72c>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007de0:	7858      	ldrb	r0, [r3, #1]
 8007de2:	f7fa fcd1 	bl	8002788 <disk_status>
 8007de6:	07c3      	lsls	r3, r0, #31
 8007de8:	f140 8140 	bpl.w	800806c <f_printf+0x9e4>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007dec:	9b07      	ldr	r3, [sp, #28]
 8007dee:	2b01      	cmp	r3, #1
 8007df0:	d0e2      	beq.n	8007db8 <f_printf+0x730>
 8007df2:	e7df      	b.n	8007db4 <f_printf+0x72c>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007df4:	79ab      	ldrb	r3, [r5, #6]
 8007df6:	061a      	lsls	r2, r3, #24
 8007df8:	f53f ae1f 	bmi.w	8007a3a <f_printf+0x3b2>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007dfc:	0798      	lsls	r0, r3, #30
 8007dfe:	f57f ae1c 	bpl.w	8007a3a <f_printf+0x3b2>
 8007e02:	ab07      	add	r3, sp, #28
 8007e04:	2201      	movs	r2, #1
 8007e06:	a905      	add	r1, sp, #20
 8007e08:	4628      	mov	r0, r5
 8007e0a:	f7fb fdb5 	bl	8003978 <f_write.part.12>
 8007e0e:	e614      	b.n	8007a3a <f_printf+0x3b2>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007e10:	79ab      	ldrb	r3, [r5, #6]
 8007e12:	061a      	lsls	r2, r3, #24
 8007e14:	f53f ae71 	bmi.w	8007afa <f_printf+0x472>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007e18:	079b      	lsls	r3, r3, #30
 8007e1a:	f57f ae6e 	bpl.w	8007afa <f_printf+0x472>
 8007e1e:	ab07      	add	r3, sp, #28
 8007e20:	2201      	movs	r2, #1
 8007e22:	a905      	add	r1, sp, #20
 8007e24:	4628      	mov	r0, r5
 8007e26:	f7fb fda7 	bl	8003978 <f_write.part.12>
 8007e2a:	e666      	b.n	8007afa <f_printf+0x472>
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007e2c:	88d9      	ldrh	r1, [r3, #6]
 8007e2e:	88aa      	ldrh	r2, [r5, #4]
 8007e30:	4291      	cmp	r1, r2
 8007e32:	f47f aee4 	bne.w	8007bfe <f_printf+0x576>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007e36:	7858      	ldrb	r0, [r3, #1]
 8007e38:	f7fa fca6 	bl	8002788 <disk_status>
 8007e3c:	07c7      	lsls	r7, r0, #31
 8007e3e:	d54d      	bpl.n	8007edc <f_printf+0x854>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8007e40:	9b07      	ldr	r3, [sp, #28]
 8007e42:	2b01      	cmp	r3, #1
 8007e44:	f47f aedb 	bne.w	8007bfe <f_printf+0x576>
 8007e48:	eba9 0204 	sub.w	r2, r9, r4
	for (n = 0; *str; str++, n++) {
 8007e4c:	f819 7b01 	ldrb.w	r7, [r9], #1
 8007e50:	2f00      	cmp	r7, #0
 8007e52:	f47f aec4 	bne.w	8007bde <f_printf+0x556>
 8007e56:	9c02      	ldr	r4, [sp, #8]
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007e58:	45a0      	cmp	r8, r4
			chc += (cc = f_puts(p, fp));
 8007e5a:	4416      	add	r6, r2
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007e5c:	f4ff aed5 	bcc.w	8007c0a <f_printf+0x582>
			if (cc != EOF) cc = chc;
 8007e60:	3201      	adds	r2, #1
 8007e62:	f47f af42 	bne.w	8007cea <f_printf+0x662>
 8007e66:	e42e      	b.n	80076c6 <f_printf+0x3e>
	s[0] = (BYTE)c;
 8007e68:	f04f 030d 	mov.w	r3, #13
 8007e6c:	f88d 3014 	strb.w	r3, [sp, #20]
	*bw = 0;	/* Clear write byte counter */
 8007e70:	f8cd b01c 	str.w	fp, [sp, #28]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007e74:	2d00      	cmp	r5, #0
 8007e76:	f43f aeb5 	beq.w	8007be4 <f_printf+0x55c>
 8007e7a:	682b      	ldr	r3, [r5, #0]
 8007e7c:	2b00      	cmp	r3, #0
 8007e7e:	f43f aeb1 	beq.w	8007be4 <f_printf+0x55c>
 8007e82:	781a      	ldrb	r2, [r3, #0]
 8007e84:	2a00      	cmp	r2, #0
 8007e86:	f43f aead 	beq.w	8007be4 <f_printf+0x55c>
 8007e8a:	88d9      	ldrh	r1, [r3, #6]
 8007e8c:	88aa      	ldrh	r2, [r5, #4]
 8007e8e:	4291      	cmp	r1, r2
 8007e90:	f47f aea8 	bne.w	8007be4 <f_printf+0x55c>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007e94:	7858      	ldrb	r0, [r3, #1]
 8007e96:	f7fa fc77 	bl	8002788 <disk_status>
 8007e9a:	07c2      	lsls	r2, r0, #31
 8007e9c:	f53f aea2 	bmi.w	8007be4 <f_printf+0x55c>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007ea0:	79ab      	ldrb	r3, [r5, #6]
 8007ea2:	061a      	lsls	r2, r3, #24
 8007ea4:	f53f ae9e 	bmi.w	8007be4 <f_printf+0x55c>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007ea8:	079b      	lsls	r3, r3, #30
 8007eaa:	f57f ae9b 	bpl.w	8007be4 <f_printf+0x55c>
 8007eae:	ab07      	add	r3, sp, #28
 8007eb0:	2201      	movs	r2, #1
 8007eb2:	a905      	add	r1, sp, #20
 8007eb4:	4628      	mov	r0, r5
 8007eb6:	f7fb fd5f 	bl	8003978 <f_write.part.12>
 8007eba:	e693      	b.n	8007be4 <f_printf+0x55c>
 8007ebc:	9b02      	ldr	r3, [sp, #8]
 8007ebe:	7818      	ldrb	r0, [r3, #0]
 8007ec0:	f108 0301 	add.w	r3, r8, #1
 8007ec4:	4607      	mov	r7, r0
 8007ec6:	9303      	str	r3, [sp, #12]
	for (n = 0; *str; str++, n++) {
 8007ec8:	2800      	cmp	r0, #0
 8007eca:	f47f ae83 	bne.w	8007bd4 <f_printf+0x54c>
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 8007ece:	45a0      	cmp	r8, r4
 8007ed0:	f4bf af0b 	bcs.w	8007cea <f_printf+0x662>
 8007ed4:	2d00      	cmp	r5, #0
 8007ed6:	f43f abf6 	beq.w	80076c6 <f_printf+0x3e>
 8007eda:	e696      	b.n	8007c0a <f_printf+0x582>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007edc:	79ab      	ldrb	r3, [r5, #6]
 8007ede:	061f      	lsls	r7, r3, #24
 8007ee0:	d4ae      	bmi.n	8007e40 <f_printf+0x7b8>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007ee2:	0798      	lsls	r0, r3, #30
 8007ee4:	d5ac      	bpl.n	8007e40 <f_printf+0x7b8>
 8007ee6:	ab07      	add	r3, sp, #28
 8007ee8:	2201      	movs	r2, #1
 8007eea:	a905      	add	r1, sp, #20
 8007eec:	4628      	mov	r0, r5
 8007eee:	f7fb fd43 	bl	8003978 <f_write.part.12>
 8007ef2:	e7a5      	b.n	8007e40 <f_printf+0x7b8>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007ef4:	79ab      	ldrb	r3, [r5, #6]
 8007ef6:	0619      	lsls	r1, r3, #24
 8007ef8:	f53f af19 	bmi.w	8007d2e <f_printf+0x6a6>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007efc:	079a      	lsls	r2, r3, #30
 8007efe:	f57f af16 	bpl.w	8007d2e <f_printf+0x6a6>
 8007f02:	ab07      	add	r3, sp, #28
 8007f04:	2201      	movs	r2, #1
 8007f06:	a905      	add	r1, sp, #20
 8007f08:	4628      	mov	r0, r5
 8007f0a:	f7fb fd35 	bl	8003978 <f_write.part.12>
 8007f0e:	e70e      	b.n	8007d2e <f_printf+0x6a6>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007f10:	79ab      	ldrb	r3, [r5, #6]
 8007f12:	061a      	lsls	r2, r3, #24
 8007f14:	f53f ae9a 	bmi.w	8007c4c <f_printf+0x5c4>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007f18:	079b      	lsls	r3, r3, #30
 8007f1a:	f57f ae97 	bpl.w	8007c4c <f_printf+0x5c4>
 8007f1e:	ab07      	add	r3, sp, #28
 8007f20:	2201      	movs	r2, #1
 8007f22:	a905      	add	r1, sp, #20
 8007f24:	4628      	mov	r0, r5
 8007f26:	f7fb fd27 	bl	8003978 <f_write.part.12>
 8007f2a:	e68f      	b.n	8007c4c <f_printf+0x5c4>
			s[i++] = d + '0';
 8007f2c:	2301      	movs	r3, #1
 8007f2e:	9302      	str	r3, [sp, #8]
 8007f30:	e54c      	b.n	80079cc <f_printf+0x344>
		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
 8007f32:	9f02      	ldr	r7, [sp, #8]
		chc = 0;
 8007f34:	2600      	movs	r6, #0
 8007f36:	463b      	mov	r3, r7
 8007f38:	e587      	b.n	8007a4a <f_printf+0x3c2>
			s[i++] = d + '0';
 8007f3a:	2303      	movs	r3, #3
 8007f3c:	9302      	str	r3, [sp, #8]
 8007f3e:	2202      	movs	r2, #2
 8007f40:	e544      	b.n	80079cc <f_printf+0x344>
 8007f42:	2302      	movs	r3, #2
 8007f44:	9302      	str	r3, [sp, #8]
 8007f46:	2201      	movs	r2, #1
 8007f48:	e540      	b.n	80079cc <f_printf+0x344>
 8007f4a:	2304      	movs	r3, #4
 8007f4c:	9302      	str	r3, [sp, #8]
 8007f4e:	2203      	movs	r2, #3
 8007f50:	e53c      	b.n	80079cc <f_printf+0x344>
 8007f52:	2305      	movs	r3, #5
 8007f54:	9302      	str	r3, [sp, #8]
 8007f56:	2204      	movs	r2, #4
 8007f58:	e538      	b.n	80079cc <f_printf+0x344>
 8007f5a:	2306      	movs	r3, #6
 8007f5c:	9302      	str	r3, [sp, #8]
 8007f5e:	2205      	movs	r2, #5
 8007f60:	e534      	b.n	80079cc <f_printf+0x344>
 8007f62:	2307      	movs	r3, #7
 8007f64:	9302      	str	r3, [sp, #8]
 8007f66:	2206      	movs	r2, #6
 8007f68:	e530      	b.n	80079cc <f_printf+0x344>
	s[0] = (BYTE)c;
 8007f6a:	230d      	movs	r3, #13
	*bw = 0;	/* Clear write byte counter */
 8007f6c:	f8cd b01c 	str.w	fp, [sp, #28]
	s[0] = (BYTE)c;
 8007f70:	f88d 3014 	strb.w	r3, [sp, #20]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007f74:	2d00      	cmp	r5, #0
 8007f76:	f43f ae75 	beq.w	8007c64 <f_printf+0x5dc>
 8007f7a:	682b      	ldr	r3, [r5, #0]
 8007f7c:	2b00      	cmp	r3, #0
 8007f7e:	f43f ae71 	beq.w	8007c64 <f_printf+0x5dc>
 8007f82:	781a      	ldrb	r2, [r3, #0]
 8007f84:	2a00      	cmp	r2, #0
 8007f86:	f43f ae6d 	beq.w	8007c64 <f_printf+0x5dc>
 8007f8a:	88d9      	ldrh	r1, [r3, #6]
 8007f8c:	88aa      	ldrh	r2, [r5, #4]
 8007f8e:	4291      	cmp	r1, r2
 8007f90:	f47f ae68 	bne.w	8007c64 <f_printf+0x5dc>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007f94:	7858      	ldrb	r0, [r3, #1]
 8007f96:	f7fa fbf7 	bl	8002788 <disk_status>
 8007f9a:	07c2      	lsls	r2, r0, #31
 8007f9c:	f53f ae62 	bmi.w	8007c64 <f_printf+0x5dc>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007fa0:	79ab      	ldrb	r3, [r5, #6]
 8007fa2:	061c      	lsls	r4, r3, #24
 8007fa4:	f53f ae5e 	bmi.w	8007c64 <f_printf+0x5dc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007fa8:	079b      	lsls	r3, r3, #30
 8007faa:	f57f ae5b 	bpl.w	8007c64 <f_printf+0x5dc>
 8007fae:	ab07      	add	r3, sp, #28
 8007fb0:	2201      	movs	r2, #1
 8007fb2:	a905      	add	r1, sp, #20
 8007fb4:	4628      	mov	r0, r5
 8007fb6:	f7fb fcdf 	bl	8003978 <f_write.part.12>
 8007fba:	e653      	b.n	8007c64 <f_printf+0x5dc>
	s[0] = (BYTE)c;
 8007fbc:	230d      	movs	r3, #13
	*bw = 0;	/* Clear write byte counter */
 8007fbe:	f8cd b01c 	str.w	fp, [sp, #28]
	s[0] = (BYTE)c;
 8007fc2:	f88d 3014 	strb.w	r3, [sp, #20]
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8007fc6:	2d00      	cmp	r5, #0
 8007fc8:	f43f adc4 	beq.w	8007b54 <f_printf+0x4cc>
 8007fcc:	682b      	ldr	r3, [r5, #0]
 8007fce:	2b00      	cmp	r3, #0
 8007fd0:	f43f adc0 	beq.w	8007b54 <f_printf+0x4cc>
 8007fd4:	781a      	ldrb	r2, [r3, #0]
 8007fd6:	2a00      	cmp	r2, #0
 8007fd8:	f43f adbc 	beq.w	8007b54 <f_printf+0x4cc>
 8007fdc:	88d9      	ldrh	r1, [r3, #6]
 8007fde:	88aa      	ldrh	r2, [r5, #4]
 8007fe0:	4291      	cmp	r1, r2
 8007fe2:	f47f adb7 	bne.w	8007b54 <f_printf+0x4cc>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
 8007fe6:	7858      	ldrb	r0, [r3, #1]
 8007fe8:	f7fa fbce 	bl	8002788 <disk_status>
 8007fec:	07c0      	lsls	r0, r0, #31
 8007fee:	f53f adb1 	bmi.w	8007b54 <f_printf+0x4cc>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8007ff2:	79ab      	ldrb	r3, [r5, #6]
 8007ff4:	061e      	lsls	r6, r3, #24
 8007ff6:	f53f adad 	bmi.w	8007b54 <f_printf+0x4cc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8007ffa:	0799      	lsls	r1, r3, #30
 8007ffc:	f57f adaa 	bpl.w	8007b54 <f_printf+0x4cc>
 8008000:	ab07      	add	r3, sp, #28
 8008002:	2201      	movs	r2, #1
 8008004:	a905      	add	r1, sp, #20
 8008006:	4628      	mov	r0, r5
 8008008:	f7fb fcb6 	bl	8003978 <f_write.part.12>
 800800c:	e5a2      	b.n	8007b54 <f_printf+0x4cc>
			s[i++] = d + '0';
 800800e:	2309      	movs	r3, #9
 8008010:	9302      	str	r3, [sp, #8]
 8008012:	2208      	movs	r2, #8
 8008014:	e4da      	b.n	80079cc <f_printf+0x344>
 8008016:	2308      	movs	r3, #8
 8008018:	9302      	str	r3, [sp, #8]
 800801a:	2207      	movs	r2, #7
 800801c:	e4d6      	b.n	80079cc <f_printf+0x344>
 800801e:	230a      	movs	r3, #10
 8008020:	9302      	str	r3, [sp, #8]
 8008022:	2209      	movs	r2, #9
 8008024:	e4d2      	b.n	80079cc <f_printf+0x344>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 8008026:	462b      	mov	r3, r5
 8008028:	eba9 0203 	sub.w	r2, r9, r3
				while (j++ < w) chc += (cc = f_putc(' ', fp));
 800802c:	1e5e      	subs	r6, r3, #1
 800802e:	42a2      	cmp	r2, r4
 8008030:	eba9 0806 	sub.w	r8, r9, r6
 8008034:	4633      	mov	r3, r6
 8008036:	d3f7      	bcc.n	8008028 <f_printf+0x9a0>
 8008038:	e742      	b.n	8007ec0 <f_printf+0x838>
			s[i++] = d + '0';
 800803a:	230c      	movs	r3, #12
 800803c:	9302      	str	r3, [sp, #8]
 800803e:	220b      	movs	r2, #11
 8008040:	e4c4      	b.n	80079cc <f_printf+0x344>
 8008042:	230b      	movs	r3, #11
 8008044:	9302      	str	r3, [sp, #8]
 8008046:	220a      	movs	r2, #10
 8008048:	e4c0      	b.n	80079cc <f_printf+0x344>
 800804a:	230d      	movs	r3, #13
 800804c:	9302      	str	r3, [sp, #8]
 800804e:	220c      	movs	r2, #12
 8008050:	e4bc      	b.n	80079cc <f_printf+0x344>
 8008052:	230f      	movs	r3, #15
 8008054:	9302      	str	r3, [sp, #8]
 8008056:	220e      	movs	r2, #14
 8008058:	e4b8      	b.n	80079cc <f_printf+0x344>
 800805a:	230e      	movs	r3, #14
 800805c:	9302      	str	r3, [sp, #8]
 800805e:	220d      	movs	r2, #13
 8008060:	e4b4      	b.n	80079cc <f_printf+0x344>
			if (!(f & 2)) {
 8008062:	bb0e      	cbnz	r6, 80080a8 <f_printf+0xa20>
				while (j++ < w) chc += (cc = f_putc(' ', fp));
 8008064:	b1f4      	cbz	r4, 80080a4 <f_printf+0xa1c>
 8008066:	f04f 0901 	mov.w	r9, #1
 800806a:	e69d      	b.n	8007da8 <f_printf+0x720>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 800806c:	79ab      	ldrb	r3, [r5, #6]
 800806e:	0618      	lsls	r0, r3, #24
 8008070:	f53f aebc 	bmi.w	8007dec <f_printf+0x764>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8008074:	0799      	lsls	r1, r3, #30
 8008076:	f57f aeb9 	bpl.w	8007dec <f_printf+0x764>
 800807a:	ab07      	add	r3, sp, #28
 800807c:	2201      	movs	r2, #1
 800807e:	a905      	add	r1, sp, #20
 8008080:	4628      	mov	r0, r5
 8008082:	f7fb fc79 	bl	8003978 <f_write.part.12>
 8008086:	e6b1      	b.n	8007dec <f_printf+0x764>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 8008088:	79ab      	ldrb	r3, [r5, #6]
 800808a:	0618      	lsls	r0, r3, #24
 800808c:	f53f ad7c 	bmi.w	8007b88 <f_printf+0x500>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8008090:	079c      	lsls	r4, r3, #30
 8008092:	f57f ad79 	bpl.w	8007b88 <f_printf+0x500>
 8008096:	ab07      	add	r3, sp, #28
 8008098:	2201      	movs	r2, #1
 800809a:	a905      	add	r1, sp, #20
 800809c:	4628      	mov	r0, r5
 800809e:	f7fb fc6b 	bl	8003978 <f_write.part.12>
 80080a2:	e571      	b.n	8007b88 <f_printf+0x500>
				while (j++ < w) chc += (cc = f_putc(' ', fp));
 80080a4:	4626      	mov	r6, r4
 80080a6:	e620      	b.n	8007cea <f_printf+0x662>
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 80080a8:	2c00      	cmp	r4, #0
 80080aa:	f43f aaf9 	beq.w	80076a0 <f_printf+0x18>
 80080ae:	2301      	movs	r3, #1
			chc = 0;
 80080b0:	4606      	mov	r6, r0
			while (j++ < w) chc += (cc = f_putc(' ', fp));
 80080b2:	9303      	str	r3, [sp, #12]
 80080b4:	e70e      	b.n	8007ed4 <f_printf+0x84c>
 80080b6:	bf00      	nop

080080b8 <UB_ATADrive_Init>:
//--------------------------------------------------------------
// init der Hardware fuer die ATA-Funktionen
// muss vor der Benutzung einmal gemacht werden
//--------------------------------------------------------------
void UB_ATADrive_Init(void)
{
 80080b8:	4770      	bx	lr
 80080ba:	bf00      	nop

080080bc <UB_ATADrive_CheckMedia>:
uint8_t UB_ATADrive_CheckMedia(void)
{
  uint8_t ret_wert=0;

  return(ret_wert);
}
 80080bc:	2000      	movs	r0, #0
 80080be:	4770      	bx	lr

080080c0 <ATA_disk_initialize>:
 80080c0:	f04f 30ff 	mov.w	r0, #4294967295
 80080c4:	4770      	bx	lr
 80080c6:	bf00      	nop

080080c8 <ATA_disk_status>:
int ATA_disk_status(void)
{
  int ret_wert=-1;

  return(ret_wert);
}
 80080c8:	f04f 30ff 	mov.w	r0, #4294967295
 80080cc:	4770      	bx	lr
 80080ce:	bf00      	nop

080080d0 <ATA_disk_read>:
 80080d0:	f04f 30ff 	mov.w	r0, #4294967295
 80080d4:	4770      	bx	lr
 80080d6:	bf00      	nop

080080d8 <ATA_disk_write>:
int ATA_disk_write(const BYTE *buff, DWORD sector, BYTE count)
{
  int ret_wert=-1;

  return(ret_wert);
}
 80080d8:	f04f 30ff 	mov.w	r0, #4294967295
 80080dc:	4770      	bx	lr
 80080de:	bf00      	nop

080080e0 <ATA_disk_ioctl>:
int ATA_disk_ioctl(BYTE cmd, void *buff)
{
  int ret_wert=-1;

  return(ret_wert);
}
 80080e0:	f04f 30ff 	mov.w	r0, #4294967295
 80080e4:	4770      	bx	lr
 80080e6:	bf00      	nop

080080e8 <UB_SDCard_Init>:
//--------------------------------------------------------------
// init der Hardware fuer die SDCard-Funktionen
// muss vor der Benutzung einmal gemacht werden
//--------------------------------------------------------------
void UB_SDCard_Init(void)
{
 80080e8:	4770      	bx	lr
 80080ea:	bf00      	nop

080080ec <UB_SDCard_CheckMedia>:
uint8_t UB_SDCard_CheckMedia(void) 
{
  uint8_t ret_wert=0;

  return(ret_wert);
}
 80080ec:	2000      	movs	r0, #0
 80080ee:	4770      	bx	lr

080080f0 <MMC_disk_initialize>:
 80080f0:	f04f 30ff 	mov.w	r0, #4294967295
 80080f4:	4770      	bx	lr
 80080f6:	bf00      	nop

080080f8 <MMC_disk_status>:
int MMC_disk_status(void)
{
  int ret_wert=-1;

  return(ret_wert);
}
 80080f8:	f04f 30ff 	mov.w	r0, #4294967295
 80080fc:	4770      	bx	lr
 80080fe:	bf00      	nop

08008100 <MMC_disk_read>:
 8008100:	f04f 30ff 	mov.w	r0, #4294967295
 8008104:	4770      	bx	lr
 8008106:	bf00      	nop

08008108 <MMC_disk_write>:
int MMC_disk_write(const BYTE *buff, DWORD sector, BYTE count)
{
  int ret_wert=-1;

  return(ret_wert);
}
 8008108:	f04f 30ff 	mov.w	r0, #4294967295
 800810c:	4770      	bx	lr
 800810e:	bf00      	nop

08008110 <MMC_disk_ioctl>:
int MMC_disk_ioctl(BYTE cmd, void *buff)
{
  int ret_wert=-1;

  return(ret_wert);
}
 8008110:	f04f 30ff 	mov.w	r0, #4294967295
 8008114:	4770      	bx	lr
 8008116:	bf00      	nop

08008118 <UB_USBDisk_Init>:
//--------------------------------------------------------------
// init der Hardware fuer die USB-Funktionen
// muss vor der Benutzung einmal gemacht werden
//--------------------------------------------------------------
void UB_USBDisk_Init(void)
{
 8008118:	4770      	bx	lr
 800811a:	bf00      	nop

0800811c <UB_USBDrive_CheckMedia>:
// Return Wert :
//   USB_PRESENT      = wenn Medium eingelegt ist
//   USB_NOT_PRESENT  = wenn kein Medium eingelegt ist
//--------------------------------------------------------------
uint8_t UB_USBDrive_CheckMedia(void)
{
 800811c:	b500      	push	{lr}
 800811e:	b083      	sub	sp, #12
  __IO uint8_t ret_wert = USB_NOT_PRESENT;
 8008120:	2300      	movs	r3, #0

  if(HCD_IsDeviceConnected(&USB_OTG_Core) && (USB_MSC_HOST_STATUS==USB_MSC_DEV_CONNECTED)) {
 8008122:	480b      	ldr	r0, [pc, #44]	; (8008150 <UB_USBDrive_CheckMedia+0x34>)
  __IO uint8_t ret_wert = USB_NOT_PRESENT;
 8008124:	f88d 3007 	strb.w	r3, [sp, #7]
  if(HCD_IsDeviceConnected(&USB_OTG_Core) && (USB_MSC_HOST_STATUS==USB_MSC_DEV_CONNECTED)) {
 8008128:	f009 fd02 	bl	8011b30 <HCD_IsDeviceConnected>
 800812c:	b118      	cbz	r0, 8008136 <UB_USBDrive_CheckMedia+0x1a>
 800812e:	4b09      	ldr	r3, [pc, #36]	; (8008154 <UB_USBDrive_CheckMedia+0x38>)
 8008130:	781b      	ldrb	r3, [r3, #0]
 8008132:	2b06      	cmp	r3, #6
 8008134:	d007      	beq.n	8008146 <UB_USBDrive_CheckMedia+0x2a>
    ret_wert=USB_PRESENT;
  }
  else {
    ret_wert=USB_NOT_PRESENT;
 8008136:	2300      	movs	r3, #0
 8008138:	f88d 3007 	strb.w	r3, [sp, #7]
  }

  return(ret_wert);
 800813c:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8008140:	b003      	add	sp, #12
 8008142:	f85d fb04 	ldr.w	pc, [sp], #4
    ret_wert=USB_PRESENT;
 8008146:	2301      	movs	r3, #1
 8008148:	f88d 3007 	strb.w	r3, [sp, #7]
 800814c:	e7f6      	b.n	800813c <UB_USBDrive_CheckMedia+0x20>
 800814e:	bf00      	nop
 8008150:	20010344 	.word	0x20010344
 8008154:	20008098 	.word	0x20008098

08008158 <USB_disk_initialize>:
 8008158:	b508      	push	{r3, lr}
 800815a:	4807      	ldr	r0, [pc, #28]	; (8008178 <USB_disk_initialize+0x20>)
 800815c:	f009 fce8 	bl	8011b30 <HCD_IsDeviceConnected>
 8008160:	b130      	cbz	r0, 8008170 <USB_disk_initialize+0x18>
 8008162:	4b06      	ldr	r3, [pc, #24]	; (800817c <USB_disk_initialize+0x24>)
 8008164:	7818      	ldrb	r0, [r3, #0]
 8008166:	3806      	subs	r0, #6
 8008168:	bf18      	it	ne
 800816a:	f04f 30ff 	movne.w	r0, #4294967295
 800816e:	bd08      	pop	{r3, pc}
 8008170:	f04f 30ff 	mov.w	r0, #4294967295
 8008174:	bd08      	pop	{r3, pc}
 8008176:	bf00      	nop
 8008178:	20010344 	.word	0x20010344
 800817c:	20008098 	.word	0x20008098

08008180 <USB_disk_status>:
// Return Wert :
//    0 = alles ok
//  < 0 = Fehler
//--------------------------------------------------------------
int USB_disk_status(void)
{
 8008180:	b508      	push	{r3, lr}
  int ret_wert=-1;

  if(HCD_IsDeviceConnected(&USB_OTG_Core) && (USB_MSC_HOST_STATUS==USB_MSC_DEV_CONNECTED)) {
 8008182:	4807      	ldr	r0, [pc, #28]	; (80081a0 <USB_disk_status+0x20>)
 8008184:	f009 fcd4 	bl	8011b30 <HCD_IsDeviceConnected>
 8008188:	b130      	cbz	r0, 8008198 <USB_disk_status+0x18>
 800818a:	4b06      	ldr	r3, [pc, #24]	; (80081a4 <USB_disk_status+0x24>)
 800818c:	7818      	ldrb	r0, [r3, #0]
 800818e:	3806      	subs	r0, #6
 8008190:	bf18      	it	ne
 8008192:	f04f 30ff 	movne.w	r0, #4294967295
 8008196:	bd08      	pop	{r3, pc}
    ret_wert=0;
  }
  else {
    ret_wert=-1;
 8008198:	f04f 30ff 	mov.w	r0, #4294967295
  }

  return(ret_wert);
}
 800819c:	bd08      	pop	{r3, pc}
 800819e:	bf00      	nop
 80081a0:	20010344 	.word	0x20010344
 80081a4:	20008098 	.word	0x20008098

080081a8 <USB_disk_read>:
// Return Wert :
//    0 = alles ok
//  < 0 = Fehler
//--------------------------------------------------------------
int USB_disk_read(BYTE *buff, DWORD sector, BYTE count)
{
 80081a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80081ac:	4607      	mov	r7, r0
  int ret_wert=-1;
  BYTE status = USBH_MSC_OK;

  if(HCD_IsDeviceConnected(&USB_OTG_Core) && (USB_MSC_HOST_STATUS==USB_MSC_DEV_CONNECTED))
 80081ae:	4815      	ldr	r0, [pc, #84]	; (8008204 <USB_disk_read+0x5c>)
{
 80081b0:	4688      	mov	r8, r1
 80081b2:	4616      	mov	r6, r2
  if(HCD_IsDeviceConnected(&USB_OTG_Core) && (USB_MSC_HOST_STATUS==USB_MSC_DEV_CONNECTED))
 80081b4:	f009 fcbc 	bl	8011b30 <HCD_IsDeviceConnected>
 80081b8:	b118      	cbz	r0, 80081c2 <USB_disk_read+0x1a>
 80081ba:	4b13      	ldr	r3, [pc, #76]	; (8008208 <USB_disk_read+0x60>)
 80081bc:	781b      	ldrb	r3, [r3, #0]
 80081be:	2b06      	cmp	r3, #6
 80081c0:	d003      	beq.n	80081ca <USB_disk_read+0x22>

  if(status==USBH_MSC_OK) {
    ret_wert=0;
  }
  else {
    ret_wert=-1;
 80081c2:	f04f 30ff 	mov.w	r0, #4294967295
  }

  return(ret_wert);
}
 80081c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      status = USBH_MSC_Read10(&USB_OTG_Core, buff, sector, 512*count);
 80081ca:	4d0e      	ldr	r5, [pc, #56]	; (8008204 <USB_disk_read+0x5c>)
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core ,&USB_Host);
 80081cc:	f8df 903c 	ldr.w	r9, [pc, #60]	; 800820c <USB_disk_read+0x64>
 80081d0:	0276      	lsls	r6, r6, #9
      status = USBH_MSC_Read10(&USB_OTG_Core, buff, sector, 512*count);
 80081d2:	4633      	mov	r3, r6
 80081d4:	4642      	mov	r2, r8
 80081d6:	4639      	mov	r1, r7
 80081d8:	4628      	mov	r0, r5
 80081da:	f00b ff91 	bl	8014100 <USBH_MSC_Read10>
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core ,&USB_Host);
 80081de:	4649      	mov	r1, r9
      status = USBH_MSC_Read10(&USB_OTG_Core, buff, sector, 512*count);
 80081e0:	4604      	mov	r4, r0
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core ,&USB_Host);
 80081e2:	4628      	mov	r0, r5
 80081e4:	f00b fb34 	bl	8013850 <USBH_MSC_HandleBOTXfer>
      if(!HCD_IsDeviceConnected(&USB_OTG_Core))
 80081e8:	4628      	mov	r0, r5
 80081ea:	f009 fca1 	bl	8011b30 <HCD_IsDeviceConnected>
 80081ee:	2800      	cmp	r0, #0
 80081f0:	d0e7      	beq.n	80081c2 <USB_disk_read+0x1a>
    while(status == USBH_MSC_BUSY );
 80081f2:	2c03      	cmp	r4, #3
 80081f4:	d0ed      	beq.n	80081d2 <USB_disk_read+0x2a>
 80081f6:	1c20      	adds	r0, r4, #0
 80081f8:	bf18      	it	ne
 80081fa:	2001      	movne	r0, #1
 80081fc:	4240      	negs	r0, r0
 80081fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008202:	bf00      	nop
 8008204:	20010344 	.word	0x20010344
 8008208:	20008098 	.word	0x20008098
 800820c:	200107f4 	.word	0x200107f4

08008210 <USB_disk_write>:
// Return Wert :
//    0 = alles ok
//  < 0 = Fehler
//--------------------------------------------------------------
int USB_disk_write(const BYTE *buff, DWORD sector, BYTE count)
{
 8008210:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008214:	4607      	mov	r7, r0
  int ret_wert=-1;
  BYTE status = USBH_MSC_OK;


  if(HCD_IsDeviceConnected(&USB_OTG_Core) && (USB_MSC_HOST_STATUS==USB_MSC_DEV_CONNECTED))
 8008216:	4815      	ldr	r0, [pc, #84]	; (800826c <USB_disk_write+0x5c>)
{
 8008218:	4688      	mov	r8, r1
 800821a:	4616      	mov	r6, r2
  if(HCD_IsDeviceConnected(&USB_OTG_Core) && (USB_MSC_HOST_STATUS==USB_MSC_DEV_CONNECTED))
 800821c:	f009 fc88 	bl	8011b30 <HCD_IsDeviceConnected>
 8008220:	b118      	cbz	r0, 800822a <USB_disk_write+0x1a>
 8008222:	4b13      	ldr	r3, [pc, #76]	; (8008270 <USB_disk_write+0x60>)
 8008224:	781b      	ldrb	r3, [r3, #0]
 8008226:	2b06      	cmp	r3, #6
 8008228:	d003      	beq.n	8008232 <USB_disk_write+0x22>

  if(status==USBH_MSC_OK) {
    ret_wert=0;
  }
  else {
    ret_wert=-1;
 800822a:	f04f 30ff 	mov.w	r0, #4294967295
  }

  return(ret_wert);
}
 800822e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      status = USBH_MSC_Write10(&USB_OTG_Core,(BYTE*)buff, sector, 512*count);
 8008232:	4d0e      	ldr	r5, [pc, #56]	; (800826c <USB_disk_write+0x5c>)
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
 8008234:	f8df 903c 	ldr.w	r9, [pc, #60]	; 8008274 <USB_disk_write+0x64>
 8008238:	0276      	lsls	r6, r6, #9
      status = USBH_MSC_Write10(&USB_OTG_Core,(BYTE*)buff, sector, 512*count);
 800823a:	4633      	mov	r3, r6
 800823c:	4642      	mov	r2, r8
 800823e:	4639      	mov	r1, r7
 8008240:	4628      	mov	r0, r5
 8008242:	f00b ff13 	bl	801406c <USBH_MSC_Write10>
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
 8008246:	4649      	mov	r1, r9
      status = USBH_MSC_Write10(&USB_OTG_Core,(BYTE*)buff, sector, 512*count);
 8008248:	4604      	mov	r4, r0
      USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
 800824a:	4628      	mov	r0, r5
 800824c:	f00b fb00 	bl	8013850 <USBH_MSC_HandleBOTXfer>
      if(!HCD_IsDeviceConnected(&USB_OTG_Core))
 8008250:	4628      	mov	r0, r5
 8008252:	f009 fc6d 	bl	8011b30 <HCD_IsDeviceConnected>
 8008256:	2800      	cmp	r0, #0
 8008258:	d0e7      	beq.n	800822a <USB_disk_write+0x1a>
    while(status == USBH_MSC_BUSY );    
 800825a:	2c03      	cmp	r4, #3
 800825c:	d0ed      	beq.n	800823a <USB_disk_write+0x2a>
 800825e:	1c20      	adds	r0, r4, #0
 8008260:	bf18      	it	ne
 8008262:	2001      	movne	r0, #1
 8008264:	4240      	negs	r0, r0
 8008266:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800826a:	bf00      	nop
 800826c:	20010344 	.word	0x20010344
 8008270:	20008098 	.word	0x20008098
 8008274:	200107f4 	.word	0x200107f4

08008278 <USB_disk_ioctl>:
//--------------------------------------------------------------
int USB_disk_ioctl(BYTE cmd, void *buff)
{
  int ret_wert=0; // immer ok  
  
  switch (cmd) {    
 8008278:	2802      	cmp	r0, #2
 800827a:	d00f      	beq.n	800829c <USB_disk_ioctl+0x24>
 800827c:	2803      	cmp	r0, #3
 800827e:	d008      	beq.n	8008292 <USB_disk_ioctl+0x1a>
 8008280:	2801      	cmp	r0, #1
 8008282:	d001      	beq.n	8008288 <USB_disk_ioctl+0x10>
      ret_wert=0;
    break;
  }

  return(ret_wert);
}
 8008284:	2000      	movs	r0, #0
 8008286:	4770      	bx	lr
      *(DWORD*)buff = (DWORD) USBH_MSC_Param.MSCapacity;
 8008288:	4b07      	ldr	r3, [pc, #28]	; (80082a8 <USB_disk_ioctl+0x30>)
 800828a:	681b      	ldr	r3, [r3, #0]
 800828c:	600b      	str	r3, [r1, #0]
}
 800828e:	2000      	movs	r0, #0
 8008290:	4770      	bx	lr
      *(DWORD*)buff = 512;
 8008292:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008296:	600b      	str	r3, [r1, #0]
}
 8008298:	2000      	movs	r0, #0
 800829a:	4770      	bx	lr
      *(WORD*)buff = 512;
 800829c:	f44f 7300 	mov.w	r3, #512	; 0x200
 80082a0:	800b      	strh	r3, [r1, #0]
}
 80082a2:	2000      	movs	r0, #0
 80082a4:	4770      	bx	lr
 80082a6:	bf00      	nop
 80082a8:	20010b10 	.word	0x20010b10

080082ac <MP3InitDecoder>:
 **************************************************************************************/
HMP3Decoder MP3InitDecoder(void)
{
	MP3DecInfo *mp3DecInfo;

	mp3DecInfo = AllocateBuffers();
 80082ac:	f001 bdf2 	b.w	8009e94 <xmp3fixpt_AllocateBuffers>

080082b0 <MP3FreeDecoder>:
 **************************************************************************************/
void MP3FreeDecoder(HMP3Decoder hMP3Decoder)
{
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;

	if (!mp3DecInfo)
 80082b0:	b108      	cbz	r0, 80082b6 <MP3FreeDecoder+0x6>
		return;

	FreeBuffers(mp3DecInfo);
 80082b2:	f001 be3d 	b.w	8009f30 <xmp3fixpt_FreeBuffers>
 80082b6:	4770      	bx	lr

080082b8 <MP3FindSyncWord>:
int MP3FindSyncWord(unsigned char *buf, int nBytes)
{
	int i;

	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
	for (i = 0; i < nBytes - 1; i++) {
 80082b8:	2901      	cmp	r1, #1
 80082ba:	dd10      	ble.n	80082de <MP3FindSyncWord+0x26>
 80082bc:	4603      	mov	r3, r0
 80082be:	3901      	subs	r1, #1
 80082c0:	2000      	movs	r0, #0
 80082c2:	e002      	b.n	80082ca <MP3FindSyncWord+0x12>
 80082c4:	3001      	adds	r0, #1
 80082c6:	4281      	cmp	r1, r0
 80082c8:	d009      	beq.n	80082de <MP3FindSyncWord+0x26>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 80082ca:	f813 2b01 	ldrb.w	r2, [r3], #1
 80082ce:	2aff      	cmp	r2, #255	; 0xff
 80082d0:	d1f8      	bne.n	80082c4 <MP3FindSyncWord+0xc>
 80082d2:	781a      	ldrb	r2, [r3, #0]
 80082d4:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
 80082d8:	2ae0      	cmp	r2, #224	; 0xe0
 80082da:	d1f3      	bne.n	80082c4 <MP3FindSyncWord+0xc>
			return i;
	}
	
	return -1;
}
 80082dc:	4770      	bx	lr
	return -1;
 80082de:	f04f 30ff 	mov.w	r0, #4294967295
}
 80082e2:	4770      	bx	lr

080082e4 <MP3GetLastFrameInfo>:
 **************************************************************************************/
void MP3GetLastFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo)
{
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;

	if (!mp3DecInfo || mp3DecInfo->layer != 3) {
 80082e4:	b118      	cbz	r0, 80082ee <MP3GetLastFrameInfo+0xa>
 80082e6:	f8d0 37d0 	ldr.w	r3, [r0, #2000]	; 0x7d0
 80082ea:	2b03      	cmp	r3, #3
 80082ec:	d008      	beq.n	8008300 <MP3GetLastFrameInfo+0x1c>
		mp3FrameInfo->bitrate = 0;
 80082ee:	2300      	movs	r3, #0
 80082f0:	600b      	str	r3, [r1, #0]
		mp3FrameInfo->nChans = 0;
 80082f2:	604b      	str	r3, [r1, #4]
		mp3FrameInfo->samprate = 0;
 80082f4:	608b      	str	r3, [r1, #8]
		mp3FrameInfo->bitsPerSample = 0;
 80082f6:	60cb      	str	r3, [r1, #12]
		mp3FrameInfo->outputSamps = 0;
 80082f8:	610b      	str	r3, [r1, #16]
		mp3FrameInfo->layer = 0;
 80082fa:	614b      	str	r3, [r1, #20]
		mp3FrameInfo->version = 0;
 80082fc:	618b      	str	r3, [r1, #24]
 80082fe:	4770      	bx	lr
{
 8008300:	b470      	push	{r4, r5, r6}
	} else {
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
		mp3FrameInfo->bitsPerSample = 16;
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8008302:	f890 47d4 	ldrb.w	r4, [r0, #2004]	; 0x7d4
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 8008306:	f8d0 67b8 	ldr.w	r6, [r0, #1976]	; 0x7b8
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800830a:	4a0b      	ldr	r2, [pc, #44]	; (8008338 <MP3GetLastFrameInfo+0x54>)
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 800830c:	f8d0 57bc 	ldr.w	r5, [r0, #1980]	; 0x7bc
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 8008310:	f8d0 07c0 	ldr.w	r0, [r0, #1984]	; 0x7c0
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 8008314:	600e      	str	r6, [r1, #0]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8008316:	eb04 0644 	add.w	r6, r4, r4, lsl #1
 800831a:	eb02 0246 	add.w	r2, r2, r6, lsl #1
		mp3FrameInfo->bitsPerSample = 16;
 800831e:	2610      	movs	r6, #16
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8008320:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		mp3FrameInfo->layer = mp3DecInfo->layer;
		mp3FrameInfo->version = mp3DecInfo->version;
 8008324:	618c      	str	r4, [r1, #24]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8008326:	fb05 f202 	mul.w	r2, r5, r2
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 800832a:	604d      	str	r5, [r1, #4]
		mp3FrameInfo->bitsPerSample = 16;
 800832c:	60ce      	str	r6, [r1, #12]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800832e:	610a      	str	r2, [r1, #16]
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 8008330:	6088      	str	r0, [r1, #8]
		mp3FrameInfo->layer = mp3DecInfo->layer;
 8008332:	614b      	str	r3, [r1, #20]
	}
}
 8008334:	bc70      	pop	{r4, r5, r6}
 8008336:	4770      	bx	lr
 8008338:	08014a90 	.word	0x08014a90

0800833c <MP3GetNextFrameInfo>:
 **************************************************************************************/
int MP3GetNextFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo, unsigned char *buf)
{
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;

	if (!mp3DecInfo)
 800833c:	b348      	cbz	r0, 8008392 <MP3GetNextFrameInfo+0x56>
{
 800833e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008340:	460d      	mov	r5, r1
		return ERR_MP3_NULL_POINTER;

	if (UnpackFrameHeader(mp3DecInfo, buf) == -1 || mp3DecInfo->layer != 3)
 8008342:	4611      	mov	r1, r2
 8008344:	4604      	mov	r4, r0
 8008346:	f000 fae7 	bl	8008918 <xmp3fixpt_UnpackFrameHeader>
 800834a:	3001      	adds	r0, #1
 800834c:	d01e      	beq.n	800838c <MP3GetNextFrameInfo+0x50>
 800834e:	f8d4 37d0 	ldr.w	r3, [r4, #2000]	; 0x7d0
 8008352:	2b03      	cmp	r3, #3
 8008354:	d11a      	bne.n	800838c <MP3GetNextFrameInfo+0x50>
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8008356:	f894 17d4 	ldrb.w	r1, [r4, #2004]	; 0x7d4
 800835a:	4a0f      	ldr	r2, [pc, #60]	; (8008398 <MP3GetNextFrameInfo+0x5c>)
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 800835c:	f8d4 67bc 	ldr.w	r6, [r4, #1980]	; 0x7bc
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 8008360:	f8d4 07c0 	ldr.w	r0, [r4, #1984]	; 0x7c0
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 8008364:	f8d4 77b8 	ldr.w	r7, [r4, #1976]	; 0x7b8
 8008368:	602f      	str	r7, [r5, #0]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800836a:	eb01 0441 	add.w	r4, r1, r1, lsl #1
 800836e:	eb02 0244 	add.w	r2, r2, r4, lsl #1
		mp3FrameInfo->bitsPerSample = 16;
 8008372:	2410      	movs	r4, #16
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8008374:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 8008378:	60a8      	str	r0, [r5, #8]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800837a:	fb06 f202 	mul.w	r2, r6, r2
		mp3FrameInfo->version = mp3DecInfo->version;
 800837e:	61a9      	str	r1, [r5, #24]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 8008380:	612a      	str	r2, [r5, #16]
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 8008382:	606e      	str	r6, [r5, #4]
		mp3FrameInfo->layer = mp3DecInfo->layer;
 8008384:	616b      	str	r3, [r5, #20]
		mp3FrameInfo->bitsPerSample = 16;
 8008386:	60ec      	str	r4, [r5, #12]
		return ERR_MP3_INVALID_FRAMEHEADER;

	MP3GetLastFrameInfo(mp3DecInfo, mp3FrameInfo);

	return ERR_MP3_NONE;
 8008388:	2000      	movs	r0, #0
 800838a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return ERR_MP3_INVALID_FRAMEHEADER;
 800838c:	f06f 0005 	mvn.w	r0, #5
}
 8008390:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return ERR_MP3_NULL_POINTER;
 8008392:	f06f 0004 	mvn.w	r0, #4
 8008396:	4770      	bx	lr
 8008398:	08014a90 	.word	0x08014a90

0800839c <MP3Decode>:
	int prevBitOffset, sfBlockBits, huffBlockBits;
	unsigned char *mainPtr;
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
//	ULONG32 ulTime;
//	StartYield(&ulTime);
	if (!mp3DecInfo)
 800839c:	2800      	cmp	r0, #0
 800839e:	f000 820b 	beq.w	80087b8 <MP3Decode+0x41c>
{
 80083a2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80083a6:	b087      	sub	sp, #28
 80083a8:	4689      	mov	r9, r1
		return ERR_MP3_NULL_POINTER;

	/* unpack frame header */
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 80083aa:	6809      	ldr	r1, [r1, #0]
 80083ac:	9302      	str	r3, [sp, #8]
 80083ae:	4607      	mov	r7, r0
 80083b0:	4616      	mov	r6, r2
 80083b2:	f000 fab1 	bl	8008918 <xmp3fixpt_UnpackFrameHeader>
	if (fhBytes < 0)	
 80083b6:	f1b0 0800 	subs.w	r8, r0, #0
 80083ba:	f2c0 80f0 	blt.w	800859e <MP3Decode+0x202>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
	*inbuf += fhBytes;
 80083be:	f8d9 1000 	ldr.w	r1, [r9]
 80083c2:	4441      	add	r1, r8
 80083c4:	f8c9 1000 	str.w	r1, [r9]
	
	/* unpack side info */
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 80083c8:	4638      	mov	r0, r7
 80083ca:	f000 fb9d 	bl	8008b08 <xmp3fixpt_UnpackSideInfo>
	if (siBytes < 0) {
 80083ce:	2800      	cmp	r0, #0
 80083d0:	f2c0 812f 	blt.w	8008632 <MP3Decode+0x296>
		MP3ClearBadFrame(mp3DecInfo, outbuf);
		return ERR_MP3_INVALID_SIDEINFO;
	}
	*inbuf += siBytes;
	*bytesLeft -= (fhBytes + siBytes);
 80083d4:	6833      	ldr	r3, [r6, #0]
	*inbuf += siBytes;
 80083d6:	f8d9 2000 	ldr.w	r2, [r9]
	*bytesLeft -= (fhBytes + siBytes);
 80083da:	eb08 0100 	add.w	r1, r8, r0
 80083de:	1a59      	subs	r1, r3, r1
	*inbuf += siBytes;
 80083e0:	eb02 0c00 	add.w	ip, r2, r0
 80083e4:	f8c9 c000 	str.w	ip, [r9]
	*bytesLeft -= (fhBytes + siBytes);
 80083e8:	6031      	str	r1, [r6, #0]
	
	/* if free mode, need to calculate bitrate and nSlots manually, based on frame size */
	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
 80083ea:	f8d7 37b8 	ldr.w	r3, [r7, #1976]	; 0x7b8
 80083ee:	2b00      	cmp	r3, #0
 80083f0:	d140      	bne.n	8008474 <MP3Decode+0xd8>
		if (!mp3DecInfo->freeBitrateFlag) {
 80083f2:	f8d7 37b0 	ldr.w	r3, [r7, #1968]	; 0x7b0
 80083f6:	2b00      	cmp	r3, #0
 80083f8:	d13f      	bne.n	800847a <MP3Decode+0xde>
			/* first time through, need to scan for next sync word and figure out frame size */
			mp3DecInfo->freeBitrateFlag = 1;
 80083fa:	2301      	movs	r3, #1
 80083fc:	f8c7 37b0 	str.w	r3, [r7, #1968]	; 0x7b0
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 8008400:	6831      	ldr	r1, [r6, #0]
	for (i = 0; i < nBytes - 1; i++) {
 8008402:	2901      	cmp	r1, #1
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 8008404:	eba2 0e08 	sub.w	lr, r2, r8
	unsigned char *bufPtr = buf;
 8008408:	4664      	mov	r4, ip
	for (i = 0; i < nBytes - 1; i++) {
 800840a:	dd1b      	ble.n	8008444 <MP3Decode+0xa8>
 800840c:	f101 3aff 	add.w	sl, r1, #4294967295
 8008410:	2200      	movs	r2, #0
 8008412:	e002      	b.n	800841a <MP3Decode+0x7e>
 8008414:	3201      	adds	r2, #1
 8008416:	4552      	cmp	r2, sl
 8008418:	d014      	beq.n	8008444 <MP3Decode+0xa8>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 800841a:	4623      	mov	r3, r4
 800841c:	3401      	adds	r4, #1
 800841e:	781d      	ldrb	r5, [r3, #0]
 8008420:	2dff      	cmp	r5, #255	; 0xff
 8008422:	d1f7      	bne.n	8008414 <MP3Decode+0x78>
 8008424:	785d      	ldrb	r5, [r3, #1]
 8008426:	f005 05e0 	and.w	r5, r5, #224	; 0xe0
 800842a:	2de0      	cmp	r5, #224	; 0xe0
 800842c:	d1f2      	bne.n	8008414 <MP3Decode+0x78>
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 800842e:	f89e 4000 	ldrb.w	r4, [lr]
 8008432:	2cff      	cmp	r4, #255	; 0xff
 8008434:	f000 80b8 	beq.w	80085a8 <MP3Decode+0x20c>
		nBytes -= (offset + 3);
 8008438:	3203      	adds	r2, #3
 800843a:	1a89      	subs	r1, r1, r2
	for (i = 0; i < nBytes - 1; i++) {
 800843c:	2901      	cmp	r1, #1
		bufPtr += 3;
 800843e:	f103 0403 	add.w	r4, r3, #3
	for (i = 0; i < nBytes - 1; i++) {
 8008442:	dce3      	bgt.n	800840c <MP3Decode+0x70>
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 8008444:	f04f 33ff 	mov.w	r3, #4294967295
 8008448:	f8c7 37b4 	str.w	r3, [r7, #1972]	; 0x7b4
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800844c:	f8d7 17c4 	ldr.w	r1, [r7, #1988]	; 0x7c4
 8008450:	f8d7 37c8 	ldr.w	r3, [r7, #1992]	; 0x7c8
 8008454:	f8d7 27bc 	ldr.w	r2, [r7, #1980]	; 0x7bc
 8008458:	fb03 f301 	mul.w	r3, r3, r1
 800845c:	fb02 f203 	mul.w	r2, r2, r3
 8008460:	2a00      	cmp	r2, #0
 8008462:	dd04      	ble.n	800846e <MP3Decode+0xd2>
 8008464:	0052      	lsls	r2, r2, #1
 8008466:	9802      	ldr	r0, [sp, #8]
 8008468:	2100      	movs	r1, #0
 800846a:	f00c f8c8 	bl	80145fe <memset>
			if (mp3DecInfo->freeBitrateSlots < 0) {
				MP3ClearBadFrame(mp3DecInfo, outbuf);
				return ERR_MP3_FREE_BITRATE_SYNC;
 800846e:	f06f 0002 	mvn.w	r0, #2
 8008472:	e096      	b.n	80085a2 <MP3Decode+0x206>
	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
 8008474:	f8d7 37b0 	ldr.w	r3, [r7, #1968]	; 0x7b0
 8008478:	b143      	cbz	r3, 800848c <MP3Decode+0xf0>
 800847a:	f8d7 57b4 	ldr.w	r5, [r7, #1972]	; 0x7b4
			}
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
		}
		mp3DecInfo->nSlots = mp3DecInfo->freeBitrateSlots + CheckPadBit(mp3DecInfo);	/* add pad byte, if required */
 800847e:	4638      	mov	r0, r7
 8008480:	f000 fa3e 	bl	8008900 <xmp3fixpt_CheckPadBit>
 8008484:	4428      	add	r0, r5
 8008486:	f8c7 07cc 	str.w	r0, [r7, #1996]	; 0x7cc
 800848a:	6831      	ldr	r1, [r6, #0]
	 *  - calling function assembles "self-contained" MP3 frames by shifting any main_data 
	 *      from the bit reservoir (in previous frames) to AFTER the sync word and side info
	 *  - calling function should set mainDataBegin to 0, and tell us exactly how large this
	 *      frame is (in bytesLeft)
	 */
	if (useSize) {
 800848c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800848e:	2b00      	cmp	r3, #0
 8008490:	f000 80b5 	beq.w	80085fe <MP3Decode+0x262>
		mp3DecInfo->nSlots = *bytesLeft;
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 8008494:	f8d7 37d8 	ldr.w	r3, [r7, #2008]	; 0x7d8
		mp3DecInfo->nSlots = *bytesLeft;
 8008498:	f8c7 17cc 	str.w	r1, [r7, #1996]	; 0x7cc
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 800849c:	2b00      	cmp	r3, #0
 800849e:	d16d      	bne.n	800857c <MP3Decode+0x1e0>
 80084a0:	2900      	cmp	r1, #0
 80084a2:	dd6b      	ble.n	800857c <MP3Decode+0x1e0>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_FRAMEHEADER;
		}

		/* can operate in-place on reformatted frames */
		mp3DecInfo->mainDataBytes = mp3DecInfo->nSlots;
 80084a4:	f8c7 17dc 	str.w	r1, [r7, #2012]	; 0x7dc
		mainPtr = *inbuf;
		*inbuf += mp3DecInfo->nSlots;
		*bytesLeft -= (mp3DecInfo->nSlots);
 80084a8:	6833      	ldr	r3, [r6, #0]
		mainPtr = *inbuf;
 80084aa:	f8d9 8000 	ldr.w	r8, [r9]
		*bytesLeft -= (mp3DecInfo->nSlots);
 80084ae:	1a5b      	subs	r3, r3, r1
		*inbuf += mp3DecInfo->nSlots;
 80084b0:	4441      	add	r1, r8
 80084b2:	f8c9 1000 	str.w	r1, [r9]
		*bytesLeft -= (mp3DecInfo->nSlots);
 80084b6:	6033      	str	r3, [r6, #0]
	}
	bitOffset = 0;
	mainBits = mp3DecInfo->mainDataBytes * 8;

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 80084b8:	f8d7 37c4 	ldr.w	r3, [r7, #1988]	; 0x7c4
	mainBits = mp3DecInfo->mainDataBytes * 8;
 80084bc:	f8d7 57dc 	ldr.w	r5, [r7, #2012]	; 0x7dc
	bitOffset = 0;
 80084c0:	2000      	movs	r0, #0
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 80084c2:	4283      	cmp	r3, r0
	mainBits = mp3DecInfo->mainDataBytes * 8;
 80084c4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
	bitOffset = 0;
 80084c8:	9005      	str	r0, [sp, #20]
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 80084ca:	dd6a      	ble.n	80085a2 <MP3Decode+0x206>
 80084cc:	f507 63fc 	add.w	r3, r7, #2016	; 0x7e0
 80084d0:	4682      	mov	sl, r0
 80084d2:	9303      	str	r3, [sp, #12]
 80084d4:	46b9      	mov	r9, r7
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80084d6:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	; 0x7bc
 80084da:	2b00      	cmp	r3, #0
 80084dc:	f340 8110 	ble.w	8008700 <MP3Decode+0x364>
 80084e0:	9c05      	ldr	r4, [sp, #20]
 80084e2:	f8dd b00c 	ldr.w	fp, [sp, #12]
 80084e6:	2700      	movs	r7, #0
 80084e8:	e017      	b.n	800851a <MP3Decode+0x17e>
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
			mainPtr += offset;
			mainBits -= sfBlockBits;

			if (offset < 0 || mainBits < huffBlockBits) {
 80084ea:	42ac      	cmp	r4, r5
 80084ec:	dc30      	bgt.n	8008550 <MP3Decode+0x1b4>
				return ERR_MP3_INVALID_SCALEFACT;
			}

			/* decode Huffman code words */
			prevBitOffset = bitOffset;
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 80084ee:	9701      	str	r7, [sp, #4]
 80084f0:	f8cd a000 	str.w	sl, [sp]
 80084f4:	f002 fda8 	bl	800b048 <xmp3fixpt_DecodeHuffman>
			if (offset < 0) {
 80084f8:	2800      	cmp	r0, #0
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 80084fa:	f107 0701 	add.w	r7, r7, #1
				MP3ClearBadFrame(mp3DecInfo, outbuf);
				return ERR_MP3_INVALID_HUFFCODES;
			}

			mainPtr += offset;
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 80084fe:	ebc6 06c0 	rsb	r6, r6, r0, lsl #3
			mainPtr += offset;
 8008502:	4480      	add	r8, r0
			if (offset < 0) {
 8008504:	f2c0 812a 	blt.w	800875c <MP3Decode+0x3c0>
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 8008508:	9c05      	ldr	r4, [sp, #20]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800850a:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	; 0x7bc
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800850e:	4426      	add	r6, r4
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8008510:	42bb      	cmp	r3, r7
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 8008512:	eba5 0506 	sub.w	r5, r5, r6
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8008516:	f340 80f3 	ble.w	8008700 <MP3Decode+0x364>
			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
 800851a:	462b      	mov	r3, r5
 800851c:	4641      	mov	r1, r8
 800851e:	aa05      	add	r2, sp, #20
 8008520:	9701      	str	r7, [sp, #4]
 8008522:	f8cd a000 	str.w	sl, [sp]
 8008526:	4648      	mov	r0, r9
 8008528:	f006 f8dc 	bl	800e6e4 <xmp3fixpt_UnpackScaleFactors>
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 800852c:	9e05      	ldr	r6, [sp, #20]
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 800852e:	f85b 3b04 	ldr.w	r3, [fp], #4
			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
 8008532:	4686      	mov	lr, r0
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 8008534:	ebc4 04ce 	rsb	r4, r4, lr, lsl #3
 8008538:	4434      	add	r4, r6
			mainPtr += offset;
 800853a:	44f0      	add	r8, lr
			mainBits -= sfBlockBits;
 800853c:	1b2d      	subs	r5, r5, r4
			if (offset < 0 || mainBits < huffBlockBits) {
 800853e:	f1be 0f00 	cmp.w	lr, #0
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 8008542:	eba3 0404 	sub.w	r4, r3, r4
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 8008546:	aa05      	add	r2, sp, #20
 8008548:	4648      	mov	r0, r9
 800854a:	4641      	mov	r1, r8
 800854c:	4623      	mov	r3, r4
			if (offset < 0 || mainBits < huffBlockBits) {
 800854e:	dacc      	bge.n	80084ea <MP3Decode+0x14e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8008550:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	; 0x7c8
 8008554:	f8d9 37c4 	ldr.w	r3, [r9, #1988]	; 0x7c4
 8008558:	f8d9 27bc 	ldr.w	r2, [r9, #1980]	; 0x7bc
 800855c:	fb03 f301 	mul.w	r3, r3, r1
 8008560:	fb02 f203 	mul.w	r2, r2, r3
 8008564:	2a00      	cmp	r2, #0
 8008566:	dd04      	ble.n	8008572 <MP3Decode+0x1d6>
 8008568:	0052      	lsls	r2, r2, #1
 800856a:	9802      	ldr	r0, [sp, #8]
 800856c:	2100      	movs	r1, #0
 800856e:	f00c f846 	bl	80145fe <memset>
				return ERR_MP3_INVALID_SCALEFACT;
 8008572:	f06f 0007 	mvn.w	r0, #7
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_SUBBAND;			
		}
	}
	return ERR_MP3_NONE;
}
 8008576:	b007      	add	sp, #28
 8008578:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800857c:	f8d7 17c8 	ldr.w	r1, [r7, #1992]	; 0x7c8
 8008580:	f8d7 37c4 	ldr.w	r3, [r7, #1988]	; 0x7c4
 8008584:	f8d7 27bc 	ldr.w	r2, [r7, #1980]	; 0x7bc
 8008588:	fb03 f301 	mul.w	r3, r3, r1
 800858c:	fb02 f203 	mul.w	r2, r2, r3
 8008590:	2a00      	cmp	r2, #0
 8008592:	dd04      	ble.n	800859e <MP3Decode+0x202>
 8008594:	0052      	lsls	r2, r2, #1
 8008596:	9802      	ldr	r0, [sp, #8]
 8008598:	2100      	movs	r1, #0
 800859a:	f00c f830 	bl	80145fe <memset>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
 800859e:	f06f 0005 	mvn.w	r0, #5
}
 80085a2:	b007      	add	sp, #28
 80085a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 80085a8:	785d      	ldrb	r5, [r3, #1]
 80085aa:	f89e 4001 	ldrb.w	r4, [lr, #1]
 80085ae:	42a5      	cmp	r5, r4
 80085b0:	f47f af42 	bne.w	8008438 <MP3Decode+0x9c>
 80085b4:	f89e 4002 	ldrb.w	r4, [lr, #2]
 80085b8:	789d      	ldrb	r5, [r3, #2]
 80085ba:	4065      	eors	r5, r4
 80085bc:	f015 0ffc 	tst.w	r5, #252	; 0xfc
 80085c0:	f47f af3a 	bne.w	8008438 <MP3Decode+0x9c>
			if ((firstFH[2] >> 1) & 0x01)
 80085c4:	07a2      	lsls	r2, r4, #30
				bufPtr--;
 80085c6:	bf48      	it	mi
 80085c8:	f103 33ff 	addmi.w	r3, r3, #4294967295
			return bufPtr - buf;
 80085cc:	eba3 050c 	sub.w	r5, r3, ip
			if (mp3DecInfo->freeBitrateSlots < 0) {
 80085d0:	2d00      	cmp	r5, #0
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 80085d2:	f8c7 57b4 	str.w	r5, [r7, #1972]	; 0x7b4
			if (mp3DecInfo->freeBitrateSlots < 0) {
 80085d6:	f6ff af39 	blt.w	800844c <MP3Decode+0xb0>
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 80085da:	44a8      	add	r8, r5
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 80085dc:	f8d7 27c0 	ldr.w	r2, [r7, #1984]	; 0x7c0
 80085e0:	f8d7 17c4 	ldr.w	r1, [r7, #1988]	; 0x7c4
 80085e4:	f8d7 47c8 	ldr.w	r4, [r7, #1992]	; 0x7c8
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 80085e8:	4440      	add	r0, r8
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 80085ea:	fb02 f300 	mul.w	r3, r2, r0
 80085ee:	00db      	lsls	r3, r3, #3
 80085f0:	fb04 f101 	mul.w	r1, r4, r1
 80085f4:	fb93 f3f1 	sdiv	r3, r3, r1
 80085f8:	f8c7 37b8 	str.w	r3, [r7, #1976]	; 0x7b8
 80085fc:	e73f      	b.n	800847e <MP3Decode+0xe2>
		if (mp3DecInfo->nSlots > *bytesLeft) {
 80085fe:	f8d7 37cc 	ldr.w	r3, [r7, #1996]	; 0x7cc
 8008602:	428b      	cmp	r3, r1
 8008604:	dd2b      	ble.n	800865e <MP3Decode+0x2c2>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8008606:	f8d7 17c4 	ldr.w	r1, [r7, #1988]	; 0x7c4
 800860a:	f8d7 37c8 	ldr.w	r3, [r7, #1992]	; 0x7c8
 800860e:	f8d7 27bc 	ldr.w	r2, [r7, #1980]	; 0x7bc
 8008612:	fb03 f301 	mul.w	r3, r3, r1
 8008616:	fb02 f203 	mul.w	r2, r2, r3
 800861a:	2a00      	cmp	r2, #0
 800861c:	dd04      	ble.n	8008628 <MP3Decode+0x28c>
 800861e:	0052      	lsls	r2, r2, #1
 8008620:	9802      	ldr	r0, [sp, #8]
 8008622:	9910      	ldr	r1, [sp, #64]	; 0x40
 8008624:	f00b ffeb 	bl	80145fe <memset>
			return ERR_MP3_INDATA_UNDERFLOW;	
 8008628:	f04f 30ff 	mov.w	r0, #4294967295
}
 800862c:	b007      	add	sp, #28
 800862e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8008632:	f8d7 17c8 	ldr.w	r1, [r7, #1992]	; 0x7c8
 8008636:	f8d7 37c4 	ldr.w	r3, [r7, #1988]	; 0x7c4
 800863a:	f8d7 27bc 	ldr.w	r2, [r7, #1980]	; 0x7bc
 800863e:	fb03 f301 	mul.w	r3, r3, r1
 8008642:	fb02 f203 	mul.w	r2, r2, r3
 8008646:	2a00      	cmp	r2, #0
 8008648:	dd04      	ble.n	8008654 <MP3Decode+0x2b8>
 800864a:	0052      	lsls	r2, r2, #1
 800864c:	9802      	ldr	r0, [sp, #8]
 800864e:	2100      	movs	r1, #0
 8008650:	f00b ffd5 	bl	80145fe <memset>
		return ERR_MP3_INVALID_SIDEINFO;
 8008654:	f06f 0006 	mvn.w	r0, #6
}
 8008658:	b007      	add	sp, #28
 800865a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
 800865e:	f8d7 17dc 	ldr.w	r1, [r7, #2012]	; 0x7dc
 8008662:	f8d7 27d8 	ldr.w	r2, [r7, #2008]	; 0x7d8
 8008666:	4291      	cmp	r1, r2
 8008668:	db1f      	blt.n	80086aa <MP3Decode+0x30e>
			memmove(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
 800866a:	1a89      	subs	r1, r1, r2
 800866c:	f107 081c 	add.w	r8, r7, #28
 8008670:	4441      	add	r1, r8
 8008672:	4640      	mov	r0, r8
 8008674:	f00b ffa9 	bl	80145ca <memmove>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBegin, *inbuf, mp3DecInfo->nSlots);
 8008678:	f8d7 07d8 	ldr.w	r0, [r7, #2008]	; 0x7d8
 800867c:	f8d7 27cc 	ldr.w	r2, [r7, #1996]	; 0x7cc
 8008680:	f8d9 1000 	ldr.w	r1, [r9]
 8008684:	4440      	add	r0, r8
 8008686:	f00b ff95 	bl	80145b4 <memcpy>
			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
 800868a:	f8d7 17cc 	ldr.w	r1, [r7, #1996]	; 0x7cc
 800868e:	f8d7 37d8 	ldr.w	r3, [r7, #2008]	; 0x7d8
			*inbuf += mp3DecInfo->nSlots;
 8008692:	f8d9 2000 	ldr.w	r2, [r9]
			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
 8008696:	440b      	add	r3, r1
 8008698:	f8c7 37dc 	str.w	r3, [r7, #2012]	; 0x7dc
			*bytesLeft -= (mp3DecInfo->nSlots);
 800869c:	6833      	ldr	r3, [r6, #0]
			*inbuf += mp3DecInfo->nSlots;
 800869e:	440a      	add	r2, r1
			*bytesLeft -= (mp3DecInfo->nSlots);
 80086a0:	1a5b      	subs	r3, r3, r1
			*inbuf += mp3DecInfo->nSlots;
 80086a2:	f8c9 2000 	str.w	r2, [r9]
			*bytesLeft -= (mp3DecInfo->nSlots);
 80086a6:	6033      	str	r3, [r6, #0]
 80086a8:	e706      	b.n	80084b8 <MP3Decode+0x11c>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes, *inbuf, mp3DecInfo->nSlots);
 80086aa:	f107 001c 	add.w	r0, r7, #28
 80086ae:	461a      	mov	r2, r3
 80086b0:	4408      	add	r0, r1
 80086b2:	f8d9 1000 	ldr.w	r1, [r9]
 80086b6:	f00b ff7d 	bl	80145b4 <memcpy>
			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
 80086ba:	f8d7 17cc 	ldr.w	r1, [r7, #1996]	; 0x7cc
 80086be:	f8d7 37dc 	ldr.w	r3, [r7, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 80086c2:	f8d9 2000 	ldr.w	r2, [r9]
			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
 80086c6:	440b      	add	r3, r1
 80086c8:	f8c7 37dc 	str.w	r3, [r7, #2012]	; 0x7dc
			*bytesLeft -= (mp3DecInfo->nSlots);
 80086cc:	6833      	ldr	r3, [r6, #0]
			*inbuf += mp3DecInfo->nSlots;
 80086ce:	440a      	add	r2, r1
			*bytesLeft -= (mp3DecInfo->nSlots);
 80086d0:	1a5b      	subs	r3, r3, r1
			*inbuf += mp3DecInfo->nSlots;
 80086d2:	f8c9 2000 	str.w	r2, [r9]
			*bytesLeft -= (mp3DecInfo->nSlots);
 80086d6:	6033      	str	r3, [r6, #0]
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 80086d8:	f8d7 17c4 	ldr.w	r1, [r7, #1988]	; 0x7c4
 80086dc:	f8d7 37c8 	ldr.w	r3, [r7, #1992]	; 0x7c8
 80086e0:	f8d7 27bc 	ldr.w	r2, [r7, #1980]	; 0x7bc
 80086e4:	fb03 f301 	mul.w	r3, r3, r1
 80086e8:	fb02 f203 	mul.w	r2, r2, r3
 80086ec:	2a00      	cmp	r2, #0
 80086ee:	dd04      	ble.n	80086fa <MP3Decode+0x35e>
 80086f0:	0052      	lsls	r2, r2, #1
 80086f2:	9802      	ldr	r0, [sp, #8]
 80086f4:	9910      	ldr	r1, [sp, #64]	; 0x40
 80086f6:	f00b ff82 	bl	80145fe <memset>
			return ERR_MP3_MAINDATA_UNDERFLOW;
 80086fa:	f06f 0001 	mvn.w	r0, #1
 80086fe:	e750      	b.n	80085a2 <MP3Decode+0x206>
		if (Dequantize(mp3DecInfo, gr) < 0) {
 8008700:	4651      	mov	r1, sl
 8008702:	4648      	mov	r0, r9
 8008704:	f002 f936 	bl	800a974 <xmp3fixpt_Dequantize>
 8008708:	2800      	cmp	r0, #0
 800870a:	db58      	blt.n	80087be <MP3Decode+0x422>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800870c:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	; 0x7bc
 8008710:	2b00      	cmp	r3, #0
 8008712:	bfc8      	it	gt
 8008714:	2400      	movgt	r4, #0
 8008716:	dc04      	bgt.n	8008722 <MP3Decode+0x386>
 8008718:	e034      	b.n	8008784 <MP3Decode+0x3e8>
 800871a:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	; 0x7bc
 800871e:	42a3      	cmp	r3, r4
 8008720:	dd30      	ble.n	8008784 <MP3Decode+0x3e8>
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 8008722:	4622      	mov	r2, r4
 8008724:	4651      	mov	r1, sl
 8008726:	4648      	mov	r0, r9
 8008728:	f003 fd7c 	bl	800c224 <xmp3fixpt_IMDCT>
 800872c:	2800      	cmp	r0, #0
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800872e:	f104 0401 	add.w	r4, r4, #1
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 8008732:	daf2      	bge.n	800871a <MP3Decode+0x37e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 8008734:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	; 0x7c8
 8008738:	f8d9 37c4 	ldr.w	r3, [r9, #1988]	; 0x7c4
 800873c:	f8d9 27bc 	ldr.w	r2, [r9, #1980]	; 0x7bc
 8008740:	fb03 f301 	mul.w	r3, r3, r1
 8008744:	fb02 f203 	mul.w	r2, r2, r3
 8008748:	2a00      	cmp	r2, #0
 800874a:	dd04      	ble.n	8008756 <MP3Decode+0x3ba>
 800874c:	0052      	lsls	r2, r2, #1
 800874e:	9802      	ldr	r0, [sp, #8]
 8008750:	2100      	movs	r1, #0
 8008752:	f00b ff54 	bl	80145fe <memset>
				return ERR_MP3_INVALID_IMDCT;			
 8008756:	f06f 000a 	mvn.w	r0, #10
 800875a:	e722      	b.n	80085a2 <MP3Decode+0x206>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800875c:	f8d9 17c4 	ldr.w	r1, [r9, #1988]	; 0x7c4
 8008760:	f8d9 37c8 	ldr.w	r3, [r9, #1992]	; 0x7c8
 8008764:	f8d9 27bc 	ldr.w	r2, [r9, #1980]	; 0x7bc
 8008768:	fb03 f301 	mul.w	r3, r3, r1
 800876c:	fb02 f203 	mul.w	r2, r2, r3
 8008770:	2a00      	cmp	r2, #0
 8008772:	dd04      	ble.n	800877e <MP3Decode+0x3e2>
 8008774:	0052      	lsls	r2, r2, #1
 8008776:	9802      	ldr	r0, [sp, #8]
 8008778:	2100      	movs	r1, #0
 800877a:	f00b ff40 	bl	80145fe <memset>
				return ERR_MP3_INVALID_HUFFCODES;
 800877e:	f06f 0008 	mvn.w	r0, #8
 8008782:	e70e      	b.n	80085a2 <MP3Decode+0x206>
		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
 8008784:	f8d9 27c8 	ldr.w	r2, [r9, #1992]	; 0x7c8
 8008788:	fb02 f20a 	mul.w	r2, r2, sl
 800878c:	fb03 f302 	mul.w	r3, r3, r2
 8008790:	9a02      	ldr	r2, [sp, #8]
 8008792:	4648      	mov	r0, r9
 8008794:	eb02 0143 	add.w	r1, r2, r3, lsl #1
 8008798:	f006 ff24 	bl	800f5e4 <xmp3fixpt_Subband>
 800879c:	2800      	cmp	r0, #0
 800879e:	db22      	blt.n	80087e6 <MP3Decode+0x44a>
 80087a0:	9a03      	ldr	r2, [sp, #12]
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 80087a2:	f8d9 37c4 	ldr.w	r3, [r9, #1988]	; 0x7c4
 80087a6:	f10a 0a01 	add.w	sl, sl, #1
 80087aa:	3208      	adds	r2, #8
 80087ac:	4553      	cmp	r3, sl
 80087ae:	9203      	str	r2, [sp, #12]
 80087b0:	f73f ae91 	bgt.w	80084d6 <MP3Decode+0x13a>
	return ERR_MP3_NONE;
 80087b4:	2000      	movs	r0, #0
 80087b6:	e6f4      	b.n	80085a2 <MP3Decode+0x206>
		return ERR_MP3_NULL_POINTER;
 80087b8:	f06f 0004 	mvn.w	r0, #4
 80087bc:	4770      	bx	lr
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 80087be:	f8d9 17c4 	ldr.w	r1, [r9, #1988]	; 0x7c4
 80087c2:	f8d9 37c8 	ldr.w	r3, [r9, #1992]	; 0x7c8
 80087c6:	f8d9 27bc 	ldr.w	r2, [r9, #1980]	; 0x7bc
 80087ca:	fb03 f301 	mul.w	r3, r3, r1
 80087ce:	fb02 f203 	mul.w	r2, r2, r3
 80087d2:	2a00      	cmp	r2, #0
 80087d4:	dd04      	ble.n	80087e0 <MP3Decode+0x444>
 80087d6:	0052      	lsls	r2, r2, #1
 80087d8:	9802      	ldr	r0, [sp, #8]
 80087da:	2100      	movs	r1, #0
 80087dc:	f00b ff0f 	bl	80145fe <memset>
			return ERR_MP3_INVALID_DEQUANTIZE;			
 80087e0:	f06f 0009 	mvn.w	r0, #9
 80087e4:	e6dd      	b.n	80085a2 <MP3Decode+0x206>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 80087e6:	f8d9 17c4 	ldr.w	r1, [r9, #1988]	; 0x7c4
 80087ea:	f8d9 37c8 	ldr.w	r3, [r9, #1992]	; 0x7c8
 80087ee:	f8d9 27bc 	ldr.w	r2, [r9, #1980]	; 0x7bc
 80087f2:	fb03 f301 	mul.w	r3, r3, r1
 80087f6:	fb02 f203 	mul.w	r2, r2, r3
 80087fa:	2a00      	cmp	r2, #0
 80087fc:	dd04      	ble.n	8008808 <MP3Decode+0x46c>
 80087fe:	0052      	lsls	r2, r2, #1
 8008800:	9802      	ldr	r0, [sp, #8]
 8008802:	2100      	movs	r1, #0
 8008804:	f00b fefb 	bl	80145fe <memset>
			return ERR_MP3_INVALID_SUBBAND;			
 8008808:	f06f 000b 	mvn.w	r0, #11
 800880c:	e6c9      	b.n	80085a2 <MP3Decode+0x206>
 800880e:	bf00      	nop

08008810 <xmp3fixpt_SetBitstreamPointer>:
 **************************************************************************************/
void SetBitstreamPointer(BitStreamInfo *bsi, int nBytes, unsigned char *buf)
{
	/* init bitstream */
	bsi->bytePtr = buf;
	bsi->iCache = 0;		/* 4-byte unsigned int */
 8008810:	2300      	movs	r3, #0
	bsi->bytePtr = buf;
 8008812:	6002      	str	r2, [r0, #0]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
	bsi->nBytes = nBytes;
 8008814:	60c1      	str	r1, [r0, #12]
	bsi->iCache = 0;		/* 4-byte unsigned int */
 8008816:	6043      	str	r3, [r0, #4]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 8008818:	6083      	str	r3, [r0, #8]
 800881a:	4770      	bx	lr

0800881c <xmp3fixpt_GetBits>:
 *              if nBits = 0, returns 0 (useful for scalefactor unpacking)
 *
 * TODO:        optimize for ARM
 **************************************************************************************/
unsigned int GetBits(BitStreamInfo *bsi, int nBits)
{
 800881c:	b4f0      	push	{r4, r5, r6, r7}
	unsigned int data, lowBits;

	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800881e:	6843      	ldr	r3, [r0, #4]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
	bsi->iCache <<= nBits;					/* left-justify cache */
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 8008820:	6884      	ldr	r4, [r0, #8]
	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
 8008822:	f001 011f 	and.w	r1, r1, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008826:	fa03 f201 	lsl.w	r2, r3, r1
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800882a:	f1c1 051f 	rsb	r5, r1, #31
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800882e:	1a61      	subs	r1, r4, r1
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 8008830:	40eb      	lsrs	r3, r5

	/* if we cross an int boundary, refill the cache */
	if (bsi->cachedBits < 0) {
 8008832:	2900      	cmp	r1, #0
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008834:	6042      	str	r2, [r0, #4]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008836:	ea4f 0353 	mov.w	r3, r3, lsr #1
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800883a:	6081      	str	r1, [r0, #8]
	if (bsi->cachedBits < 0) {
 800883c:	db02      	blt.n	8008844 <xmp3fixpt_GetBits+0x28>
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
		bsi->iCache <<= lowBits;			/* left-justify cache */
	}

	return data;
}
 800883e:	4618      	mov	r0, r3
 8008840:	bcf0      	pop	{r4, r5, r6, r7}
 8008842:	4770      	bx	lr
	int nBytes = bsi->nBytes;
 8008844:	68c5      	ldr	r5, [r0, #12]
	if (nBytes >= 4) {
 8008846:	2d03      	cmp	r5, #3
		lowBits = -bsi->cachedBits;
 8008848:	f1c1 0600 	rsb	r6, r1, #0
	if (nBytes >= 4) {
 800884c:	dc2e      	bgt.n	80088ac <xmp3fixpt_GetBits+0x90>
		bsi->iCache = 0;
 800884e:	2200      	movs	r2, #0
 8008850:	6042      	str	r2, [r0, #4]
		while (nBytes--) {
 8008852:	2d00      	cmp	r5, #0
 8008854:	d048      	beq.n	80088e8 <xmp3fixpt_GetBits+0xcc>
 8008856:	6804      	ldr	r4, [r0, #0]
			bsi->iCache |= (*bsi->bytePtr++);
 8008858:	1c62      	adds	r2, r4, #1
 800885a:	6002      	str	r2, [r0, #0]
 800885c:	7822      	ldrb	r2, [r4, #0]
		while (nBytes--) {
 800885e:	2d01      	cmp	r5, #1
			bsi->iCache <<= 8;
 8008860:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8008864:	6042      	str	r2, [r0, #4]
		while (nBytes--) {
 8008866:	d00c      	beq.n	8008882 <xmp3fixpt_GetBits+0x66>
			bsi->iCache |= (*bsi->bytePtr++);
 8008868:	1ca7      	adds	r7, r4, #2
 800886a:	6007      	str	r7, [r0, #0]
 800886c:	7867      	ldrb	r7, [r4, #1]
 800886e:	433a      	orrs	r2, r7
			bsi->iCache <<= 8;
 8008870:	0212      	lsls	r2, r2, #8
		while (nBytes--) {
 8008872:	2d02      	cmp	r5, #2
			bsi->iCache <<= 8;
 8008874:	6042      	str	r2, [r0, #4]
		while (nBytes--) {
 8008876:	d004      	beq.n	8008882 <xmp3fixpt_GetBits+0x66>
			bsi->iCache |= (*bsi->bytePtr++);
 8008878:	1ce7      	adds	r7, r4, #3
 800887a:	6007      	str	r7, [r0, #0]
 800887c:	78a4      	ldrb	r4, [r4, #2]
 800887e:	4322      	orrs	r2, r4
			bsi->iCache <<= 8;
 8008880:	0212      	lsls	r2, r2, #8
 8008882:	f1c5 0403 	rsb	r4, r5, #3
 8008886:	00e4      	lsls	r4, r4, #3
 8008888:	fa02 f404 	lsl.w	r4, r2, r4
 800888c:	f101 0220 	add.w	r2, r1, #32
 8008890:	fa04 f606 	lsl.w	r6, r4, r6
 8008894:	fa24 f202 	lsr.w	r2, r4, r2
		bsi->nBytes = 0;
 8008898:	2400      	movs	r4, #0
 800889a:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
 800889e:	60c4      	str	r4, [r0, #12]
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 80088a0:	4313      	orrs	r3, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 80088a2:	6046      	str	r6, [r0, #4]
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 80088a4:	6081      	str	r1, [r0, #8]
}
 80088a6:	bcf0      	pop	{r4, r5, r6, r7}
 80088a8:	4618      	mov	r0, r3
 80088aa:	4770      	bx	lr
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80088ac:	6807      	ldr	r7, [r0, #0]
 80088ae:	463c      	mov	r4, r7
 80088b0:	1c7a      	adds	r2, r7, #1
 80088b2:	6002      	str	r2, [r0, #0]
 80088b4:	f814 2b02 	ldrb.w	r2, [r4], #2
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80088b8:	6004      	str	r4, [r0, #0]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80088ba:	0612      	lsls	r2, r2, #24
 80088bc:	6042      	str	r2, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80088be:	787c      	ldrb	r4, [r7, #1]
 80088c0:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80088c4:	1cfc      	adds	r4, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80088c6:	6042      	str	r2, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80088c8:	6004      	str	r4, [r0, #0]
 80088ca:	78bc      	ldrb	r4, [r7, #2]
 80088cc:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 80088d0:	1d3a      	adds	r2, r7, #4
 80088d2:	e880 0014 	stmia.w	r0, {r2, r4}
 80088d6:	78fa      	ldrb	r2, [r7, #3]
		bsi->nBytes -= 4;
 80088d8:	3d04      	subs	r5, #4
		bsi->iCache |= (*bsi->bytePtr++);
 80088da:	4322      	orrs	r2, r4
 80088dc:	3120      	adds	r1, #32
 80088de:	fa02 f606 	lsl.w	r6, r2, r6
		bsi->nBytes -= 4;
 80088e2:	60c5      	str	r5, [r0, #12]
 80088e4:	40ca      	lsrs	r2, r1
 80088e6:	e7db      	b.n	80088a0 <xmp3fixpt_GetBits+0x84>
		while (nBytes--) {
 80088e8:	462e      	mov	r6, r5
 80088ea:	462a      	mov	r2, r5
 80088ec:	e7d4      	b.n	8008898 <xmp3fixpt_GetBits+0x7c>
 80088ee:	bf00      	nop

080088f0 <xmp3fixpt_CalcBitsUsed>:
 **************************************************************************************/
int CalcBitsUsed(BitStreamInfo *bsi, unsigned char *startBuf, int startOffset)
{
	int bitsUsed;

	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 80088f0:	6803      	ldr	r3, [r0, #0]
	bitsUsed -= bsi->cachedBits;
 80088f2:	6880      	ldr	r0, [r0, #8]
	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 80088f4:	1a59      	subs	r1, r3, r1
	bitsUsed -= bsi->cachedBits;
 80088f6:	ebc0 00c1 	rsb	r0, r0, r1, lsl #3
	bitsUsed -= startOffset;

	return bitsUsed;
}
 80088fa:	1a80      	subs	r0, r0, r2
 80088fc:	4770      	bx	lr
 80088fe:	bf00      	nop

08008900 <xmp3fixpt_CheckPadBit>:
int CheckPadBit(MP3DecInfo *mp3DecInfo)
{
	FrameHeader *fh;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS)
 8008900:	b130      	cbz	r0, 8008910 <xmp3fixpt_CheckPadBit+0x10>
 8008902:	6803      	ldr	r3, [r0, #0]
 8008904:	b123      	cbz	r3, 8008910 <xmp3fixpt_CheckPadBit+0x10>
		return -1;

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	return (fh->paddingBit ? 1 : 0);
 8008906:	6958      	ldr	r0, [r3, #20]
 8008908:	3000      	adds	r0, #0
 800890a:	bf18      	it	ne
 800890c:	2001      	movne	r0, #1
 800890e:	4770      	bx	lr
		return -1;
 8008910:	f04f 30ff 	mov.w	r0, #4294967295
}
 8008914:	4770      	bx	lr
 8008916:	bf00      	nop

08008918 <xmp3fixpt_UnpackFrameHeader>:

	int verIdx;
	FrameHeader *fh;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 8008918:	2800      	cmp	r0, #0
 800891a:	f000 80e5 	beq.w	8008ae8 <xmp3fixpt_UnpackFrameHeader+0x1d0>
 800891e:	6803      	ldr	r3, [r0, #0]
 8008920:	2b00      	cmp	r3, #0
 8008922:	f000 80e1 	beq.w	8008ae8 <xmp3fixpt_UnpackFrameHeader+0x1d0>
 8008926:	780a      	ldrb	r2, [r1, #0]
 8008928:	2aff      	cmp	r2, #255	; 0xff
 800892a:	f040 80dd 	bne.w	8008ae8 <xmp3fixpt_UnpackFrameHeader+0x1d0>
{
 800892e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 8008932:	784a      	ldrb	r2, [r1, #1]
 8008934:	f002 04e0 	and.w	r4, r2, #224	; 0xe0
 8008938:	2ce0      	cmp	r4, #224	; 0xe0
{
 800893a:	b083      	sub	sp, #12
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 800893c:	f040 80cf 	bne.w	8008ade <xmp3fixpt_UnpackFrameHeader+0x1c6>
		return -1;

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	/* read header fields - use bitmasks instead of GetBits() for speed, since format never varies */
	verIdx =         (buf[1] >> 3) & 0x03;
 8008940:	08d2      	lsrs	r2, r2, #3
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 8008942:	0794      	lsls	r4, r2, #30
 8008944:	bf1a      	itte	ne
 8008946:	43d2      	mvnne	r2, r2
 8008948:	f002 0201 	andne.w	r2, r2, #1
 800894c:	2202      	moveq	r2, #2
 800894e:	701a      	strb	r2, [r3, #0]
	fh->layer = 4 - ((buf[1] >> 1) & 0x03);     /* easy mapping of index to layer number, 4 = error */
 8008950:	784d      	ldrb	r5, [r1, #1]
 8008952:	f3c5 0541 	ubfx	r5, r5, #1, #2
 8008956:	f1c5 0904 	rsb	r9, r5, #4
 800895a:	f8c3 9004 	str.w	r9, [r3, #4]
	fh->crc =   1 - ((buf[1] >> 0) & 0x01);
 800895e:	f891 e001 	ldrb.w	lr, [r1, #1]
 8008962:	ea6f 040e 	mvn.w	r4, lr
 8008966:	f004 0401 	and.w	r4, r4, #1
 800896a:	609c      	str	r4, [r3, #8]
	fh->brIdx =      (buf[2] >> 4) & 0x0f;
 800896c:	788e      	ldrb	r6, [r1, #2]
 800896e:	0936      	lsrs	r6, r6, #4
 8008970:	60de      	str	r6, [r3, #12]
	fh->srIdx =      (buf[2] >> 2) & 0x03;
 8008972:	788c      	ldrb	r4, [r1, #2]
 8008974:	f3c4 0481 	ubfx	r4, r4, #2, #2
 8008978:	611c      	str	r4, [r3, #16]
	fh->paddingBit = (buf[2] >> 1) & 0x01;
 800897a:	f891 8002 	ldrb.w	r8, [r1, #2]
 800897e:	f3c8 0840 	ubfx	r8, r8, #1, #1
 8008982:	f8c3 8014 	str.w	r8, [r3, #20]
	fh->privateBit = (buf[2] >> 0) & 0x01;
 8008986:	788f      	ldrb	r7, [r1, #2]
 8008988:	f007 0701 	and.w	r7, r7, #1
 800898c:	619f      	str	r7, [r3, #24]
	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */    
 800898e:	78cf      	ldrb	r7, [r1, #3]
 8008990:	09bf      	lsrs	r7, r7, #6
 8008992:	771f      	strb	r7, [r3, #28]
	fh->modeExt =    (buf[3] >> 4) & 0x03;
 8008994:	f891 c003 	ldrb.w	ip, [r1, #3]
	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */    
 8008998:	9700      	str	r7, [sp, #0]
	fh->modeExt =    (buf[3] >> 4) & 0x03;
 800899a:	f3cc 1c01 	ubfx	ip, ip, #4, #2
 800899e:	f8c3 c020 	str.w	ip, [r3, #32]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
 80089a2:	f891 c003 	ldrb.w	ip, [r1, #3]
 80089a6:	f3cc 0cc0 	ubfx	ip, ip, #3, #1
 80089aa:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
	fh->origFlag =   (buf[3] >> 2) & 0x01;
 80089ae:	f891 c003 	ldrb.w	ip, [r1, #3]
 80089b2:	f3cc 0c80 	ubfx	ip, ip, #2, #1
 80089b6:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 80089ba:	f891 c003 	ldrb.w	ip, [r1, #3]
 80089be:	f00e 0701 	and.w	r7, lr, #1
 80089c2:	f00c 0c03 	and.w	ip, ip, #3

	/* check parameters to avoid indexing tables with bad values */
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 80089c6:	2c03      	cmp	r4, #3
 80089c8:	9701      	str	r7, [sp, #4]
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 80089ca:	f8c3 c02c 	str.w	ip, [r3, #44]	; 0x2c
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 80089ce:	f000 8086 	beq.w	8008ade <xmp3fixpt_UnpackFrameHeader+0x1c6>
 80089d2:	f1b9 0f04 	cmp.w	r9, #4
 80089d6:	f000 8082 	beq.w	8008ade <xmp3fixpt_UnpackFrameHeader+0x1c6>
 80089da:	2e0f      	cmp	r6, #15
 80089dc:	d07f      	beq.n	8008ade <xmp3fixpt_UnpackFrameHeader+0x1c6>
		return -1;

	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 80089de:	f04f 0cde 	mov.w	ip, #222	; 0xde
 80089e2:	fb0c fb02 	mul.w	fp, ip, r2
 80089e6:	f8df a114 	ldr.w	sl, [pc, #276]	; 8008afc <xmp3fixpt_UnpackFrameHeader+0x1e4>
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 80089ea:	9f00      	ldr	r7, [sp, #0]
	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 80089ec:	f04f 0c4a 	mov.w	ip, #74	; 0x4a
 80089f0:	fb1c bc04 	smlabb	ip, ip, r4, fp
 80089f4:	44d4      	add	ip, sl
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 80089f6:	2f01      	cmp	r7, #1
	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 80089f8:	f8c3 c034 	str.w	ip, [r3, #52]	; 0x34
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 80089fc:	d005      	beq.n	8008a0a <xmp3fixpt_UnpackFrameHeader+0xf2>
		fh->modeExt = 0;
 80089fe:	f04f 0c00 	mov.w	ip, #0

	/* init user-accessible data */
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 8008a02:	2f03      	cmp	r7, #3
		fh->modeExt = 0;
 8008a04:	f8c3 c020 	str.w	ip, [r3, #32]
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 8008a08:	d066      	beq.n	8008ad8 <xmp3fixpt_UnpackFrameHeader+0x1c0>
 8008a0a:	f04f 0a02 	mov.w	sl, #2
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 8008a0e:	ea4f 0e42 	mov.w	lr, r2, lsl #1
 8008a12:	eb0e 0c02 	add.w	ip, lr, r2
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 8008a16:	f1c5 0503 	rsb	r5, r5, #3
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 8008a1a:	eb0c 0b04 	add.w	fp, ip, r4
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 8008a1e:	f8c0 a7bc 	str.w	sl, [r0, #1980]	; 0x7bc
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 8008a22:	f8df a0dc 	ldr.w	sl, [pc, #220]	; 8008b00 <xmp3fixpt_UnpackFrameHeader+0x1e8>
	mp3DecInfo->layer = fh->layer;
 8008a26:	f8c0 97d0 	str.w	r9, [r0, #2000]	; 0x7d0
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 8008a2a:	2a00      	cmp	r2, #0
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 8008a2c:	eb0c 0905 	add.w	r9, ip, r5
	mp3DecInfo->version = fh->ver;
 8008a30:	f880 27d4 	strb.w	r2, [r0, #2004]	; 0x7d4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 8008a34:	4a2e      	ldr	r2, [pc, #184]	; (8008af0 <xmp3fixpt_UnpackFrameHeader+0x1d8>)
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 8008a36:	f85a 702b 	ldr.w	r7, [sl, fp, lsl #2]
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 8008a3a:	f932 2019 	ldrsh.w	r2, [r2, r9, lsl #1]
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 8008a3e:	f8c0 77c0 	str.w	r7, [r0, #1984]	; 0x7c0
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 8008a42:	bf14      	ite	ne
 8008a44:	f04f 0a01 	movne.w	sl, #1
 8008a48:	f04f 0a02 	moveq.w	sl, #2
 8008a4c:	f8c0 a7c4 	str.w	sl, [r0, #1988]	; 0x7c4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 8008a50:	fb92 f2fa 	sdiv	r2, r2, sl
 8008a54:	f8c0 27c8 	str.w	r2, [r0, #1992]	; 0x7c8
	/* get bitrate and nSlots from table, unless brIdx == 0 (free mode) in which case caller must figure it out himself
	 * question - do we want to overwrite mp3DecInfo->bitrate with 0 each time if it's free mode, and
	 *  copy the pre-calculated actual free bitrate into it in mp3dec.c (according to the spec, 
	 *  this shouldn't be necessary, since it should be either all frames free or none free)
	 */
	if (fh->brIdx) {
 8008a58:	b36e      	cbz	r6, 8008ab6 <xmp3fixpt_UnpackFrameHeader+0x19e>
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008a5a:	ebcc 1c0c 	rsb	ip, ip, ip, lsl #4
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 8008a5e:	9a00      	ldr	r2, [sp, #0]
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008a60:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 8008b04 <xmp3fixpt_UnpackFrameHeader+0x1ec>
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8008a64:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
 8008a68:	4464      	add	r4, ip
 8008a6a:	4434      	add	r4, r6
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 8008a6c:	2a03      	cmp	r2, #3
 8008a6e:	bf0c      	ite	eq
 8008a70:	4677      	moveq	r7, lr
 8008a72:	f10e 0701 	addne.w	r7, lr, #1
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008a76:	ebc5 1505 	rsb	r5, r5, r5, lsl #4
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8008a7a:	4a1e      	ldr	r2, [pc, #120]	; (8008af4 <xmp3fixpt_UnpackFrameHeader+0x1dc>)
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008a7c:	44ac      	add	ip, r5
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 8008a7e:	4d1e      	ldr	r5, [pc, #120]	; (8008af8 <xmp3fixpt_UnpackFrameHeader+0x1e0>)
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8008a80:	f932 2014 	ldrsh.w	r2, [r2, r4, lsl #1]
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 8008a84:	9c01      	ldr	r4, [sp, #4]
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 8008a86:	f935 5017 	ldrsh.w	r5, [r5, r7, lsl #1]
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008a8a:	4466      	add	r6, ip
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 8008a8c:	2c00      	cmp	r4, #0
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008a8e:	f939 4016 	ldrsh.w	r4, [r9, r6, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8008a92:	eba2 0205 	sub.w	r2, r2, r5
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 8008a96:	f1a2 0204 	sub.w	r2, r2, #4
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 8008a9a:	bf14      	ite	ne
 8008a9c:	2600      	movne	r6, #0
 8008a9e:	2602      	moveq	r6, #2
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008aa0:	ebc4 1544 	rsb	r5, r4, r4, lsl #5
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 8008aa4:	1b92      	subs	r2, r2, r6
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008aa6:	eb04 0485 	add.w	r4, r4, r5, lsl #2
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 8008aaa:	4442      	add	r2, r8
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008aac:	00e4      	lsls	r4, r4, #3
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 8008aae:	f8c0 27cc 	str.w	r2, [r0, #1996]	; 0x7cc
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 8008ab2:	f8c0 47b8 	str.w	r4, [r0, #1976]	; 0x7b8
	}

	/* load crc word, if enabled, and return length of frame header (in bytes) */
	if (fh->crc) {
 8008ab6:	9a01      	ldr	r2, [sp, #4]
 8008ab8:	b12a      	cbz	r2, 8008ac6 <xmp3fixpt_UnpackFrameHeader+0x1ae>
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
		return 6;
	} else {
		fh->CRCWord = 0;
 8008aba:	2200      	movs	r2, #0
		return 4;
 8008abc:	2004      	movs	r0, #4
		fh->CRCWord = 0;
 8008abe:	631a      	str	r2, [r3, #48]	; 0x30
	}
}
 8008ac0:	b003      	add	sp, #12
 8008ac2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 8008ac6:	7908      	ldrb	r0, [r1, #4]
 8008ac8:	794a      	ldrb	r2, [r1, #5]
 8008aca:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
		return 6;
 8008ace:	2006      	movs	r0, #6
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 8008ad0:	631a      	str	r2, [r3, #48]	; 0x30
}
 8008ad2:	b003      	add	sp, #12
 8008ad4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 8008ad8:	f04f 0a01 	mov.w	sl, #1
 8008adc:	e797      	b.n	8008a0e <xmp3fixpt_UnpackFrameHeader+0xf6>
		return -1;
 8008ade:	f04f 30ff 	mov.w	r0, #4294967295
}
 8008ae2:	b003      	add	sp, #12
 8008ae4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -1;
 8008ae8:	f04f 30ff 	mov.w	r0, #4294967295
}
 8008aec:	4770      	bx	lr
 8008aee:	bf00      	nop
 8008af0:	08014a90 	.word	0x08014a90
 8008af4:	0801496c 	.word	0x0801496c
 8008af8:	08014a7c 	.word	0x08014a7c
 8008afc:	080146d0 	.word	0x080146d0
 8008b00:	08014bb4 	.word	0x08014bb4
 8008b04:	08014aa4 	.word	0x08014aa4

08008b08 <xmp3fixpt_UnpackSideInfo>:
 *
 * Return:      length (in bytes) of side info data
 *              -1 if null input pointers
 **************************************************************************************/
int UnpackSideInfo(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 8008b08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008b0c:	b08b      	sub	sp, #44	; 0x2c
	FrameHeader *fh;
	SideInfo *si;
	SideInfoSub *sis;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS)
 8008b0e:	9008      	str	r0, [sp, #32]
 8008b10:	2800      	cmp	r0, #0
 8008b12:	f001 81b9 	beq.w	8009e88 <xmp3fixpt_UnpackSideInfo+0x1380>
 8008b16:	6803      	ldr	r3, [r0, #0]
 8008b18:	4607      	mov	r7, r0
 8008b1a:	2b00      	cmp	r3, #0
 8008b1c:	f001 81b4 	beq.w	8009e88 <xmp3fixpt_UnpackSideInfo+0x1380>
 8008b20:	6842      	ldr	r2, [r0, #4]
 8008b22:	9207      	str	r2, [sp, #28]
 8008b24:	4616      	mov	r6, r2
 8008b26:	2a00      	cmp	r2, #0
 8008b28:	f001 81ae 	beq.w	8009e88 <xmp3fixpt_UnpackSideInfo+0x1380>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));

	bsi = &bitStreamInfo;
	if (fh->ver == MPEG1) {
 8008b2c:	781a      	ldrb	r2, [r3, #0]
 8008b2e:	9202      	str	r2, [sp, #8]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8008b30:	784c      	ldrb	r4, [r1, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8008b32:	780d      	ldrb	r5, [r1, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8008b34:	78c8      	ldrb	r0, [r1, #3]
	if (fh->ver == MPEG1) {
 8008b36:	2a00      	cmp	r2, #0
 8008b38:	f000 80f3 	beq.w	8008d22 <xmp3fixpt_UnpackSideInfo+0x21a>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8008b3c:	0424      	lsls	r4, r4, #16
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
			for (bd = 0; bd < MAX_SCFBD; bd++)
				si->scfsi[ch][bd] = GetBits(bsi, 1);
	} else {
		/* MPEG 2, MPEG 2.5 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 8008b3e:	7f1a      	ldrb	r2, [r3, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8008b40:	788b      	ldrb	r3, [r1, #2]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8008b42:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
		bsi->iCache |= (*bsi->bytePtr++);
 8008b46:	4304      	orrs	r4, r0
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 8008b48:	2a03      	cmp	r2, #3
		bsi->iCache |= (*bsi->bytePtr++);
 8008b4a:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 8008b4e:	ea4f 2204 	mov.w	r2, r4, lsl #8
 8008b52:	bf0c      	ite	eq
 8008b54:	231e      	moveq	r3, #30
 8008b56:	231d      	movne	r3, #29
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 8008b58:	fa22 f303 	lsr.w	r3, r2, r3
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008b5c:	ea4f 0353 	mov.w	r3, r3, lsr #1
		SetBitstreamPointer(bsi, nBytes, buf);
		si->mainDataBegin = GetBits(bsi, 8);
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 8008b60:	6073      	str	r3, [r6, #4]
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8008b62:	ea4f 6414 	mov.w	r4, r4, lsr #24
 8008b66:	bf0b      	itete	eq
 8008b68:	2001      	moveq	r0, #1
 8008b6a:	2002      	movne	r0, #2
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 8008b6c:	2309      	moveq	r3, #9
 8008b6e:	2311      	movne	r3, #17
		si->mainDataBegin = GetBits(bsi, 8);
 8008b70:	6034      	str	r4, [r6, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8008b72:	f101 0504 	add.w	r5, r1, #4
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 8008b76:	bf08      	it	eq
 8008b78:	2605      	moveq	r6, #5
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008b7a:	fa02 f100 	lsl.w	r1, r2, r0
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 8008b7e:	bf18      	it	ne
 8008b80:	260d      	movne	r6, #13
 8008b82:	9309      	str	r3, [sp, #36]	; 0x24
 8008b84:	bf0c      	ite	eq
 8008b86:	2217      	moveq	r2, #23
 8008b88:	2216      	movne	r2, #22
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 8008b8a:	9808      	ldr	r0, [sp, #32]
 8008b8c:	f8d0 37c4 	ldr.w	r3, [r0, #1988]	; 0x7c4
 8008b90:	9306      	str	r3, [sp, #24]
 8008b92:	2b00      	cmp	r3, #0
 8008b94:	f340 80be 	ble.w	8008d14 <xmp3fixpt_UnpackSideInfo+0x20c>
 8008b98:	2300      	movs	r3, #0
 8008b9a:	9305      	str	r3, [sp, #20]
 8008b9c:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	; 0x7bc
 8008ba0:	9301      	str	r3, [sp, #4]
 8008ba2:	9b07      	ldr	r3, [sp, #28]
 8008ba4:	9303      	str	r3, [sp, #12]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8008ba6:	9b01      	ldr	r3, [sp, #4]
 8008ba8:	2b00      	cmp	r3, #0
 8008baa:	f340 80a7 	ble.w	8008cfc <xmp3fixpt_UnpackSideInfo+0x1f4>
 8008bae:	9b02      	ldr	r3, [sp, #8]
 8008bb0:	9c03      	ldr	r4, [sp, #12]
 8008bb2:	2b00      	cmp	r3, #0
 8008bb4:	bf0c      	ite	eq
 8008bb6:	231b      	moveq	r3, #27
 8008bb8:	2316      	movne	r3, #22
 8008bba:	9304      	str	r3, [sp, #16]
 8008bbc:	bf0c      	ite	eq
 8008bbe:	f04f 0e04 	moveq.w	lr, #4
 8008bc2:	f04f 0e09 	movne.w	lr, #9
 8008bc6:	2700      	movs	r7, #0
 8008bc8:	460b      	mov	r3, r1
	if (bsi->cachedBits < 0) {
 8008bca:	f1b2 010c 	subs.w	r1, r2, #12
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008bce:	ea4f 5c13 	mov.w	ip, r3, lsr #20
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008bd2:	ea4f 3003 	mov.w	r0, r3, lsl #12
	if (bsi->cachedBits < 0) {
 8008bd6:	f100 82fa 	bmi.w	80091ce <xmp3fixpt_UnpackSideInfo+0x6c6>
 8008bda:	0dc0      	lsrs	r0, r0, #23
 8008bdc:	055b      	lsls	r3, r3, #21
			sis = &si->sis[gr][ch];						/* side info subblock for this granule, channel */

			sis->part23Length =    GetBits(bsi, 12);
 8008bde:	f8c4 c028 	str.w	ip, [r4, #40]	; 0x28
	if (bsi->cachedBits < 0) {
 8008be2:	f1b1 0c09 	subs.w	ip, r1, #9
 8008be6:	f100 829d 	bmi.w	8009124 <xmp3fixpt_UnpackSideInfo+0x61c>
 8008bea:	f1bc 0208 	subs.w	r2, ip, #8
 8008bee:	ea4f 6113 	mov.w	r1, r3, lsr #24
			sis->nBigvals =        GetBits(bsi, 9);
 8008bf2:	62e0      	str	r0, [r4, #44]	; 0x2c
 8008bf4:	ea4f 2303 	mov.w	r3, r3, lsl #8
	if (bsi->cachedBits < 0) {
 8008bf8:	f100 82c2 	bmi.w	8009180 <xmp3fixpt_UnpackSideInfo+0x678>
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 8008bfc:	9804      	ldr	r0, [sp, #16]
			sis->globalGain =      GetBits(bsi, 8);
 8008bfe:	6321      	str	r1, [r4, #48]	; 0x30
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 8008c00:	fa23 f000 	lsr.w	r0, r3, r0
	if (bsi->cachedBits < 0) {
 8008c04:	ebb2 020e 	subs.w	r2, r2, lr
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008c08:	ea4f 0050 	mov.w	r0, r0, lsr #1
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008c0c:	fa03 f30e 	lsl.w	r3, r3, lr
	if (bsi->cachedBits < 0) {
 8008c10:	f100 822e 	bmi.w	8009070 <xmp3fixpt_UnpackSideInfo+0x568>
 8008c14:	f1b2 0801 	subs.w	r8, r2, #1
 8008c18:	ea4f 71d3 	mov.w	r1, r3, lsr #31
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 8008c1c:	6360      	str	r0, [r4, #52]	; 0x34
 8008c1e:	ea4f 0343 	mov.w	r3, r3, lsl #1
	if (bsi->cachedBits < 0) {
 8008c22:	f100 8256 	bmi.w	80090d2 <xmp3fixpt_UnpackSideInfo+0x5ca>
			sis->winSwitchFlag =   GetBits(bsi, 1);
 8008c26:	63a1      	str	r1, [r4, #56]	; 0x38

			if(sis->winSwitchFlag) {
 8008c28:	2900      	cmp	r1, #0
 8008c2a:	f000 8185 	beq.w	8008f38 <xmp3fixpt_UnpackSideInfo+0x430>
	if (bsi->cachedBits < 0) {
 8008c2e:	f1b8 0002 	subs.w	r0, r8, #2
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008c32:	ea4f 7293 	mov.w	r2, r3, lsr #30
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008c36:	ea4f 0c83 	mov.w	ip, r3, lsl #2
	if (bsi->cachedBits < 0) {
 8008c3a:	f100 8417 	bmi.w	800946c <xmp3fixpt_UnpackSideInfo+0x964>
 8008c3e:	ea4f 7cdc 	mov.w	ip, ip, lsr #31
 8008c42:	00db      	lsls	r3, r3, #3
 8008c44:	1e41      	subs	r1, r0, #1
				/* this is a start, stop, short, or mixed block */
				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
 8008c46:	63e2      	str	r2, [r4, #60]	; 0x3c
	if (bsi->cachedBits < 0) {
 8008c48:	f100 8318 	bmi.w	800927c <xmp3fixpt_UnpackSideInfo+0x774>
 8008c4c:	1f48      	subs	r0, r1, #5
 8008c4e:	ea4f 68d3 	mov.w	r8, r3, lsr #27
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 8008c52:	f8c4 c040 	str.w	ip, [r4, #64]	; 0x40
 8008c56:	ea4f 1343 	mov.w	r3, r3, lsl #5
	if (bsi->cachedBits < 0) {
 8008c5a:	f100 8341 	bmi.w	80092e0 <xmp3fixpt_UnpackSideInfo+0x7d8>
 8008c5e:	1f41      	subs	r1, r0, #5
 8008c60:	ea4f 69d3 	mov.w	r9, r3, lsr #27
				sis->tableSelect[0] =  GetBits(bsi, 5);
 8008c64:	f8c4 8044 	str.w	r8, [r4, #68]	; 0x44
 8008c68:	ea4f 1343 	mov.w	r3, r3, lsl #5
	if (bsi->cachedBits < 0) {
 8008c6c:	f100 836a 	bmi.w	8009344 <xmp3fixpt_UnpackSideInfo+0x83c>
				sis->tableSelect[1] =  GetBits(bsi, 5);
				sis->tableSelect[2] =  0;					/* unused */
 8008c70:	2000      	movs	r0, #0
 8008c72:	64e0      	str	r0, [r4, #76]	; 0x4c
	if (bsi->cachedBits < 0) {
 8008c74:	1ec8      	subs	r0, r1, #3
 8008c76:	ea4f 7853 	mov.w	r8, r3, lsr #29
				sis->tableSelect[1] =  GetBits(bsi, 5);
 8008c7a:	f8c4 9048 	str.w	r9, [r4, #72]	; 0x48
 8008c7e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
	if (bsi->cachedBits < 0) {
 8008c82:	f100 8393 	bmi.w	80093ac <xmp3fixpt_UnpackSideInfo+0x8a4>
 8008c86:	1ec1      	subs	r1, r0, #3
 8008c88:	ea4f 7953 	mov.w	r9, r3, lsr #29
				sis->subBlockGain[0] = GetBits(bsi, 3);
 8008c8c:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
 8008c90:	ea4f 03c3 	mov.w	r3, r3, lsl #3
	if (bsi->cachedBits < 0) {
 8008c94:	f100 83bc 	bmi.w	8009410 <xmp3fixpt_UnpackSideInfo+0x908>
 8008c98:	ea4f 7853 	mov.w	r8, r3, lsr #29
 8008c9c:	00db      	lsls	r3, r3, #3
 8008c9e:	1ec8      	subs	r0, r1, #3
				sis->subBlockGain[1] = GetBits(bsi, 3);
 8008ca0:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
	if (bsi->cachedBits < 0) {
 8008ca4:	f100 82bd 	bmi.w	8009222 <xmp3fixpt_UnpackSideInfo+0x71a>
 8008ca8:	0fd9      	lsrs	r1, r3, #31
 8008caa:	005b      	lsls	r3, r3, #1
				sis->subBlockGain[2] = GetBits(bsi, 3);
 8008cac:	f8c4 8058 	str.w	r8, [r4, #88]	; 0x58

				/* TODO - check logic */
				if (sis->blockType == 0) {
 8008cb0:	2a00      	cmp	r2, #0
 8008cb2:	f040 81d6 	bne.w	8009062 <xmp3fixpt_UnpackSideInfo+0x55a>
					/* this should not be allowed, according to spec */
					sis->nBigvals = 0;
 8008cb6:	62e2      	str	r2, [r4, #44]	; 0x2c
					sis->part23Length = 0;
 8008cb8:	62a2      	str	r2, [r4, #40]	; 0x28
					sis->sfCompress = 0;
 8008cba:	6362      	str	r2, [r4, #52]	; 0x34
 8008cbc:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8008cbe:	f1c2 0214 	rsb	r2, r2, #20
					sis->region0Count = 8;
				} else {
					/* start, stop, or short-mixed */
					sis->region0Count = 7;
				}
				sis->region1Count = 20 - sis->region0Count;
 8008cc2:	6622      	str	r2, [r4, #96]	; 0x60
				sis->tableSelect[1] =  GetBits(bsi, 5);
				sis->tableSelect[2] =  GetBits(bsi, 5);
				sis->region0Count =    GetBits(bsi, 4);
				sis->region1Count =    GetBits(bsi, 3);
			}
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 8008cc4:	9a02      	ldr	r2, [sp, #8]
 8008cc6:	2a00      	cmp	r2, #0
 8008cc8:	f000 8164 	beq.w	8008f94 <xmp3fixpt_UnpackSideInfo+0x48c>
 8008ccc:	2200      	movs	r2, #0
	if (bsi->cachedBits < 0) {
 8008cce:	f1b0 0c01 	subs.w	ip, r0, #1
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 8008cd2:	6662      	str	r2, [r4, #100]	; 0x64
	if (bsi->cachedBits < 0) {
 8008cd4:	f100 816d 	bmi.w	8008fb2 <xmp3fixpt_UnpackSideInfo+0x4aa>
 8008cd8:	f1bc 0201 	subs.w	r2, ip, #1
 8008cdc:	ea4f 70d3 	mov.w	r0, r3, lsr #31
			sis->sfactScale =        GetBits(bsi, 1);
 8008ce0:	66a1      	str	r1, [r4, #104]	; 0x68
 8008ce2:	ea4f 0343 	mov.w	r3, r3, lsl #1
	if (bsi->cachedBits < 0) {
 8008ce6:	f100 8193 	bmi.w	8009010 <xmp3fixpt_UnpackSideInfo+0x508>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8008cea:	9901      	ldr	r1, [sp, #4]
			sis->count1TableSelect = GetBits(bsi, 1);
 8008cec:	66e0      	str	r0, [r4, #108]	; 0x6c
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 8008cee:	3701      	adds	r7, #1
 8008cf0:	42b9      	cmp	r1, r7
 8008cf2:	f104 0448 	add.w	r4, r4, #72	; 0x48
 8008cf6:	f73f af68 	bgt.w	8008bca <xmp3fixpt_UnpackSideInfo+0xc2>
 8008cfa:	4619      	mov	r1, r3
 8008cfc:	9803      	ldr	r0, [sp, #12]
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 8008cfe:	9b05      	ldr	r3, [sp, #20]
 8008d00:	3090      	adds	r0, #144	; 0x90
 8008d02:	9003      	str	r0, [sp, #12]
 8008d04:	9806      	ldr	r0, [sp, #24]
 8008d06:	3301      	adds	r3, #1
 8008d08:	4283      	cmp	r3, r0
 8008d0a:	9305      	str	r3, [sp, #20]
 8008d0c:	f6ff af4b 	blt.w	8008ba6 <xmp3fixpt_UnpackSideInfo+0x9e>
 8008d10:	9b07      	ldr	r3, [sp, #28]
 8008d12:	681c      	ldr	r4, [r3, #0]
		}
	}
	mp3DecInfo->mainDataBegin = si->mainDataBegin;	/* needed by main decode loop */
 8008d14:	9b08      	ldr	r3, [sp, #32]
 8008d16:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008d18:	f8c3 47d8 	str.w	r4, [r3, #2008]	; 0x7d8

	ASSERT(nBytes == CalcBitsUsed(bsi, buf, 0) >> 3);

	return nBytes;	
}
 8008d1c:	b00b      	add	sp, #44	; 0x2c
 8008d1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8008d22:	0424      	lsls	r4, r4, #16
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 8008d24:	7f1a      	ldrb	r2, [r3, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8008d26:	788b      	ldrb	r3, [r1, #2]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8008d28:	f8d7 77bc 	ldr.w	r7, [r7, #1980]	; 0x7bc
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8008d2c:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
		bsi->iCache |= (*bsi->bytePtr++);
 8008d30:	4304      	orrs	r4, r0
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 8008d32:	2a03      	cmp	r2, #3
		bsi->iCache |= (*bsi->bytePtr++);
 8008d34:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 8008d38:	ea4f 2244 	mov.w	r2, r4, lsl #9
 8008d3c:	bf0c      	ite	eq
 8008d3e:	231a      	moveq	r3, #26
 8008d40:	231c      	movne	r3, #28
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 8008d42:	fa22 f303 	lsr.w	r3, r2, r3
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008d46:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8008d4a:	bf0c      	ite	eq
 8008d4c:	2005      	moveq	r0, #5
 8008d4e:	2003      	movne	r0, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8008d50:	ea4f 54d4 	mov.w	r4, r4, lsr #23
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 8008d54:	6073      	str	r3, [r6, #4]
		si->mainDataBegin = GetBits(bsi, 9);
 8008d56:	6034      	str	r4, [r6, #0]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 8008d58:	bf0c      	ite	eq
 8008d5a:	2311      	moveq	r3, #17
 8008d5c:	2320      	movne	r3, #32
		bsi->iCache |= (*bsi->bytePtr++);
 8008d5e:	f101 0504 	add.w	r5, r1, #4
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 8008d62:	bf08      	it	eq
 8008d64:	260d      	moveq	r6, #13
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008d66:	fa02 f100 	lsl.w	r1, r2, r0
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 8008d6a:	bf16      	itet	ne
 8008d6c:	261c      	movne	r6, #28
 8008d6e:	2212      	moveq	r2, #18
 8008d70:	2214      	movne	r2, #20
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8008d72:	2f00      	cmp	r7, #0
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 8008d74:	9309      	str	r3, [sp, #36]	; 0x24
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8008d76:	f77f af08 	ble.w	8008b8a <xmp3fixpt_UnpackSideInfo+0x82>
 8008d7a:	9807      	ldr	r0, [sp, #28]
 8008d7c:	eb00 1907 	add.w	r9, r0, r7, lsl #4
 8008d80:	e01a      	b.n	8008db8 <xmp3fixpt_UnpackSideInfo+0x2b0>
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8008d82:	6087      	str	r7, [r0, #8]
	if (bsi->cachedBits < 0) {
 8008d84:	1e5f      	subs	r7, r3, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008d86:	ea4f 72d1 	mov.w	r2, r1, lsr #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008d8a:	ea4f 0141 	mov.w	r1, r1, lsl #1
	if (bsi->cachedBits < 0) {
 8008d8e:	d44a      	bmi.n	8008e26 <xmp3fixpt_UnpackSideInfo+0x31e>
 8008d90:	1e7b      	subs	r3, r7, #1
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8008d92:	60c2      	str	r2, [r0, #12]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008d94:	ea4f 72d1 	mov.w	r2, r1, lsr #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008d98:	ea4f 0141 	mov.w	r1, r1, lsl #1
	if (bsi->cachedBits < 0) {
 8008d9c:	d473      	bmi.n	8008e86 <xmp3fixpt_UnpackSideInfo+0x37e>
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8008d9e:	6102      	str	r2, [r0, #16]
	if (bsi->cachedBits < 0) {
 8008da0:	1e5a      	subs	r2, r3, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008da2:	ea4f 77d1 	mov.w	r7, r1, lsr #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008da6:	ea4f 0141 	mov.w	r1, r1, lsl #1
	if (bsi->cachedBits < 0) {
 8008daa:	f100 809d 	bmi.w	8008ee8 <xmp3fixpt_UnpackSideInfo+0x3e0>
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8008dae:	6147      	str	r7, [r0, #20]
 8008db0:	3010      	adds	r0, #16
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 8008db2:	4581      	cmp	r9, r0
 8008db4:	f43f aee9 	beq.w	8008b8a <xmp3fixpt_UnpackSideInfo+0x82>
	if (bsi->cachedBits < 0) {
 8008db8:	1e53      	subs	r3, r2, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008dba:	ea4f 77d1 	mov.w	r7, r1, lsr #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008dbe:	ea4f 0141 	mov.w	r1, r1, lsl #1
	if (bsi->cachedBits < 0) {
 8008dc2:	d5de      	bpl.n	8008d82 <xmp3fixpt_UnpackSideInfo+0x27a>
	if (nBytes >= 4) {
 8008dc4:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8008dc6:	f1c2 0101 	rsb	r1, r2, #1
	if (nBytes >= 4) {
 8008dca:	f300 8699 	bgt.w	8009b00 <xmp3fixpt_UnpackSideInfo+0xff8>
		while (nBytes--) {
 8008dce:	2e00      	cmp	r6, #0
 8008dd0:	f001 8030 	beq.w	8009e34 <xmp3fixpt_UnpackSideInfo+0x132c>
			bsi->iCache |= (*bsi->bytePtr++);
 8008dd4:	f895 e000 	ldrb.w	lr, [r5]
		while (nBytes--) {
 8008dd8:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8008dda:	ea4f 280e 	mov.w	r8, lr, lsl #8
		while (nBytes--) {
 8008dde:	f001 801f 	beq.w	8009e20 <xmp3fixpt_UnpackSideInfo+0x1318>
			bsi->iCache |= (*bsi->bytePtr++);
 8008de2:	f895 c001 	ldrb.w	ip, [r5, #1]
 8008de6:	f895 e002 	ldrb.w	lr, [r5, #2]
 8008dea:	ea4c 0c08 	orr.w	ip, ip, r8
 8008dee:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
 8008df2:	f1c6 0c03 	rsb	ip, r6, #3
			bsi->iCache <<= 8;
 8008df6:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 8008dfa:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8008dfe:	fa0e fc0c 	lsl.w	ip, lr, ip
 8008e02:	321f      	adds	r2, #31
			bsi->iCache |= (*bsi->bytePtr++);
 8008e04:	3503      	adds	r5, #3
 8008e06:	fa2c fe02 	lsr.w	lr, ip, r2
 8008e0a:	fa0c f101 	lsl.w	r1, ip, r1
 8008e0e:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
		bsi->nBytes = 0;
 8008e12:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8008e14:	ea47 070e 	orr.w	r7, r7, lr
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8008e18:	6087      	str	r7, [r0, #8]
	if (bsi->cachedBits < 0) {
 8008e1a:	1e5f      	subs	r7, r3, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008e1c:	ea4f 72d1 	mov.w	r2, r1, lsr #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008e20:	ea4f 0141 	mov.w	r1, r1, lsl #1
	if (bsi->cachedBits < 0) {
 8008e24:	d5b4      	bpl.n	8008d90 <xmp3fixpt_UnpackSideInfo+0x288>
	if (nBytes >= 4) {
 8008e26:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8008e28:	f1c3 0101 	rsb	r1, r3, #1
	if (nBytes >= 4) {
 8008e2c:	f300 8650 	bgt.w	8009ad0 <xmp3fixpt_UnpackSideInfo+0xfc8>
		while (nBytes--) {
 8008e30:	2e00      	cmp	r6, #0
 8008e32:	f001 801b 	beq.w	8009e6c <xmp3fixpt_UnpackSideInfo+0x1364>
			bsi->iCache |= (*bsi->bytePtr++);
 8008e36:	f895 e000 	ldrb.w	lr, [r5]
		while (nBytes--) {
 8008e3a:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8008e3c:	ea4f 280e 	mov.w	r8, lr, lsl #8
		while (nBytes--) {
 8008e40:	f001 800a 	beq.w	8009e58 <xmp3fixpt_UnpackSideInfo+0x1350>
			bsi->iCache |= (*bsi->bytePtr++);
 8008e44:	f895 c001 	ldrb.w	ip, [r5, #1]
 8008e48:	f895 e002 	ldrb.w	lr, [r5, #2]
 8008e4c:	ea4c 0c08 	orr.w	ip, ip, r8
 8008e50:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
 8008e54:	f1c6 0c03 	rsb	ip, r6, #3
			bsi->iCache <<= 8;
 8008e58:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 8008e5c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8008e60:	fa0e fe0c 	lsl.w	lr, lr, ip
 8008e64:	331f      	adds	r3, #31
			bsi->iCache |= (*bsi->bytePtr++);
 8008e66:	3503      	adds	r5, #3
 8008e68:	fa2e f303 	lsr.w	r3, lr, r3
 8008e6c:	fa0e f101 	lsl.w	r1, lr, r1
 8008e70:	eb07 07c6 	add.w	r7, r7, r6, lsl #3
		bsi->nBytes = 0;
 8008e74:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8008e76:	431a      	orrs	r2, r3
	if (bsi->cachedBits < 0) {
 8008e78:	1e7b      	subs	r3, r7, #1
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8008e7a:	60c2      	str	r2, [r0, #12]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008e7c:	ea4f 72d1 	mov.w	r2, r1, lsr #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008e80:	ea4f 0141 	mov.w	r1, r1, lsl #1
	if (bsi->cachedBits < 0) {
 8008e84:	d58b      	bpl.n	8008d9e <xmp3fixpt_UnpackSideInfo+0x296>
	if (nBytes >= 4) {
 8008e86:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8008e88:	f1c7 0101 	rsb	r1, r7, #1
	if (nBytes >= 4) {
 8008e8c:	f300 8666 	bgt.w	8009b5c <xmp3fixpt_UnpackSideInfo+0x1054>
		while (nBytes--) {
 8008e90:	2e00      	cmp	r6, #0
 8008e92:	f000 87d3 	beq.w	8009e3c <xmp3fixpt_UnpackSideInfo+0x1334>
			bsi->iCache |= (*bsi->bytePtr++);
 8008e96:	f895 e000 	ldrb.w	lr, [r5]
		while (nBytes--) {
 8008e9a:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8008e9c:	ea4f 280e 	mov.w	r8, lr, lsl #8
		while (nBytes--) {
 8008ea0:	f000 87e8 	beq.w	8009e74 <xmp3fixpt_UnpackSideInfo+0x136c>
			bsi->iCache |= (*bsi->bytePtr++);
 8008ea4:	f895 c001 	ldrb.w	ip, [r5, #1]
 8008ea8:	f895 e002 	ldrb.w	lr, [r5, #2]
 8008eac:	ea4c 0c08 	orr.w	ip, ip, r8
 8008eb0:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
 8008eb4:	f1c6 0c03 	rsb	ip, r6, #3
			bsi->iCache <<= 8;
 8008eb8:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 8008ebc:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8008ec0:	fa0e fe0c 	lsl.w	lr, lr, ip
 8008ec4:	371f      	adds	r7, #31
			bsi->iCache |= (*bsi->bytePtr++);
 8008ec6:	3503      	adds	r5, #3
 8008ec8:	fa2e f707 	lsr.w	r7, lr, r7
 8008ecc:	fa0e f101 	lsl.w	r1, lr, r1
 8008ed0:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
		bsi->nBytes = 0;
 8008ed4:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8008ed6:	433a      	orrs	r2, r7
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 8008ed8:	6102      	str	r2, [r0, #16]
	if (bsi->cachedBits < 0) {
 8008eda:	1e5a      	subs	r2, r3, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008edc:	ea4f 77d1 	mov.w	r7, r1, lsr #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008ee0:	ea4f 0141 	mov.w	r1, r1, lsl #1
	if (bsi->cachedBits < 0) {
 8008ee4:	f57f af63 	bpl.w	8008dae <xmp3fixpt_UnpackSideInfo+0x2a6>
	if (nBytes >= 4) {
 8008ee8:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8008eea:	f1c3 0c01 	rsb	ip, r3, #1
	if (nBytes >= 4) {
 8008eee:	f300 8620 	bgt.w	8009b32 <xmp3fixpt_UnpackSideInfo+0x102a>
		while (nBytes--) {
 8008ef2:	2e00      	cmp	r6, #0
 8008ef4:	f000 8790 	beq.w	8009e18 <xmp3fixpt_UnpackSideInfo+0x1310>
			bsi->iCache |= (*bsi->bytePtr++);
 8008ef8:	f895 8000 	ldrb.w	r8, [r5]
		while (nBytes--) {
 8008efc:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8008efe:	ea4f 2a08 	mov.w	sl, r8, lsl #8
		while (nBytes--) {
 8008f02:	f000 879f 	beq.w	8009e44 <xmp3fixpt_UnpackSideInfo+0x133c>
			bsi->iCache |= (*bsi->bytePtr++);
 8008f06:	7869      	ldrb	r1, [r5, #1]
 8008f08:	f895 e002 	ldrb.w	lr, [r5, #2]
 8008f0c:	ea41 010a 	orr.w	r1, r1, sl
 8008f10:	ea4e 2e01 	orr.w	lr, lr, r1, lsl #8
 8008f14:	f1c6 0103 	rsb	r1, r6, #3
			bsi->iCache <<= 8;
 8008f18:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 8008f1c:	00c9      	lsls	r1, r1, #3
 8008f1e:	fa0e f101 	lsl.w	r1, lr, r1
 8008f22:	331f      	adds	r3, #31
 8008f24:	fa21 f303 	lsr.w	r3, r1, r3
			bsi->iCache |= (*bsi->bytePtr++);
 8008f28:	3503      	adds	r5, #3
 8008f2a:	fa01 f10c 	lsl.w	r1, r1, ip
 8008f2e:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
		bsi->nBytes = 0;
 8008f32:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8008f34:	431f      	orrs	r7, r3
 8008f36:	e73a      	b.n	8008dae <xmp3fixpt_UnpackSideInfo+0x2a6>
	if (bsi->cachedBits < 0) {
 8008f38:	f1b8 0205 	subs.w	r2, r8, #5
				sis->blockType = 0;
 8008f3c:	63e1      	str	r1, [r4, #60]	; 0x3c
				sis->mixedBlock = 0;
 8008f3e:	6421      	str	r1, [r4, #64]	; 0x40
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008f40:	ea4f 60d3 	mov.w	r0, r3, lsr #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 8008f44:	ea4f 1143 	mov.w	r1, r3, lsl #5
	if (bsi->cachedBits < 0) {
 8008f48:	f100 8375 	bmi.w	8009636 <xmp3fixpt_UnpackSideInfo+0xb2e>
 8008f4c:	0ec9      	lsrs	r1, r1, #27
 8008f4e:	029b      	lsls	r3, r3, #10
				sis->tableSelect[0] =  GetBits(bsi, 5);
 8008f50:	6460      	str	r0, [r4, #68]	; 0x44
	if (bsi->cachedBits < 0) {
 8008f52:	1f50      	subs	r0, r2, #5
 8008f54:	f100 8312 	bmi.w	800957c <xmp3fixpt_UnpackSideInfo+0xa74>
				sis->tableSelect[1] =  GetBits(bsi, 5);
 8008f58:	64a1      	str	r1, [r4, #72]	; 0x48
	if (bsi->cachedBits < 0) {
 8008f5a:	1f41      	subs	r1, r0, #5
 8008f5c:	ea4f 62d3 	mov.w	r2, r3, lsr #27
 8008f60:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8008f64:	f100 833a 	bmi.w	80095dc <xmp3fixpt_UnpackSideInfo+0xad4>
 8008f68:	0f18      	lsrs	r0, r3, #28
 8008f6a:	011b      	lsls	r3, r3, #4
				sis->tableSelect[2] =  GetBits(bsi, 5);
 8008f6c:	64e2      	str	r2, [r4, #76]	; 0x4c
	if (bsi->cachedBits < 0) {
 8008f6e:	1f0a      	subs	r2, r1, #4
 8008f70:	f100 82a9 	bmi.w	80094c6 <xmp3fixpt_UnpackSideInfo+0x9be>
				sis->region0Count =    GetBits(bsi, 4);
 8008f74:	65e0      	str	r0, [r4, #92]	; 0x5c
	if (bsi->cachedBits < 0) {
 8008f76:	1ed0      	subs	r0, r2, #3
 8008f78:	ea4f 7c53 	mov.w	ip, r3, lsr #29
 8008f7c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8008f80:	f100 82d1 	bmi.w	8009526 <xmp3fixpt_UnpackSideInfo+0xa1e>
 8008f84:	0fd9      	lsrs	r1, r3, #31
 8008f86:	005b      	lsls	r3, r3, #1
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 8008f88:	9a02      	ldr	r2, [sp, #8]
				sis->region1Count =    GetBits(bsi, 3);
 8008f8a:	f8c4 c060 	str.w	ip, [r4, #96]	; 0x60
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 8008f8e:	2a00      	cmp	r2, #0
 8008f90:	f47f ae9c 	bne.w	8008ccc <xmp3fixpt_UnpackSideInfo+0x1c4>
	if (bsi->cachedBits < 0) {
 8008f94:	1e42      	subs	r2, r0, #1
 8008f96:	f100 8422 	bmi.w	80097de <xmp3fixpt_UnpackSideInfo+0xcd6>
 8008f9a:	ea4f 78d3 	mov.w	r8, r3, lsr #31
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 8008f9e:	468c      	mov	ip, r1
	if (bsi->cachedBits < 0) {
 8008fa0:	4610      	mov	r0, r2
 8008fa2:	4641      	mov	r1, r8
 8008fa4:	005b      	lsls	r3, r3, #1
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 8008fa6:	4662      	mov	r2, ip
	if (bsi->cachedBits < 0) {
 8008fa8:	f1b0 0c01 	subs.w	ip, r0, #1
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 8008fac:	6662      	str	r2, [r4, #100]	; 0x64
	if (bsi->cachedBits < 0) {
 8008fae:	f57f ae93 	bpl.w	8008cd8 <xmp3fixpt_UnpackSideInfo+0x1d0>
	if (nBytes >= 4) {
 8008fb2:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8008fb4:	f1c0 0301 	rsb	r3, r0, #1
	if (nBytes >= 4) {
 8008fb8:	f300 83dd 	bgt.w	8009776 <xmp3fixpt_UnpackSideInfo+0xc6e>
		while (nBytes--) {
 8008fbc:	2e00      	cmp	r6, #0
 8008fbe:	f000 8625 	beq.w	8009c0c <xmp3fixpt_UnpackSideInfo+0x1104>
			bsi->iCache |= (*bsi->bytePtr++);
 8008fc2:	782a      	ldrb	r2, [r5, #0]
		while (nBytes--) {
 8008fc4:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8008fc6:	ea4f 2902 	mov.w	r9, r2, lsl #8
		while (nBytes--) {
 8008fca:	f000 85df 	beq.w	8009b8c <xmp3fixpt_UnpackSideInfo+0x1084>
			bsi->iCache |= (*bsi->bytePtr++);
 8008fce:	f895 8001 	ldrb.w	r8, [r5, #1]
 8008fd2:	78aa      	ldrb	r2, [r5, #2]
 8008fd4:	ea48 0809 	orr.w	r8, r8, r9
 8008fd8:	ea42 2808 	orr.w	r8, r2, r8, lsl #8
 8008fdc:	f1c6 0203 	rsb	r2, r6, #3
			bsi->iCache <<= 8;
 8008fe0:	ea4f 2808 	mov.w	r8, r8, lsl #8
 8008fe4:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 8008fe8:	fa08 f20a 	lsl.w	r2, r8, sl
 8008fec:	301f      	adds	r0, #31
 8008fee:	fa02 f303 	lsl.w	r3, r2, r3
 8008ff2:	fa22 f800 	lsr.w	r8, r2, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8008ff6:	3503      	adds	r5, #3
 8008ff8:	0fd8      	lsrs	r0, r3, #31
 8008ffa:	005b      	lsls	r3, r3, #1
 8008ffc:	eb0c 0cc6 	add.w	ip, ip, r6, lsl #3
		bsi->nBytes = 0;
 8009000:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009002:	ea41 0108 	orr.w	r1, r1, r8
	if (bsi->cachedBits < 0) {
 8009006:	f1bc 0201 	subs.w	r2, ip, #1
			sis->sfactScale =        GetBits(bsi, 1);
 800900a:	66a1      	str	r1, [r4, #104]	; 0x68
	if (bsi->cachedBits < 0) {
 800900c:	f57f ae6d 	bpl.w	8008cea <xmp3fixpt_UnpackSideInfo+0x1e2>
	if (nBytes >= 4) {
 8009010:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009012:	f1cc 0301 	rsb	r3, ip, #1
	if (nBytes >= 4) {
 8009016:	f300 8382 	bgt.w	800971e <xmp3fixpt_UnpackSideInfo+0xc16>
		while (nBytes--) {
 800901a:	2e00      	cmp	r6, #0
 800901c:	f000 85ed 	beq.w	8009bfa <xmp3fixpt_UnpackSideInfo+0x10f2>
			bsi->iCache |= (*bsi->bytePtr++);
 8009020:	7829      	ldrb	r1, [r5, #0]
		while (nBytes--) {
 8009022:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009024:	ea4f 2901 	mov.w	r9, r1, lsl #8
		while (nBytes--) {
 8009028:	f000 85cd 	beq.w	8009bc6 <xmp3fixpt_UnpackSideInfo+0x10be>
			bsi->iCache |= (*bsi->bytePtr++);
 800902c:	f895 8001 	ldrb.w	r8, [r5, #1]
 8009030:	78a9      	ldrb	r1, [r5, #2]
 8009032:	ea48 0809 	orr.w	r8, r8, r9
 8009036:	ea41 2808 	orr.w	r8, r1, r8, lsl #8
 800903a:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 800903e:	ea4f 2808 	mov.w	r8, r8, lsl #8
 8009042:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8009046:	fa08 f809 	lsl.w	r8, r8, r9
 800904a:	f10c 011f 	add.w	r1, ip, #31
			bsi->iCache |= (*bsi->bytePtr++);
 800904e:	3503      	adds	r5, #3
 8009050:	fa28 f101 	lsr.w	r1, r8, r1
 8009054:	fa08 f303 	lsl.w	r3, r8, r3
 8009058:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
		bsi->nBytes = 0;
 800905c:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800905e:	4308      	orrs	r0, r1
 8009060:	e643      	b.n	8008cea <xmp3fixpt_UnpackSideInfo+0x1e2>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 8009062:	2a02      	cmp	r2, #2
 8009064:	f000 83b2 	beq.w	80097cc <xmp3fixpt_UnpackSideInfo+0xcc4>
					sis->region0Count = 7;
 8009068:	2207      	movs	r2, #7
 800906a:	65e2      	str	r2, [r4, #92]	; 0x5c
 800906c:	220d      	movs	r2, #13
 800906e:	e628      	b.n	8008cc2 <xmp3fixpt_UnpackSideInfo+0x1ba>
	if (nBytes >= 4) {
 8009070:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009072:	f1c2 0300 	rsb	r3, r2, #0
	if (nBytes >= 4) {
 8009076:	f300 833a 	bgt.w	80096ee <xmp3fixpt_UnpackSideInfo+0xbe6>
		while (nBytes--) {
 800907a:	2e00      	cmp	r6, #0
 800907c:	f000 85b8 	beq.w	8009bf0 <xmp3fixpt_UnpackSideInfo+0x10e8>
			bsi->iCache |= (*bsi->bytePtr++);
 8009080:	f895 c000 	ldrb.w	ip, [r5]
		while (nBytes--) {
 8009084:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009086:	ea4f 210c 	mov.w	r1, ip, lsl #8
		while (nBytes--) {
 800908a:	f000 85d3 	beq.w	8009c34 <xmp3fixpt_UnpackSideInfo+0x112c>
			bsi->iCache |= (*bsi->bytePtr++);
 800908e:	f895 8001 	ldrb.w	r8, [r5, #1]
 8009092:	f895 c002 	ldrb.w	ip, [r5, #2]
 8009096:	ea48 0101 	orr.w	r1, r8, r1
 800909a:	ea4c 2101 	orr.w	r1, ip, r1, lsl #8
 800909e:	f1c6 0c03 	rsb	ip, r6, #3
 80090a2:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
			bsi->iCache <<= 8;
 80090a6:	0209      	lsls	r1, r1, #8
 80090a8:	fa01 f10c 	lsl.w	r1, r1, ip
 80090ac:	fa01 f303 	lsl.w	r3, r1, r3
 80090b0:	f102 0c20 	add.w	ip, r2, #32
 80090b4:	fa21 fc0c 	lsr.w	ip, r1, ip
			bsi->iCache |= (*bsi->bytePtr++);
 80090b8:	3503      	adds	r5, #3
 80090ba:	0fd9      	lsrs	r1, r3, #31
 80090bc:	005b      	lsls	r3, r3, #1
 80090be:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
		bsi->nBytes = 0;
 80090c2:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 80090c4:	ea40 000c 	orr.w	r0, r0, ip
	if (bsi->cachedBits < 0) {
 80090c8:	f1b2 0801 	subs.w	r8, r2, #1
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 80090cc:	6360      	str	r0, [r4, #52]	; 0x34
	if (bsi->cachedBits < 0) {
 80090ce:	f57f adaa 	bpl.w	8008c26 <xmp3fixpt_UnpackSideInfo+0x11e>
	if (nBytes >= 4) {
 80090d2:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 80090d4:	f1c2 0301 	rsb	r3, r2, #1
	if (nBytes >= 4) {
 80090d8:	f300 82d9 	bgt.w	800968e <xmp3fixpt_UnpackSideInfo+0xb86>
		while (nBytes--) {
 80090dc:	2e00      	cmp	r6, #0
 80090de:	f000 8564 	beq.w	8009baa <xmp3fixpt_UnpackSideInfo+0x10a2>
			bsi->iCache |= (*bsi->bytePtr++);
 80090e2:	7828      	ldrb	r0, [r5, #0]
		while (nBytes--) {
 80090e4:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 80090e6:	ea4f 2900 	mov.w	r9, r0, lsl #8
		while (nBytes--) {
 80090ea:	f000 8594 	beq.w	8009c16 <xmp3fixpt_UnpackSideInfo+0x110e>
			bsi->iCache |= (*bsi->bytePtr++);
 80090ee:	f895 c001 	ldrb.w	ip, [r5, #1]
 80090f2:	78a8      	ldrb	r0, [r5, #2]
 80090f4:	ea4c 0c09 	orr.w	ip, ip, r9
 80090f8:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
 80090fc:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 8009100:	0200      	lsls	r0, r0, #8
 8009102:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8009106:	fa00 f009 	lsl.w	r0, r0, r9
 800910a:	f102 0c1f 	add.w	ip, r2, #31
			bsi->iCache |= (*bsi->bytePtr++);
 800910e:	3503      	adds	r5, #3
 8009110:	fa20 fc0c 	lsr.w	ip, r0, ip
 8009114:	fa00 f303 	lsl.w	r3, r0, r3
 8009118:	eb08 08c6 	add.w	r8, r8, r6, lsl #3
		bsi->nBytes = 0;
 800911c:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800911e:	ea41 010c 	orr.w	r1, r1, ip
 8009122:	e580      	b.n	8008c26 <xmp3fixpt_UnpackSideInfo+0x11e>
	if (nBytes >= 4) {
 8009124:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009126:	f1c1 0309 	rsb	r3, r1, #9
	if (nBytes >= 4) {
 800912a:	f300 82c7 	bgt.w	80096bc <xmp3fixpt_UnpackSideInfo+0xbb4>
		while (nBytes--) {
 800912e:	2e00      	cmp	r6, #0
 8009130:	f000 857b 	beq.w	8009c2a <xmp3fixpt_UnpackSideInfo+0x1122>
			bsi->iCache |= (*bsi->bytePtr++);
 8009134:	782a      	ldrb	r2, [r5, #0]
		while (nBytes--) {
 8009136:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009138:	ea4f 2902 	mov.w	r9, r2, lsl #8
		while (nBytes--) {
 800913c:	f000 8587 	beq.w	8009c4e <xmp3fixpt_UnpackSideInfo+0x1146>
			bsi->iCache |= (*bsi->bytePtr++);
 8009140:	f895 8001 	ldrb.w	r8, [r5, #1]
 8009144:	78aa      	ldrb	r2, [r5, #2]
 8009146:	ea48 0809 	orr.w	r8, r8, r9
 800914a:	ea42 2208 	orr.w	r2, r2, r8, lsl #8
 800914e:	f1c6 0803 	rsb	r8, r6, #3
			bsi->iCache <<= 8;
 8009152:	0212      	lsls	r2, r2, #8
 8009154:	ea4f 0ac8 	mov.w	sl, r8, lsl #3
 8009158:	fa02 f80a 	lsl.w	r8, r2, sl
 800915c:	fa08 f303 	lsl.w	r3, r8, r3
 8009160:	3117      	adds	r1, #23
 8009162:	fa28 f801 	lsr.w	r8, r8, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009166:	3503      	adds	r5, #3
 8009168:	0e19      	lsrs	r1, r3, #24
 800916a:	021b      	lsls	r3, r3, #8
 800916c:	eb0c 0cc6 	add.w	ip, ip, r6, lsl #3
		bsi->nBytes = 0;
 8009170:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009172:	ea40 0008 	orr.w	r0, r0, r8
	if (bsi->cachedBits < 0) {
 8009176:	f1bc 0208 	subs.w	r2, ip, #8
			sis->nBigvals =        GetBits(bsi, 9);
 800917a:	62e0      	str	r0, [r4, #44]	; 0x2c
	if (bsi->cachedBits < 0) {
 800917c:	f57f ad3e 	bpl.w	8008bfc <xmp3fixpt_UnpackSideInfo+0xf4>
	if (nBytes >= 4) {
 8009180:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009182:	f1cc 0808 	rsb	r8, ip, #8
	if (nBytes >= 4) {
 8009186:	f300 830f 	bgt.w	80097a8 <xmp3fixpt_UnpackSideInfo+0xca0>
		while (nBytes--) {
 800918a:	2e00      	cmp	r6, #0
 800918c:	f000 8509 	beq.w	8009ba2 <xmp3fixpt_UnpackSideInfo+0x109a>
			bsi->iCache |= (*bsi->bytePtr++);
 8009190:	782b      	ldrb	r3, [r5, #0]
		while (nBytes--) {
 8009192:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009194:	ea4f 2903 	mov.w	r9, r3, lsl #8
		while (nBytes--) {
 8009198:	f000 850b 	beq.w	8009bb2 <xmp3fixpt_UnpackSideInfo+0x10aa>
			bsi->iCache |= (*bsi->bytePtr++);
 800919c:	7868      	ldrb	r0, [r5, #1]
 800919e:	78ab      	ldrb	r3, [r5, #2]
 80091a0:	ea40 0009 	orr.w	r0, r0, r9
 80091a4:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80091a8:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 80091ac:	021b      	lsls	r3, r3, #8
 80091ae:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 80091b2:	fa03 f309 	lsl.w	r3, r3, r9
 80091b6:	f10c 0018 	add.w	r0, ip, #24
 80091ba:	fa23 f000 	lsr.w	r0, r3, r0
			bsi->iCache |= (*bsi->bytePtr++);
 80091be:	3503      	adds	r5, #3
 80091c0:	fa03 f308 	lsl.w	r3, r3, r8
 80091c4:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
		bsi->nBytes = 0;
 80091c8:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 80091ca:	4301      	orrs	r1, r0
 80091cc:	e516      	b.n	8008bfc <xmp3fixpt_UnpackSideInfo+0xf4>
	if (nBytes >= 4) {
 80091ce:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 80091d0:	f1c2 030c 	rsb	r3, r2, #12
	if (nBytes >= 4) {
 80091d4:	f300 82b7 	bgt.w	8009746 <xmp3fixpt_UnpackSideInfo+0xc3e>
		while (nBytes--) {
 80091d8:	2e00      	cmp	r6, #0
 80091da:	f000 8512 	beq.w	8009c02 <xmp3fixpt_UnpackSideInfo+0x10fa>
			bsi->iCache |= (*bsi->bytePtr++);
 80091de:	7828      	ldrb	r0, [r5, #0]
		while (nBytes--) {
 80091e0:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 80091e2:	ea4f 2900 	mov.w	r9, r0, lsl #8
		while (nBytes--) {
 80091e6:	f000 84f8 	beq.w	8009bda <xmp3fixpt_UnpackSideInfo+0x10d2>
			bsi->iCache |= (*bsi->bytePtr++);
 80091ea:	f895 8001 	ldrb.w	r8, [r5, #1]
 80091ee:	78a8      	ldrb	r0, [r5, #2]
 80091f0:	ea48 0809 	orr.w	r8, r8, r9
 80091f4:	ea40 2008 	orr.w	r0, r0, r8, lsl #8
 80091f8:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 80091fc:	0200      	lsls	r0, r0, #8
 80091fe:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8009202:	fa00 f909 	lsl.w	r9, r0, r9
 8009206:	fa09 f303 	lsl.w	r3, r9, r3
 800920a:	3214      	adds	r2, #20
 800920c:	0dd8      	lsrs	r0, r3, #23
			bsi->iCache |= (*bsi->bytePtr++);
 800920e:	3503      	adds	r5, #3
 8009210:	fa29 f902 	lsr.w	r9, r9, r2
 8009214:	025b      	lsls	r3, r3, #9
 8009216:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
		bsi->nBytes = 0;
 800921a:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800921c:	ea4c 0c09 	orr.w	ip, ip, r9
 8009220:	e4dd      	b.n	8008bde <xmp3fixpt_UnpackSideInfo+0xd6>
	if (nBytes >= 4) {
 8009222:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009224:	f1c1 0303 	rsb	r3, r1, #3
	if (nBytes >= 4) {
 8009228:	f300 830a 	bgt.w	8009840 <xmp3fixpt_UnpackSideInfo+0xd38>
		while (nBytes--) {
 800922c:	2e00      	cmp	r6, #0
 800922e:	f000 8519 	beq.w	8009c64 <xmp3fixpt_UnpackSideInfo+0x115c>
			bsi->iCache |= (*bsi->bytePtr++);
 8009232:	f895 9000 	ldrb.w	r9, [r5]
		while (nBytes--) {
 8009236:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009238:	ea4f 2b09 	mov.w	fp, r9, lsl #8
		while (nBytes--) {
 800923c:	f000 85d0 	beq.w	8009de0 <xmp3fixpt_UnpackSideInfo+0x12d8>
			bsi->iCache |= (*bsi->bytePtr++);
 8009240:	f895 9001 	ldrb.w	r9, [r5, #1]
 8009244:	f895 a002 	ldrb.w	sl, [r5, #2]
 8009248:	ea49 090b 	orr.w	r9, r9, fp
 800924c:	ea4a 2a09 	orr.w	sl, sl, r9, lsl #8
 8009250:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 8009254:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 8009258:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800925c:	fa0a f909 	lsl.w	r9, sl, r9
 8009260:	fa09 f303 	lsl.w	r3, r9, r3
 8009264:	311d      	adds	r1, #29
 8009266:	fa29 f901 	lsr.w	r9, r9, r1
			bsi->iCache |= (*bsi->bytePtr++);
 800926a:	3503      	adds	r5, #3
 800926c:	0fd9      	lsrs	r1, r3, #31
 800926e:	005b      	lsls	r3, r3, #1
 8009270:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
		bsi->nBytes = 0;
 8009274:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009276:	ea48 0809 	orr.w	r8, r8, r9
 800927a:	e517      	b.n	8008cac <xmp3fixpt_UnpackSideInfo+0x1a4>
	if (nBytes >= 4) {
 800927c:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 800927e:	f1c0 0301 	rsb	r3, r0, #1
	if (nBytes >= 4) {
 8009282:	f300 82f6 	bgt.w	8009872 <xmp3fixpt_UnpackSideInfo+0xd6a>
		while (nBytes--) {
 8009286:	2e00      	cmp	r6, #0
 8009288:	f000 85a5 	beq.w	8009dd6 <xmp3fixpt_UnpackSideInfo+0x12ce>
			bsi->iCache |= (*bsi->bytePtr++);
 800928c:	f895 8000 	ldrb.w	r8, [r5]
		while (nBytes--) {
 8009290:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009292:	ea4f 2a08 	mov.w	sl, r8, lsl #8
		while (nBytes--) {
 8009296:	f000 8591 	beq.w	8009dbc <xmp3fixpt_UnpackSideInfo+0x12b4>
			bsi->iCache |= (*bsi->bytePtr++);
 800929a:	f895 8001 	ldrb.w	r8, [r5, #1]
 800929e:	f895 9002 	ldrb.w	r9, [r5, #2]
 80092a2:	ea48 080a 	orr.w	r8, r8, sl
 80092a6:	ea49 2908 	orr.w	r9, r9, r8, lsl #8
 80092aa:	f1c6 0803 	rsb	r8, r6, #3
			bsi->iCache <<= 8;
 80092ae:	ea4f 2909 	mov.w	r9, r9, lsl #8
 80092b2:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 80092b6:	fa09 f808 	lsl.w	r8, r9, r8
 80092ba:	fa08 f303 	lsl.w	r3, r8, r3
 80092be:	301f      	adds	r0, #31
 80092c0:	fa28 f900 	lsr.w	r9, r8, r0
			bsi->iCache |= (*bsi->bytePtr++);
 80092c4:	3503      	adds	r5, #3
 80092c6:	ea4f 68d3 	mov.w	r8, r3, lsr #27
 80092ca:	015b      	lsls	r3, r3, #5
 80092cc:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
		bsi->nBytes = 0;
 80092d0:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 80092d2:	ea4c 0c09 	orr.w	ip, ip, r9
	if (bsi->cachedBits < 0) {
 80092d6:	1f48      	subs	r0, r1, #5
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 80092d8:	f8c4 c040 	str.w	ip, [r4, #64]	; 0x40
	if (bsi->cachedBits < 0) {
 80092dc:	f57f acbf 	bpl.w	8008c5e <xmp3fixpt_UnpackSideInfo+0x156>
	if (nBytes >= 4) {
 80092e0:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 80092e2:	f1c1 0305 	rsb	r3, r1, #5
	if (nBytes >= 4) {
 80092e6:	f300 835d 	bgt.w	80099a4 <xmp3fixpt_UnpackSideInfo+0xe9c>
		while (nBytes--) {
 80092ea:	2e00      	cmp	r6, #0
 80092ec:	f000 84db 	beq.w	8009ca6 <xmp3fixpt_UnpackSideInfo+0x119e>
			bsi->iCache |= (*bsi->bytePtr++);
 80092f0:	f895 9000 	ldrb.w	r9, [r5]
		while (nBytes--) {
 80092f4:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 80092f6:	ea4f 2b09 	mov.w	fp, r9, lsl #8
		while (nBytes--) {
 80092fa:	f000 84c7 	beq.w	8009c8c <xmp3fixpt_UnpackSideInfo+0x1184>
			bsi->iCache |= (*bsi->bytePtr++);
 80092fe:	f895 9001 	ldrb.w	r9, [r5, #1]
 8009302:	f895 a002 	ldrb.w	sl, [r5, #2]
 8009306:	ea49 090b 	orr.w	r9, r9, fp
 800930a:	ea4a 2a09 	orr.w	sl, sl, r9, lsl #8
 800930e:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 8009312:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 8009316:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800931a:	fa0a f909 	lsl.w	r9, sl, r9
 800931e:	fa09 f303 	lsl.w	r3, r9, r3
 8009322:	311b      	adds	r1, #27
 8009324:	fa29 fa01 	lsr.w	sl, r9, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009328:	3503      	adds	r5, #3
 800932a:	ea4f 69d3 	mov.w	r9, r3, lsr #27
 800932e:	015b      	lsls	r3, r3, #5
 8009330:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
		bsi->nBytes = 0;
 8009334:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009336:	ea48 080a 	orr.w	r8, r8, sl
	if (bsi->cachedBits < 0) {
 800933a:	1f41      	subs	r1, r0, #5
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800933c:	f8c4 8044 	str.w	r8, [r4, #68]	; 0x44
	if (bsi->cachedBits < 0) {
 8009340:	f57f ac96 	bpl.w	8008c70 <xmp3fixpt_UnpackSideInfo+0x168>
	if (nBytes >= 4) {
 8009344:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009346:	f1c0 0305 	rsb	r3, r0, #5
	if (nBytes >= 4) {
 800934a:	f300 8311 	bgt.w	8009970 <xmp3fixpt_UnpackSideInfo+0xe68>
		while (nBytes--) {
 800934e:	2e00      	cmp	r6, #0
 8009350:	f000 84eb 	beq.w	8009d2a <xmp3fixpt_UnpackSideInfo+0x1222>
			bsi->iCache |= (*bsi->bytePtr++);
 8009354:	f895 8000 	ldrb.w	r8, [r5]
		while (nBytes--) {
 8009358:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 800935a:	ea4f 2b08 	mov.w	fp, r8, lsl #8
		while (nBytes--) {
 800935e:	f000 84d7 	beq.w	8009d10 <xmp3fixpt_UnpackSideInfo+0x1208>
			bsi->iCache |= (*bsi->bytePtr++);
 8009362:	f895 8001 	ldrb.w	r8, [r5, #1]
 8009366:	f895 a002 	ldrb.w	sl, [r5, #2]
 800936a:	ea48 080b 	orr.w	r8, r8, fp
 800936e:	ea4a 2a08 	orr.w	sl, sl, r8, lsl #8
 8009372:	f1c6 0803 	rsb	r8, r6, #3
			bsi->iCache <<= 8;
 8009376:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 800937a:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800937e:	fa0a f808 	lsl.w	r8, sl, r8
 8009382:	fa08 f303 	lsl.w	r3, r8, r3
 8009386:	301b      	adds	r0, #27
 8009388:	fa28 fa00 	lsr.w	sl, r8, r0
			bsi->iCache |= (*bsi->bytePtr++);
 800938c:	3503      	adds	r5, #3
 800938e:	ea4f 7853 	mov.w	r8, r3, lsr #29
 8009392:	00db      	lsls	r3, r3, #3
 8009394:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
		bsi->nBytes = 0;
 8009398:	2600      	movs	r6, #0
				sis->tableSelect[2] =  0;					/* unused */
 800939a:	2000      	movs	r0, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800939c:	ea49 090a 	orr.w	r9, r9, sl
				sis->tableSelect[2] =  0;					/* unused */
 80093a0:	64e0      	str	r0, [r4, #76]	; 0x4c
	if (bsi->cachedBits < 0) {
 80093a2:	1ec8      	subs	r0, r1, #3
				sis->tableSelect[1] =  GetBits(bsi, 5);
 80093a4:	f8c4 9048 	str.w	r9, [r4, #72]	; 0x48
	if (bsi->cachedBits < 0) {
 80093a8:	f57f ac6d 	bpl.w	8008c86 <xmp3fixpt_UnpackSideInfo+0x17e>
	if (nBytes >= 4) {
 80093ac:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 80093ae:	f1c1 0303 	rsb	r3, r1, #3
	if (nBytes >= 4) {
 80093b2:	f300 82c3 	bgt.w	800993c <xmp3fixpt_UnpackSideInfo+0xe34>
		while (nBytes--) {
 80093b6:	2e00      	cmp	r6, #0
 80093b8:	f000 8496 	beq.w	8009ce8 <xmp3fixpt_UnpackSideInfo+0x11e0>
			bsi->iCache |= (*bsi->bytePtr++);
 80093bc:	f895 9000 	ldrb.w	r9, [r5]
		while (nBytes--) {
 80093c0:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 80093c2:	ea4f 2b09 	mov.w	fp, r9, lsl #8
		while (nBytes--) {
 80093c6:	f000 8482 	beq.w	8009cce <xmp3fixpt_UnpackSideInfo+0x11c6>
			bsi->iCache |= (*bsi->bytePtr++);
 80093ca:	f895 9001 	ldrb.w	r9, [r5, #1]
 80093ce:	f895 a002 	ldrb.w	sl, [r5, #2]
 80093d2:	ea49 090b 	orr.w	r9, r9, fp
 80093d6:	ea4a 2a09 	orr.w	sl, sl, r9, lsl #8
 80093da:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 80093de:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 80093e2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 80093e6:	fa0a f909 	lsl.w	r9, sl, r9
 80093ea:	fa09 f303 	lsl.w	r3, r9, r3
 80093ee:	311d      	adds	r1, #29
 80093f0:	fa29 fa01 	lsr.w	sl, r9, r1
			bsi->iCache |= (*bsi->bytePtr++);
 80093f4:	3503      	adds	r5, #3
 80093f6:	ea4f 7953 	mov.w	r9, r3, lsr #29
 80093fa:	00db      	lsls	r3, r3, #3
 80093fc:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
		bsi->nBytes = 0;
 8009400:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009402:	ea48 080a 	orr.w	r8, r8, sl
	if (bsi->cachedBits < 0) {
 8009406:	1ec1      	subs	r1, r0, #3
				sis->subBlockGain[0] = GetBits(bsi, 3);
 8009408:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
	if (bsi->cachedBits < 0) {
 800940c:	f57f ac44 	bpl.w	8008c98 <xmp3fixpt_UnpackSideInfo+0x190>
	if (nBytes >= 4) {
 8009410:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009412:	f1c0 0303 	rsb	r3, r0, #3
	if (nBytes >= 4) {
 8009416:	f300 825e 	bgt.w	80098d6 <xmp3fixpt_UnpackSideInfo+0xdce>
		while (nBytes--) {
 800941a:	2e00      	cmp	r6, #0
 800941c:	f000 84a5 	beq.w	8009d6a <xmp3fixpt_UnpackSideInfo+0x1262>
			bsi->iCache |= (*bsi->bytePtr++);
 8009420:	f895 8000 	ldrb.w	r8, [r5]
		while (nBytes--) {
 8009424:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009426:	ea4f 2b08 	mov.w	fp, r8, lsl #8
		while (nBytes--) {
 800942a:	f000 8491 	beq.w	8009d50 <xmp3fixpt_UnpackSideInfo+0x1248>
			bsi->iCache |= (*bsi->bytePtr++);
 800942e:	f895 8001 	ldrb.w	r8, [r5, #1]
 8009432:	f895 a002 	ldrb.w	sl, [r5, #2]
 8009436:	ea48 080b 	orr.w	r8, r8, fp
 800943a:	ea4a 2a08 	orr.w	sl, sl, r8, lsl #8
 800943e:	f1c6 0803 	rsb	r8, r6, #3
			bsi->iCache <<= 8;
 8009442:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 8009446:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800944a:	fa0a f808 	lsl.w	r8, sl, r8
 800944e:	fa08 f303 	lsl.w	r3, r8, r3
 8009452:	301d      	adds	r0, #29
 8009454:	fa28 fa00 	lsr.w	sl, r8, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009458:	3503      	adds	r5, #3
 800945a:	ea4f 7853 	mov.w	r8, r3, lsr #29
 800945e:	00db      	lsls	r3, r3, #3
 8009460:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
		bsi->nBytes = 0;
 8009464:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009466:	ea49 090a 	orr.w	r9, r9, sl
 800946a:	e418      	b.n	8008c9e <xmp3fixpt_UnpackSideInfo+0x196>
	if (nBytes >= 4) {
 800946c:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 800946e:	f1c8 0302 	rsb	r3, r8, #2
	if (nBytes >= 4) {
 8009472:	f300 824a 	bgt.w	800990a <xmp3fixpt_UnpackSideInfo+0xe02>
		while (nBytes--) {
 8009476:	2e00      	cmp	r6, #0
 8009478:	f000 849b 	beq.w	8009db2 <xmp3fixpt_UnpackSideInfo+0x12aa>
			bsi->iCache |= (*bsi->bytePtr++);
 800947c:	7829      	ldrb	r1, [r5, #0]
		while (nBytes--) {
 800947e:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009480:	ea4f 2901 	mov.w	r9, r1, lsl #8
		while (nBytes--) {
 8009484:	f000 8488 	beq.w	8009d98 <xmp3fixpt_UnpackSideInfo+0x1290>
			bsi->iCache |= (*bsi->bytePtr++);
 8009488:	f895 c001 	ldrb.w	ip, [r5, #1]
 800948c:	78a9      	ldrb	r1, [r5, #2]
 800948e:	ea4c 0c09 	orr.w	ip, ip, r9
 8009492:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
 8009496:	f1c6 0903 	rsb	r9, r6, #3
			bsi->iCache <<= 8;
 800949a:	0209      	lsls	r1, r1, #8
 800949c:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 80094a0:	fa01 f909 	lsl.w	r9, r1, r9
 80094a4:	fa09 f303 	lsl.w	r3, r9, r3
 80094a8:	f108 081e 	add.w	r8, r8, #30
 80094ac:	ea4f 7cd3 	mov.w	ip, r3, lsr #31
			bsi->iCache |= (*bsi->bytePtr++);
 80094b0:	3503      	adds	r5, #3
 80094b2:	fa29 f908 	lsr.w	r9, r9, r8
 80094b6:	005b      	lsls	r3, r3, #1
 80094b8:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
		bsi->nBytes = 0;
 80094bc:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 80094be:	ea42 0209 	orr.w	r2, r2, r9
 80094c2:	f7ff bbbf 	b.w	8008c44 <xmp3fixpt_UnpackSideInfo+0x13c>
	if (nBytes >= 4) {
 80094c6:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 80094c8:	f1c1 0304 	rsb	r3, r1, #4
	if (nBytes >= 4) {
 80094cc:	f300 8284 	bgt.w	80099d8 <xmp3fixpt_UnpackSideInfo+0xed0>
		while (nBytes--) {
 80094d0:	2e00      	cmp	r6, #0
 80094d2:	f000 845c 	beq.w	8009d8e <xmp3fixpt_UnpackSideInfo+0x1286>
			bsi->iCache |= (*bsi->bytePtr++);
 80094d6:	f895 c000 	ldrb.w	ip, [r5]
		while (nBytes--) {
 80094da:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 80094dc:	ea4f 290c 	mov.w	r9, ip, lsl #8
		while (nBytes--) {
 80094e0:	f000 8448 	beq.w	8009d74 <xmp3fixpt_UnpackSideInfo+0x126c>
			bsi->iCache |= (*bsi->bytePtr++);
 80094e4:	f895 8001 	ldrb.w	r8, [r5, #1]
 80094e8:	f895 c002 	ldrb.w	ip, [r5, #2]
 80094ec:	ea48 0909 	orr.w	r9, r8, r9
 80094f0:	ea4c 2909 	orr.w	r9, ip, r9, lsl #8
 80094f4:	f1c6 0c03 	rsb	ip, r6, #3
			bsi->iCache <<= 8;
 80094f8:	ea4f 2909 	mov.w	r9, r9, lsl #8
 80094fc:	ea4f 08cc 	mov.w	r8, ip, lsl #3
 8009500:	fa09 fc08 	lsl.w	ip, r9, r8
 8009504:	fa0c f303 	lsl.w	r3, ip, r3
 8009508:	311c      	adds	r1, #28
 800950a:	fa2c f101 	lsr.w	r1, ip, r1
			bsi->iCache |= (*bsi->bytePtr++);
 800950e:	3503      	adds	r5, #3
 8009510:	ea4f 7c53 	mov.w	ip, r3, lsr #29
 8009514:	00db      	lsls	r3, r3, #3
 8009516:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
		bsi->nBytes = 0;
 800951a:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800951c:	4308      	orrs	r0, r1
				sis->region0Count =    GetBits(bsi, 4);
 800951e:	65e0      	str	r0, [r4, #92]	; 0x5c
	if (bsi->cachedBits < 0) {
 8009520:	1ed0      	subs	r0, r2, #3
 8009522:	f57f ad2f 	bpl.w	8008f84 <xmp3fixpt_UnpackSideInfo+0x47c>
	if (nBytes >= 4) {
 8009526:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009528:	f1c2 0303 	rsb	r3, r2, #3
	if (nBytes >= 4) {
 800952c:	f300 8287 	bgt.w	8009a3e <xmp3fixpt_UnpackSideInfo+0xf36>
		while (nBytes--) {
 8009530:	2e00      	cmp	r6, #0
 8009532:	f000 8409 	beq.w	8009d48 <xmp3fixpt_UnpackSideInfo+0x1240>
			bsi->iCache |= (*bsi->bytePtr++);
 8009536:	7829      	ldrb	r1, [r5, #0]
		while (nBytes--) {
 8009538:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 800953a:	ea4f 2901 	mov.w	r9, r1, lsl #8
		while (nBytes--) {
 800953e:	f000 83f9 	beq.w	8009d34 <xmp3fixpt_UnpackSideInfo+0x122c>
			bsi->iCache |= (*bsi->bytePtr++);
 8009542:	f895 8001 	ldrb.w	r8, [r5, #1]
 8009546:	78a9      	ldrb	r1, [r5, #2]
 8009548:	ea48 0909 	orr.w	r9, r8, r9
 800954c:	ea41 2909 	orr.w	r9, r1, r9, lsl #8
 8009550:	f1c6 0103 	rsb	r1, r6, #3
			bsi->iCache <<= 8;
 8009554:	ea4f 2909 	mov.w	r9, r9, lsl #8
 8009558:	ea4f 08c1 	mov.w	r8, r1, lsl #3
 800955c:	fa09 f108 	lsl.w	r1, r9, r8
 8009560:	fa01 f303 	lsl.w	r3, r1, r3
 8009564:	321d      	adds	r2, #29
 8009566:	fa21 f202 	lsr.w	r2, r1, r2
			bsi->iCache |= (*bsi->bytePtr++);
 800956a:	3503      	adds	r5, #3
 800956c:	0fd9      	lsrs	r1, r3, #31
 800956e:	005b      	lsls	r3, r3, #1
 8009570:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
		bsi->nBytes = 0;
 8009574:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009576:	ea4c 0c02 	orr.w	ip, ip, r2
 800957a:	e505      	b.n	8008f88 <xmp3fixpt_UnpackSideInfo+0x480>
	if (nBytes >= 4) {
 800957c:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 800957e:	f1c2 0305 	rsb	r3, r2, #5
	if (nBytes >= 4) {
 8009582:	f300 8243 	bgt.w	8009a0c <xmp3fixpt_UnpackSideInfo+0xf04>
		while (nBytes--) {
 8009586:	2e00      	cmp	r6, #0
 8009588:	f000 83be 	beq.w	8009d08 <xmp3fixpt_UnpackSideInfo+0x1200>
			bsi->iCache |= (*bsi->bytePtr++);
 800958c:	f895 c000 	ldrb.w	ip, [r5]
		while (nBytes--) {
 8009590:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 8009592:	ea4f 290c 	mov.w	r9, ip, lsl #8
		while (nBytes--) {
 8009596:	f000 83ac 	beq.w	8009cf2 <xmp3fixpt_UnpackSideInfo+0x11ea>
			bsi->iCache |= (*bsi->bytePtr++);
 800959a:	f895 8001 	ldrb.w	r8, [r5, #1]
 800959e:	f895 c002 	ldrb.w	ip, [r5, #2]
 80095a2:	ea48 0909 	orr.w	r9, r8, r9
 80095a6:	ea4c 2909 	orr.w	r9, ip, r9, lsl #8
 80095aa:	f1c6 0c03 	rsb	ip, r6, #3
			bsi->iCache <<= 8;
 80095ae:	ea4f 2909 	mov.w	r9, r9, lsl #8
 80095b2:	ea4f 08cc 	mov.w	r8, ip, lsl #3
 80095b6:	fa09 fc08 	lsl.w	ip, r9, r8
 80095ba:	fa0c f303 	lsl.w	r3, ip, r3
 80095be:	321b      	adds	r2, #27
 80095c0:	fa2c fc02 	lsr.w	ip, ip, r2
			bsi->iCache |= (*bsi->bytePtr++);
 80095c4:	3503      	adds	r5, #3
 80095c6:	0eda      	lsrs	r2, r3, #27
 80095c8:	015b      	lsls	r3, r3, #5
 80095ca:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
		bsi->nBytes = 0;
 80095ce:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 80095d0:	ea41 010c 	orr.w	r1, r1, ip
				sis->tableSelect[1] =  GetBits(bsi, 5);
 80095d4:	64a1      	str	r1, [r4, #72]	; 0x48
	if (bsi->cachedBits < 0) {
 80095d6:	1f41      	subs	r1, r0, #5
 80095d8:	f57f acc6 	bpl.w	8008f68 <xmp3fixpt_UnpackSideInfo+0x460>
	if (nBytes >= 4) {
 80095dc:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 80095de:	f1c0 0305 	rsb	r3, r0, #5
	if (nBytes >= 4) {
 80095e2:	f300 8243 	bgt.w	8009a6c <xmp3fixpt_UnpackSideInfo+0xf64>
		while (nBytes--) {
 80095e6:	2e00      	cmp	r6, #0
 80095e8:	f000 836d 	beq.w	8009cc6 <xmp3fixpt_UnpackSideInfo+0x11be>
			bsi->iCache |= (*bsi->bytePtr++);
 80095ec:	f895 c000 	ldrb.w	ip, [r5]
		while (nBytes--) {
 80095f0:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 80095f2:	ea4f 290c 	mov.w	r9, ip, lsl #8
		while (nBytes--) {
 80095f6:	f000 835b 	beq.w	8009cb0 <xmp3fixpt_UnpackSideInfo+0x11a8>
			bsi->iCache |= (*bsi->bytePtr++);
 80095fa:	f895 8001 	ldrb.w	r8, [r5, #1]
 80095fe:	f895 c002 	ldrb.w	ip, [r5, #2]
 8009602:	ea48 0909 	orr.w	r9, r8, r9
 8009606:	ea4c 2909 	orr.w	r9, ip, r9, lsl #8
 800960a:	f1c6 0c03 	rsb	ip, r6, #3
			bsi->iCache <<= 8;
 800960e:	ea4f 2909 	mov.w	r9, r9, lsl #8
 8009612:	ea4f 08cc 	mov.w	r8, ip, lsl #3
 8009616:	fa09 fc08 	lsl.w	ip, r9, r8
 800961a:	fa0c f303 	lsl.w	r3, ip, r3
 800961e:	301b      	adds	r0, #27
 8009620:	fa2c fc00 	lsr.w	ip, ip, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009624:	3503      	adds	r5, #3
 8009626:	0f18      	lsrs	r0, r3, #28
 8009628:	011b      	lsls	r3, r3, #4
 800962a:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
		bsi->nBytes = 0;
 800962e:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009630:	ea42 020c 	orr.w	r2, r2, ip
 8009634:	e49a      	b.n	8008f6c <xmp3fixpt_UnpackSideInfo+0x464>
	if (nBytes >= 4) {
 8009636:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 8009638:	f1c8 0305 	rsb	r3, r8, #5
	if (nBytes >= 4) {
 800963c:	f300 8133 	bgt.w	80098a6 <xmp3fixpt_UnpackSideInfo+0xd9e>
		while (nBytes--) {
 8009640:	2e00      	cmp	r6, #0
 8009642:	f000 831f 	beq.w	8009c84 <xmp3fixpt_UnpackSideInfo+0x117c>
			bsi->iCache |= (*bsi->bytePtr++);
 8009646:	7829      	ldrb	r1, [r5, #0]
		while (nBytes--) {
 8009648:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 800964a:	ea4f 2901 	mov.w	r9, r1, lsl #8
		while (nBytes--) {
 800964e:	f000 830e 	beq.w	8009c6e <xmp3fixpt_UnpackSideInfo+0x1166>
			bsi->iCache |= (*bsi->bytePtr++);
 8009652:	f895 c001 	ldrb.w	ip, [r5, #1]
 8009656:	78a9      	ldrb	r1, [r5, #2]
 8009658:	ea4c 0909 	orr.w	r9, ip, r9
 800965c:	ea41 2109 	orr.w	r1, r1, r9, lsl #8
 8009660:	f1c6 0c03 	rsb	ip, r6, #3
 8009664:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
			bsi->iCache <<= 8;
 8009668:	ea4f 2901 	mov.w	r9, r1, lsl #8
 800966c:	fa09 f10c 	lsl.w	r1, r9, ip
 8009670:	fa01 f303 	lsl.w	r3, r1, r3
 8009674:	f108 081b 	add.w	r8, r8, #27
 8009678:	fa21 fc08 	lsr.w	ip, r1, r8
			bsi->iCache |= (*bsi->bytePtr++);
 800967c:	3503      	adds	r5, #3
 800967e:	0ed9      	lsrs	r1, r3, #27
 8009680:	015b      	lsls	r3, r3, #5
 8009682:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
		bsi->nBytes = 0;
 8009686:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009688:	ea40 000c 	orr.w	r0, r0, ip
 800968c:	e460      	b.n	8008f50 <xmp3fixpt_UnpackSideInfo+0x448>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800968e:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009692:	7828      	ldrb	r0, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8009694:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009698:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800969c:	ea4c 6c00 	orr.w	ip, ip, r0, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80096a0:	78a8      	ldrb	r0, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 80096a2:	ea4c 0c08 	orr.w	ip, ip, r8
 80096a6:	ea4c 2c00 	orr.w	ip, ip, r0, lsl #8
 80096aa:	f102 081f 	add.w	r8, r2, #31
 80096ae:	fa0c f303 	lsl.w	r3, ip, r3
		bsi->nBytes -= 4;
 80096b2:	3e04      	subs	r6, #4
 80096b4:	fa2c fc08 	lsr.w	ip, ip, r8
		bsi->iCache |= (*bsi->bytePtr++);
 80096b8:	3504      	adds	r5, #4
 80096ba:	e530      	b.n	800911e <xmp3fixpt_UnpackSideInfo+0x616>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80096bc:	f895 8001 	ldrb.w	r8, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80096c0:	782a      	ldrb	r2, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 80096c2:	f895 c003 	ldrb.w	ip, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80096c6:	ea4f 4808 	mov.w	r8, r8, lsl #16
 80096ca:	ea48 6802 	orr.w	r8, r8, r2, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80096ce:	78aa      	ldrb	r2, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 80096d0:	ea48 080c 	orr.w	r8, r8, ip
 80096d4:	ea48 2802 	orr.w	r8, r8, r2, lsl #8
 80096d8:	fa08 f303 	lsl.w	r3, r8, r3
 80096dc:	f101 0c17 	add.w	ip, r1, #23
		bsi->nBytes -= 4;
 80096e0:	3e04      	subs	r6, #4
 80096e2:	0e19      	lsrs	r1, r3, #24
 80096e4:	fa28 f80c 	lsr.w	r8, r8, ip
		bsi->iCache |= (*bsi->bytePtr++);
 80096e8:	3504      	adds	r5, #4
 80096ea:	021b      	lsls	r3, r3, #8
 80096ec:	e541      	b.n	8009172 <xmp3fixpt_UnpackSideInfo+0x66a>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80096ee:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80096f2:	7829      	ldrb	r1, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 80096f4:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80096f8:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80096fc:	ea4c 6c01 	orr.w	ip, ip, r1, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009700:	78a9      	ldrb	r1, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009702:	ea4c 0c08 	orr.w	ip, ip, r8
 8009706:	ea4c 2c01 	orr.w	ip, ip, r1, lsl #8
 800970a:	fa0c f303 	lsl.w	r3, ip, r3
 800970e:	3220      	adds	r2, #32
 8009710:	0fd9      	lsrs	r1, r3, #31
		bsi->nBytes -= 4;
 8009712:	3e04      	subs	r6, #4
 8009714:	fa2c fc02 	lsr.w	ip, ip, r2
		bsi->iCache |= (*bsi->bytePtr++);
 8009718:	3504      	adds	r5, #4
 800971a:	005b      	lsls	r3, r3, #1
 800971c:	e4d2      	b.n	80090c4 <xmp3fixpt_UnpackSideInfo+0x5bc>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800971e:	7869      	ldrb	r1, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009720:	f895 8000 	ldrb.w	r8, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 8009724:	78ea      	ldrb	r2, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009726:	0409      	lsls	r1, r1, #16
 8009728:	ea41 6108 	orr.w	r1, r1, r8, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800972c:	f895 8002 	ldrb.w	r8, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009730:	4311      	orrs	r1, r2
 8009732:	ea41 2108 	orr.w	r1, r1, r8, lsl #8
 8009736:	f10c 021f 	add.w	r2, ip, #31
 800973a:	fa01 f303 	lsl.w	r3, r1, r3
		bsi->nBytes -= 4;
 800973e:	3e04      	subs	r6, #4
 8009740:	40d1      	lsrs	r1, r2
		bsi->iCache |= (*bsi->bytePtr++);
 8009742:	3504      	adds	r5, #4
 8009744:	e48b      	b.n	800905e <xmp3fixpt_UnpackSideInfo+0x556>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009746:	f895 9001 	ldrb.w	r9, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800974a:	7829      	ldrb	r1, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 800974c:	78e8      	ldrb	r0, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800974e:	ea4f 4909 	mov.w	r9, r9, lsl #16
 8009752:	ea49 6901 	orr.w	r9, r9, r1, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009756:	78a9      	ldrb	r1, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009758:	ea49 0900 	orr.w	r9, r9, r0
 800975c:	ea49 2901 	orr.w	r9, r9, r1, lsl #8
 8009760:	fa09 f303 	lsl.w	r3, r9, r3
 8009764:	f102 0114 	add.w	r1, r2, #20
 8009768:	0dd8      	lsrs	r0, r3, #23
		bsi->nBytes -= 4;
 800976a:	3e04      	subs	r6, #4
 800976c:	fa29 f901 	lsr.w	r9, r9, r1
		bsi->iCache |= (*bsi->bytePtr++);
 8009770:	3504      	adds	r5, #4
 8009772:	025b      	lsls	r3, r3, #9
 8009774:	e552      	b.n	800921c <xmp3fixpt_UnpackSideInfo+0x714>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009776:	f895 8001 	ldrb.w	r8, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800977a:	782a      	ldrb	r2, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 800977c:	f895 c003 	ldrb.w	ip, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009780:	ea4f 4808 	mov.w	r8, r8, lsl #16
 8009784:	ea48 6802 	orr.w	r8, r8, r2, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009788:	78aa      	ldrb	r2, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 800978a:	ea48 080c 	orr.w	r8, r8, ip
 800978e:	ea48 2802 	orr.w	r8, r8, r2, lsl #8
 8009792:	fa08 f303 	lsl.w	r3, r8, r3
 8009796:	f100 0c1f 	add.w	ip, r0, #31
		bsi->nBytes -= 4;
 800979a:	3e04      	subs	r6, #4
 800979c:	0fd8      	lsrs	r0, r3, #31
 800979e:	fa28 f80c 	lsr.w	r8, r8, ip
		bsi->iCache |= (*bsi->bytePtr++);
 80097a2:	3504      	adds	r5, #4
 80097a4:	005b      	lsls	r3, r3, #1
 80097a6:	e42c      	b.n	8009002 <xmp3fixpt_UnpackSideInfo+0x4fa>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80097a8:	7868      	ldrb	r0, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80097aa:	782b      	ldrb	r3, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 80097ac:	78ea      	ldrb	r2, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80097ae:	0400      	lsls	r0, r0, #16
 80097b0:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80097b4:	78ab      	ldrb	r3, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 80097b6:	4310      	orrs	r0, r2
 80097b8:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 80097bc:	f10c 0218 	add.w	r2, ip, #24
 80097c0:	fa00 f308 	lsl.w	r3, r0, r8
		bsi->nBytes -= 4;
 80097c4:	3e04      	subs	r6, #4
 80097c6:	40d0      	lsrs	r0, r2
		bsi->iCache |= (*bsi->bytePtr++);
 80097c8:	3504      	adds	r5, #4
 80097ca:	e4fe      	b.n	80091ca <xmp3fixpt_UnpackSideInfo+0x6c2>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 80097cc:	f1bc 0f00 	cmp.w	ip, #0
 80097d0:	f47f ac4a 	bne.w	8009068 <xmp3fixpt_UnpackSideInfo+0x560>
					sis->region0Count = 8;
 80097d4:	2208      	movs	r2, #8
 80097d6:	65e2      	str	r2, [r4, #92]	; 0x5c
 80097d8:	220c      	movs	r2, #12
 80097da:	f7ff ba72 	b.w	8008cc2 <xmp3fixpt_UnpackSideInfo+0x1ba>
	if (nBytes >= 4) {
 80097de:	2e03      	cmp	r6, #3
		lowBits = -bsi->cachedBits;
 80097e0:	f1c0 0301 	rsb	r3, r0, #1
	if (nBytes >= 4) {
 80097e4:	f300 815b 	bgt.w	8009a9e <xmp3fixpt_UnpackSideInfo+0xf96>
		while (nBytes--) {
 80097e8:	2e00      	cmp	r6, #0
 80097ea:	f000 8305 	beq.w	8009df8 <xmp3fixpt_UnpackSideInfo+0x12f0>
			bsi->iCache |= (*bsi->bytePtr++);
 80097ee:	f895 c000 	ldrb.w	ip, [r5]
		while (nBytes--) {
 80097f2:	2e01      	cmp	r6, #1
			bsi->iCache <<= 8;
 80097f4:	ea4f 290c 	mov.w	r9, ip, lsl #8
		while (nBytes--) {
 80097f8:	f000 8302 	beq.w	8009e00 <xmp3fixpt_UnpackSideInfo+0x12f8>
			bsi->iCache |= (*bsi->bytePtr++);
 80097fc:	f895 8001 	ldrb.w	r8, [r5, #1]
 8009800:	f895 c002 	ldrb.w	ip, [r5, #2]
 8009804:	ea48 0809 	orr.w	r8, r8, r9
 8009808:	ea4c 2808 	orr.w	r8, ip, r8, lsl #8
 800980c:	f1c6 0c03 	rsb	ip, r6, #3
			bsi->iCache <<= 8;
 8009810:	ea4f 2808 	mov.w	r8, r8, lsl #8
 8009814:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8009818:	fa08 fc0c 	lsl.w	ip, r8, ip
 800981c:	fa0c f303 	lsl.w	r3, ip, r3
 8009820:	301f      	adds	r0, #31
 8009822:	ea4f 78d3 	mov.w	r8, r3, lsr #31
			bsi->iCache |= (*bsi->bytePtr++);
 8009826:	3503      	adds	r5, #3
 8009828:	fa2c fc00 	lsr.w	ip, ip, r0
 800982c:	005b      	lsls	r3, r3, #1
 800982e:	eb02 00c6 	add.w	r0, r2, r6, lsl #3
		bsi->nBytes = 0;
 8009832:	2600      	movs	r6, #0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 8009834:	ea4c 0c01 	orr.w	ip, ip, r1
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 8009838:	4662      	mov	r2, ip
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800983a:	4641      	mov	r1, r8
 800983c:	f7ff bbb4 	b.w	8008fa8 <xmp3fixpt_UnpackSideInfo+0x4a0>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009840:	7868      	ldrb	r0, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009842:	f895 a000 	ldrb.w	sl, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 8009846:	f895 9003 	ldrb.w	r9, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800984a:	0400      	lsls	r0, r0, #16
 800984c:	ea40 600a 	orr.w	r0, r0, sl, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009850:	f895 a002 	ldrb.w	sl, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009854:	ea40 0909 	orr.w	r9, r0, r9
 8009858:	ea49 290a 	orr.w	r9, r9, sl, lsl #8
 800985c:	fa09 f303 	lsl.w	r3, r9, r3
 8009860:	f101 001d 	add.w	r0, r1, #29
		bsi->nBytes -= 4;
 8009864:	3e04      	subs	r6, #4
 8009866:	0fd9      	lsrs	r1, r3, #31
 8009868:	fa29 f900 	lsr.w	r9, r9, r0
		bsi->iCache |= (*bsi->bytePtr++);
 800986c:	3504      	adds	r5, #4
 800986e:	005b      	lsls	r3, r3, #1
 8009870:	e501      	b.n	8009276 <xmp3fixpt_UnpackSideInfo+0x76e>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009872:	7869      	ldrb	r1, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009874:	f895 9000 	ldrb.w	r9, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 8009878:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800987c:	f895 a002 	ldrb.w	sl, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009880:	0409      	lsls	r1, r1, #16
 8009882:	ea41 6109 	orr.w	r1, r1, r9, lsl #24
		bsi->iCache |= (*bsi->bytePtr++);
 8009886:	ea41 0908 	orr.w	r9, r1, r8
 800988a:	ea49 290a 	orr.w	r9, r9, sl, lsl #8
 800988e:	fa09 f303 	lsl.w	r3, r9, r3
 8009892:	f100 011f 	add.w	r1, r0, #31
 8009896:	ea4f 68d3 	mov.w	r8, r3, lsr #27
		bsi->nBytes -= 4;
 800989a:	3e04      	subs	r6, #4
 800989c:	fa29 f901 	lsr.w	r9, r9, r1
		bsi->iCache |= (*bsi->bytePtr++);
 80098a0:	3504      	adds	r5, #4
 80098a2:	015b      	lsls	r3, r3, #5
 80098a4:	e515      	b.n	80092d2 <xmp3fixpt_UnpackSideInfo+0x7ca>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80098a6:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80098aa:	782a      	ldrb	r2, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 80098ac:	78e9      	ldrb	r1, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80098ae:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80098b2:	ea4c 6c02 	orr.w	ip, ip, r2, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80098b6:	78aa      	ldrb	r2, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 80098b8:	ea4c 0c01 	orr.w	ip, ip, r1
 80098bc:	ea4c 2c02 	orr.w	ip, ip, r2, lsl #8
 80098c0:	fa0c f303 	lsl.w	r3, ip, r3
 80098c4:	f108 021b 	add.w	r2, r8, #27
 80098c8:	0ed9      	lsrs	r1, r3, #27
		bsi->nBytes -= 4;
 80098ca:	3e04      	subs	r6, #4
 80098cc:	fa2c fc02 	lsr.w	ip, ip, r2
		bsi->iCache |= (*bsi->bytePtr++);
 80098d0:	3504      	adds	r5, #4
 80098d2:	015b      	lsls	r3, r3, #5
 80098d4:	e6d8      	b.n	8009688 <xmp3fixpt_UnpackSideInfo+0xb80>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80098d6:	7869      	ldrb	r1, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80098d8:	f895 a000 	ldrb.w	sl, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 80098dc:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80098e0:	f895 b002 	ldrb.w	fp, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80098e4:	0409      	lsls	r1, r1, #16
 80098e6:	ea41 610a 	orr.w	r1, r1, sl, lsl #24
		bsi->iCache |= (*bsi->bytePtr++);
 80098ea:	ea41 0a08 	orr.w	sl, r1, r8
 80098ee:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
 80098f2:	fa0a f303 	lsl.w	r3, sl, r3
 80098f6:	f100 011d 	add.w	r1, r0, #29
 80098fa:	ea4f 7853 	mov.w	r8, r3, lsr #29
		bsi->nBytes -= 4;
 80098fe:	3e04      	subs	r6, #4
 8009900:	fa2a fa01 	lsr.w	sl, sl, r1
		bsi->iCache |= (*bsi->bytePtr++);
 8009904:	3504      	adds	r5, #4
 8009906:	00db      	lsls	r3, r3, #3
 8009908:	e5ad      	b.n	8009466 <xmp3fixpt_UnpackSideInfo+0x95e>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800990a:	f895 9001 	ldrb.w	r9, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800990e:	7829      	ldrb	r1, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8009910:	78e8      	ldrb	r0, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009912:	ea4f 4909 	mov.w	r9, r9, lsl #16
 8009916:	ea49 6901 	orr.w	r9, r9, r1, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800991a:	78a9      	ldrb	r1, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 800991c:	ea49 0900 	orr.w	r9, r9, r0
 8009920:	ea49 2901 	orr.w	r9, r9, r1, lsl #8
 8009924:	fa09 f303 	lsl.w	r3, r9, r3
 8009928:	f108 001e 	add.w	r0, r8, #30
 800992c:	ea4f 7cd3 	mov.w	ip, r3, lsr #31
		bsi->nBytes -= 4;
 8009930:	3e04      	subs	r6, #4
 8009932:	fa29 f900 	lsr.w	r9, r9, r0
		bsi->iCache |= (*bsi->bytePtr++);
 8009936:	3504      	adds	r5, #4
 8009938:	005b      	lsls	r3, r3, #1
 800993a:	e5c0      	b.n	80094be <xmp3fixpt_UnpackSideInfo+0x9b6>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800993c:	7868      	ldrb	r0, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800993e:	f895 a000 	ldrb.w	sl, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 8009942:	f895 9003 	ldrb.w	r9, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009946:	f895 b002 	ldrb.w	fp, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800994a:	0400      	lsls	r0, r0, #16
 800994c:	ea40 600a 	orr.w	r0, r0, sl, lsl #24
		bsi->iCache |= (*bsi->bytePtr++);
 8009950:	ea40 0a09 	orr.w	sl, r0, r9
 8009954:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
 8009958:	fa0a f303 	lsl.w	r3, sl, r3
 800995c:	f101 001d 	add.w	r0, r1, #29
 8009960:	ea4f 7953 	mov.w	r9, r3, lsr #29
		bsi->nBytes -= 4;
 8009964:	3e04      	subs	r6, #4
 8009966:	fa2a fa00 	lsr.w	sl, sl, r0
		bsi->iCache |= (*bsi->bytePtr++);
 800996a:	3504      	adds	r5, #4
 800996c:	00db      	lsls	r3, r3, #3
 800996e:	e548      	b.n	8009402 <xmp3fixpt_UnpackSideInfo+0x8fa>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009970:	7869      	ldrb	r1, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009972:	f895 a000 	ldrb.w	sl, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 8009976:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800997a:	f895 b002 	ldrb.w	fp, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800997e:	0409      	lsls	r1, r1, #16
 8009980:	ea41 610a 	orr.w	r1, r1, sl, lsl #24
		bsi->iCache |= (*bsi->bytePtr++);
 8009984:	ea41 0a08 	orr.w	sl, r1, r8
 8009988:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
 800998c:	fa0a f303 	lsl.w	r3, sl, r3
 8009990:	f100 011b 	add.w	r1, r0, #27
 8009994:	ea4f 7853 	mov.w	r8, r3, lsr #29
		bsi->nBytes -= 4;
 8009998:	3e04      	subs	r6, #4
 800999a:	fa2a fa01 	lsr.w	sl, sl, r1
		bsi->iCache |= (*bsi->bytePtr++);
 800999e:	3504      	adds	r5, #4
 80099a0:	00db      	lsls	r3, r3, #3
 80099a2:	e4fa      	b.n	800939a <xmp3fixpt_UnpackSideInfo+0x892>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80099a4:	7868      	ldrb	r0, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80099a6:	f895 a000 	ldrb.w	sl, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 80099aa:	f895 9003 	ldrb.w	r9, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80099ae:	f895 b002 	ldrb.w	fp, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80099b2:	0400      	lsls	r0, r0, #16
 80099b4:	ea40 600a 	orr.w	r0, r0, sl, lsl #24
		bsi->iCache |= (*bsi->bytePtr++);
 80099b8:	ea40 0a09 	orr.w	sl, r0, r9
 80099bc:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
 80099c0:	fa0a f303 	lsl.w	r3, sl, r3
 80099c4:	f101 001b 	add.w	r0, r1, #27
 80099c8:	ea4f 69d3 	mov.w	r9, r3, lsr #27
		bsi->nBytes -= 4;
 80099cc:	3e04      	subs	r6, #4
 80099ce:	fa2a fa00 	lsr.w	sl, sl, r0
		bsi->iCache |= (*bsi->bytePtr++);
 80099d2:	3504      	adds	r5, #4
 80099d4:	015b      	lsls	r3, r3, #5
 80099d6:	e4ae      	b.n	8009336 <xmp3fixpt_UnpackSideInfo+0x82e>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80099d8:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 80099dc:	782a      	ldrb	r2, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 80099de:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 80099e2:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80099e6:	ea4c 6c02 	orr.w	ip, ip, r2, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 80099ea:	78aa      	ldrb	r2, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 80099ec:	ea4c 0c08 	orr.w	ip, ip, r8
 80099f0:	ea4c 2c02 	orr.w	ip, ip, r2, lsl #8
 80099f4:	fa0c f303 	lsl.w	r3, ip, r3
 80099f8:	f101 021c 	add.w	r2, r1, #28
 80099fc:	fa2c f102 	lsr.w	r1, ip, r2
		bsi->nBytes -= 4;
 8009a00:	3e04      	subs	r6, #4
 8009a02:	ea4f 7c53 	mov.w	ip, r3, lsr #29
		bsi->iCache |= (*bsi->bytePtr++);
 8009a06:	3504      	adds	r5, #4
 8009a08:	00db      	lsls	r3, r3, #3
 8009a0a:	e587      	b.n	800951c <xmp3fixpt_UnpackSideInfo+0xa14>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009a0c:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009a10:	7828      	ldrb	r0, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8009a12:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009a16:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 8009a1a:	ea4c 6c00 	orr.w	ip, ip, r0, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009a1e:	78a8      	ldrb	r0, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009a20:	ea4c 0c08 	orr.w	ip, ip, r8
 8009a24:	ea4c 2c00 	orr.w	ip, ip, r0, lsl #8
 8009a28:	fa0c f303 	lsl.w	r3, ip, r3
 8009a2c:	f102 001b 	add.w	r0, r2, #27
		bsi->nBytes -= 4;
 8009a30:	3e04      	subs	r6, #4
 8009a32:	0eda      	lsrs	r2, r3, #27
 8009a34:	fa2c fc00 	lsr.w	ip, ip, r0
		bsi->iCache |= (*bsi->bytePtr++);
 8009a38:	3504      	adds	r5, #4
 8009a3a:	015b      	lsls	r3, r3, #5
 8009a3c:	e5c8      	b.n	80095d0 <xmp3fixpt_UnpackSideInfo+0xac8>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009a3e:	7869      	ldrb	r1, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009a40:	7828      	ldrb	r0, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8009a42:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009a46:	0409      	lsls	r1, r1, #16
 8009a48:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009a4c:	78a8      	ldrb	r0, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009a4e:	ea41 0108 	orr.w	r1, r1, r8
 8009a52:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8009a56:	fa01 f303 	lsl.w	r3, r1, r3
 8009a5a:	f102 001d 	add.w	r0, r2, #29
 8009a5e:	fa21 f200 	lsr.w	r2, r1, r0
		bsi->nBytes -= 4;
 8009a62:	3e04      	subs	r6, #4
 8009a64:	0fd9      	lsrs	r1, r3, #31
		bsi->iCache |= (*bsi->bytePtr++);
 8009a66:	3504      	adds	r5, #4
 8009a68:	005b      	lsls	r3, r3, #1
 8009a6a:	e584      	b.n	8009576 <xmp3fixpt_UnpackSideInfo+0xa6e>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009a6c:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009a70:	7829      	ldrb	r1, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8009a72:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009a76:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 8009a7a:	ea4c 6c01 	orr.w	ip, ip, r1, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009a7e:	78a9      	ldrb	r1, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009a80:	ea4c 0c08 	orr.w	ip, ip, r8
 8009a84:	ea4c 2c01 	orr.w	ip, ip, r1, lsl #8
 8009a88:	fa0c f303 	lsl.w	r3, ip, r3
 8009a8c:	f100 011b 	add.w	r1, r0, #27
		bsi->nBytes -= 4;
 8009a90:	3e04      	subs	r6, #4
 8009a92:	0f18      	lsrs	r0, r3, #28
 8009a94:	fa2c fc01 	lsr.w	ip, ip, r1
		bsi->iCache |= (*bsi->bytePtr++);
 8009a98:	3504      	adds	r5, #4
 8009a9a:	011b      	lsls	r3, r3, #4
 8009a9c:	e5c8      	b.n	8009630 <xmp3fixpt_UnpackSideInfo+0xb28>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009a9e:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009aa2:	782a      	ldrb	r2, [r5, #0]
		bsi->iCache |= (*bsi->bytePtr++);
 8009aa4:	f895 8003 	ldrb.w	r8, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009aa8:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 8009aac:	ea4c 6c02 	orr.w	ip, ip, r2, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009ab0:	78aa      	ldrb	r2, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009ab2:	ea4c 0c08 	orr.w	ip, ip, r8
 8009ab6:	ea4c 2c02 	orr.w	ip, ip, r2, lsl #8
 8009aba:	fa0c f303 	lsl.w	r3, ip, r3
 8009abe:	301f      	adds	r0, #31
 8009ac0:	ea4f 78d3 	mov.w	r8, r3, lsr #31
		bsi->nBytes -= 4;
 8009ac4:	3e04      	subs	r6, #4
 8009ac6:	fa2c fc00 	lsr.w	ip, ip, r0
		bsi->iCache |= (*bsi->bytePtr++);
 8009aca:	3504      	adds	r5, #4
 8009acc:	005b      	lsls	r3, r3, #1
 8009ace:	e6b1      	b.n	8009834 <xmp3fixpt_UnpackSideInfo+0xd2c>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009ad0:	f895 e000 	ldrb.w	lr, [r5]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009ad4:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache |= (*bsi->bytePtr++);
 8009ad8:	78ef      	ldrb	r7, [r5, #3]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009ada:	ea4f 6e0e 	mov.w	lr, lr, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009ade:	ea4e 4e0c 	orr.w	lr, lr, ip, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009ae2:	f895 c002 	ldrb.w	ip, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009ae6:	ea4e 0e07 	orr.w	lr, lr, r7
 8009aea:	f103 071f 	add.w	r7, r3, #31
 8009aee:	ea4e 230c 	orr.w	r3, lr, ip, lsl #8
 8009af2:	fa03 f101 	lsl.w	r1, r3, r1
		bsi->nBytes -= 4;
 8009af6:	3e04      	subs	r6, #4
 8009af8:	40fb      	lsrs	r3, r7
		bsi->iCache |= (*bsi->bytePtr++);
 8009afa:	3504      	adds	r5, #4
 8009afc:	f7ff b9bb 	b.w	8008e76 <xmp3fixpt_UnpackSideInfo+0x36e>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009b00:	f895 e001 	ldrb.w	lr, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009b04:	f895 c000 	ldrb.w	ip, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 8009b08:	78eb      	ldrb	r3, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009b0a:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 8009b0e:	ea4e 6e0c 	orr.w	lr, lr, ip, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009b12:	f895 c002 	ldrb.w	ip, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009b16:	ea4e 0e03 	orr.w	lr, lr, r3
 8009b1a:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
 8009b1e:	f102 031f 	add.w	r3, r2, #31
 8009b22:	fa0e f101 	lsl.w	r1, lr, r1
		bsi->nBytes -= 4;
 8009b26:	3e04      	subs	r6, #4
 8009b28:	fa2e fe03 	lsr.w	lr, lr, r3
		bsi->iCache |= (*bsi->bytePtr++);
 8009b2c:	3504      	adds	r5, #4
 8009b2e:	f7ff b971 	b.w	8008e14 <xmp3fixpt_UnpackSideInfo+0x30c>
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009b32:	7869      	ldrb	r1, [r5, #1]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009b34:	f895 e000 	ldrb.w	lr, [r5]
		bsi->iCache |= (*bsi->bytePtr++);
 8009b38:	78ea      	ldrb	r2, [r5, #3]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009b3a:	0409      	lsls	r1, r1, #16
 8009b3c:	ea41 610e 	orr.w	r1, r1, lr, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009b40:	f895 e002 	ldrb.w	lr, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009b44:	4311      	orrs	r1, r2
 8009b46:	f103 021f 	add.w	r2, r3, #31
 8009b4a:	ea41 230e 	orr.w	r3, r1, lr, lsl #8
 8009b4e:	fa03 f10c 	lsl.w	r1, r3, ip
		bsi->nBytes -= 4;
 8009b52:	3e04      	subs	r6, #4
 8009b54:	40d3      	lsrs	r3, r2
		bsi->iCache |= (*bsi->bytePtr++);
 8009b56:	3504      	adds	r5, #4
 8009b58:	f7ff b9ec 	b.w	8008f34 <xmp3fixpt_UnpackSideInfo+0x42c>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009b5c:	f895 e000 	ldrb.w	lr, [r5]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009b60:	f895 c001 	ldrb.w	ip, [r5, #1]
		bsi->iCache |= (*bsi->bytePtr++);
 8009b64:	78eb      	ldrb	r3, [r5, #3]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 8009b66:	ea4f 6e0e 	mov.w	lr, lr, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 8009b6a:	ea4e 4e0c 	orr.w	lr, lr, ip, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 8009b6e:	f895 c002 	ldrb.w	ip, [r5, #2]
		bsi->iCache |= (*bsi->bytePtr++);
 8009b72:	ea4e 0e03 	orr.w	lr, lr, r3
 8009b76:	f107 031f 	add.w	r3, r7, #31
 8009b7a:	ea4e 270c 	orr.w	r7, lr, ip, lsl #8
 8009b7e:	fa07 f101 	lsl.w	r1, r7, r1
		bsi->nBytes -= 4;
 8009b82:	3e04      	subs	r6, #4
 8009b84:	40df      	lsrs	r7, r3
		bsi->iCache |= (*bsi->bytePtr++);
 8009b86:	3504      	adds	r5, #4
 8009b88:	f7ff b9a5 	b.w	8008ed6 <xmp3fixpt_UnpackSideInfo+0x3ce>
 8009b8c:	0612      	lsls	r2, r2, #24
 8009b8e:	fa02 f303 	lsl.w	r3, r2, r3
 8009b92:	301f      	adds	r0, #31
 8009b94:	fa22 f800 	lsr.w	r8, r2, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009b98:	3501      	adds	r5, #1
 8009b9a:	0fd8      	lsrs	r0, r3, #31
 8009b9c:	005b      	lsls	r3, r3, #1
 8009b9e:	f7ff ba2d 	b.w	8008ffc <xmp3fixpt_UnpackSideInfo+0x4f4>
		while (nBytes--) {
 8009ba2:	4633      	mov	r3, r6
 8009ba4:	4630      	mov	r0, r6
 8009ba6:	f7ff bb0d 	b.w	80091c4 <xmp3fixpt_UnpackSideInfo+0x6bc>
 8009baa:	4633      	mov	r3, r6
 8009bac:	46b4      	mov	ip, r6
 8009bae:	f7ff bab3 	b.w	8009118 <xmp3fixpt_UnpackSideInfo+0x610>
 8009bb2:	0618      	lsls	r0, r3, #24
 8009bb4:	f10c 0c18 	add.w	ip, ip, #24
 8009bb8:	fa00 f308 	lsl.w	r3, r0, r8
			bsi->iCache |= (*bsi->bytePtr++);
 8009bbc:	3501      	adds	r5, #1
 8009bbe:	fa20 f00c 	lsr.w	r0, r0, ip
 8009bc2:	f7ff baff 	b.w	80091c4 <xmp3fixpt_UnpackSideInfo+0x6bc>
 8009bc6:	0609      	lsls	r1, r1, #24
 8009bc8:	f10c 0c1f 	add.w	ip, ip, #31
 8009bcc:	fa01 f303 	lsl.w	r3, r1, r3
 8009bd0:	3501      	adds	r5, #1
 8009bd2:	fa21 f10c 	lsr.w	r1, r1, ip
 8009bd6:	f7ff ba3f 	b.w	8009058 <xmp3fixpt_UnpackSideInfo+0x550>
 8009bda:	0600      	lsls	r0, r0, #24
 8009bdc:	fa00 f303 	lsl.w	r3, r0, r3
 8009be0:	3214      	adds	r2, #20
 8009be2:	fa20 f902 	lsr.w	r9, r0, r2
 8009be6:	3501      	adds	r5, #1
 8009be8:	0dd8      	lsrs	r0, r3, #23
 8009bea:	025b      	lsls	r3, r3, #9
 8009bec:	f7ff bb13 	b.w	8009216 <xmp3fixpt_UnpackSideInfo+0x70e>
		while (nBytes--) {
 8009bf0:	4633      	mov	r3, r6
 8009bf2:	4631      	mov	r1, r6
 8009bf4:	46b4      	mov	ip, r6
 8009bf6:	f7ff ba62 	b.w	80090be <xmp3fixpt_UnpackSideInfo+0x5b6>
 8009bfa:	4633      	mov	r3, r6
 8009bfc:	4631      	mov	r1, r6
 8009bfe:	f7ff ba2b 	b.w	8009058 <xmp3fixpt_UnpackSideInfo+0x550>
 8009c02:	4633      	mov	r3, r6
 8009c04:	4630      	mov	r0, r6
 8009c06:	46b1      	mov	r9, r6
 8009c08:	f7ff bb05 	b.w	8009216 <xmp3fixpt_UnpackSideInfo+0x70e>
 8009c0c:	4633      	mov	r3, r6
 8009c0e:	4630      	mov	r0, r6
 8009c10:	46b0      	mov	r8, r6
 8009c12:	f7ff b9f3 	b.w	8008ffc <xmp3fixpt_UnpackSideInfo+0x4f4>
 8009c16:	ea4f 6c00 	mov.w	ip, r0, lsl #24
 8009c1a:	321f      	adds	r2, #31
 8009c1c:	fa0c f303 	lsl.w	r3, ip, r3
			bsi->iCache |= (*bsi->bytePtr++);
 8009c20:	3501      	adds	r5, #1
 8009c22:	fa2c fc02 	lsr.w	ip, ip, r2
 8009c26:	f7ff ba77 	b.w	8009118 <xmp3fixpt_UnpackSideInfo+0x610>
		while (nBytes--) {
 8009c2a:	4633      	mov	r3, r6
 8009c2c:	4631      	mov	r1, r6
 8009c2e:	46b0      	mov	r8, r6
 8009c30:	f7ff ba9c 	b.w	800916c <xmp3fixpt_UnpackSideInfo+0x664>
 8009c34:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
 8009c38:	fa0c f303 	lsl.w	r3, ip, r3
 8009c3c:	f102 0120 	add.w	r1, r2, #32
 8009c40:	fa2c fc01 	lsr.w	ip, ip, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009c44:	3501      	adds	r5, #1
 8009c46:	0fd9      	lsrs	r1, r3, #31
 8009c48:	005b      	lsls	r3, r3, #1
 8009c4a:	f7ff ba38 	b.w	80090be <xmp3fixpt_UnpackSideInfo+0x5b6>
 8009c4e:	0612      	lsls	r2, r2, #24
 8009c50:	fa02 f303 	lsl.w	r3, r2, r3
 8009c54:	3117      	adds	r1, #23
 8009c56:	fa22 f801 	lsr.w	r8, r2, r1
 8009c5a:	3501      	adds	r5, #1
 8009c5c:	0e19      	lsrs	r1, r3, #24
 8009c5e:	021b      	lsls	r3, r3, #8
 8009c60:	f7ff ba84 	b.w	800916c <xmp3fixpt_UnpackSideInfo+0x664>
		while (nBytes--) {
 8009c64:	4633      	mov	r3, r6
 8009c66:	4631      	mov	r1, r6
 8009c68:	46b1      	mov	r9, r6
 8009c6a:	f7ff bb01 	b.w	8009270 <xmp3fixpt_UnpackSideInfo+0x768>
 8009c6e:	0609      	lsls	r1, r1, #24
 8009c70:	fa01 f303 	lsl.w	r3, r1, r3
 8009c74:	f108 0c1b 	add.w	ip, r8, #27
 8009c78:	fa21 fc0c 	lsr.w	ip, r1, ip
			bsi->iCache |= (*bsi->bytePtr++);
 8009c7c:	3501      	adds	r5, #1
 8009c7e:	0ed9      	lsrs	r1, r3, #27
 8009c80:	015b      	lsls	r3, r3, #5
 8009c82:	e4fe      	b.n	8009682 <xmp3fixpt_UnpackSideInfo+0xb7a>
		while (nBytes--) {
 8009c84:	4633      	mov	r3, r6
 8009c86:	4631      	mov	r1, r6
 8009c88:	46b4      	mov	ip, r6
 8009c8a:	e4fa      	b.n	8009682 <xmp3fixpt_UnpackSideInfo+0xb7a>
 8009c8c:	ea4f 6909 	mov.w	r9, r9, lsl #24
 8009c90:	fa09 f303 	lsl.w	r3, r9, r3
 8009c94:	311b      	adds	r1, #27
 8009c96:	fa29 fa01 	lsr.w	sl, r9, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009c9a:	3501      	adds	r5, #1
 8009c9c:	ea4f 69d3 	mov.w	r9, r3, lsr #27
 8009ca0:	015b      	lsls	r3, r3, #5
 8009ca2:	f7ff bb45 	b.w	8009330 <xmp3fixpt_UnpackSideInfo+0x828>
		while (nBytes--) {
 8009ca6:	4633      	mov	r3, r6
 8009ca8:	46b1      	mov	r9, r6
 8009caa:	46b2      	mov	sl, r6
 8009cac:	f7ff bb40 	b.w	8009330 <xmp3fixpt_UnpackSideInfo+0x828>
 8009cb0:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
 8009cb4:	fa0c f303 	lsl.w	r3, ip, r3
 8009cb8:	301b      	adds	r0, #27
 8009cba:	fa2c fc00 	lsr.w	ip, ip, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009cbe:	3501      	adds	r5, #1
 8009cc0:	0f18      	lsrs	r0, r3, #28
 8009cc2:	011b      	lsls	r3, r3, #4
 8009cc4:	e4b1      	b.n	800962a <xmp3fixpt_UnpackSideInfo+0xb22>
		while (nBytes--) {
 8009cc6:	4633      	mov	r3, r6
 8009cc8:	4630      	mov	r0, r6
 8009cca:	46b4      	mov	ip, r6
 8009ccc:	e4ad      	b.n	800962a <xmp3fixpt_UnpackSideInfo+0xb22>
 8009cce:	ea4f 6909 	mov.w	r9, r9, lsl #24
 8009cd2:	fa09 f303 	lsl.w	r3, r9, r3
 8009cd6:	311d      	adds	r1, #29
 8009cd8:	fa29 fa01 	lsr.w	sl, r9, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009cdc:	3501      	adds	r5, #1
 8009cde:	ea4f 7953 	mov.w	r9, r3, lsr #29
 8009ce2:	00db      	lsls	r3, r3, #3
 8009ce4:	f7ff bb8a 	b.w	80093fc <xmp3fixpt_UnpackSideInfo+0x8f4>
		while (nBytes--) {
 8009ce8:	4633      	mov	r3, r6
 8009cea:	46b1      	mov	r9, r6
 8009cec:	46b2      	mov	sl, r6
 8009cee:	f7ff bb85 	b.w	80093fc <xmp3fixpt_UnpackSideInfo+0x8f4>
 8009cf2:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
 8009cf6:	fa0c f303 	lsl.w	r3, ip, r3
 8009cfa:	321b      	adds	r2, #27
 8009cfc:	fa2c fc02 	lsr.w	ip, ip, r2
			bsi->iCache |= (*bsi->bytePtr++);
 8009d00:	3501      	adds	r5, #1
 8009d02:	0eda      	lsrs	r2, r3, #27
 8009d04:	015b      	lsls	r3, r3, #5
 8009d06:	e460      	b.n	80095ca <xmp3fixpt_UnpackSideInfo+0xac2>
		while (nBytes--) {
 8009d08:	4633      	mov	r3, r6
 8009d0a:	4632      	mov	r2, r6
 8009d0c:	46b4      	mov	ip, r6
 8009d0e:	e45c      	b.n	80095ca <xmp3fixpt_UnpackSideInfo+0xac2>
 8009d10:	ea4f 6808 	mov.w	r8, r8, lsl #24
 8009d14:	fa08 f303 	lsl.w	r3, r8, r3
 8009d18:	301b      	adds	r0, #27
 8009d1a:	fa28 fa00 	lsr.w	sl, r8, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009d1e:	3501      	adds	r5, #1
 8009d20:	ea4f 7853 	mov.w	r8, r3, lsr #29
 8009d24:	00db      	lsls	r3, r3, #3
 8009d26:	f7ff bb35 	b.w	8009394 <xmp3fixpt_UnpackSideInfo+0x88c>
		while (nBytes--) {
 8009d2a:	4633      	mov	r3, r6
 8009d2c:	46b0      	mov	r8, r6
 8009d2e:	46b2      	mov	sl, r6
 8009d30:	f7ff bb30 	b.w	8009394 <xmp3fixpt_UnpackSideInfo+0x88c>
 8009d34:	0609      	lsls	r1, r1, #24
 8009d36:	fa01 f303 	lsl.w	r3, r1, r3
 8009d3a:	321d      	adds	r2, #29
 8009d3c:	fa21 f202 	lsr.w	r2, r1, r2
			bsi->iCache |= (*bsi->bytePtr++);
 8009d40:	3501      	adds	r5, #1
 8009d42:	0fd9      	lsrs	r1, r3, #31
 8009d44:	005b      	lsls	r3, r3, #1
 8009d46:	e413      	b.n	8009570 <xmp3fixpt_UnpackSideInfo+0xa68>
		while (nBytes--) {
 8009d48:	4633      	mov	r3, r6
 8009d4a:	4631      	mov	r1, r6
 8009d4c:	4632      	mov	r2, r6
 8009d4e:	e40f      	b.n	8009570 <xmp3fixpt_UnpackSideInfo+0xa68>
 8009d50:	ea4f 6808 	mov.w	r8, r8, lsl #24
 8009d54:	fa08 f303 	lsl.w	r3, r8, r3
 8009d58:	301d      	adds	r0, #29
 8009d5a:	fa28 fa00 	lsr.w	sl, r8, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009d5e:	3501      	adds	r5, #1
 8009d60:	ea4f 7853 	mov.w	r8, r3, lsr #29
 8009d64:	00db      	lsls	r3, r3, #3
 8009d66:	f7ff bb7b 	b.w	8009460 <xmp3fixpt_UnpackSideInfo+0x958>
		while (nBytes--) {
 8009d6a:	4633      	mov	r3, r6
 8009d6c:	46b0      	mov	r8, r6
 8009d6e:	46b2      	mov	sl, r6
 8009d70:	f7ff bb76 	b.w	8009460 <xmp3fixpt_UnpackSideInfo+0x958>
 8009d74:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
 8009d78:	fa0c f303 	lsl.w	r3, ip, r3
 8009d7c:	311c      	adds	r1, #28
 8009d7e:	fa2c f101 	lsr.w	r1, ip, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009d82:	3501      	adds	r5, #1
 8009d84:	ea4f 7c53 	mov.w	ip, r3, lsr #29
 8009d88:	00db      	lsls	r3, r3, #3
 8009d8a:	f7ff bbc4 	b.w	8009516 <xmp3fixpt_UnpackSideInfo+0xa0e>
		while (nBytes--) {
 8009d8e:	4633      	mov	r3, r6
 8009d90:	46b4      	mov	ip, r6
 8009d92:	4631      	mov	r1, r6
 8009d94:	f7ff bbbf 	b.w	8009516 <xmp3fixpt_UnpackSideInfo+0xa0e>
 8009d98:	0609      	lsls	r1, r1, #24
 8009d9a:	fa01 f303 	lsl.w	r3, r1, r3
 8009d9e:	f108 081e 	add.w	r8, r8, #30
 8009da2:	ea4f 7cd3 	mov.w	ip, r3, lsr #31
 8009da6:	fa21 f908 	lsr.w	r9, r1, r8
			bsi->iCache |= (*bsi->bytePtr++);
 8009daa:	3501      	adds	r5, #1
 8009dac:	005b      	lsls	r3, r3, #1
 8009dae:	f7ff bb83 	b.w	80094b8 <xmp3fixpt_UnpackSideInfo+0x9b0>
		while (nBytes--) {
 8009db2:	4633      	mov	r3, r6
 8009db4:	46b4      	mov	ip, r6
 8009db6:	46b1      	mov	r9, r6
 8009db8:	f7ff bb7e 	b.w	80094b8 <xmp3fixpt_UnpackSideInfo+0x9b0>
 8009dbc:	ea4f 6808 	mov.w	r8, r8, lsl #24
 8009dc0:	fa08 f303 	lsl.w	r3, r8, r3
 8009dc4:	301f      	adds	r0, #31
 8009dc6:	fa28 f900 	lsr.w	r9, r8, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009dca:	3501      	adds	r5, #1
 8009dcc:	ea4f 68d3 	mov.w	r8, r3, lsr #27
 8009dd0:	015b      	lsls	r3, r3, #5
 8009dd2:	f7ff ba7b 	b.w	80092cc <xmp3fixpt_UnpackSideInfo+0x7c4>
		while (nBytes--) {
 8009dd6:	4633      	mov	r3, r6
 8009dd8:	46b0      	mov	r8, r6
 8009dda:	46b1      	mov	r9, r6
 8009ddc:	f7ff ba76 	b.w	80092cc <xmp3fixpt_UnpackSideInfo+0x7c4>
 8009de0:	ea4f 6909 	mov.w	r9, r9, lsl #24
 8009de4:	fa09 f303 	lsl.w	r3, r9, r3
 8009de8:	311d      	adds	r1, #29
 8009dea:	fa29 f901 	lsr.w	r9, r9, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009dee:	3501      	adds	r5, #1
 8009df0:	0fd9      	lsrs	r1, r3, #31
 8009df2:	005b      	lsls	r3, r3, #1
 8009df4:	f7ff ba3c 	b.w	8009270 <xmp3fixpt_UnpackSideInfo+0x768>
		while (nBytes--) {
 8009df8:	4633      	mov	r3, r6
 8009dfa:	46b0      	mov	r8, r6
 8009dfc:	46b4      	mov	ip, r6
 8009dfe:	e516      	b.n	800982e <xmp3fixpt_UnpackSideInfo+0xd26>
 8009e00:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
 8009e04:	fa0c f303 	lsl.w	r3, ip, r3
 8009e08:	301f      	adds	r0, #31
 8009e0a:	ea4f 78d3 	mov.w	r8, r3, lsr #31
 8009e0e:	fa2c fc00 	lsr.w	ip, ip, r0
			bsi->iCache |= (*bsi->bytePtr++);
 8009e12:	3501      	adds	r5, #1
 8009e14:	005b      	lsls	r3, r3, #1
 8009e16:	e50a      	b.n	800982e <xmp3fixpt_UnpackSideInfo+0xd26>
		while (nBytes--) {
 8009e18:	4631      	mov	r1, r6
 8009e1a:	4633      	mov	r3, r6
 8009e1c:	f7ff b887 	b.w	8008f2e <xmp3fixpt_UnpackSideInfo+0x426>
 8009e20:	ea4f 6e0e 	mov.w	lr, lr, lsl #24
 8009e24:	321f      	adds	r2, #31
 8009e26:	fa0e f101 	lsl.w	r1, lr, r1
			bsi->iCache |= (*bsi->bytePtr++);
 8009e2a:	3501      	adds	r5, #1
 8009e2c:	fa2e fe02 	lsr.w	lr, lr, r2
 8009e30:	f7fe bfed 	b.w	8008e0e <xmp3fixpt_UnpackSideInfo+0x306>
		while (nBytes--) {
 8009e34:	4631      	mov	r1, r6
 8009e36:	46b6      	mov	lr, r6
 8009e38:	f7fe bfe9 	b.w	8008e0e <xmp3fixpt_UnpackSideInfo+0x306>
 8009e3c:	4631      	mov	r1, r6
 8009e3e:	4637      	mov	r7, r6
 8009e40:	f7ff b846 	b.w	8008ed0 <xmp3fixpt_UnpackSideInfo+0x3c8>
 8009e44:	ea4f 6808 	mov.w	r8, r8, lsl #24
 8009e48:	331f      	adds	r3, #31
 8009e4a:	fa08 f10c 	lsl.w	r1, r8, ip
 8009e4e:	fa28 f303 	lsr.w	r3, r8, r3
			bsi->iCache |= (*bsi->bytePtr++);
 8009e52:	3501      	adds	r5, #1
 8009e54:	f7ff b86b 	b.w	8008f2e <xmp3fixpt_UnpackSideInfo+0x426>
 8009e58:	ea4f 6e0e 	mov.w	lr, lr, lsl #24
 8009e5c:	331f      	adds	r3, #31
 8009e5e:	fa0e f101 	lsl.w	r1, lr, r1
 8009e62:	fa2e f303 	lsr.w	r3, lr, r3
 8009e66:	3501      	adds	r5, #1
 8009e68:	f7ff b802 	b.w	8008e70 <xmp3fixpt_UnpackSideInfo+0x368>
		while (nBytes--) {
 8009e6c:	4631      	mov	r1, r6
 8009e6e:	4633      	mov	r3, r6
 8009e70:	f7fe bffe 	b.w	8008e70 <xmp3fixpt_UnpackSideInfo+0x368>
 8009e74:	ea4f 6e0e 	mov.w	lr, lr, lsl #24
 8009e78:	371f      	adds	r7, #31
 8009e7a:	fa0e f101 	lsl.w	r1, lr, r1
 8009e7e:	fa2e f707 	lsr.w	r7, lr, r7
			bsi->iCache |= (*bsi->bytePtr++);
 8009e82:	3501      	adds	r5, #1
 8009e84:	f7ff b824 	b.w	8008ed0 <xmp3fixpt_UnpackSideInfo+0x3c8>
		return -1;
 8009e88:	f04f 33ff 	mov.w	r3, #4294967295
 8009e8c:	9309      	str	r3, [sp, #36]	; 0x24
 8009e8e:	4618      	mov	r0, r3
 8009e90:	f7fe bf44 	b.w	8008d1c <xmp3fixpt_UnpackSideInfo+0x214>

08009e94 <xmp3fixpt_AllocateBuffers>:
 *
 * Notes:       if one or more mallocs fail, function frees any buffers already
 *                allocated before returning
 **************************************************************************************/
MP3DecInfo *AllocateBuffers(void)
{
 8009e94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
//	hi =  (HuffmanInfo *)     malloc(sizeof(HuffmanInfo));
//	di =  (DequantInfo *)     malloc(sizeof(DequantInfo));
//	mi =  (IMDCTInfo *)       malloc(sizeof(IMDCTInfo));
//	sbi = (SubbandInfo *)     malloc(sizeof(SubbandInfo));

	mp3DecInfo->FrameHeaderPS =     (void *)fh;
 8009e98:	4c22      	ldr	r4, [pc, #136]	; (8009f24 <xmp3fixpt_AllocateBuffers+0x90>)
	mp3DecInfo->SideInfoPS =        (void *)si;
	mp3DecInfo->ScaleFactorInfoPS = (void *)sfi;
	mp3DecInfo->HuffmanInfoPS =     (void *)hi;
	mp3DecInfo->DequantInfoPS =     (void *)di;
 8009e9a:	4d23      	ldr	r5, [pc, #140]	; (8009f28 <xmp3fixpt_AllocateBuffers+0x94>)
	mp3DecInfo->IMDCTInfoPS =       (void *)mi;
	mp3DecInfo->SubbandInfoPS =     (void *)sbi;
 8009e9c:	4e23      	ldr	r6, [pc, #140]	; (8009f2c <xmp3fixpt_AllocateBuffers+0x98>)
 8009e9e:	61a6      	str	r6, [r4, #24]
	mp3DecInfo->FrameHeaderPS =     (void *)fh;
 8009ea0:	f504 63fe 	add.w	r3, r4, #2032	; 0x7f0
 8009ea4:	4618      	mov	r0, r3
	mp3DecInfo->DequantInfoPS =     (void *)di;
 8009ea6:	f605 37a4 	addw	r7, r5, #2980	; 0xba4
	mp3DecInfo->SideInfoPS =        (void *)si;
 8009eaa:	f604 0a28 	addw	sl, r4, #2088	; 0x828
	mp3DecInfo->IMDCTInfoPS =       (void *)mi;
 8009eae:	f605 65ec 	addw	r5, r5, #3820	; 0xeec
	mp3DecInfo->ScaleFactorInfoPS = (void *)sfi;
 8009eb2:	f504 6917 	add.w	r9, r4, #2416	; 0x970
	mp3DecInfo->HuffmanInfoPS =     (void *)hi;
 8009eb6:	f604 288c 	addw	r8, r4, #2700	; 0xa8c
 8009eba:	2238      	movs	r2, #56	; 0x38
 8009ebc:	2100      	movs	r1, #0
	mp3DecInfo->FrameHeaderPS =     (void *)fh;
 8009ebe:	6023      	str	r3, [r4, #0]
	mp3DecInfo->DequantInfoPS =     (void *)di;
 8009ec0:	6127      	str	r7, [r4, #16]
	mp3DecInfo->IMDCTInfoPS =       (void *)mi;
 8009ec2:	6165      	str	r5, [r4, #20]
	mp3DecInfo->SideInfoPS =        (void *)si;
 8009ec4:	f8c4 a004 	str.w	sl, [r4, #4]
	mp3DecInfo->ScaleFactorInfoPS = (void *)sfi;
 8009ec8:	f8c4 9008 	str.w	r9, [r4, #8]
	mp3DecInfo->HuffmanInfoPS =     (void *)hi;
 8009ecc:	f8c4 800c 	str.w	r8, [r4, #12]
 8009ed0:	f00a fb95 	bl	80145fe <memset>
 8009ed4:	4650      	mov	r0, sl
 8009ed6:	f44f 72a4 	mov.w	r2, #328	; 0x148
 8009eda:	2100      	movs	r1, #0
 8009edc:	f00a fb8f 	bl	80145fe <memset>
 8009ee0:	4648      	mov	r0, r9
 8009ee2:	f44f 728e 	mov.w	r2, #284	; 0x11c
 8009ee6:	2100      	movs	r1, #0
 8009ee8:	f00a fb89 	bl	80145fe <memset>
 8009eec:	4640      	mov	r0, r8
 8009eee:	f241 2210 	movw	r2, #4624	; 0x1210
 8009ef2:	2100      	movs	r1, #0
 8009ef4:	f00a fb83 	bl	80145fe <memset>
 8009ef8:	4638      	mov	r0, r7
 8009efa:	f44f 7252 	mov.w	r2, #840	; 0x348
 8009efe:	2100      	movs	r1, #0
 8009f00:	f00a fb7d 	bl	80145fe <memset>
 8009f04:	4628      	mov	r0, r5
 8009f06:	f44f 52d9 	mov.w	r2, #6944	; 0x1b20
 8009f0a:	2100      	movs	r1, #0
 8009f0c:	f00a fb77 	bl	80145fe <memset>
 8009f10:	4630      	mov	r0, r6
 8009f12:	f242 2204 	movw	r2, #8708	; 0x2204
 8009f16:	2100      	movs	r1, #0
 8009f18:	f00a fb71 	bl	80145fe <memset>
	ClearBuffer(di,  sizeof(DequantInfo));
	ClearBuffer(mi,  sizeof(IMDCTInfo));
	ClearBuffer(sbi, sizeof(SubbandInfo));

	return mp3DecInfo;
}
 8009f1c:	4620      	mov	r0, r4
 8009f1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009f22:	bf00      	nop
 8009f24:	20002130 	.word	0x20002130
 8009f28:	20003228 	.word	0x20003228
 8009f2c:	20005c34 	.word	0x20005c34

08009f30 <xmp3fixpt_FreeBuffers>:
 * Return:      none
 *
 * Notes:       safe to call even if some buffers were not allocated (uses SAFE_FREE)
 **************************************************************************************/
void FreeBuffers(MP3DecInfo *mp3DecInfo)
{
 8009f30:	4770      	bx	lr
 8009f32:	bf00      	nop

08009f34 <xmp3fixpt_FDCT32>:
 * TODO:        code organization and optimization for ARM
 *              possibly interleave stereo (cut # of coef loads in half - may not have
 *                enough registers)
 **************************************************************************************/
void FDCT32(int *buf, int *dest, int offset, int oddBlock, int gb)
{
 8009f34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009f38:	b087      	sub	sp, #28
 8009f3a:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8009f3c:	9100      	str	r1, [sp, #0]
	/* scaling - ensure at least 6 guard bits for DCT 
	 * (in practice this is already true 99% of time, so this code is
	 *  almost never triggered)
	 */
	es = 0;
	if (gb < 6) {
 8009f3e:	2c05      	cmp	r4, #5
{
 8009f40:	9202      	str	r2, [sp, #8]
 8009f42:	9303      	str	r3, [sp, #12]
	if (gb < 6) {
 8009f44:	f300 8511 	bgt.w	800a96a <xmp3fixpt_FDCT32+0xa36>
		es = 6 - gb;
 8009f48:	f1c4 0b06 	rsb	fp, r4, #6
 8009f4c:	1f03      	subs	r3, r0, #4
 8009f4e:	f100 017c 	add.w	r1, r0, #124	; 0x7c
		for (i = 0; i < 32; i++)
			buf[i] >>= es;
 8009f52:	685a      	ldr	r2, [r3, #4]
 8009f54:	fa42 f20b 	asr.w	r2, r2, fp
 8009f58:	f843 2f04 	str.w	r2, [r3, #4]!
		for (i = 0; i < 32; i++)
 8009f5c:	428b      	cmp	r3, r1
 8009f5e:	d1f8      	bne.n	8009f52 <xmp3fixpt_FDCT32+0x1e>
	}

	/* first pass */    
	D32FP(0, 1, 5, 1);
 8009f60:	6801      	ldr	r1, [r0, #0]
 8009f62:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 8009f64:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 8009f66:	6c06      	ldr	r6, [r0, #64]	; 0x40

#elif defined(ARM_TEST)
static __inline__ int MULSHIFT32(int x, int y)
{
	int zlow;
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 8009f68:	4bca      	ldr	r3, [pc, #808]	; (800a294 <xmp3fixpt_FDCT32+0x360>)
 8009f6a:	1a8c      	subs	r4, r1, r2
 8009f6c:	440a      	add	r2, r1
 8009f6e:	fb83 1404 	smull	r1, r4, r3, r4
 8009f72:	1ba9      	subs	r1, r5, r6
 8009f74:	19ab      	adds	r3, r5, r6
 8009f76:	0064      	lsls	r4, r4, #1
 8009f78:	4dc7      	ldr	r5, [pc, #796]	; (800a298 <xmp3fixpt_FDCT32+0x364>)
 8009f7a:	fb85 6101 	smull	r6, r1, r5, r1
 8009f7e:	18d5      	adds	r5, r2, r3
 8009f80:	0149      	lsls	r1, r1, #5
 8009f82:	1ad2      	subs	r2, r2, r3
 8009f84:	6005      	str	r5, [r0, #0]
 8009f86:	4ec5      	ldr	r6, [pc, #788]	; (800a29c <xmp3fixpt_FDCT32+0x368>)
 8009f88:	fb86 3202 	smull	r3, r2, r6, r2
 8009f8c:	0052      	lsls	r2, r2, #1
 8009f8e:	1865      	adds	r5, r4, r1
 8009f90:	1a63      	subs	r3, r4, r1
 8009f92:	63c2      	str	r2, [r0, #60]	; 0x3c
 8009f94:	6405      	str	r5, [r0, #64]	; 0x40
 8009f96:	fb86 2303 	smull	r2, r3, r6, r3
	D32FP(1, 1, 3, 1);
 8009f9a:	6847      	ldr	r7, [r0, #4]
 8009f9c:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8009f9e:	6b85      	ldr	r5, [r0, #56]	; 0x38
 8009fa0:	6c46      	ldr	r6, [r0, #68]	; 0x44
 8009fa2:	49bf      	ldr	r1, [pc, #764]	; (800a2a0 <xmp3fixpt_FDCT32+0x36c>)
	D32FP(0, 1, 5, 1);
 8009fa4:	005b      	lsls	r3, r3, #1
	D32FP(1, 1, 3, 1);
 8009fa6:	1abc      	subs	r4, r7, r2
	D32FP(0, 1, 5, 1);
 8009fa8:	67c3      	str	r3, [r0, #124]	; 0x7c
	D32FP(1, 1, 3, 1);
 8009faa:	443a      	add	r2, r7
 8009fac:	fb81 3404 	smull	r3, r4, r1, r4
 8009fb0:	1ba9      	subs	r1, r5, r6
 8009fb2:	19ab      	adds	r3, r5, r6
 8009fb4:	0064      	lsls	r4, r4, #1
 8009fb6:	4dbb      	ldr	r5, [pc, #748]	; (800a2a4 <xmp3fixpt_FDCT32+0x370>)
 8009fb8:	fb85 6101 	smull	r6, r1, r5, r1
 8009fbc:	18d5      	adds	r5, r2, r3
 8009fbe:	00c9      	lsls	r1, r1, #3
 8009fc0:	1ad2      	subs	r2, r2, r3
 8009fc2:	6045      	str	r5, [r0, #4]
 8009fc4:	4eb8      	ldr	r6, [pc, #736]	; (800a2a8 <xmp3fixpt_FDCT32+0x374>)
 8009fc6:	fb86 3202 	smull	r3, r2, r6, r2
 8009fca:	0052      	lsls	r2, r2, #1
 8009fcc:	1865      	adds	r5, r4, r1
 8009fce:	1a63      	subs	r3, r4, r1
 8009fd0:	6382      	str	r2, [r0, #56]	; 0x38
 8009fd2:	6445      	str	r5, [r0, #68]	; 0x44
 8009fd4:	fb86 2303 	smull	r2, r3, r6, r3
	D32FP(2, 1, 3, 1);
 8009fd8:	6887      	ldr	r7, [r0, #8]
 8009fda:	6f42      	ldr	r2, [r0, #116]	; 0x74
 8009fdc:	6b45      	ldr	r5, [r0, #52]	; 0x34
 8009fde:	6c86      	ldr	r6, [r0, #72]	; 0x48
 8009fe0:	49b2      	ldr	r1, [pc, #712]	; (800a2ac <xmp3fixpt_FDCT32+0x378>)
	D32FP(1, 1, 3, 1);
 8009fe2:	005b      	lsls	r3, r3, #1
	D32FP(2, 1, 3, 1);
 8009fe4:	1abc      	subs	r4, r7, r2
	D32FP(1, 1, 3, 1);
 8009fe6:	6783      	str	r3, [r0, #120]	; 0x78
	D32FP(2, 1, 3, 1);
 8009fe8:	443a      	add	r2, r7
 8009fea:	fb81 3404 	smull	r3, r4, r1, r4
 8009fee:	1ba9      	subs	r1, r5, r6
 8009ff0:	19ab      	adds	r3, r5, r6
 8009ff2:	0064      	lsls	r4, r4, #1
 8009ff4:	4dae      	ldr	r5, [pc, #696]	; (800a2b0 <xmp3fixpt_FDCT32+0x37c>)
 8009ff6:	fb85 6101 	smull	r6, r1, r5, r1
 8009ffa:	18d5      	adds	r5, r2, r3
 8009ffc:	00c9      	lsls	r1, r1, #3
 8009ffe:	1ad2      	subs	r2, r2, r3
 800a000:	6085      	str	r5, [r0, #8]
 800a002:	4eac      	ldr	r6, [pc, #688]	; (800a2b4 <xmp3fixpt_FDCT32+0x380>)
 800a004:	fb86 3202 	smull	r3, r2, r6, r2
 800a008:	0052      	lsls	r2, r2, #1
 800a00a:	1865      	adds	r5, r4, r1
 800a00c:	1a63      	subs	r3, r4, r1
 800a00e:	6342      	str	r2, [r0, #52]	; 0x34
 800a010:	6485      	str	r5, [r0, #72]	; 0x48
 800a012:	fb86 2303 	smull	r2, r3, r6, r3
	D32FP(3, 1, 2, 1);
 800a016:	68c7      	ldr	r7, [r0, #12]
 800a018:	6f02      	ldr	r2, [r0, #112]	; 0x70
 800a01a:	6b05      	ldr	r5, [r0, #48]	; 0x30
 800a01c:	6cc6      	ldr	r6, [r0, #76]	; 0x4c
 800a01e:	49a6      	ldr	r1, [pc, #664]	; (800a2b8 <xmp3fixpt_FDCT32+0x384>)
	D32FP(2, 1, 3, 1);
 800a020:	005b      	lsls	r3, r3, #1
	D32FP(3, 1, 2, 1);
 800a022:	1abc      	subs	r4, r7, r2
	D32FP(2, 1, 3, 1);
 800a024:	6743      	str	r3, [r0, #116]	; 0x74
	D32FP(3, 1, 2, 1);
 800a026:	443a      	add	r2, r7
 800a028:	fb81 3404 	smull	r3, r4, r1, r4
 800a02c:	1ba9      	subs	r1, r5, r6
 800a02e:	19ab      	adds	r3, r5, r6
 800a030:	0064      	lsls	r4, r4, #1
 800a032:	4da2      	ldr	r5, [pc, #648]	; (800a2bc <xmp3fixpt_FDCT32+0x388>)
 800a034:	fb85 6101 	smull	r6, r1, r5, r1
 800a038:	18d5      	adds	r5, r2, r3
 800a03a:	0089      	lsls	r1, r1, #2
 800a03c:	1ad2      	subs	r2, r2, r3
 800a03e:	60c5      	str	r5, [r0, #12]
 800a040:	4e9f      	ldr	r6, [pc, #636]	; (800a2c0 <xmp3fixpt_FDCT32+0x38c>)
 800a042:	fb86 3202 	smull	r3, r2, r6, r2
 800a046:	0052      	lsls	r2, r2, #1
 800a048:	1865      	adds	r5, r4, r1
 800a04a:	1a63      	subs	r3, r4, r1
 800a04c:	6302      	str	r2, [r0, #48]	; 0x30
 800a04e:	64c5      	str	r5, [r0, #76]	; 0x4c
 800a050:	fb86 2303 	smull	r2, r3, r6, r3
	D32FP(4, 1, 2, 1);
 800a054:	6907      	ldr	r7, [r0, #16]
 800a056:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800a058:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 800a05a:	6d06      	ldr	r6, [r0, #80]	; 0x50
 800a05c:	4999      	ldr	r1, [pc, #612]	; (800a2c4 <xmp3fixpt_FDCT32+0x390>)
	D32FP(3, 1, 2, 1);
 800a05e:	005b      	lsls	r3, r3, #1
	D32FP(4, 1, 2, 1);
 800a060:	1abc      	subs	r4, r7, r2
	D32FP(3, 1, 2, 1);
 800a062:	6703      	str	r3, [r0, #112]	; 0x70
	D32FP(4, 1, 2, 1);
 800a064:	443a      	add	r2, r7
 800a066:	fb81 3404 	smull	r3, r4, r1, r4
 800a06a:	1ba9      	subs	r1, r5, r6
 800a06c:	19ab      	adds	r3, r5, r6
 800a06e:	0064      	lsls	r4, r4, #1
 800a070:	4d95      	ldr	r5, [pc, #596]	; (800a2c8 <xmp3fixpt_FDCT32+0x394>)
 800a072:	fb85 6101 	smull	r6, r1, r5, r1
 800a076:	18d5      	adds	r5, r2, r3
 800a078:	0089      	lsls	r1, r1, #2
 800a07a:	1ad2      	subs	r2, r2, r3
 800a07c:	6105      	str	r5, [r0, #16]
 800a07e:	4e93      	ldr	r6, [pc, #588]	; (800a2cc <xmp3fixpt_FDCT32+0x398>)
 800a080:	fb86 3202 	smull	r3, r2, r6, r2
 800a084:	0052      	lsls	r2, r2, #1
 800a086:	1865      	adds	r5, r4, r1
 800a088:	1a63      	subs	r3, r4, r1
 800a08a:	62c2      	str	r2, [r0, #44]	; 0x2c
 800a08c:	6505      	str	r5, [r0, #80]	; 0x50
 800a08e:	fb86 2303 	smull	r2, r3, r6, r3
	D32FP(5, 1, 1, 2);
 800a092:	6947      	ldr	r7, [r0, #20]
 800a094:	6e82      	ldr	r2, [r0, #104]	; 0x68
 800a096:	6a85      	ldr	r5, [r0, #40]	; 0x28
 800a098:	6d46      	ldr	r6, [r0, #84]	; 0x54
 800a09a:	498d      	ldr	r1, [pc, #564]	; (800a2d0 <xmp3fixpt_FDCT32+0x39c>)
	D32FP(4, 1, 2, 1);
 800a09c:	005b      	lsls	r3, r3, #1
	D32FP(5, 1, 1, 2);
 800a09e:	1abc      	subs	r4, r7, r2
	D32FP(4, 1, 2, 1);
 800a0a0:	66c3      	str	r3, [r0, #108]	; 0x6c
	D32FP(5, 1, 1, 2);
 800a0a2:	443a      	add	r2, r7
 800a0a4:	fb81 3404 	smull	r3, r4, r1, r4
 800a0a8:	1ba9      	subs	r1, r5, r6
 800a0aa:	19ab      	adds	r3, r5, r6
 800a0ac:	0064      	lsls	r4, r4, #1
 800a0ae:	4d89      	ldr	r5, [pc, #548]	; (800a2d4 <xmp3fixpt_FDCT32+0x3a0>)
 800a0b0:	fb85 6101 	smull	r6, r1, r5, r1
 800a0b4:	18d5      	adds	r5, r2, r3
 800a0b6:	0049      	lsls	r1, r1, #1
 800a0b8:	1ad2      	subs	r2, r2, r3
 800a0ba:	6145      	str	r5, [r0, #20]
 800a0bc:	4e86      	ldr	r6, [pc, #536]	; (800a2d8 <xmp3fixpt_FDCT32+0x3a4>)
 800a0be:	fb86 3202 	smull	r3, r2, r6, r2
 800a0c2:	0092      	lsls	r2, r2, #2
 800a0c4:	1865      	adds	r5, r4, r1
 800a0c6:	1a63      	subs	r3, r4, r1
 800a0c8:	6282      	str	r2, [r0, #40]	; 0x28
 800a0ca:	6545      	str	r5, [r0, #84]	; 0x54
 800a0cc:	fb86 2303 	smull	r2, r3, r6, r3
	D32FP(6, 1, 1, 2);
 800a0d0:	6987      	ldr	r7, [r0, #24]
 800a0d2:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800a0d4:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800a0d6:	6d86      	ldr	r6, [r0, #88]	; 0x58
 800a0d8:	4980      	ldr	r1, [pc, #512]	; (800a2dc <xmp3fixpt_FDCT32+0x3a8>)
	D32FP(5, 1, 1, 2);
 800a0da:	009b      	lsls	r3, r3, #2
	D32FP(6, 1, 1, 2);
 800a0dc:	1abc      	subs	r4, r7, r2
	D32FP(5, 1, 1, 2);
 800a0de:	6683      	str	r3, [r0, #104]	; 0x68
	D32FP(6, 1, 1, 2);
 800a0e0:	443a      	add	r2, r7
 800a0e2:	fb81 3404 	smull	r3, r4, r1, r4
 800a0e6:	1ba9      	subs	r1, r5, r6
 800a0e8:	19ab      	adds	r3, r5, r6
 800a0ea:	0064      	lsls	r4, r4, #1
 800a0ec:	4d7c      	ldr	r5, [pc, #496]	; (800a2e0 <xmp3fixpt_FDCT32+0x3ac>)
 800a0ee:	fb85 6101 	smull	r6, r1, r5, r1
 800a0f2:	18d5      	adds	r5, r2, r3
 800a0f4:	0049      	lsls	r1, r1, #1
 800a0f6:	1ad2      	subs	r2, r2, r3
 800a0f8:	6185      	str	r5, [r0, #24]
 800a0fa:	4e7a      	ldr	r6, [pc, #488]	; (800a2e4 <xmp3fixpt_FDCT32+0x3b0>)
 800a0fc:	fb86 3202 	smull	r3, r2, r6, r2
 800a100:	0092      	lsls	r2, r2, #2
 800a102:	1865      	adds	r5, r4, r1
 800a104:	1a63      	subs	r3, r4, r1
 800a106:	6242      	str	r2, [r0, #36]	; 0x24
 800a108:	6585      	str	r5, [r0, #88]	; 0x58
 800a10a:	fb86 2303 	smull	r2, r3, r6, r3
	D32FP(7, 1, 1, 4);
 800a10e:	69c7      	ldr	r7, [r0, #28]
 800a110:	6e02      	ldr	r2, [r0, #96]	; 0x60
 800a112:	6a05      	ldr	r5, [r0, #32]
 800a114:	6dc6      	ldr	r6, [r0, #92]	; 0x5c
 800a116:	4974      	ldr	r1, [pc, #464]	; (800a2e8 <xmp3fixpt_FDCT32+0x3b4>)
	D32FP(6, 1, 1, 2);
 800a118:	009b      	lsls	r3, r3, #2
	D32FP(7, 1, 1, 4);
 800a11a:	1abc      	subs	r4, r7, r2
	D32FP(6, 1, 1, 2);
 800a11c:	6643      	str	r3, [r0, #100]	; 0x64
	D32FP(7, 1, 1, 4);
 800a11e:	443a      	add	r2, r7
 800a120:	fb81 3404 	smull	r3, r4, r1, r4
 800a124:	1ba9      	subs	r1, r5, r6
 800a126:	19ab      	adds	r3, r5, r6
 800a128:	0064      	lsls	r4, r4, #1
 800a12a:	4d70      	ldr	r5, [pc, #448]	; (800a2ec <xmp3fixpt_FDCT32+0x3b8>)
 800a12c:	fb85 6101 	smull	r6, r1, r5, r1
 800a130:	18d5      	adds	r5, r2, r3
 800a132:	0049      	lsls	r1, r1, #1
 800a134:	1ad2      	subs	r2, r2, r3
 800a136:	61c5      	str	r5, [r0, #28]
 800a138:	4e6d      	ldr	r6, [pc, #436]	; (800a2f0 <xmp3fixpt_FDCT32+0x3bc>)
 800a13a:	fb86 3202 	smull	r3, r2, r6, r2
 800a13e:	0112      	lsls	r2, r2, #4
 800a140:	1865      	adds	r5, r4, r1
 800a142:	1a63      	subs	r3, r4, r1
 800a144:	6202      	str	r2, [r0, #32]
 800a146:	65c5      	str	r5, [r0, #92]	; 0x5c
 800a148:	fb86 2303 	smull	r2, r3, r6, r3
 800a14c:	011b      	lsls	r3, r3, #4
 800a14e:	6603      	str	r3, [r0, #96]	; 0x60
 800a150:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 800a2f8 <xmp3fixpt_FDCT32+0x3c4>
 800a154:	f8cd b010 	str.w	fp, [sp, #16]
 800a158:	f100 03a0 	add.w	r3, r0, #160	; 0xa0
 800a15c:	f100 0720 	add.w	r7, r0, #32
 800a160:	9005      	str	r0, [sp, #20]
 800a162:	9301      	str	r3, [sp, #4]

	/* second pass */
	for (i = 4; i > 0; i--) {
		a0 = buf[0]; 	    a7 = buf[7];		a3 = buf[3];	    a4 = buf[4];
 800a164:	f857 6c20 	ldr.w	r6, [r7, #-32]
 800a168:	f857 4c04 	ldr.w	r4, [r7, #-4]
 800a16c:	f857 5c14 	ldr.w	r5, [r7, #-20]
 800a170:	f857 1c10 	ldr.w	r1, [r7, #-16]
 800a174:	f8da 3060 	ldr.w	r3, [sl, #96]	; 0x60
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 800a178:	1b32      	subs	r2, r6, r4
 800a17a:	eb06 0904 	add.w	r9, r6, r4
 800a17e:	fb83 4202 	smull	r4, r2, r3, r2
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 800a182:	1a6b      	subs	r3, r5, r1
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 800a184:	0054      	lsls	r4, r2, #1
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 800a186:	440d      	add	r5, r1
 800a188:	f8da 2064 	ldr.w	r2, [sl, #100]	; 0x64
 800a18c:	fb82 1303 	smull	r1, r3, r2, r3
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800a190:	eba9 0105 	sub.w	r1, r9, r5
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 800a194:	00da      	lsls	r2, r3, #3
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800a196:	44a9      	add	r9, r5
 800a198:	f8da 5068 	ldr.w	r5, [sl, #104]	; 0x68
 800a19c:	fb85 3101 	smull	r3, r1, r5, r1
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800a1a0:	1aa3      	subs	r3, r4, r2
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800a1a2:	0049      	lsls	r1, r1, #1
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800a1a4:	4422      	add	r2, r4
 800a1a6:	fb85 4303 	smull	r4, r3, r5, r3

		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 800a1aa:	f857 4c1c 	ldr.w	r4, [r7, #-28]
 800a1ae:	f857 5c08 	ldr.w	r5, [r7, #-8]
 800a1b2:	f857 8c18 	ldr.w	r8, [r7, #-24]
 800a1b6:	f857 6c0c 	ldr.w	r6, [r7, #-12]
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 800a1ba:	eba4 0e05 	sub.w	lr, r4, r5
 800a1be:	4425      	add	r5, r4
 800a1c0:	f8da 406c 	ldr.w	r4, [sl, #108]	; 0x6c
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800a1c4:	005b      	lsls	r3, r3, #1
 800a1c6:	4620      	mov	r0, r4
 800a1c8:	fb80 4e0e 	smull	r4, lr, r0, lr
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 800a1cc:	eba8 0406 	sub.w	r4, r8, r6
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 800a1d0:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 800a1d4:	44b0      	add	r8, r6
 800a1d6:	f8da 6070 	ldr.w	r6, [sl, #112]	; 0x70
 800a1da:	fb86 c404 	smull	ip, r4, r6, r4
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800a1de:	eba5 0c08 	sub.w	ip, r5, r8
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 800a1e2:	0064      	lsls	r4, r4, #1
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800a1e4:	4445      	add	r5, r8
 800a1e6:	f8da 8074 	ldr.w	r8, [sl, #116]	; 0x74
 800a1ea:	fb88 6c0c 	smull	r6, ip, r8, ip
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 800a1ee:	ebae 0604 	sub.w	r6, lr, r4
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800a1f2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 800a1f6:	4474      	add	r4, lr
 800a1f8:	fb88 e606 	smull	lr, r6, r8, r6
 800a1fc:	483d      	ldr	r0, [pc, #244]	; (800a2f4 <xmp3fixpt_FDCT32+0x3c0>)

		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800a1fe:	eba9 0805 	sub.w	r8, r9, r5
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 800a202:	00b6      	lsls	r6, r6, #2
 800a204:	fb80 e808 	smull	lr, r8, r0, r8
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 800a208:	eba1 0e0c 	sub.w	lr, r1, ip
 800a20c:	fb80 be0e 	smull	fp, lr, r0, lr
 800a210:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800a214:	448c      	add	ip, r1
		buf[0] = b0;	    buf[1] = b1;
		buf[2] = b2 + b3;	buf[3] = b3;
 800a216:	44f4      	add	ip, lr
		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800a218:	444d      	add	r5, r9
 800a21a:	ea4f 0848 	mov.w	r8, r8, lsl #1

		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800a21e:	1b11      	subs	r1, r2, r4
		buf[2] = b2 + b3;	buf[3] = b3;
 800a220:	f847 cc18 	str.w	ip, [r7, #-24]
 800a224:	f847 ec14 	str.w	lr, [r7, #-20]
		buf[0] = b0;	    buf[1] = b1;
 800a228:	f847 5c20 	str.w	r5, [r7, #-32]
 800a22c:	f847 8c1c 	str.w	r8, [r7, #-28]
 800a230:	fb80 5101 	smull	r5, r1, r0, r1
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800a234:	1b9d      	subs	r5, r3, r6
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800a236:	0049      	lsls	r1, r1, #1
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800a238:	4433      	add	r3, r6
 800a23a:	fb80 6505 	smull	r6, r5, r0, r5
 800a23e:	006d      	lsls	r5, r5, #1
		b6 += b7;
 800a240:	442b      	add	r3, r5
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800a242:	4422      	add	r2, r4
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800a244:	441a      	add	r2, r3
		buf[6] = b5 + b6;	buf[7] = b7;
 800a246:	440b      	add	r3, r1
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800a248:	4429      	add	r1, r5
		buf[6] = b5 + b6;	buf[7] = b7;
 800a24a:	e907 002a 	stmdb	r7, {r1, r3, r5}
	for (i = 4; i > 0; i--) {
 800a24e:	9b01      	ldr	r3, [sp, #4]
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800a250:	f847 2c10 	str.w	r2, [r7, #-16]
 800a254:	3720      	adds	r7, #32
	for (i = 4; i > 0; i--) {
 800a256:	429f      	cmp	r7, r3
 800a258:	f10a 0a18 	add.w	sl, sl, #24
 800a25c:	d182      	bne.n	800a164 <xmp3fixpt_FDCT32+0x230>
		buf += 8;
	}
	buf -= 32;	/* reset */

	/* sample 0 - always delayed one block */
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a25e:	9902      	ldr	r1, [sp, #8]
 800a260:	9a03      	ldr	r2, [sp, #12]
 800a262:	f8dd b010 	ldr.w	fp, [sp, #16]
 800a266:	9805      	ldr	r0, [sp, #20]
 800a268:	1a8b      	subs	r3, r1, r2
 800a26a:	f003 0307 	and.w	r3, r3, #7
 800a26e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800a272:	009c      	lsls	r4, r3, #2
 800a274:	2a00      	cmp	r2, #0
 800a276:	f000 836a 	beq.w	800a94e <xmp3fixpt_FDCT32+0xa1a>
 800a27a:	9d00      	ldr	r5, [sp, #0]
	s = buf[ 0];				d[0] = d[8] = s;
    
	/* samples 16 to 31 */
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800a27c:	9a02      	ldr	r2, [sp, #8]
	s = buf[ 0];				d[0] = d[8] = s;
 800a27e:	6801      	ldr	r1, [r0, #0]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a280:	192e      	adds	r6, r5, r4
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800a282:	0092      	lsls	r2, r2, #2
	s = buf[ 0];				d[0] = d[8] = s;
 800a284:	6231      	str	r1, [r6, #32]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a286:	f04f 0e00 	mov.w	lr, #0
	s = buf[ 0];				d[0] = d[8] = s;
 800a28a:	f845 1023 	str.w	r1, [r5, r3, lsl #2]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800a28e:	f44f 5188 	mov.w	r1, #4352	; 0x1100
 800a292:	e033      	b.n	800a2fc <xmp3fixpt_FDCT32+0x3c8>
 800a294:	4013c251 	.word	0x4013c251
 800a298:	518522fb 	.word	0x518522fb
 800a29c:	404f4672 	.word	0x404f4672
 800a2a0:	40b345bd 	.word	0x40b345bd
 800a2a4:	6d0b20cf 	.word	0x6d0b20cf
 800a2a8:	42e13c10 	.word	0x42e13c10
 800a2ac:	41fa2d6d 	.word	0x41fa2d6d
 800a2b0:	41d95790 	.word	0x41d95790
 800a2b4:	48919f44 	.word	0x48919f44
 800a2b8:	43f93421 	.word	0x43f93421
 800a2bc:	5efc8d96 	.word	0x5efc8d96
 800a2c0:	52cb0e63 	.word	0x52cb0e63
 800a2c4:	46cc1bc4 	.word	0x46cc1bc4
 800a2c8:	4ad81a97 	.word	0x4ad81a97
 800a2cc:	64e2402e 	.word	0x64e2402e
 800a2d0:	4a9d9cf0 	.word	0x4a9d9cf0
 800a2d4:	7c7d1db3 	.word	0x7c7d1db3
 800a2d8:	43e224a9 	.word	0x43e224a9
 800a2dc:	4fae3711 	.word	0x4fae3711
 800a2e0:	6b6fcf26 	.word	0x6b6fcf26
 800a2e4:	6e3c92c1 	.word	0x6e3c92c1
 800a2e8:	56601ea7 	.word	0x56601ea7
 800a2ec:	5f4cf6eb 	.word	0x5f4cf6eb
 800a2f0:	519e4e04 	.word	0x519e4e04
 800a2f4:	5a82799a 	.word	0x5a82799a
 800a2f8:	08014bd8 	.word	0x08014bd8
 800a2fc:	4411      	add	r1, r2
 800a2fe:	186a      	adds	r2, r5, r1

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 800a300:	6843      	ldr	r3, [r0, #4]
 800a302:	6213      	str	r3, [r2, #32]
 800a304:	506b      	str	r3, [r5, r1]

	tmp = buf[25] + buf[29];
 800a306:	6e47      	ldr	r7, [r0, #100]	; 0x64
 800a308:	6f43      	ldr	r3, [r0, #116]	; 0x74
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800a30a:	6c45      	ldr	r5, [r0, #68]	; 0x44
	tmp = buf[25] + buf[29];
 800a30c:	443b      	add	r3, r7
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800a30e:	441d      	add	r5, r3
 800a310:	f8c2 5120 	str.w	r5, [r2, #288]	; 0x120
 800a314:	f8c2 5100 	str.w	r5, [r2, #256]	; 0x100
	s = buf[ 9] + buf[13];		d[0] = d[8] = s;	d += 64;
 800a318:	6b47      	ldr	r7, [r0, #52]	; 0x34
 800a31a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800a31c:	443d      	add	r5, r7
 800a31e:	f8c2 5220 	str.w	r5, [r2, #544]	; 0x220
 800a322:	f8c2 5200 	str.w	r5, [r2, #512]	; 0x200
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 800a326:	6d45      	ldr	r5, [r0, #84]	; 0x54
 800a328:	441d      	add	r5, r3
 800a32a:	f8c2 5320 	str.w	r5, [r2, #800]	; 0x320
 800a32e:	f8c2 5300 	str.w	r5, [r2, #768]	; 0x300

	tmp = buf[29] + buf[27];
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 800a332:	6945      	ldr	r5, [r0, #20]
	tmp = buf[29] + buf[27];
 800a334:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800a336:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 800a338:	f8c2 5420 	str.w	r5, [r2, #1056]	; 0x420
 800a33c:	f8c2 5400 	str.w	r5, [r2, #1024]	; 0x400
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 800a340:	6d45      	ldr	r5, [r0, #84]	; 0x54
	tmp = buf[29] + buf[27];
 800a342:	441f      	add	r7, r3
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 800a344:	197b      	adds	r3, r7, r5
 800a346:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
 800a34a:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
	s = buf[13] + buf[11];		d[0] = d[8] = s;	d += 64;
 800a34e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a350:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 800a352:	442b      	add	r3, r5
 800a354:	f8c2 3620 	str.w	r3, [r2, #1568]	; 0x620
 800a358:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 800a35c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800a35e:	443b      	add	r3, r7
 800a360:	f8c2 3720 	str.w	r3, [r2, #1824]	; 0x720
 800a364:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700

	tmp = buf[27] + buf[31];
 800a368:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800a36a:	6fc7      	ldr	r7, [r0, #124]	; 0x7c
	s = buf[ 3];				d[0] = d[8] = s;	d += 64;
 800a36c:	68c5      	ldr	r5, [r0, #12]
 800a36e:	f8c2 5820 	str.w	r5, [r2, #2080]	; 0x820
 800a372:	f8c2 5800 	str.w	r5, [r2, #2048]	; 0x800
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 800a376:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
	tmp = buf[27] + buf[31];
 800a378:	441f      	add	r7, r3
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 800a37a:	197b      	adds	r3, r7, r5
 800a37c:	f8c2 3920 	str.w	r3, [r2, #2336]	; 0x920
 800a380:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
	s = buf[11] + buf[15];		d[0] = d[8] = s;	d += 64;
 800a384:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 800a386:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800a388:	442b      	add	r3, r5
 800a38a:	f8c2 3a20 	str.w	r3, [r2, #2592]	; 0xa20
 800a38e:	f8c2 3a00 	str.w	r3, [r2, #2560]	; 0xa00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 800a392:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800a394:	443b      	add	r3, r7
 800a396:	f8c2 3b20 	str.w	r3, [r2, #2848]	; 0xb20
 800a39a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00

	tmp = buf[31];
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 800a39e:	69c3      	ldr	r3, [r0, #28]
	tmp = buf[31];
 800a3a0:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 800a3a2:	f8c2 3c20 	str.w	r3, [r2, #3104]	; 0xc20
 800a3a6:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 800a3aa:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800a3ac:	442b      	add	r3, r5
 800a3ae:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
 800a3b2:	f8c2 3d00 	str.w	r3, [r2, #3328]	; 0xd00
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 800a3b6:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
	s = tmp;					d[0] = d[8] = s;
 800a3b8:	f8c2 5f20 	str.w	r5, [r2, #3872]	; 0xf20
 800a3bc:	f8c2 5f00 	str.w	r5, [r2, #3840]	; 0xf00

	/* samples 16 to 1 (sample 16 used again) */
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a3c0:	f5a4 647c 	sub.w	r4, r4, #4032	; 0xfc0
 800a3c4:	9d00      	ldr	r5, [sp, #0]
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 800a3c6:	f8c2 3e20 	str.w	r3, [r2, #3616]	; 0xe20
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a3ca:	44a6      	add	lr, r4
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 800a3cc:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a3d0:	eb05 030e 	add.w	r3, r5, lr

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 800a3d4:	6844      	ldr	r4, [r0, #4]
 800a3d6:	621c      	str	r4, [r3, #32]
 800a3d8:	f845 400e 	str.w	r4, [r5, lr]

	tmp = buf[30] + buf[25];
 800a3dc:	6f87      	ldr	r7, [r0, #120]	; 0x78
 800a3de:	6e44      	ldr	r4, [r0, #100]	; 0x64
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800a3e0:	6c45      	ldr	r5, [r0, #68]	; 0x44
	tmp = buf[30] + buf[25];
 800a3e2:	443c      	add	r4, r7
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800a3e4:	4425      	add	r5, r4
 800a3e6:	f8c3 5120 	str.w	r5, [r3, #288]	; 0x120
 800a3ea:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
	s = buf[14] + buf[ 9];		d[0] = d[8] = s;	d += 64;
 800a3ee:	6a47      	ldr	r7, [r0, #36]	; 0x24
 800a3f0:	6b85      	ldr	r5, [r0, #56]	; 0x38
 800a3f2:	443d      	add	r5, r7
 800a3f4:	f8c3 5220 	str.w	r5, [r3, #544]	; 0x220
 800a3f8:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800a3fc:	6d85      	ldr	r5, [r0, #88]	; 0x58
 800a3fe:	4425      	add	r5, r4
 800a400:	f8c3 5320 	str.w	r5, [r3, #800]	; 0x320
 800a404:	f8c3 5300 	str.w	r5, [r3, #768]	; 0x300
	s = buf[ 6];				d[0] = d[8] = s;	d += 64;
 800a408:	6984      	ldr	r4, [r0, #24]
 800a40a:	f8c3 4420 	str.w	r4, [r3, #1056]	; 0x420
 800a40e:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400

	tmp = buf[26] + buf[30];
 800a412:	6e87      	ldr	r7, [r0, #104]	; 0x68
 800a414:	6f84      	ldr	r4, [r0, #120]	; 0x78
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800a416:	6d85      	ldr	r5, [r0, #88]	; 0x58
	tmp = buf[26] + buf[30];
 800a418:	443c      	add	r4, r7
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800a41a:	4425      	add	r5, r4
 800a41c:	f8c3 5520 	str.w	r5, [r3, #1312]	; 0x520
 800a420:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
	s = buf[10] + buf[14];		d[0] = d[8] = s;	d += 64;
 800a424:	6b87      	ldr	r7, [r0, #56]	; 0x38
 800a426:	6a85      	ldr	r5, [r0, #40]	; 0x28
 800a428:	443d      	add	r5, r7
 800a42a:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
 800a42e:	f8c3 5600 	str.w	r5, [r3, #1536]	; 0x600
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800a432:	6c85      	ldr	r5, [r0, #72]	; 0x48
 800a434:	4425      	add	r5, r4
 800a436:	f8c3 5720 	str.w	r5, [r3, #1824]	; 0x720
 800a43a:	f8c3 5700 	str.w	r5, [r3, #1792]	; 0x700
	s = buf[ 2];				d[0] = d[8] = s;	d += 64;
 800a43e:	6884      	ldr	r4, [r0, #8]
 800a440:	f8c3 4820 	str.w	r4, [r3, #2080]	; 0x820
 800a444:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800

	tmp = buf[28] + buf[26];
 800a448:	6f07      	ldr	r7, [r0, #112]	; 0x70
 800a44a:	6e84      	ldr	r4, [r0, #104]	; 0x68
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800a44c:	6c85      	ldr	r5, [r0, #72]	; 0x48
	tmp = buf[28] + buf[26];
 800a44e:	443c      	add	r4, r7
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800a450:	4425      	add	r5, r4
 800a452:	f8c3 5920 	str.w	r5, [r3, #2336]	; 0x920
 800a456:	f8c3 5900 	str.w	r5, [r3, #2304]	; 0x900
	s = buf[12] + buf[10];		d[0] = d[8] = s;	d += 64;
 800a45a:	6b05      	ldr	r5, [r0, #48]	; 0x30
 800a45c:	6a87      	ldr	r7, [r0, #40]	; 0x28
 800a45e:	443d      	add	r5, r7
 800a460:	f8c3 5a20 	str.w	r5, [r3, #2592]	; 0xa20
 800a464:	f8c3 5a00 	str.w	r5, [r3, #2560]	; 0xa00
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800a468:	6d05      	ldr	r5, [r0, #80]	; 0x50
 800a46a:	4425      	add	r5, r4
 800a46c:	f8c3 5b20 	str.w	r5, [r3, #2848]	; 0xb20
 800a470:	f8c3 5b00 	str.w	r5, [r3, #2816]	; 0xb00
	s = buf[ 4];				d[0] = d[8] = s;	d += 64;
 800a474:	6904      	ldr	r4, [r0, #16]
 800a476:	f8c3 4c20 	str.w	r4, [r3, #3104]	; 0xc20
 800a47a:	f8c3 4c00 	str.w	r4, [r3, #3072]	; 0xc00

	tmp = buf[24] + buf[28];
 800a47e:	6e07      	ldr	r7, [r0, #96]	; 0x60
 800a480:	6f04      	ldr	r4, [r0, #112]	; 0x70
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800a482:	6d05      	ldr	r5, [r0, #80]	; 0x50
	tmp = buf[24] + buf[28];
 800a484:	443c      	add	r4, r7
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800a486:	4425      	add	r5, r4
 800a488:	f8c3 5d20 	str.w	r5, [r3, #3360]	; 0xd20
 800a48c:	f8c3 5d00 	str.w	r5, [r3, #3328]	; 0xd00
	s = buf[ 8] + buf[12];		d[0] = d[8] = s;	d += 64;
 800a490:	6b07      	ldr	r7, [r0, #48]	; 0x30
 800a492:	6a05      	ldr	r5, [r0, #32]
 800a494:	443d      	add	r5, r7
 800a496:	f8c3 5e20 	str.w	r5, [r3, #3616]	; 0xe20
 800a49a:	f8c3 5e00 	str.w	r5, [r3, #3584]	; 0xe00
	s = buf[16] + tmp;			d[0] = d[8] = s;
 800a49e:	6c07      	ldr	r7, [r0, #64]	; 0x40
 800a4a0:	443c      	add	r4, r7
 800a4a2:	f8c3 4f20 	str.w	r4, [r3, #3872]	; 0xf20
 800a4a6:	f8c3 4f00 	str.w	r4, [r3, #3840]	; 0xf00

	/* this is so rarely invoked that it's not worth making two versions of the output
	 *   shuffle code (one for no shift, one for clip + variable shift) like in IMDCT
	 * here we just load, clip, shift, and store on the rare instances that es != 0
	 */
	if (es) {
 800a4aa:	f1bb 0f00 	cmp.w	fp, #0
 800a4ae:	f000 824b 	beq.w	800a948 <xmp3fixpt_FDCT32+0xa14>
		d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);
 800a4b2:	6830      	ldr	r0, [r6, #0]
 800a4b4:	f1cb 041f 	rsb	r4, fp, #31
 800a4b8:	17c5      	asrs	r5, r0, #31
 800a4ba:	fa40 f704 	asr.w	r7, r0, r4
 800a4be:	42bd      	cmp	r5, r7
 800a4c0:	d003      	beq.n	800a4ca <xmp3fixpt_FDCT32+0x596>
 800a4c2:	2001      	movs	r0, #1
 800a4c4:	40a0      	lsls	r0, r4
 800a4c6:	3801      	subs	r0, #1
 800a4c8:	4068      	eors	r0, r5
 800a4ca:	fa00 f00b 	lsl.w	r0, r0, fp
 800a4ce:	6230      	str	r0, [r6, #32]
 800a4d0:	6030      	str	r0, [r6, #0]
	
		d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
		for (i = 16; i <= 31; i++) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800a4d2:	9800      	ldr	r0, [sp, #0]
 800a4d4:	5845      	ldr	r5, [r0, r1]
 800a4d6:	2001      	movs	r0, #1
 800a4d8:	40a0      	lsls	r0, r4
 800a4da:	3801      	subs	r0, #1
 800a4dc:	17ee      	asrs	r6, r5, #31
 800a4de:	ea80 0706 	eor.w	r7, r0, r6
 800a4e2:	fa45 fc04 	asr.w	ip, r5, r4
 800a4e6:	4566      	cmp	r6, ip
 800a4e8:	bf18      	it	ne
 800a4ea:	463d      	movne	r5, r7
 800a4ec:	9e00      	ldr	r6, [sp, #0]
 800a4ee:	fa05 f50b 	lsl.w	r5, r5, fp
 800a4f2:	6215      	str	r5, [r2, #32]
 800a4f4:	5075      	str	r5, [r6, r1]
 800a4f6:	f8d2 7100 	ldr.w	r7, [r2, #256]	; 0x100
 800a4fa:	f8d2 6200 	ldr.w	r6, [r2, #512]	; 0x200
 800a4fe:	f8d2 5300 	ldr.w	r5, [r2, #768]	; 0x300
 800a502:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
 800a506:	f8d2 a500 	ldr.w	sl, [r2, #1280]	; 0x500
 800a50a:	ea4f 7ce7 	mov.w	ip, r7, asr #31
 800a50e:	ea80 080c 	eor.w	r8, r0, ip
 800a512:	fa47 f904 	asr.w	r9, r7, r4
 800a516:	45cc      	cmp	ip, r9
 800a518:	bf18      	it	ne
 800a51a:	4647      	movne	r7, r8
 800a51c:	fa07 f70b 	lsl.w	r7, r7, fp
 800a520:	ea4f 78e6 	mov.w	r8, r6, asr #31
 800a524:	ea80 0c08 	eor.w	ip, r0, r8
 800a528:	f8c2 7120 	str.w	r7, [r2, #288]	; 0x120
 800a52c:	f8c2 7100 	str.w	r7, [r2, #256]	; 0x100
 800a530:	fa46 f704 	asr.w	r7, r6, r4
 800a534:	45b8      	cmp	r8, r7
 800a536:	bf18      	it	ne
 800a538:	4666      	movne	r6, ip
 800a53a:	fa06 f60b 	lsl.w	r6, r6, fp
 800a53e:	ea4f 78e5 	mov.w	r8, r5, asr #31
 800a542:	ea80 0908 	eor.w	r9, r0, r8
 800a546:	f8c2 6220 	str.w	r6, [r2, #544]	; 0x220
 800a54a:	f8c2 6200 	str.w	r6, [r2, #512]	; 0x200
 800a54e:	fa45 f604 	asr.w	r6, r5, r4
 800a552:	45b0      	cmp	r8, r6
 800a554:	bf18      	it	ne
 800a556:	464d      	movne	r5, r9
 800a558:	17cf      	asrs	r7, r1, #31
 800a55a:	fa05 f50b 	lsl.w	r5, r5, fp
 800a55e:	ea80 0c07 	eor.w	ip, r0, r7
 800a562:	f8c2 5320 	str.w	r5, [r2, #800]	; 0x320
 800a566:	f8c2 5300 	str.w	r5, [r2, #768]	; 0x300
 800a56a:	fa41 f504 	asr.w	r5, r1, r4
 800a56e:	42af      	cmp	r7, r5
 800a570:	bf18      	it	ne
 800a572:	4661      	movne	r1, ip
 800a574:	fa01 f10b 	lsl.w	r1, r1, fp
 800a578:	ea4f 75ea 	mov.w	r5, sl, asr #31
 800a57c:	ea80 0805 	eor.w	r8, r0, r5
 800a580:	f8c2 1420 	str.w	r1, [r2, #1056]	; 0x420
 800a584:	f8c2 1400 	str.w	r1, [r2, #1024]	; 0x400
 800a588:	fa4a f104 	asr.w	r1, sl, r4
 800a58c:	f8d2 7600 	ldr.w	r7, [r2, #1536]	; 0x600
 800a590:	428d      	cmp	r5, r1
 800a592:	bf0c      	ite	eq
 800a594:	4651      	moveq	r1, sl
 800a596:	4641      	movne	r1, r8
 800a598:	f8d2 5700 	ldr.w	r5, [r2, #1792]	; 0x700
 800a59c:	17fe      	asrs	r6, r7, #31
 800a59e:	fa01 f10b 	lsl.w	r1, r1, fp
 800a5a2:	17ef      	asrs	r7, r5, #31
 800a5a4:	f8d2 5800 	ldr.w	r5, [r2, #2048]	; 0x800
 800a5a8:	f8c2 1520 	str.w	r1, [r2, #1312]	; 0x520
 800a5ac:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
 800a5b0:	f8d2 1600 	ldr.w	r1, [r2, #1536]	; 0x600
 800a5b4:	ea4f 7ae5 	mov.w	sl, r5, asr #31
 800a5b8:	f8d2 5600 	ldr.w	r5, [r2, #1536]	; 0x600
 800a5bc:	ea80 0c06 	eor.w	ip, r0, r6
 800a5c0:	4121      	asrs	r1, r4
 800a5c2:	428e      	cmp	r6, r1
 800a5c4:	bf18      	it	ne
 800a5c6:	4665      	movne	r5, ip
 800a5c8:	4629      	mov	r1, r5
 800a5ca:	fa01 f10b 	lsl.w	r1, r1, fp
 800a5ce:	f8d2 5900 	ldr.w	r5, [r2, #2304]	; 0x900
 800a5d2:	f8c2 1620 	str.w	r1, [r2, #1568]	; 0x620
 800a5d6:	f8c2 1600 	str.w	r1, [r2, #1536]	; 0x600
 800a5da:	f8d2 1700 	ldr.w	r1, [r2, #1792]	; 0x700
 800a5de:	ea4f 78e5 	mov.w	r8, r5, asr #31
 800a5e2:	f8d2 5700 	ldr.w	r5, [r2, #1792]	; 0x700
 800a5e6:	ea80 0907 	eor.w	r9, r0, r7
 800a5ea:	4121      	asrs	r1, r4
 800a5ec:	428f      	cmp	r7, r1
 800a5ee:	bf18      	it	ne
 800a5f0:	464d      	movne	r5, r9
 800a5f2:	46ac      	mov	ip, r5
 800a5f4:	f8d2 5800 	ldr.w	r5, [r2, #2048]	; 0x800
 800a5f8:	ea80 060a 	eor.w	r6, r0, sl
 800a5fc:	fa45 f704 	asr.w	r7, r5, r4
 800a600:	45ba      	cmp	sl, r7
 800a602:	bf18      	it	ne
 800a604:	4635      	movne	r5, r6
 800a606:	f8d2 7900 	ldr.w	r7, [r2, #2304]	; 0x900
 800a60a:	f8d2 ae00 	ldr.w	sl, [r2, #3584]	; 0xe00
 800a60e:	ea80 0608 	eor.w	r6, r0, r8
 800a612:	4639      	mov	r1, r7
 800a614:	4127      	asrs	r7, r4
 800a616:	45b8      	cmp	r8, r7
 800a618:	bf18      	it	ne
 800a61a:	4631      	movne	r1, r6
 800a61c:	4688      	mov	r8, r1
 800a61e:	fa08 f60b 	lsl.w	r6, r8, fp
 800a622:	f8c2 6920 	str.w	r6, [r2, #2336]	; 0x920
 800a626:	f8c2 6900 	str.w	r6, [r2, #2304]	; 0x900
 800a62a:	f8d2 6a00 	ldr.w	r6, [r2, #2560]	; 0xa00
 800a62e:	f8d2 7d00 	ldr.w	r7, [r2, #3328]	; 0xd00
 800a632:	fa0c f10b 	lsl.w	r1, ip, fp
 800a636:	fa05 f50b 	lsl.w	r5, r5, fp
 800a63a:	ea4f 7ce6 	mov.w	ip, r6, asr #31
 800a63e:	f8c2 5820 	str.w	r5, [r2, #2080]	; 0x820
 800a642:	f8c2 5800 	str.w	r5, [r2, #2048]	; 0x800
 800a646:	ea80 080c 	eor.w	r8, r0, ip
 800a64a:	f8d2 5b00 	ldr.w	r5, [r2, #2816]	; 0xb00
 800a64e:	f8c2 1720 	str.w	r1, [r2, #1824]	; 0x720
 800a652:	fa46 f904 	asr.w	r9, r6, r4
 800a656:	45cc      	cmp	ip, r9
 800a658:	bf18      	it	ne
 800a65a:	4646      	movne	r6, r8
 800a65c:	fa06 f60b 	lsl.w	r6, r6, fp
 800a660:	ea4f 78e5 	mov.w	r8, r5, asr #31
 800a664:	f8c2 1700 	str.w	r1, [r2, #1792]	; 0x700
 800a668:	f8c2 6a20 	str.w	r6, [r2, #2592]	; 0xa20
 800a66c:	f8d2 1c00 	ldr.w	r1, [r2, #3072]	; 0xc00
 800a670:	f8c2 6a00 	str.w	r6, [r2, #2560]	; 0xa00
 800a674:	ea80 0908 	eor.w	r9, r0, r8
 800a678:	fa45 f604 	asr.w	r6, r5, r4
 800a67c:	45b0      	cmp	r8, r6
 800a67e:	bf18      	it	ne
 800a680:	464d      	movne	r5, r9
 800a682:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 800a686:	fa05 f50b 	lsl.w	r5, r5, fp
 800a68a:	f8c2 5b20 	str.w	r5, [r2, #2848]	; 0xb20
 800a68e:	f8c2 5b00 	str.w	r5, [r2, #2816]	; 0xb00
 800a692:	ea80 090c 	eor.w	r9, r0, ip
 800a696:	fa41 f504 	asr.w	r5, r1, r4
 800a69a:	45ac      	cmp	ip, r5
 800a69c:	bf08      	it	eq
 800a69e:	4689      	moveq	r9, r1
 800a6a0:	f8d2 1f00 	ldr.w	r1, [r2, #3840]	; 0xf00
 800a6a4:	ea4f 78e7 	mov.w	r8, r7, asr #31
 800a6a8:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 800a6ac:	fa09 f10b 	lsl.w	r1, r9, fp
 800a6b0:	f8c2 1c20 	str.w	r1, [r2, #3104]	; 0xc20
 800a6b4:	f8c2 1c00 	str.w	r1, [r2, #3072]	; 0xc00
 800a6b8:	ea4f 76ea 	mov.w	r6, sl, asr #31
 800a6bc:	fa47 f104 	asr.w	r1, r7, r4
 800a6c0:	ea80 0508 	eor.w	r5, r0, r8
 800a6c4:	4588      	cmp	r8, r1
 800a6c6:	bf08      	it	eq
 800a6c8:	463d      	moveq	r5, r7
 800a6ca:	fa4a f704 	asr.w	r7, sl, r4
 800a6ce:	ea80 0106 	eor.w	r1, r0, r6
 800a6d2:	42be      	cmp	r6, r7
 800a6d4:	bf0c      	ite	eq
 800a6d6:	4656      	moveq	r6, sl
 800a6d8:	460e      	movne	r6, r1
 800a6da:	f8d2 7f00 	ldr.w	r7, [r2, #3840]	; 0xf00
 800a6de:	ea8c 0800 	eor.w	r8, ip, r0
 800a6e2:	4639      	mov	r1, r7
 800a6e4:	4127      	asrs	r7, r4
 800a6e6:	45bc      	cmp	ip, r7
 800a6e8:	bf18      	it	ne
 800a6ea:	4641      	movne	r1, r8
 800a6ec:	fa05 f50b 	lsl.w	r5, r5, fp
		}

		d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		for (i = 15; i >= 0; i--) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800a6f0:	9f00      	ldr	r7, [sp, #0]
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800a6f2:	f8c2 5d20 	str.w	r5, [r2, #3360]	; 0xd20
 800a6f6:	fa06 f60b 	lsl.w	r6, r6, fp
 800a6fa:	fa01 f10b 	lsl.w	r1, r1, fp
 800a6fe:	f8c2 5d00 	str.w	r5, [r2, #3328]	; 0xd00
 800a702:	f8c2 6e20 	str.w	r6, [r2, #3616]	; 0xe20
 800a706:	f8c2 6e00 	str.w	r6, [r2, #3584]	; 0xe00
 800a70a:	f8c2 1f20 	str.w	r1, [r2, #3872]	; 0xf20
 800a70e:	f8c2 1f00 	str.w	r1, [r2, #3840]	; 0xf00
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800a712:	f857 100e 	ldr.w	r1, [r7, lr]
 800a716:	17cd      	asrs	r5, r1, #31
 800a718:	fa41 f604 	asr.w	r6, r1, r4
 800a71c:	ea80 0205 	eor.w	r2, r0, r5
 800a720:	42ae      	cmp	r6, r5
 800a722:	bf08      	it	eq
 800a724:	460a      	moveq	r2, r1
 800a726:	fa02 f20b 	lsl.w	r2, r2, fp
 800a72a:	621a      	str	r2, [r3, #32]
 800a72c:	f847 200e 	str.w	r2, [r7, lr]
 800a730:	f8d3 5100 	ldr.w	r5, [r3, #256]	; 0x100
 800a734:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 800a738:	f8d3 e300 	ldr.w	lr, [r3, #768]	; 0x300
 800a73c:	f8d3 7400 	ldr.w	r7, [r3, #1024]	; 0x400
 800a740:	ea4f 7ce5 	mov.w	ip, r5, asr #31
 800a744:	17d1      	asrs	r1, r2, #31
 800a746:	fa45 f904 	asr.w	r9, r5, r4
 800a74a:	ea80 060c 	eor.w	r6, r0, ip
 800a74e:	ea4f 78ee 	mov.w	r8, lr, asr #31
 800a752:	45e1      	cmp	r9, ip
 800a754:	bf08      	it	eq
 800a756:	462e      	moveq	r6, r5
 800a758:	fa42 f904 	asr.w	r9, r2, r4
 800a75c:	ea80 0501 	eor.w	r5, r0, r1
 800a760:	ea4f 7ce7 	mov.w	ip, r7, asr #31
 800a764:	4589      	cmp	r9, r1
 800a766:	bf08      	it	eq
 800a768:	4615      	moveq	r5, r2
 800a76a:	fa4e f904 	asr.w	r9, lr, r4
 800a76e:	ea80 0108 	eor.w	r1, r0, r8
 800a772:	45c1      	cmp	r9, r8
 800a774:	bf08      	it	eq
 800a776:	4671      	moveq	r1, lr
 800a778:	ea80 020c 	eor.w	r2, r0, ip
 800a77c:	fa47 fe04 	asr.w	lr, r7, r4
 800a780:	45e6      	cmp	lr, ip
 800a782:	bf08      	it	eq
 800a784:	463a      	moveq	r2, r7
 800a786:	fa02 f20b 	lsl.w	r2, r2, fp
 800a78a:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
 800a78e:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
 800a792:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
 800a796:	f8d3 9600 	ldr.w	r9, [r3, #1536]	; 0x600
 800a79a:	f8d3 8700 	ldr.w	r8, [r3, #1792]	; 0x700
 800a79e:	f8d3 c800 	ldr.w	ip, [r3, #2048]	; 0x800
 800a7a2:	f8d3 e900 	ldr.w	lr, [r3, #2304]	; 0x900
 800a7a6:	f8d3 7a00 	ldr.w	r7, [r3, #2560]	; 0xa00
 800a7aa:	fa01 f10b 	lsl.w	r1, r1, fp
 800a7ae:	fa05 f50b 	lsl.w	r5, r5, fp
 800a7b2:	f8c3 1320 	str.w	r1, [r3, #800]	; 0x320
 800a7b6:	f8c3 1300 	str.w	r1, [r3, #768]	; 0x300
 800a7ba:	17d1      	asrs	r1, r2, #31
 800a7bc:	fa42 fa04 	asr.w	sl, r2, r4
 800a7c0:	f8c3 5220 	str.w	r5, [r3, #544]	; 0x220
 800a7c4:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
 800a7c8:	ea80 0501 	eor.w	r5, r0, r1
 800a7cc:	458a      	cmp	sl, r1
 800a7ce:	bf14      	ite	ne
 800a7d0:	4629      	movne	r1, r5
 800a7d2:	4611      	moveq	r1, r2
 800a7d4:	fa01 f10b 	lsl.w	r1, r1, fp
 800a7d8:	ea4f 7ae9 	mov.w	sl, r9, asr #31
 800a7dc:	ea80 050a 	eor.w	r5, r0, sl
 800a7e0:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
 800a7e4:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
 800a7e8:	fa49 f104 	asr.w	r1, r9, r4
 800a7ec:	4551      	cmp	r1, sl
 800a7ee:	bf08      	it	eq
 800a7f0:	464d      	moveq	r5, r9
 800a7f2:	fa05 f50b 	lsl.w	r5, r5, fp
 800a7f6:	ea4f 79e8 	mov.w	r9, r8, asr #31
 800a7fa:	ea80 0109 	eor.w	r1, r0, r9
 800a7fe:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
 800a802:	f8c3 5600 	str.w	r5, [r3, #1536]	; 0x600
 800a806:	fa48 f504 	asr.w	r5, r8, r4
 800a80a:	454d      	cmp	r5, r9
 800a80c:	bf18      	it	ne
 800a80e:	4688      	movne	r8, r1
 800a810:	ea4f 7aec 	mov.w	sl, ip, asr #31
 800a814:	fa08 f80b 	lsl.w	r8, r8, fp
 800a818:	ea80 010a 	eor.w	r1, r0, sl
 800a81c:	f8c3 8720 	str.w	r8, [r3, #1824]	; 0x720
 800a820:	f8c3 8700 	str.w	r8, [r3, #1792]	; 0x700
 800a824:	fa4c f804 	asr.w	r8, ip, r4
 800a828:	45d0      	cmp	r8, sl
 800a82a:	bf18      	it	ne
 800a82c:	468c      	movne	ip, r1
 800a82e:	ea4f 75ee 	mov.w	r5, lr, asr #31
 800a832:	fa0c fc0b 	lsl.w	ip, ip, fp
 800a836:	ea80 0105 	eor.w	r1, r0, r5
 800a83a:	f8c3 c820 	str.w	ip, [r3, #2080]	; 0x820
 800a83e:	f8c3 c800 	str.w	ip, [r3, #2048]	; 0x800
 800a842:	fa4e fc04 	asr.w	ip, lr, r4
 800a846:	45ac      	cmp	ip, r5
 800a848:	bf18      	it	ne
 800a84a:	468e      	movne	lr, r1
 800a84c:	f8d3 5c00 	ldr.w	r5, [r3, #3072]	; 0xc00
 800a850:	f8d3 2f00 	ldr.w	r2, [r3, #3840]	; 0xf00
 800a854:	9200      	str	r2, [sp, #0]
 800a856:	fa06 f60b 	lsl.w	r6, r6, fp
 800a85a:	fa0e fe0b 	lsl.w	lr, lr, fp
 800a85e:	ea4f 7ce5 	mov.w	ip, r5, asr #31
 800a862:	f8c3 6120 	str.w	r6, [r3, #288]	; 0x120
 800a866:	f8c3 6100 	str.w	r6, [r3, #256]	; 0x100
 800a86a:	f8d3 5d00 	ldr.w	r5, [r3, #3328]	; 0xd00
 800a86e:	f8d3 6b00 	ldr.w	r6, [r3, #2816]	; 0xb00
 800a872:	f8c3 e920 	str.w	lr, [r3, #2336]	; 0x920
 800a876:	f8c3 e900 	str.w	lr, [r3, #2304]	; 0x900
 800a87a:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	; 0xe00
 800a87e:	ea4f 79e7 	mov.w	r9, r7, asr #31
 800a882:	ea80 0109 	eor.w	r1, r0, r9
 800a886:	ea4f 7ae2 	mov.w	sl, r2, asr #31
 800a88a:	fa47 fe04 	asr.w	lr, r7, r4
 800a88e:	9a00      	ldr	r2, [sp, #0]
 800a890:	45ce      	cmp	lr, r9
 800a892:	bf18      	it	ne
 800a894:	460f      	movne	r7, r1
 800a896:	ea4f 78e6 	mov.w	r8, r6, asr #31
 800a89a:	fa07 f70b 	lsl.w	r7, r7, fp
 800a89e:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 800a8a2:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
 800a8a6:	f8c3 7a20 	str.w	r7, [r3, #2592]	; 0xa20
 800a8aa:	ea80 0108 	eor.w	r1, r0, r8
 800a8ae:	f8c3 7a00 	str.w	r7, [r3, #2560]	; 0xa00
 800a8b2:	fa46 f704 	asr.w	r7, r6, r4
 800a8b6:	4547      	cmp	r7, r8
 800a8b8:	bf08      	it	eq
 800a8ba:	4631      	moveq	r1, r6
 800a8bc:	fa42 f904 	asr.w	r9, r2, r4
 800a8c0:	ea8c 0700 	eor.w	r7, ip, r0
 800a8c4:	45e1      	cmp	r9, ip
 800a8c6:	bf18      	it	ne
 800a8c8:	463a      	movne	r2, r7
 800a8ca:	4694      	mov	ip, r2
 800a8cc:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 800a8d0:	17ed      	asrs	r5, r5, #31
 800a8d2:	ea85 0600 	eor.w	r6, r5, r0
 800a8d6:	fa42 f704 	asr.w	r7, r2, r4
 800a8da:	42af      	cmp	r7, r5
 800a8dc:	bf18      	it	ne
 800a8de:	4632      	movne	r2, r6
 800a8e0:	4615      	mov	r5, r2
 800a8e2:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	; 0xe00
 800a8e6:	fa42 f704 	asr.w	r7, r2, r4
 800a8ea:	9a00      	ldr	r2, [sp, #0]
 800a8ec:	fa42 f404 	asr.w	r4, r2, r4
 800a8f0:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	; 0xe00
 800a8f4:	ea80 060a 	eor.w	r6, r0, sl
 800a8f8:	4557      	cmp	r7, sl
 800a8fa:	bf18      	it	ne
 800a8fc:	4632      	movne	r2, r6
 800a8fe:	4692      	mov	sl, r2
 800a900:	9a00      	ldr	r2, [sp, #0]
 800a902:	ea80 000e 	eor.w	r0, r0, lr
 800a906:	45a6      	cmp	lr, r4
 800a908:	bf18      	it	ne
 800a90a:	4602      	movne	r2, r0
 800a90c:	fa01 f10b 	lsl.w	r1, r1, fp
 800a910:	fa0c f70b 	lsl.w	r7, ip, fp
 800a914:	fa05 f50b 	lsl.w	r5, r5, fp
 800a918:	fa0a f00b 	lsl.w	r0, sl, fp
 800a91c:	fa02 f20b 	lsl.w	r2, r2, fp
 800a920:	f8c3 1b20 	str.w	r1, [r3, #2848]	; 0xb20
 800a924:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
 800a928:	f8c3 7c20 	str.w	r7, [r3, #3104]	; 0xc20
 800a92c:	f8c3 7c00 	str.w	r7, [r3, #3072]	; 0xc00
 800a930:	f8c3 5d20 	str.w	r5, [r3, #3360]	; 0xd20
 800a934:	f8c3 5d00 	str.w	r5, [r3, #3328]	; 0xd00
 800a938:	f8c3 0e20 	str.w	r0, [r3, #3616]	; 0xe20
 800a93c:	f8c3 0e00 	str.w	r0, [r3, #3584]	; 0xe00
 800a940:	f8c3 2f20 	str.w	r2, [r3, #3872]	; 0xf20
 800a944:	f8c3 2f00 	str.w	r2, [r3, #3840]	; 0xf00
		}
	}
}
 800a948:	b007      	add	sp, #28
 800a94a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a94e:	9f00      	ldr	r7, [sp, #0]
	s = buf[ 0];				d[0] = d[8] = s;
 800a950:	6805      	ldr	r5, [r0, #0]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a952:	f504 5388 	add.w	r3, r4, #4352	; 0x1100
 800a956:	4611      	mov	r1, r2
 800a958:	18fe      	adds	r6, r7, r3
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800a95a:	9a02      	ldr	r2, [sp, #8]
	s = buf[ 0];				d[0] = d[8] = s;
 800a95c:	6235      	str	r5, [r6, #32]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800a95e:	0092      	lsls	r2, r2, #2
	s = buf[ 0];				d[0] = d[8] = s;
 800a960:	50fd      	str	r5, [r7, r3]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800a962:	f44f 5e88 	mov.w	lr, #4352	; 0x1100
 800a966:	463d      	mov	r5, r7
 800a968:	e4c8      	b.n	800a2fc <xmp3fixpt_FDCT32+0x3c8>
	es = 0;
 800a96a:	f04f 0b00 	mov.w	fp, #0
 800a96e:	f7ff baf7 	b.w	8009f60 <xmp3fixpt_FDCT32+0x2c>
 800a972:	bf00      	nop

0800a974 <xmp3fixpt_Dequantize>:
	HuffmanInfo *hi;
	DequantInfo *di;
	CriticalBandInfo *cbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800a974:	2800      	cmp	r0, #0
 800a976:	f000 812f 	beq.w	800abd8 <xmp3fixpt_Dequantize+0x264>
{
 800a97a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800a97e:	f8d0 a000 	ldr.w	sl, [r0]
{
 800a982:	b08f      	sub	sp, #60	; 0x3c
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800a984:	f1ba 0f00 	cmp.w	sl, #0
 800a988:	f000 8123 	beq.w	800abd2 <xmp3fixpt_Dequantize+0x25e>
 800a98c:	6843      	ldr	r3, [r0, #4]
 800a98e:	9307      	str	r3, [sp, #28]
 800a990:	2b00      	cmp	r3, #0
 800a992:	f000 811e 	beq.w	800abd2 <xmp3fixpt_Dequantize+0x25e>
 800a996:	6883      	ldr	r3, [r0, #8]
 800a998:	9308      	str	r3, [sp, #32]
 800a99a:	2b00      	cmp	r3, #0
 800a99c:	f000 8119 	beq.w	800abd2 <xmp3fixpt_Dequantize+0x25e>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 800a9a0:	68c5      	ldr	r5, [r0, #12]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800a9a2:	2d00      	cmp	r5, #0
 800a9a4:	f000 8115 	beq.w	800abd2 <xmp3fixpt_Dequantize+0x25e>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 800a9a8:	6903      	ldr	r3, [r0, #16]
 800a9aa:	9306      	str	r3, [sp, #24]
 800a9ac:	461a      	mov	r2, r3
 800a9ae:	2b00      	cmp	r3, #0
 800a9b0:	f000 810f 	beq.w	800abd2 <xmp3fixpt_Dequantize+0x25e>
	di = (DequantInfo *)mp3DecInfo->DequantInfoPS;
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800a9b4:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	; 0x7bc
 800a9b8:	910a      	str	r1, [sp, #40]	; 0x28
	mOut[0] = mOut[1] = 0;
 800a9ba:	2600      	movs	r6, #0
	cbi = di->cbi;
 800a9bc:	f502 7246 	add.w	r2, r2, #792	; 0x318
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800a9c0:	42b3      	cmp	r3, r6
	mOut[0] = mOut[1] = 0;
 800a9c2:	960d      	str	r6, [sp, #52]	; 0x34
 800a9c4:	960c      	str	r6, [sp, #48]	; 0x30
	cbi = di->cbi;
 800a9c6:	9209      	str	r2, [sp, #36]	; 0x24
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800a9c8:	dd2f      	ble.n	800aa2a <xmp3fixpt_Dequantize+0xb6>
 800a9ca:	9b07      	ldr	r3, [sp, #28]
 800a9cc:	950b      	str	r5, [sp, #44]	; 0x2c
 800a9ce:	eb01 08c1 	add.w	r8, r1, r1, lsl #3
 800a9d2:	eb03 1808 	add.w	r8, r3, r8, lsl #4
 800a9d6:	9b08      	ldr	r3, [sp, #32]
 800a9d8:	ebc1 1741 	rsb	r7, r1, r1, lsl #5
 800a9dc:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 800a9e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a9e2:	f505 5990 	add.w	r9, r5, #4608	; 0x1200
 800a9e6:	f108 0828 	add.w	r8, r8, #40	; 0x28
 800a9ea:	46ab      	mov	fp, r5
 800a9ec:	4644      	mov	r4, r8
 800a9ee:	f109 0908 	add.w	r9, r9, #8
 800a9f2:	461d      	mov	r5, r3
 800a9f4:	4680      	mov	r8, r0
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh,
 800a9f6:	e88d 0090 	stmia.w	sp, {r4, r7}
 800a9fa:	9502      	str	r5, [sp, #8]
 800a9fc:	4653      	mov	r3, sl
 800a9fe:	f1a9 0208 	sub.w	r2, r9, #8
 800aa02:	4658      	mov	r0, fp
 800aa04:	9906      	ldr	r1, [sp, #24]
 800aa06:	f000 f9d5 	bl	800adb4 <xmp3fixpt_DequantChannel>
 800aa0a:	f849 0b04 	str.w	r0, [r9], #4
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800aa0e:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800aa12:	3601      	adds	r6, #1
 800aa14:	42b3      	cmp	r3, r6
 800aa16:	f104 0448 	add.w	r4, r4, #72	; 0x48
 800aa1a:	f107 073e 	add.w	r7, r7, #62	; 0x3e
 800aa1e:	f105 0518 	add.w	r5, r5, #24
 800aa22:	f50b 6b10 	add.w	fp, fp, #2304	; 0x900
 800aa26:	dce6      	bgt.n	800a9f6 <xmp3fixpt_Dequantize+0x82>
 800aa28:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
	/* joint stereo processing assumes one guard bit in input samples
	 * it's extremely rare not to have at least one gb, so if this is the case
	 *   just make a pass over the data and clip to [-2^30+1, 2^30-1]
	 * in practice this may never happen
	 */
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
 800aa2a:	f8da 0020 	ldr.w	r0, [sl, #32]
 800aa2e:	2800      	cmp	r0, #0
 800aa30:	d06d      	beq.n	800ab0e <xmp3fixpt_Dequantize+0x19a>
 800aa32:	f241 2308 	movw	r3, #4616	; 0x1208
 800aa36:	58eb      	ldr	r3, [r5, r3]
 800aa38:	2b00      	cmp	r3, #0
 800aa3a:	f340 8088 	ble.w	800ab4e <xmp3fixpt_Dequantize+0x1da>
 800aa3e:	f241 230c 	movw	r3, #4620	; 0x120c
 800aa42:	58eb      	ldr	r3, [r5, r3]
 800aa44:	2b00      	cmp	r3, #0
 800aa46:	f340 8082 	ble.w	800ab4e <xmp3fixpt_Dequantize+0x1da>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
		}
	}

	/* do mid-side stereo processing, if enabled */
	if (fh->modeExt >> 1) {
 800aa4a:	0843      	lsrs	r3, r0, #1
 800aa4c:	f000 80c7 	beq.w	800abde <xmp3fixpt_Dequantize+0x26a>
		if (fh->modeExt & 0x01) {
 800aa50:	07c2      	lsls	r2, r0, #31
 800aa52:	d50d      	bpl.n	800aa70 <xmp3fixpt_Dequantize+0xfc>
			/* intensity stereo enabled - run mid-side up to start of right zero region */
			if (cbi[1].cbType == 0)
 800aa54:	9a06      	ldr	r2, [sp, #24]
 800aa56:	f8d2 3330 	ldr.w	r3, [r2, #816]	; 0x330
 800aa5a:	2b00      	cmp	r3, #0
 800aa5c:	f040 80ae 	bne.w	800abbc <xmp3fixpt_Dequantize+0x248>
				nSamps = fh->sfBand->l[cbi[1].cbEndL + 1];
 800aa60:	f8d2 3344 	ldr.w	r3, [r2, #836]	; 0x344
 800aa64:	f8da 2034 	ldr.w	r2, [sl, #52]	; 0x34
 800aa68:	3301      	adds	r3, #1
 800aa6a:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800aa6e:	e008      	b.n	800aa82 <xmp3fixpt_Dequantize+0x10e>
			else 
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
		} else {
			/* intensity stereo disabled - run mid-side on whole spectrum */
			nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800aa70:	f241 2204 	movw	r2, #4612	; 0x1204
 800aa74:	f505 5390 	add.w	r3, r5, #4608	; 0x1200
 800aa78:	58a9      	ldr	r1, [r5, r2]
 800aa7a:	681b      	ldr	r3, [r3, #0]
 800aa7c:	4299      	cmp	r1, r3
 800aa7e:	bfb8      	it	lt
 800aa80:	4619      	movlt	r1, r3
		}
		MidSideProc(hi->huffDecBuf, nSamps, mOut);
 800aa82:	ac0c      	add	r4, sp, #48	; 0x30
 800aa84:	4628      	mov	r0, r5
 800aa86:	4622      	mov	r2, r4
 800aa88:	f004 fa6e 	bl	800ef68 <xmp3fixpt_MidSideProc>
 800aa8c:	f8da 0020 	ldr.w	r0, [sl, #32]
	}

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
 800aa90:	07c3      	lsls	r3, r0, #31
 800aa92:	d520      	bpl.n	800aad6 <xmp3fixpt_Dequantize+0x162>
		nSamps = hi->nonZeroBound[0];
 800aa94:	f505 5390 	add.w	r3, r5, #4608	; 0x1200
		if (fh->ver == MPEG1) {
 800aa98:	f89a 2000 	ldrb.w	r2, [sl]
		nSamps = hi->nonZeroBound[0];
 800aa9c:	6819      	ldr	r1, [r3, #0]
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 800aa9e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		if (fh->ver == MPEG1) {
 800aaa0:	2a00      	cmp	r2, #0
 800aaa2:	d137      	bne.n	800ab14 <xmp3fixpt_Dequantize+0x1a0>
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 800aaa4:	9b07      	ldr	r3, [sp, #28]
 800aaa6:	9403      	str	r4, [sp, #12]
 800aaa8:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
 800aaac:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800aab0:	ebc6 1346 	rsb	r3, r6, r6, lsl #5
 800aab4:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800aab8:	9202      	str	r2, [sp, #8]
 800aaba:	9a08      	ldr	r2, [sp, #32]
 800aabc:	1040      	asrs	r0, r0, #1
 800aabe:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800aac2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800aac4:	9001      	str	r0, [sp, #4]
 800aac6:	9200      	str	r2, [sp, #0]
 800aac8:	4628      	mov	r0, r5
 800aaca:	333e      	adds	r3, #62	; 0x3e
 800aacc:	4652      	mov	r2, sl
 800aace:	f004 fa7d 	bl	800efcc <xmp3fixpt_IntensityProcMPEG1>
 800aad2:	f8da 0020 	ldr.w	r0, [sl, #32]
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		}
	}

	/* adjust guard bit count and nonZeroBound if we did any stereo processing */
	if (fh->modeExt) {
 800aad6:	b1d0      	cbz	r0, 800ab0e <xmp3fixpt_Dequantize+0x19a>
		hi->gb[0] = CLZ(mOut[0]) - 1;
		hi->gb[1] = CLZ(mOut[1]) - 1;
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800aad8:	f241 2404 	movw	r4, #4612	; 0x1204
 800aadc:	f505 5690 	add.w	r6, r5, #4608	; 0x1200
 800aae0:	5929      	ldr	r1, [r5, r4]
 800aae2:	6830      	ldr	r0, [r6, #0]
while (!(x & 0x80000000)) {
numZeros++;
x <
}*/

	__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 800aae4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800aae6:	fab3 f383 	clz	r3, r3
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800aaea:	f241 2e08 	movw	lr, #4616	; 0x1208
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800aaee:	4281      	cmp	r1, r0
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800aaf0:	f241 270c 	movw	r7, #4620	; 0x120c
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800aaf4:	bfb8      	it	lt
 800aaf6:	4601      	movlt	r1, r0
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800aaf8:	1e5a      	subs	r2, r3, #1
 800aafa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800aafc:	fab3 f383 	clz	r3, r3
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800ab00:	3b01      	subs	r3, #1
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800ab02:	f845 200e 	str.w	r2, [r5, lr]
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800ab06:	51eb      	str	r3, [r5, r7]
		hi->nonZeroBound[0] = nSamps;
 800ab08:	6031      	str	r1, [r6, #0]
		hi->nonZeroBound[1] = nSamps;
 800ab0a:	5129      	str	r1, [r5, r4]
	}

	/* output format Q(DQ_FRACBITS_OUT) */
	return 0;
 800ab0c:	2000      	movs	r0, #0
}
 800ab0e:	b00f      	add	sp, #60	; 0x3c
 800ab10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 800ab14:	9b07      	ldr	r3, [sp, #28]
 800ab16:	9404      	str	r4, [sp, #16]
 800ab18:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
 800ab1c:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800ab20:	9c08      	ldr	r4, [sp, #32]
 800ab22:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800ab26:	9203      	str	r2, [sp, #12]
 800ab28:	4622      	mov	r2, r4
 800ab2a:	32f8      	adds	r2, #248	; 0xf8
 800ab2c:	ebc6 1346 	rsb	r3, r6, r6, lsl #5
 800ab30:	1040      	asrs	r0, r0, #1
 800ab32:	9201      	str	r2, [sp, #4]
 800ab34:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800ab38:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ab3a:	9002      	str	r0, [sp, #8]
 800ab3c:	9200      	str	r2, [sp, #0]
 800ab3e:	4628      	mov	r0, r5
 800ab40:	333e      	adds	r3, #62	; 0x3e
 800ab42:	4652      	mov	r2, sl
 800ab44:	f004 fbec 	bl	800f320 <xmp3fixpt_IntensityProcMPEG2>
 800ab48:	f8da 0020 	ldr.w	r0, [sl, #32]
 800ab4c:	e7c3      	b.n	800aad6 <xmp3fixpt_Dequantize+0x162>
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800ab4e:	f505 5390 	add.w	r3, r5, #4608	; 0x1200
 800ab52:	681c      	ldr	r4, [r3, #0]
 800ab54:	2c00      	cmp	r4, #0
 800ab56:	dd14      	ble.n	800ab82 <xmp3fixpt_Dequantize+0x20e>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800ab58:	4922      	ldr	r1, [pc, #136]	; (800abe4 <xmp3fixpt_Dequantize+0x270>)
 800ab5a:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 800ab5e:	462b      	mov	r3, r5
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 800ab60:	f06f 4640 	mvn.w	r6, #3221225472	; 0xc0000000
 800ab64:	e003      	b.n	800ab6e <xmp3fixpt_Dequantize+0x1fa>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800ab66:	6019      	str	r1, [r3, #0]
 800ab68:	3304      	adds	r3, #4
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800ab6a:	429c      	cmp	r4, r3
 800ab6c:	d009      	beq.n	800ab82 <xmp3fixpt_Dequantize+0x20e>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800ab6e:	681a      	ldr	r2, [r3, #0]
 800ab70:	428a      	cmp	r2, r1
 800ab72:	dbf8      	blt.n	800ab66 <xmp3fixpt_Dequantize+0x1f2>
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 800ab74:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800ab78:	bfa8      	it	ge
 800ab7a:	601e      	strge	r6, [r3, #0]
 800ab7c:	3304      	adds	r3, #4
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800ab7e:	429c      	cmp	r4, r3
 800ab80:	d1f5      	bne.n	800ab6e <xmp3fixpt_Dequantize+0x1fa>
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 800ab82:	f241 2304 	movw	r3, #4612	; 0x1204
 800ab86:	58eb      	ldr	r3, [r5, r3]
 800ab88:	2b00      	cmp	r3, #0
 800ab8a:	f77f af5e 	ble.w	800aa4a <xmp3fixpt_Dequantize+0xd6>
 800ab8e:	f503 7310 	add.w	r3, r3, #576	; 0x240
 800ab92:	eb05 0483 	add.w	r4, r5, r3, lsl #2
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 800ab96:	4913      	ldr	r1, [pc, #76]	; (800abe4 <xmp3fixpt_Dequantize+0x270>)
 800ab98:	f505 6310 	add.w	r3, r5, #2304	; 0x900
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 800ab9c:	f06f 4640 	mvn.w	r6, #3221225472	; 0xc0000000
 800aba0:	e004      	b.n	800abac <xmp3fixpt_Dequantize+0x238>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 800aba2:	6019      	str	r1, [r3, #0]
 800aba4:	3304      	adds	r3, #4
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 800aba6:	429c      	cmp	r4, r3
 800aba8:	f43f af4f 	beq.w	800aa4a <xmp3fixpt_Dequantize+0xd6>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 800abac:	681a      	ldr	r2, [r3, #0]
 800abae:	428a      	cmp	r2, r1
 800abb0:	dbf7      	blt.n	800aba2 <xmp3fixpt_Dequantize+0x22e>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 800abb2:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800abb6:	bfa8      	it	ge
 800abb8:	601e      	strge	r6, [r3, #0]
 800abba:	e7f3      	b.n	800aba4 <xmp3fixpt_Dequantize+0x230>
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
 800abbc:	f8d2 2340 	ldr.w	r2, [r2, #832]	; 0x340
 800abc0:	f8da 3034 	ldr.w	r3, [sl, #52]	; 0x34
 800abc4:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800abc8:	f9b3 1030 	ldrsh.w	r1, [r3, #48]	; 0x30
 800abcc:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800abd0:	e757      	b.n	800aa82 <xmp3fixpt_Dequantize+0x10e>
		return -1;
 800abd2:	f04f 30ff 	mov.w	r0, #4294967295
 800abd6:	e79a      	b.n	800ab0e <xmp3fixpt_Dequantize+0x19a>
 800abd8:	f04f 30ff 	mov.w	r0, #4294967295
 800abdc:	4770      	bx	lr
 800abde:	2001      	movs	r0, #1
 800abe0:	ac0c      	add	r4, sp, #48	; 0x30
 800abe2:	e757      	b.n	800aa94 <xmp3fixpt_Dequantize+0x120>
 800abe4:	c0000001 	.word	0xc0000001

0800abe8 <DequantBlock>:
 * Outputs:     dequantized samples in Q25 format
 *
 * Return:      bitwise-OR of the unsigned outputs (for guard bit calculations)
 **************************************************************************************/
static int DequantBlock(int *inbuf, int *outbuf, int num, int scale)
{
 800abe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int mask = 0;
	const int *tab16, *coef;

	tab16 = pow43_14[scale & 0x3];
	scalef = pow14[scale & 0x3];
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800abec:	ea4f 0ca3 	mov.w	ip, r3, asr #2
	tab16 = pow43_14[scale & 0x3];
 800abf0:	f003 0403 	and.w	r4, r3, #3
	scalef = pow14[scale & 0x3];
 800abf4:	4b64      	ldr	r3, [pc, #400]	; (800ad88 <DequantBlock+0x1a0>)
 800abf6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
{
 800abfa:	b089      	sub	sp, #36	; 0x24
	scalef = pow14[scale & 0x3];
 800abfc:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800ac00:	9302      	str	r3, [sp, #8]
	tab16 = pow43_14[scale & 0x3];
 800ac02:	4b61      	ldr	r3, [pc, #388]	; (800ad88 <DequantBlock+0x1a0>)
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800ac04:	f1bc 0f1f 	cmp.w	ip, #31
 800ac08:	bfa8      	it	ge
 800ac0a:	f04f 0c1f 	movge.w	ip, #31
	tab16 = pow43_14[scale & 0x3];
 800ac0e:	eb03 1b84 	add.w	fp, r3, r4, lsl #6

	/* cache first 4 values */
	shift = MIN(scalei + 3, 31);
 800ac12:	f1bc 0f1b 	cmp.w	ip, #27
 800ac16:	bfd8      	it	le
 800ac18:	f10c 0503 	addle.w	r5, ip, #3
{
 800ac1c:	4606      	mov	r6, r0
	shift = MAX(shift, 0);
	tab4[0] = 0;
	tab4[1] = tab16[1] >> shift;
 800ac1e:	f8db 4004 	ldr.w	r4, [fp, #4]
	tab4[2] = tab16[2] >> shift;
 800ac22:	f8db 0008 	ldr.w	r0, [fp, #8]
	tab4[3] = tab16[3] >> shift;
 800ac26:	f8db 300c 	ldr.w	r3, [fp, #12]
 800ac2a:	bfd4      	ite	le
 800ac2c:	ea25 75e5 	bicle.w	r5, r5, r5, asr #31
 800ac30:	251f      	movgt	r5, #31
	tab4[2] = tab16[2] >> shift;
 800ac32:	fa40 f705 	asr.w	r7, r0, r5
	tab4[1] = tab16[1] >> shift;
 800ac36:	412c      	asrs	r4, r5
	tab4[3] = tab16[3] >> shift;
 800ac38:	412b      	asrs	r3, r5
	tab4[0] = 0;
 800ac3a:	2000      	movs	r0, #0
 800ac3c:	3904      	subs	r1, #4
	tab4[1] = tab16[1] >> shift;
 800ac3e:	9405      	str	r4, [sp, #20]
	tab4[2] = tab16[2] >> shift;
 800ac40:	9706      	str	r7, [sp, #24]
	tab4[3] = tab16[3] >> shift;
 800ac42:	9307      	str	r3, [sp, #28]
	tab4[0] = 0;
 800ac44:	9004      	str	r0, [sp, #16]
	int mask = 0;
 800ac46:	46e0      	mov	r8, ip
 800ac48:	e00e      	b.n	800ac68 <DequantBlock+0x80>
		sx = *inbuf++;
		x = sx & 0x7fffffff;	/* sx = sign|mag */

		if (x < 4) {

			y = tab4[x];
 800ac4a:	ac08      	add	r4, sp, #32
 800ac4c:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800ac50:	f855 4c10 	ldr.w	r4, [r5, #-16]
			}
		}

		/* sign and store */
		mask |= y;
		*outbuf++ = (sx < 0) ? -y : y;
 800ac54:	2b00      	cmp	r3, #0
		mask |= y;
 800ac56:	ea40 0004 	orr.w	r0, r0, r4
		*outbuf++ = (sx < 0) ? -y : y;
 800ac5a:	bfb8      	it	lt
 800ac5c:	4264      	neglt	r4, r4

	} while (--num);
 800ac5e:	3a01      	subs	r2, #1
		*outbuf++ = (sx < 0) ? -y : y;
 800ac60:	f841 4f04 	str.w	r4, [r1, #4]!
	} while (--num);
 800ac64:	f000 8088 	beq.w	800ad78 <DequantBlock+0x190>
		sx = *inbuf++;
 800ac68:	f856 3b04 	ldr.w	r3, [r6], #4
		x = sx & 0x7fffffff;	/* sx = sign|mag */
 800ac6c:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
		if (x < 4) {
 800ac70:	2d03      	cmp	r5, #3
 800ac72:	ddea      	ble.n	800ac4a <DequantBlock+0x62>
		} else if (x < 16) {
 800ac74:	2d0f      	cmp	r5, #15
 800ac76:	dc0a      	bgt.n	800ac8e <DequantBlock+0xa6>
			y = tab16[x];
 800ac78:	f85b 4025 	ldr.w	r4, [fp, r5, lsl #2]
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 800ac7c:	f1b8 0f00 	cmp.w	r8, #0
 800ac80:	bfba      	itte	lt
 800ac82:	f1c8 0500 	rsblt	r5, r8, #0
 800ac86:	40ac      	lsllt	r4, r5
 800ac88:	fa44 f408 	asrge.w	r4, r4, r8
 800ac8c:	e7e2      	b.n	800ac54 <DequantBlock+0x6c>
			if (x < 64) {
 800ac8e:	2d3f      	cmp	r5, #63	; 0x3f
 800ac90:	dc0f      	bgt.n	800acb2 <DequantBlock+0xca>
				y = pow43[x-16];
 800ac92:	4c3d      	ldr	r4, [pc, #244]	; (800ad88 <DequantBlock+0x1a0>)
 800ac94:	eb04 0585 	add.w	r5, r4, r5, lsl #2
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800ac98:	9c02      	ldr	r4, [sp, #8]
 800ac9a:	f8d5 50d0 	ldr.w	r5, [r5, #208]	; 0xd0
 800ac9e:	fb85 7404 	smull	r7, r4, r5, r4
 800aca2:	4627      	mov	r7, r4
				shift = scalei - 3;
 800aca4:	f1a8 0403 	sub.w	r4, r8, #3
			if (shift < 0) {
 800aca8:	2c00      	cmp	r4, #0
 800acaa:	db5a      	blt.n	800ad62 <DequantBlock+0x17a>
				y >>= shift;
 800acac:	fa47 f404 	asr.w	r4, r7, r4
 800acb0:	e7d0      	b.n	800ac54 <DequantBlock+0x6c>
				x <<= 17;
 800acb2:	046c      	lsls	r4, r5, #17
				if (x < 0x08000000)
 800acb4:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
 800acb8:	da61      	bge.n	800ad7e <DequantBlock+0x196>
					x <<= 4, shift += 4;
 800acba:	2704      	movs	r7, #4
 800acbc:	056c      	lsls	r4, r5, #21
 800acbe:	9701      	str	r7, [sp, #4]
 800acc0:	2506      	movs	r5, #6
				if (x < 0x20000000)
 800acc2:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
					x <<= 2, shift += 2;
 800acc6:	bfbc      	itt	lt
 800acc8:	00a4      	lsllt	r4, r4, #2
 800acca:	9501      	strlt	r5, [sp, #4]
				if (x < 0x40000000)
 800accc:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 800acd0:	da03      	bge.n	800acda <DequantBlock+0xf2>
					x <<= 1, shift += 1;
 800acd2:	9d01      	ldr	r5, [sp, #4]
 800acd4:	3501      	adds	r5, #1
 800acd6:	0064      	lsls	r4, r4, #1
 800acd8:	9501      	str	r5, [sp, #4]
				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 800acda:	4d2c      	ldr	r5, [pc, #176]	; (800ad8c <DequantBlock+0x1a4>)
 800acdc:	4f2c      	ldr	r7, [pc, #176]	; (800ad90 <DequantBlock+0x1a8>)
 800acde:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 800adac <DequantBlock+0x1c4>
 800ace2:	f8df e0cc 	ldr.w	lr, [pc, #204]	; 800adb0 <DequantBlock+0x1c8>
 800ace6:	42ac      	cmp	r4, r5
 800ace8:	4d2a      	ldr	r5, [pc, #168]	; (800ad94 <DequantBlock+0x1ac>)
 800acea:	bfc8      	it	gt
 800acec:	463d      	movgt	r5, r7
 800acee:	4f2a      	ldr	r7, [pc, #168]	; (800ad98 <DequantBlock+0x1b0>)
 800acf0:	9503      	str	r5, [sp, #12]
 800acf2:	bfd8      	it	le
 800acf4:	46b9      	movle	r9, r7
 800acf6:	4f29      	ldr	r7, [pc, #164]	; (800ad9c <DequantBlock+0x1b4>)
 800acf8:	4d29      	ldr	r5, [pc, #164]	; (800ada0 <DequantBlock+0x1b8>)
 800acfa:	bfd8      	it	le
 800acfc:	46ba      	movle	sl, r7
 800acfe:	4f29      	ldr	r7, [pc, #164]	; (800ada4 <DequantBlock+0x1bc>)
 800ad00:	bfc8      	it	gt
 800ad02:	46a9      	movgt	r9, r5
 800ad04:	f105 55f9 	add.w	r5, r5, #522190848	; 0x1f200000
 800ad08:	bfd8      	it	le
 800ad0a:	46bc      	movle	ip, r7
 800ad0c:	f505 25ce 	add.w	r5, r5, #421888	; 0x67000
 800ad10:	4f25      	ldr	r7, [pc, #148]	; (800ada8 <DequantBlock+0x1c0>)
 800ad12:	f205 159b 	addw	r5, r5, #411	; 0x19b
 800ad16:	bfcc      	ite	gt
 800ad18:	46aa      	movgt	sl, r5
 800ad1a:	46be      	movle	lr, r7
 800ad1c:	4625      	mov	r5, r4
 800ad1e:	fb8e 7505 	smull	r7, r5, lr, r5
				y = MULSHIFT32(y, x) + coef[1];
 800ad22:	4465      	add	r5, ip
 800ad24:	46a6      	mov	lr, r4
 800ad26:	fb85 ce0e 	smull	ip, lr, r5, lr
				y = MULSHIFT32(y, x) + coef[2];
 800ad2a:	44f2      	add	sl, lr
 800ad2c:	4625      	mov	r5, r4
 800ad2e:	fb8a e505 	smull	lr, r5, sl, r5
				y = MULSHIFT32(y, x) + coef[3];
 800ad32:	44a9      	add	r9, r5
 800ad34:	fb89 5404 	smull	r5, r4, r9, r4
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 800ad38:	4f13      	ldr	r7, [pc, #76]	; (800ad88 <DequantBlock+0x1a0>)
 800ad3a:	9d01      	ldr	r5, [sp, #4]
 800ad3c:	eb07 0785 	add.w	r7, r7, r5, lsl #2
				y = MULSHIFT32(y, x) + coef[4];
 800ad40:	9d03      	ldr	r5, [sp, #12]
 800ad42:	442c      	add	r4, r5
 800ad44:	f8d7 51d0 	ldr.w	r5, [r7, #464]	; 0x1d0
 800ad48:	fb84 e505 	smull	lr, r5, r4, r5
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 800ad4c:	00ed      	lsls	r5, r5, #3
 800ad4e:	9c02      	ldr	r4, [sp, #8]
 800ad50:	fb85 e404 	smull	lr, r4, r5, r4
				shift = scalei - pow2exp[shift];
 800ad54:	f8d7 51f0 	ldr.w	r5, [r7, #496]	; 0x1f0
 800ad58:	4627      	mov	r7, r4
 800ad5a:	eba8 0405 	sub.w	r4, r8, r5
			if (shift < 0) {
 800ad5e:	2c00      	cmp	r4, #0
 800ad60:	daa4      	bge.n	800acac <DequantBlock+0xc4>
				shift = -shift;
 800ad62:	4265      	negs	r5, r4
				if (y > (0x7fffffff >> shift))
 800ad64:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 800ad68:	fa44 fe05 	asr.w	lr, r4, r5
 800ad6c:	4577      	cmp	r7, lr
 800ad6e:	f73f af71 	bgt.w	800ac54 <DequantBlock+0x6c>
					y <<= shift;
 800ad72:	fa07 f405 	lsl.w	r4, r7, r5
 800ad76:	e76d      	b.n	800ac54 <DequantBlock+0x6c>

	return mask;
}
 800ad78:	b009      	add	sp, #36	; 0x24
 800ad7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				shift = 0;
 800ad7e:	2700      	movs	r7, #0
 800ad80:	2502      	movs	r5, #2
 800ad82:	9701      	str	r7, [sp, #4]
 800ad84:	e79d      	b.n	800acc2 <DequantBlock+0xda>
 800ad86:	bf00      	nop
 800ad88:	08014c98 	.word	0x08014c98
 800ad8c:	5a827999 	.word	0x5a827999
 800ad90:	fef577b4 	.word	0xfef577b4
 800ad94:	ff581859 	.word	0xff581859
 800ad98:	236c498d 	.word	0x236c498d
 800ad9c:	5957aa1b 	.word	0x5957aa1b
 800ada0:	27c2cef0 	.word	0x27c2cef0
 800ada4:	b02e4828 	.word	0xb02e4828
 800ada8:	29a0bda9 	.word	0x29a0bda9
 800adac:	d333f6a4 	.word	0xd333f6a4
 800adb0:	10852163 	.word	0x10852163

0800adb4 <xmp3fixpt_DequantChannel>:
 *
 * Notes:       dequantized samples in Q(DQ_FRACBITS_OUT) format 
 **************************************************************************************/
int DequantChannel(int *sampleBuf, int *workBuf, int *nonZeroBound, FrameHeader *fh, SideInfoSub *sis, 
					ScaleFactorInfoSub *sfis, CriticalBandInfo *cbi)
{
 800adb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800adb8:	b091      	sub	sp, #68	; 0x44
	int globalGain, gainI;
	int cbMax[3];
	ARRAY3 *buf;    /* short block reorder */
	
	/* set default start/end points for short/long blocks - will update with non-zero cb info */
	if (sis->blockType == 2) {
 800adba:	9c1a      	ldr	r4, [sp, #104]	; 0x68
{
 800adbc:	9007      	str	r0, [sp, #28]
	if (sis->blockType == 2) {
 800adbe:	6964      	ldr	r4, [r4, #20]
{
 800adc0:	9108      	str	r1, [sp, #32]
	if (sis->blockType == 2) {
 800adc2:	2c02      	cmp	r4, #2
{
 800adc4:	9206      	str	r2, [sp, #24]
 800adc6:	9305      	str	r3, [sp, #20]
	if (sis->blockType == 2) {
 800adc8:	f000 80f6 	beq.w	800afb8 <xmp3fixpt_DequantChannel+0x204>
		cbEndS = 13;
	} else {
		/* long block */
		cbStartL = 0;
		cbEndL =   22;
		cbStartS = 13;
 800adcc:	230d      	movs	r3, #13
 800adce:	9303      	str	r3, [sp, #12]
		cbEndL =   22;
 800add0:	f04f 0916 	mov.w	r9, #22

	/* sfactScale = 0 --> quantizer step size = 2
	 * sfactScale = 1 --> quantizer step size = sqrt(2)
	 *   so sfactMultiplier = 2 or 4 (jump through globalGain by powers of 2 or sqrt(2))
	 */
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800add4:	9b1a      	ldr	r3, [sp, #104]	; 0x68
	/* offset globalGain by -2 if midSide enabled, for 1/sqrt(2) used in MidSideProc()
	 *  (DequantBlock() does 0.25 * gainI so knocking it down by two is the same as 
	 *   dividing every sample by sqrt(2) = multiplying by 2^-.5)
	 */
	globalGain = sis->globalGain;
	if (fh->modeExt >> 1)
 800add6:	9a05      	ldr	r2, [sp, #20]
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800add8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	if (fh->modeExt >> 1)
 800adda:	6a11      	ldr	r1, [r2, #32]
	globalGain = sis->globalGain;
 800addc:	9a1a      	ldr	r2, [sp, #104]	; 0x68
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800adde:	3301      	adds	r3, #1
 800ade0:	005b      	lsls	r3, r3, #1
	cbMax[2] = cbMax[1] = cbMax[0] = 0;
 800ade2:	2000      	movs	r0, #0
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800ade4:	9301      	str	r3, [sp, #4]
	if (fh->modeExt >> 1)
 800ade6:	084b      	lsrs	r3, r1, #1
	globalGain = sis->globalGain;
 800ade8:	6892      	ldr	r2, [r2, #8]
	cbMax[2] = cbMax[1] = cbMax[0] = 0;
 800adea:	900d      	str	r0, [sp, #52]	; 0x34
	if (fh->modeExt >> 1)
 800adec:	d100      	bne.n	800adf0 <xmp3fixpt_DequantChannel+0x3c>
		 globalGain -= 2;
	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */
 800adee:	3202      	adds	r2, #2
 800adf0:	f1c2 03d2 	rsb	r3, r2, #210	; 0xd2
 800adf4:	9300      	str	r3, [sp, #0]
 800adf6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800adf8:	f8cd 9008 	str.w	r9, [sp, #8]
{
 800adfc:	f04f 0b00 	mov.w	fp, #0
	/* long blocks */
	for (cb = 0; cb < cbEndL; cb++) {

		nonZero = 0;
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800ae00:	f8df 8240 	ldr.w	r8, [pc, #576]	; 800b044 <xmp3fixpt_DequantChannel+0x290>
 800ae04:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
{
 800ae08:	465d      	mov	r5, fp
 800ae0a:	46da      	mov	sl, fp
 800ae0c:	1e5f      	subs	r7, r3, #1
 800ae0e:	e002      	b.n	800ae16 <xmp3fixpt_DequantChannel+0x62>
	for (cb = 0; cb < cbEndL; cb++) {
 800ae10:	9b02      	ldr	r3, [sp, #8]
 800ae12:	429e      	cmp	r6, r3
 800ae14:	da29      	bge.n	800ae6a <xmp3fixpt_DequantChannel+0xb6>
 800ae16:	9b05      	ldr	r3, [sp, #20]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800ae18:	f8d9 103c 	ldr.w	r1, [r9, #60]	; 0x3c
 800ae1c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ae1e:	f817 0f01 	ldrb.w	r0, [r7, #1]!
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800ae22:	f932 4015 	ldrsh.w	r4, [r2, r5, lsl #1]
 800ae26:	eb02 0245 	add.w	r2, r2, r5, lsl #1
 800ae2a:	1c6e      	adds	r6, r5, #1
 800ae2c:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 800ae30:	460b      	mov	r3, r1
 800ae32:	1b14      	subs	r4, r2, r4
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800ae34:	eb08 0206 	add.w	r2, r8, r6
 800ae38:	b109      	cbz	r1, 800ae3e <xmp3fixpt_DequantChannel+0x8a>
 800ae3a:	f812 3c01 	ldrb.w	r3, [r2, #-1]

		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800ae3e:	9a07      	ldr	r2, [sp, #28]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800ae40:	4403      	add	r3, r0
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800ae42:	eb02 018a 	add.w	r1, r2, sl, lsl #2
 800ae46:	e89d 0005 	ldmia.w	sp, {r0, r2}
 800ae4a:	fb02 0303 	mla	r3, r2, r3, r0
 800ae4e:	4622      	mov	r2, r4
 800ae50:	4608      	mov	r0, r1
 800ae52:	f7ff fec9 	bl	800abe8 <DequantBlock>
		i += nSamps;
 800ae56:	44a2      	add	sl, r4

		/* update highest non-zero critical band */
		if (nonZero) 
			cbMax[0] = cb;
		gbMask |= nonZero;
 800ae58:	ea4b 0b00 	orr.w	fp, fp, r0
		if (nonZero) 
 800ae5c:	b100      	cbz	r0, 800ae60 <xmp3fixpt_DequantChannel+0xac>
			cbMax[0] = cb;
 800ae5e:	950d      	str	r5, [sp, #52]	; 0x34

		if (i >= *nonZeroBound) 
 800ae60:	9b06      	ldr	r3, [sp, #24]
 800ae62:	681b      	ldr	r3, [r3, #0]
 800ae64:	459a      	cmp	sl, r3
 800ae66:	4635      	mov	r5, r6
 800ae68:	dbd2      	blt.n	800ae10 <xmp3fixpt_DequantChannel+0x5c>
			break;
	}

	/* set cbi (Type, EndS[], EndSMax will be overwritten if we proceed to do short blocks) */
	cbi->cbType = 0;			/* long only */
	cbi->cbEndL  = cbMax[0];
 800ae6a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800ae6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ae6e:	6153      	str	r3, [r2, #20]
	cbi->cbType = 0;			/* long only */
 800ae70:	2300      	movs	r3, #0
 800ae72:	6013      	str	r3, [r2, #0]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800ae74:	60d3      	str	r3, [r2, #12]
 800ae76:	6093      	str	r3, [r2, #8]
 800ae78:	6053      	str	r3, [r2, #4]
	cbi->cbEndSMax = 0;
 800ae7a:	6113      	str	r3, [r2, #16]

	/* early exit if no short blocks */
	if (cbStartS >= 12) 
 800ae7c:	9b03      	ldr	r3, [sp, #12]
 800ae7e:	2b0b      	cmp	r3, #11
 800ae80:	dc70      	bgt.n	800af64 <xmp3fixpt_DequantChannel+0x1b0>
 800ae82:	9903      	ldr	r1, [sp, #12]
		return CLZ(gbMask) - 1;
	
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 800ae84:	910d      	str	r1, [sp, #52]	; 0x34
 800ae86:	004b      	lsls	r3, r1, #1
 800ae88:	185a      	adds	r2, r3, r1
 800ae8a:	910e      	str	r1, [sp, #56]	; 0x38
 800ae8c:	910f      	str	r1, [sp, #60]	; 0x3c
 800ae8e:	991b      	ldr	r1, [sp, #108]	; 0x6c

			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);

			/* update highest non-zero critical band */
			if (nonZero)
				cbMax[w] = cb;
 800ae90:	f8cd a008 	str.w	sl, [sp, #8]
 800ae94:	3217      	adds	r2, #23
 800ae96:	188a      	adds	r2, r1, r2
 800ae98:	9204      	str	r2, [sp, #16]
 800ae9a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800ae9c:	4651      	mov	r1, sl
 800ae9e:	3228      	adds	r2, #40	; 0x28
 800aea0:	f8dd a010 	ldr.w	sl, [sp, #16]
 800aea4:	920b      	str	r2, [sp, #44]	; 0x2c
 800aea6:	4658      	mov	r0, fp
 800aea8:	4693      	mov	fp, r2
 800aeaa:	9a05      	ldr	r2, [sp, #20]
 800aeac:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800aeb0:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800aeb2:	4413      	add	r3, r2
 800aeb4:	9a07      	ldr	r2, [sp, #28]
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800aeb6:	f9b3 6030 	ldrsh.w	r6, [r3, #48]	; 0x30
 800aeba:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
 800aebe:	1af6      	subs	r6, r6, r3
 800aec0:	9b03      	ldr	r3, [sp, #12]
 800aec2:	eb02 0481 	add.w	r4, r2, r1, lsl #2
 800aec6:	3301      	adds	r3, #1
 800aec8:	46a1      	mov	r9, r4
		for (w = 0; w < 3; w++) {
 800aeca:	9409      	str	r4, [sp, #36]	; 0x24
 800aecc:	00b5      	lsls	r5, r6, #2
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800aece:	930a      	str	r3, [sp, #40]	; 0x28
		for (w = 0; w < 3; w++) {
 800aed0:	2700      	movs	r7, #0
 800aed2:	4604      	mov	r4, r0
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 800aed4:	9900      	ldr	r1, [sp, #0]
 800aed6:	f85b 3b04 	ldr.w	r3, [fp], #4
 800aeda:	f81a 2b01 	ldrb.w	r2, [sl], #1
 800aede:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800aee2:	9901      	ldr	r1, [sp, #4]
 800aee4:	4648      	mov	r0, r9
 800aee6:	fb01 3302 	mla	r3, r1, r2, r3
 800aeea:	4641      	mov	r1, r8
 800aeec:	4632      	mov	r2, r6
 800aeee:	f7ff fe7b 	bl	800abe8 <DequantBlock>
 800aef2:	44a9      	add	r9, r5
			gbMask |= nonZero;
 800aef4:	4304      	orrs	r4, r0
 800aef6:	44a8      	add	r8, r5
			if (nonZero)
 800aef8:	b118      	cbz	r0, 800af02 <xmp3fixpt_DequantChannel+0x14e>
				cbMax[w] = cb;
 800aefa:	aa0d      	add	r2, sp, #52	; 0x34
 800aefc:	9b03      	ldr	r3, [sp, #12]
 800aefe:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
		for (w = 0; w < 3; w++) {
 800af02:	3701      	adds	r7, #1
 800af04:	2f03      	cmp	r7, #3
 800af06:	d1e5      	bne.n	800aed4 <xmp3fixpt_DequantChannel+0x120>
		}

		/* reorder blocks */
		buf = (ARRAY3 *)(sampleBuf + i);
		i += 3*nSamps;
 800af08:	9a02      	ldr	r2, [sp, #8]
 800af0a:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 800af0e:	441a      	add	r2, r3
		for (j = 0; j < nSamps; j++) {
 800af10:	2e00      	cmp	r6, #0
 800af12:	4620      	mov	r0, r4
		i += 3*nSamps;
 800af14:	9202      	str	r2, [sp, #8]
 800af16:	9c09      	ldr	r4, [sp, #36]	; 0x24
		for (j = 0; j < nSamps; j++) {
 800af18:	dd12      	ble.n	800af40 <xmp3fixpt_DequantChannel+0x18c>
 800af1a:	9a08      	ldr	r2, [sp, #32]
 800af1c:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
 800af20:	4415      	add	r5, r2
 800af22:	4631      	mov	r1, r6
 800af24:	1f13      	subs	r3, r2, #4
			buf[j][0] = workBuf[0*nSamps + j];
 800af26:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800af2a:	6022      	str	r2, [r4, #0]
			buf[j][1] = workBuf[1*nSamps + j];
 800af2c:	f855 2b04 	ldr.w	r2, [r5], #4
 800af30:	6062      	str	r2, [r4, #4]
			buf[j][2] = workBuf[2*nSamps + j];
 800af32:	f856 2b04 	ldr.w	r2, [r6], #4
 800af36:	60a2      	str	r2, [r4, #8]
		for (j = 0; j < nSamps; j++) {
 800af38:	42a9      	cmp	r1, r5
 800af3a:	f104 040c 	add.w	r4, r4, #12
 800af3e:	d1f2      	bne.n	800af26 <xmp3fixpt_DequantChannel+0x172>
		}

		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);

		if (i >= *nonZeroBound) 
 800af40:	9b06      	ldr	r3, [sp, #24]
 800af42:	9a02      	ldr	r2, [sp, #8]
 800af44:	681b      	ldr	r3, [r3, #0]
 800af46:	429a      	cmp	r2, r3
 800af48:	da33      	bge.n	800afb2 <xmp3fixpt_DequantChannel+0x1fe>
 800af4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800af4c:	9a04      	ldr	r2, [sp, #16]
 800af4e:	9303      	str	r3, [sp, #12]
 800af50:	3203      	adds	r2, #3
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800af52:	2b0d      	cmp	r3, #13
 800af54:	9204      	str	r2, [sp, #16]
 800af56:	d00b      	beq.n	800af70 <xmp3fixpt_DequantChannel+0x1bc>
 800af58:	005b      	lsls	r3, r3, #1
 800af5a:	9902      	ldr	r1, [sp, #8]
 800af5c:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800af60:	4692      	mov	sl, r2
 800af62:	e7a2      	b.n	800aeaa <xmp3fixpt_DequantChannel+0xf6>
	__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 800af64:	fabb f08b 	clz	r0, fp
		return CLZ(gbMask) - 1;
 800af68:	3801      	subs	r0, #1
	cbi->cbEndSMax = cbMax[0];
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);

	return CLZ(gbMask) - 1;
}
 800af6a:	b011      	add	sp, #68	; 0x44
 800af6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800af70:	f8dd a008 	ldr.w	sl, [sp, #8]
 800af74:	4683      	mov	fp, r0
	*nonZeroBound = i;
 800af76:	9b06      	ldr	r3, [sp, #24]
	cbi->cbEndS[1] = cbMax[1];
 800af78:	990e      	ldr	r1, [sp, #56]	; 0x38
	*nonZeroBound = i;
 800af7a:	f8c3 a000 	str.w	sl, [r3]
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800af7e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
	cbi->cbEndS[0] = cbMax[0];
 800af80:	9c1c      	ldr	r4, [sp, #112]	; 0x70
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800af82:	6998      	ldr	r0, [r3, #24]
	cbi->cbEndS[0] = cbMax[0];
 800af84:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cbi->cbEndS[2] = cbMax[2];
 800af86:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
	cbi->cbEndS[0] = cbMax[0];
 800af88:	6063      	str	r3, [r4, #4]
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800af8a:	2800      	cmp	r0, #0
 800af8c:	bf0c      	ite	eq
 800af8e:	2001      	moveq	r0, #1
 800af90:	2002      	movne	r0, #2
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
 800af92:	428b      	cmp	r3, r1
 800af94:	bfb8      	it	lt
 800af96:	460b      	movlt	r3, r1
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 800af98:	4293      	cmp	r3, r2
 800af9a:	bfb8      	it	lt
 800af9c:	4613      	movlt	r3, r2
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800af9e:	6020      	str	r0, [r4, #0]
 800afa0:	fabb f08b 	clz	r0, fp
	return CLZ(gbMask) - 1;
 800afa4:	3801      	subs	r0, #1
	cbi->cbEndS[1] = cbMax[1];
 800afa6:	60a1      	str	r1, [r4, #8]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 800afa8:	6123      	str	r3, [r4, #16]
	cbi->cbEndS[2] = cbMax[2];
 800afaa:	60e2      	str	r2, [r4, #12]
}
 800afac:	b011      	add	sp, #68	; 0x44
 800afae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800afb2:	4692      	mov	sl, r2
 800afb4:	4683      	mov	fp, r0
 800afb6:	e7de      	b.n	800af76 <xmp3fixpt_DequantChannel+0x1c2>
		if (sis->mixedBlock) { 
 800afb8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800afba:	f8d3 a018 	ldr.w	sl, [r3, #24]
 800afbe:	f1ba 0f00 	cmp.w	sl, #0
 800afc2:	d11e      	bne.n	800b002 <xmp3fixpt_DequantChannel+0x24e>
	if (fh->modeExt >> 1)
 800afc4:	9a05      	ldr	r2, [sp, #20]
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800afc6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	if (fh->modeExt >> 1)
 800afc8:	6a11      	ldr	r1, [r2, #32]
	globalGain = sis->globalGain;
 800afca:	9a1a      	ldr	r2, [sp, #104]	; 0x68
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800afcc:	3301      	adds	r3, #1
 800afce:	005b      	lsls	r3, r3, #1
	if (fh->modeExt >> 1)
 800afd0:	ea5f 0b61 	movs.w	fp, r1, asr #1
	globalGain = sis->globalGain;
 800afd4:	6892      	ldr	r2, [r2, #8]
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800afd6:	9301      	str	r3, [sp, #4]
	if (fh->modeExt >> 1)
 800afd8:	d01f      	beq.n	800b01a <xmp3fixpt_DequantChannel+0x266>
	cbi->cbType = 0;			/* long only */
 800afda:	9b1c      	ldr	r3, [sp, #112]	; 0x70
			cbStartS = 0;
 800afdc:	f8cd a00c 	str.w	sl, [sp, #12]
	cbi->cbType = 0;			/* long only */
 800afe0:	f8c3 a000 	str.w	sl, [r3]
	cbi->cbEndL  = cbMax[0];
 800afe4:	f8c3 a014 	str.w	sl, [r3, #20]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800afe8:	f8c3 a00c 	str.w	sl, [r3, #12]
 800afec:	f8c3 a008 	str.w	sl, [r3, #8]
 800aff0:	f8c3 a004 	str.w	sl, [r3, #4]
	cbi->cbEndSMax = 0;
 800aff4:	f8c3 a010 	str.w	sl, [r3, #16]
 800aff8:	f1c2 03d2 	rsb	r3, r2, #210	; 0xd2
 800affc:	9300      	str	r3, [sp, #0]
	gbMask = 0;
 800affe:	46d3      	mov	fp, sl
 800b000:	e73f      	b.n	800ae82 <xmp3fixpt_DequantChannel+0xce>
			cbEndL = (fh->ver == MPEG1 ? 8 : 6); 
 800b002:	9b05      	ldr	r3, [sp, #20]
 800b004:	781b      	ldrb	r3, [r3, #0]
			cbStartS = 3; 
 800b006:	2b00      	cmp	r3, #0
 800b008:	f04f 0303 	mov.w	r3, #3
 800b00c:	bf14      	ite	ne
 800b00e:	f04f 0906 	movne.w	r9, #6
 800b012:	f04f 0908 	moveq.w	r9, #8
 800b016:	9303      	str	r3, [sp, #12]
 800b018:	e6dc      	b.n	800add4 <xmp3fixpt_DequantChannel+0x20>
	cbi->cbType = 0;			/* long only */
 800b01a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
			cbStartS = 0;
 800b01c:	f8cd b00c 	str.w	fp, [sp, #12]
	cbi->cbType = 0;			/* long only */
 800b020:	f8c3 b000 	str.w	fp, [r3]
	cbi->cbEndL  = cbMax[0];
 800b024:	f8c3 b014 	str.w	fp, [r3, #20]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800b028:	f8c3 b00c 	str.w	fp, [r3, #12]
 800b02c:	f8c3 b008 	str.w	fp, [r3, #8]
 800b030:	f8c3 b004 	str.w	fp, [r3, #4]
	cbi->cbEndSMax = 0;
 800b034:	f8c3 b010 	str.w	fp, [r3, #16]
 800b038:	f1c2 03d0 	rsb	r3, r2, #208	; 0xd0
 800b03c:	9300      	str	r3, [sp, #0]
	i = 0;
 800b03e:	46da      	mov	sl, fp
 800b040:	e71f      	b.n	800ae82 <xmp3fixpt_DequantChannel+0xce>
 800b042:	bf00      	nop
 800b044:	08014ea8 	.word	0x08014ea8

0800b048 <xmp3fixpt_DecodeHuffman>:
 *                byte located at buf + offset)
 *              -1 if null input pointers, huffBlockBits < 0, or decoder runs 
 *                out of bits prematurely (invalid bitstream)
 **************************************************************************************/
int DecodeHuffman(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int huffBlockBits, int gr, int ch)
{
 800b048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b04c:	b09b      	sub	sp, #108	; 0x6c
 800b04e:	9113      	str	r1, [sp, #76]	; 0x4c
 800b050:	920a      	str	r2, [sp, #40]	; 0x28
 800b052:	9302      	str	r3, [sp, #8]
	SideInfoSub *sis;
	ScaleFactorInfo *sfi;
	HuffmanInfo *hi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS)
 800b054:	2800      	cmp	r0, #0
 800b056:	f000 8184 	beq.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
 800b05a:	6801      	ldr	r1, [r0, #0]
 800b05c:	2900      	cmp	r1, #0
 800b05e:	f000 8180 	beq.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
 800b062:	6843      	ldr	r3, [r0, #4]
 800b064:	930b      	str	r3, [sp, #44]	; 0x2c
 800b066:	461c      	mov	r4, r3
 800b068:	2b00      	cmp	r3, #0
 800b06a:	f000 817a 	beq.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
 800b06e:	6883      	ldr	r3, [r0, #8]
 800b070:	2b00      	cmp	r3, #0
 800b072:	f000 8176 	beq.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
 800b076:	68c3      	ldr	r3, [r0, #12]
 800b078:	9310      	str	r3, [sp, #64]	; 0x40
 800b07a:	2b00      	cmp	r3, #0
 800b07c:	f000 8171 	beq.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
	sis = &si->sis[gr][ch];
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);

	if (huffBlockBits < 0)
 800b080:	9b02      	ldr	r3, [sp, #8]
 800b082:	2b00      	cmp	r3, #0
 800b084:	f2c0 816d 	blt.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
		return -1;

	/* figure out region boundaries (the first 2*bigVals coefficients divided into 3 regions) */
	if (sis->winSwitchFlag && sis->blockType == 2) {
 800b088:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800b08a:	9a24      	ldr	r2, [sp, #144]	; 0x90
 800b08c:	9825      	ldr	r0, [sp, #148]	; 0x94
 800b08e:	00db      	lsls	r3, r3, #3
 800b090:	189a      	adds	r2, r3, r2
 800b092:	9311      	str	r3, [sp, #68]	; 0x44
 800b094:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800b096:	00db      	lsls	r3, r3, #3
 800b098:	930f      	str	r3, [sp, #60]	; 0x3c
 800b09a:	0112      	lsls	r2, r2, #4
 800b09c:	4403      	add	r3, r0
 800b09e:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800b0a2:	4422      	add	r2, r4
 800b0a4:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b0a6:	2b00      	cmp	r3, #0
 800b0a8:	f040 8290 	bne.w	800b5cc <xmp3fixpt_DecodeHuffman+0x584>
				r1Start = fh->sfBand->l[6] + 2*w;
			}
		}
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
	} else {
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800b0ac:	9a24      	ldr	r2, [sp, #144]	; 0x90
 800b0ae:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b0b0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800b0b2:	4413      	add	r3, r2
 800b0b4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800b0b6:	011b      	lsls	r3, r3, #4
 800b0b8:	4402      	add	r2, r0
 800b0ba:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800b0be:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800b0c0:	4413      	add	r3, r2
 800b0c2:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 800b0c4:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800b0c6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800b0c8:	3101      	adds	r1, #1
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800b0ca:	440b      	add	r3, r1
 800b0cc:	3301      	adds	r3, #1
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800b0ce:	f932 0011 	ldrsh.w	r0, [r2, r1, lsl #1]
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800b0d2:	f932 5013 	ldrsh.w	r5, [r2, r3, lsl #1]
	}

	/* offset rEnd index by 1 so first region = rEnd[1] - rEnd[0], etc. */
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800b0d6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800b0d8:	9a25      	ldr	r2, [sp, #148]	; 0x94
 800b0da:	9f10      	ldr	r7, [sp, #64]	; 0x40
 800b0dc:	1899      	adds	r1, r3, r2
 800b0de:	9a24      	ldr	r2, [sp, #144]	; 0x90
 800b0e0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b0e2:	4413      	add	r3, r2
 800b0e4:	00cc      	lsls	r4, r1, #3
 800b0e6:	011b      	lsls	r3, r3, #4
 800b0e8:	18e2      	adds	r2, r4, r3
 800b0ea:	4432      	add	r2, r6
 800b0ec:	9e25      	ldr	r6, [sp, #148]	; 0x94
 800b0ee:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b0f0:	0052      	lsls	r2, r2, #1
 800b0f2:	f5b2 7f10 	cmp.w	r2, #576	; 0x240
 800b0f6:	bfa8      	it	ge
 800b0f8:	f44f 7210 	movge.w	r2, #576	; 0x240
 800b0fc:	eb07 0686 	add.w	r6, r7, r6, lsl #2
 800b100:	4617      	mov	r7, r2
	rEnd[2] = MIN(r2Start, rEnd[3]);
	rEnd[1] = MIN(r1Start, rEnd[3]);
	rEnd[0] = 0;

	/* rounds up to first all-zero pair (we don't check last pair for (x,y) == (non-zero, zero)) */
	hi->nonZeroBound[ch] = rEnd[3];
 800b102:	f506 5e90 	add.w	lr, r6, #4608	; 0x1200
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800b106:	42bd      	cmp	r5, r7
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800b108:	9214      	str	r2, [sp, #80]	; 0x50
	rEnd[0] = 0;
 800b10a:	aa1a      	add	r2, sp, #104	; 0x68
 800b10c:	9205      	str	r2, [sp, #20]
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800b10e:	bfa8      	it	ge
 800b110:	463d      	movge	r5, r7
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800b112:	42b8      	cmp	r0, r7
	hi->nonZeroBound[ch] = rEnd[3];
 800b114:	f8ce 7000 	str.w	r7, [lr]
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800b118:	463e      	mov	r6, r7
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800b11a:	bfa8      	it	ge
 800b11c:	4638      	movge	r0, r7
	hi->nonZeroBound[ch] = rEnd[3];
 800b11e:	f8cd e054 	str.w	lr, [sp, #84]	; 0x54
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800b122:	46be      	mov	lr, r7
	rEnd[0] = 0;
 800b124:	9f05      	ldr	r7, [sp, #20]
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800b126:	9619      	str	r6, [sp, #100]	; 0x64
 800b128:	f104 0244 	add.w	r2, r4, #68	; 0x44
	rEnd[0] = 0;
 800b12c:	2400      	movs	r4, #0
 800b12e:	f847 4d10 	str.w	r4, [r7, #-16]!
 800b132:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800b134:	9705      	str	r7, [sp, #20]
 800b136:	441a      	add	r2, r3
 800b138:	9f10      	ldr	r7, [sp, #64]	; 0x40
 800b13a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800b13c:	9518      	str	r5, [sp, #96]	; 0x60
 800b13e:	18b2      	adds	r2, r6, r2
 800b140:	eb07 2101 	add.w	r1, r7, r1, lsl #8
 800b144:	9207      	str	r2, [sp, #28]
 800b146:	681b      	ldr	r3, [r3, #0]
	hi->nonZeroBound[ch] = rEnd[3];
 800b148:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800b14a:	910d      	str	r1, [sp, #52]	; 0x34
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800b14c:	9017      	str	r0, [sp, #92]	; 0x5c
		return 0;
 800b14e:	9404      	str	r4, [sp, #16]
	hi->nonZeroBound[ch] = rEnd[3];
 800b150:	9206      	str	r2, [sp, #24]

	/* decode Huffman pairs (rEnd[i] are always even numbers) */
	bitsLeft = huffBlockBits;
	for (i = 0; i < 3; i++) {
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800b152:	9905      	ldr	r1, [sp, #20]
 800b154:	460a      	mov	r2, r1
 800b156:	680c      	ldr	r4, [r1, #0]
 800b158:	f852 5f04 	ldr.w	r5, [r2, #4]!
 800b15c:	9205      	str	r2, [sp, #20]
 800b15e:	1b2d      	subs	r5, r5, r4
 800b160:	9a0d      	ldr	r2, [sp, #52]	; 0x34
	if(nVals <= 0) 
 800b162:	2d00      	cmp	r5, #0
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800b164:	eb02 0484 	add.w	r4, r2, r4, lsl #2
	if(nVals <= 0) 
 800b168:	f340 8293 	ble.w	800b692 <xmp3fixpt_DecodeHuffman+0x64a>
	if (bitsLeft < 0)
 800b16c:	9a02      	ldr	r2, [sp, #8]
 800b16e:	2a00      	cmp	r2, #0
 800b170:	f2c0 80f7 	blt.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800b174:	9a07      	ldr	r2, [sp, #28]
	tabType = huffTabLookup[tabIdx].tabType;
 800b176:	489d      	ldr	r0, [pc, #628]	; (800b3ec <xmp3fixpt_DecodeHuffman+0x3a4>)
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800b178:	6811      	ldr	r1, [r2, #0]
	tabType = huffTabLookup[tabIdx].tabType;
 800b17a:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
	cachedBits = (8 - bitOffset) & 0x07;
 800b17e:	425a      	negs	r2, r3
	if (cachedBits)
 800b180:	f012 0207 	ands.w	r2, r2, #7
	tabType = huffTabLookup[tabIdx].tabType;
 800b184:	7933      	ldrb	r3, [r6, #4]
 800b186:	9301      	str	r3, [sp, #4]
	if (cachedBits)
 800b188:	f000 80f0 	beq.w	800b36c <xmp3fixpt_DecodeHuffman+0x324>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800b18c:	9f06      	ldr	r7, [sp, #24]
 800b18e:	783e      	ldrb	r6, [r7, #0]
 800b190:	f1c2 0320 	rsb	r3, r2, #32
 800b194:	fa06 f303 	lsl.w	r3, r6, r3
 800b198:	463e      	mov	r6, r7
	if (tabType == noBits) {
 800b19a:	9f01      	ldr	r7, [sp, #4]
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800b19c:	3601      	adds	r6, #1
	if (tabType == noBits) {
 800b19e:	2f00      	cmp	r7, #0
 800b1a0:	f040 80ea 	bne.w	800b378 <xmp3fixpt_DecodeHuffman+0x330>
 800b1a4:	9904      	ldr	r1, [sp, #16]
 800b1a6:	463b      	mov	r3, r7
 800b1a8:	4622      	mov	r2, r4
			xy[i+0] = 0;
 800b1aa:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
		for (i = 0; i < nVals; i+=2) {
 800b1ae:	3302      	adds	r3, #2
 800b1b0:	429d      	cmp	r5, r3
			xy[i+1] = 0;
 800b1b2:	6051      	str	r1, [r2, #4]
 800b1b4:	f102 0208 	add.w	r2, r2, #8
		for (i = 0; i < nVals; i+=2) {
 800b1b8:	dcf7      	bgt.n	800b1aa <xmp3fixpt_DecodeHuffman+0x162>
		return 0;
 800b1ba:	2100      	movs	r1, #0
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
			return -1;

		/* update bitstream position */
		buf += (bitsUsed + *bitOffset) >> 3;
 800b1bc:	980a      	ldr	r0, [sp, #40]	; 0x28
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
		bitsLeft -= bitsUsed;
 800b1be:	9c02      	ldr	r4, [sp, #8]
		buf += (bitsUsed + *bitOffset) >> 3;
 800b1c0:	6802      	ldr	r2, [r0, #0]
 800b1c2:	440a      	add	r2, r1
		bitsLeft -= bitsUsed;
 800b1c4:	1a61      	subs	r1, r4, r1
 800b1c6:	9102      	str	r1, [sp, #8]
 800b1c8:	9907      	ldr	r1, [sp, #28]
 800b1ca:	3104      	adds	r1, #4
 800b1cc:	9107      	str	r1, [sp, #28]
		buf += (bitsUsed + *bitOffset) >> 3;
 800b1ce:	9906      	ldr	r1, [sp, #24]
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 800b1d0:	f002 0307 	and.w	r3, r2, #7
		buf += (bitsUsed + *bitOffset) >> 3;
 800b1d4:	eb01 02e2 	add.w	r2, r1, r2, asr #3
 800b1d8:	9206      	str	r2, [sp, #24]
	for (i = 0; i < 3; i++) {
 800b1da:	9a05      	ldr	r2, [sp, #20]
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 800b1dc:	6003      	str	r3, [r0, #0]
	for (i = 0; i < 3; i++) {
 800b1de:	a919      	add	r1, sp, #100	; 0x64
 800b1e0:	4291      	cmp	r1, r2
 800b1e2:	d1b6      	bne.n	800b152 <xmp3fixpt_DecodeHuffman+0x10a>
	}

	/* decode Huffman quads (if any) */
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800b1e4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800b1e6:	9914      	ldr	r1, [sp, #80]	; 0x50
 800b1e8:	eb02 0681 	add.w	r6, r2, r1, lsl #2
	if (bitsLeft <= 0)
 800b1ec:	9a02      	ldr	r2, [sp, #8]
 800b1ee:	2a00      	cmp	r2, #0
 800b1f0:	f340 82d6 	ble.w	800b7a0 <xmp3fixpt_DecodeHuffman+0x758>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800b1f4:	9924      	ldr	r1, [sp, #144]	; 0x90
 800b1f6:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800b1f8:	9825      	ldr	r0, [sp, #148]	; 0x94
 800b1fa:	440a      	add	r2, r1
 800b1fc:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800b1fe:	0112      	lsls	r2, r2, #4
 800b200:	4401      	add	r1, r0
 800b202:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800b206:	990b      	ldr	r1, [sp, #44]	; 0x2c
	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 800b208:	4879      	ldr	r0, [pc, #484]	; (800b3f0 <xmp3fixpt_DecodeHuffman+0x3a8>)
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800b20a:	4411      	add	r1, r2
	cachedBits = (8 - bitOffset) & 0x07;
 800b20c:	425b      	negs	r3, r3
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800b20e:	6eca      	ldr	r2, [r1, #108]	; 0x6c
	maxBits = quadTabMaxBits[tabIdx];
 800b210:	4978      	ldr	r1, [pc, #480]	; (800b3f4 <xmp3fixpt_DecodeHuffman+0x3ac>)
	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 800b212:	f850 a022 	ldr.w	sl, [r0, r2, lsl #2]
	maxBits = quadTabMaxBits[tabIdx];
 800b216:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
	if (cachedBits)
 800b21a:	f013 0107 	ands.w	r1, r3, #7
 800b21e:	f040 81f0 	bne.w	800b602 <xmp3fixpt_DecodeHuffman+0x5ba>
		buf += (bitsUsed + *bitOffset) >> 3;
 800b222:	9b06      	ldr	r3, [sp, #24]
 800b224:	9301      	str	r3, [sp, #4]
	cache = 0;
 800b226:	460a      	mov	r2, r1
 800b228:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800b22a:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 800b3f8 <xmp3fixpt_DecodeHuffman+0x3b0>
 800b22e:	f5c3 7e0f 	rsb	lr, r3, #572	; 0x23c
	bitsLeft -= cachedBits;
 800b232:	9b02      	ldr	r3, [sp, #8]
	i = padBits = 0;
 800b234:	f04f 0c00 	mov.w	ip, #0
 800b238:	f10e 0e01 	add.w	lr, lr, #1
 800b23c:	f1c0 0820 	rsb	r8, r0, #32
 800b240:	4667      	mov	r7, ip
	bitsLeft -= cachedBits;
 800b242:	eba3 0b01 	sub.w	fp, r3, r1
	while (i < (nVals - 3)) {
 800b246:	4577      	cmp	r7, lr
 800b248:	da59      	bge.n	800b2fe <xmp3fixpt_DecodeHuffman+0x2b6>
		if (bitsLeft >= 16) {
 800b24a:	f1bb 0f0f 	cmp.w	fp, #15
 800b24e:	f340 81e1 	ble.w	800b614 <xmp3fixpt_DecodeHuffman+0x5cc>
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b252:	9801      	ldr	r0, [sp, #4]
 800b254:	7805      	ldrb	r5, [r0, #0]
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b256:	7840      	ldrb	r0, [r0, #1]
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b258:	f1c1 0318 	rsb	r3, r1, #24
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b25c:	f1c1 0410 	rsb	r4, r1, #16
 800b260:	40a0      	lsls	r0, r4
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b262:	fa05 f303 	lsl.w	r3, r5, r3
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b266:	4303      	orrs	r3, r0
 800b268:	9801      	ldr	r0, [sp, #4]
 800b26a:	3002      	adds	r0, #2
			bitsLeft -= 16;
 800b26c:	f1ab 0b10 	sub.w	fp, fp, #16
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b270:	9001      	str	r0, [sp, #4]
 800b272:	431a      	orrs	r2, r3
			cachedBits += 16;
 800b274:	3110      	adds	r1, #16
 800b276:	f106 0010 	add.w	r0, r6, #16
 800b27a:	e010      	b.n	800b29e <xmp3fixpt_DecodeHuffman+0x256>
			i += 4;
 800b27c:	3704      	adds	r7, #4
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800b27e:	4577      	cmp	r7, lr
			*vwxy++ = v;
 800b280:	f840 6c10 	str.w	r6, [r0, #-16]
			*vwxy++ = w;
 800b284:	f840 5c0c 	str.w	r5, [r0, #-12]
			*vwxy++ = x;
 800b288:	f840 4c08 	str.w	r4, [r0, #-8]
			*vwxy++ = y;
 800b28c:	f840 3c04 	str.w	r3, [r0, #-4]
 800b290:	4606      	mov	r6, r0
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800b292:	f280 81e8 	bge.w	800b666 <xmp3fixpt_DecodeHuffman+0x61e>
 800b296:	2909      	cmp	r1, #9
 800b298:	f100 0010 	add.w	r0, r0, #16
 800b29c:	ddd3      	ble.n	800b246 <xmp3fixpt_DecodeHuffman+0x1fe>
			cw = tBase[cache >> (32 - maxBits)];
 800b29e:	fa22 f308 	lsr.w	r3, r2, r8
 800b2a2:	4453      	add	r3, sl
 800b2a4:	f819 3003 	ldrb.w	r3, [r9, r3]
			len = GetHLenQ(cw);
 800b2a8:	091c      	lsrs	r4, r3, #4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 800b2aa:	f013 0608 	ands.w	r6, r3, #8
			cachedBits -= len;
 800b2ae:	eba1 0104 	sub.w	r1, r1, r4
			cache <<= len;
 800b2b2:	fa02 f204 	lsl.w	r2, r2, r4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 800b2b6:	d005      	beq.n	800b2c4 <xmp3fixpt_DecodeHuffman+0x27c>
 800b2b8:	f002 4600 	and.w	r6, r2, #2147483648	; 0x80000000
 800b2bc:	3901      	subs	r1, #1
 800b2be:	f046 0601 	orr.w	r6, r6, #1
 800b2c2:	0052      	lsls	r2, r2, #1
			w = GetCWWQ(cw);	if(w) {ApplySign(w, cache); cache <<= 1; cachedBits--;}
 800b2c4:	f013 0504 	ands.w	r5, r3, #4
 800b2c8:	d005      	beq.n	800b2d6 <xmp3fixpt_DecodeHuffman+0x28e>
 800b2ca:	f002 4500 	and.w	r5, r2, #2147483648	; 0x80000000
 800b2ce:	3901      	subs	r1, #1
 800b2d0:	f045 0501 	orr.w	r5, r5, #1
 800b2d4:	0052      	lsls	r2, r2, #1
			x = GetCWXQ(cw);	if(x) {ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800b2d6:	f013 0402 	ands.w	r4, r3, #2
 800b2da:	d005      	beq.n	800b2e8 <xmp3fixpt_DecodeHuffman+0x2a0>
 800b2dc:	f002 4400 	and.w	r4, r2, #2147483648	; 0x80000000
 800b2e0:	3901      	subs	r1, #1
 800b2e2:	f044 0401 	orr.w	r4, r4, #1
 800b2e6:	0052      	lsls	r2, r2, #1
			y = GetCWYQ(cw);	if(y) {ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800b2e8:	f013 0301 	ands.w	r3, r3, #1
 800b2ec:	d005      	beq.n	800b2fa <xmp3fixpt_DecodeHuffman+0x2b2>
 800b2ee:	f002 4300 	and.w	r3, r2, #2147483648	; 0x80000000
 800b2f2:	3901      	subs	r1, #1
 800b2f4:	f043 0301 	orr.w	r3, r3, #1
 800b2f8:	0052      	lsls	r2, r2, #1
			if (cachedBits < padBits)
 800b2fa:	4561      	cmp	r1, ip
 800b2fc:	dabe      	bge.n	800b27c <xmp3fixpt_DecodeHuffman+0x234>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800b2fe:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800b300:	6813      	ldr	r3, [r2, #0]
 800b302:	443b      	add	r3, r7

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 800b304:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800b308:	6013      	str	r3, [r2, #0]
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 800b30a:	da0f      	bge.n	800b32c <xmp3fixpt_DecodeHuffman+0x2e4>
		hi->huffDecBuf[ch][i] = 0;
 800b30c:	9925      	ldr	r1, [sp, #148]	; 0x94
 800b30e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800b310:	440a      	add	r2, r1
 800b312:	ebc3 7183 	rsb	r1, r3, r3, lsl #30
 800b316:	eb03 1382 	add.w	r3, r3, r2, lsl #6
 800b31a:	008a      	lsls	r2, r1, #2
 800b31c:	9910      	ldr	r1, [sp, #64]	; 0x40
 800b31e:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 800b322:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 800b326:	2100      	movs	r1, #0
 800b328:	f009 f969 	bl	80145fe <memset>
	
	/* If bits used for 576 samples < huffBlockBits, then the extras are considered
	 *  to be stuffing bits (throw away, but need to return correct bitstream position) 
	 */
	buf += (bitsLeft + *bitOffset) >> 3;
 800b32c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800b32e:	9902      	ldr	r1, [sp, #8]
 800b330:	6813      	ldr	r3, [r2, #0]
 800b332:	4419      	add	r1, r3
 800b334:	460b      	mov	r3, r1
 800b336:	9906      	ldr	r1, [sp, #24]
 800b338:	eb01 00e3 	add.w	r0, r1, r3, asr #3
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
	
	return (buf - startBuf);
 800b33c:	9913      	ldr	r1, [sp, #76]	; 0x4c
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 800b33e:	f003 0307 	and.w	r3, r3, #7
	return (buf - startBuf);
 800b342:	1a40      	subs	r0, r0, r1
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 800b344:	6013      	str	r3, [r2, #0]
}
 800b346:	b01b      	add	sp, #108	; 0x6c
 800b348:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		bitsLeft += (cachedBits - padBits);
 800b34c:	eba2 0109 	sub.w	r1, r2, r9
		return (startBits - bitsLeft);
 800b350:	9b02      	ldr	r3, [sp, #8]
		bitsLeft += (cachedBits - padBits);
 800b352:	4451      	add	r1, sl
		return (startBits - bitsLeft);
 800b354:	1a59      	subs	r1, r3, r1
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
 800b356:	2900      	cmp	r1, #0
 800b358:	db03      	blt.n	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
 800b35a:	9b02      	ldr	r3, [sp, #8]
 800b35c:	428b      	cmp	r3, r1
 800b35e:	f6bf af2d 	bge.w	800b1bc <xmp3fixpt_DecodeHuffman+0x174>
		return -1;
 800b362:	f04f 30ff 	mov.w	r0, #4294967295
}
 800b366:	b01b      	add	sp, #108	; 0x6c
 800b368:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (tabType == noBits) {
 800b36c:	9f01      	ldr	r7, [sp, #4]
	if (cachedBits)
 800b36e:	9e06      	ldr	r6, [sp, #24]
	cache = 0;
 800b370:	4613      	mov	r3, r2
	if (tabType == noBits) {
 800b372:	2f00      	cmp	r7, #0
 800b374:	f43f af16 	beq.w	800b1a4 <xmp3fixpt_DecodeHuffman+0x15c>
	bitsLeft -= cachedBits;
 800b378:	9f02      	ldr	r7, [sp, #8]
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800b37a:	f8df e080 	ldr.w	lr, [pc, #128]	; 800b3fc <xmp3fixpt_DecodeHuffman+0x3b4>
 800b37e:	f8df c080 	ldr.w	ip, [pc, #128]	; 800b400 <xmp3fixpt_DecodeHuffman+0x3b8>
 800b382:	f85e e021 	ldr.w	lr, [lr, r1, lsl #2]
	bitsLeft -= cachedBits;
 800b386:	eba7 0b02 	sub.w	fp, r7, r2
	} else if (tabType == oneShot) {
 800b38a:	9f01      	ldr	r7, [sp, #4]
 800b38c:	2f01      	cmp	r7, #1
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800b38e:	eb0c 0a4e 	add.w	sl, ip, lr, lsl #1
	} else if (tabType == oneShot) {
 800b392:	f000 8186 	beq.w	800b6a2 <xmp3fixpt_DecodeHuffman+0x65a>
	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
 800b396:	3f02      	subs	r7, #2
 800b398:	2f01      	cmp	r7, #1
 800b39a:	d8e2      	bhi.n	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
	linBits = huffTabLookup[tabIdx].linBits;
 800b39c:	f850 1031 	ldr.w	r1, [r0, r1, lsl #3]
 800b3a0:	9108      	str	r1, [sp, #32]
 800b3a2:	4608      	mov	r0, r1
					minBits = linBits + 1;
 800b3a4:	1c47      	adds	r7, r0, #1
					y += (int)(cache >> (32 - linBits));
 800b3a6:	f1c0 0020 	rsb	r0, r0, #32
 800b3aa:	900e      	str	r0, [sp, #56]	; 0x38
 800b3ac:	4658      	mov	r0, fp
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800b3ae:	4651      	mov	r1, sl
 800b3b0:	46d3      	mov	fp, sl
					minBits = linBits + 1;
 800b3b2:	970c      	str	r7, [sp, #48]	; 0x30
	linBits = huffTabLookup[tabIdx].linBits;
 800b3b4:	f04f 0900 	mov.w	r9, #0
 800b3b8:	4682      	mov	sl, r0
			if (bitsLeft >= 16) {
 800b3ba:	f1ba 0f0f 	cmp.w	sl, #15
 800b3be:	dd63      	ble.n	800b488 <xmp3fixpt_DecodeHuffman+0x440>
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b3c0:	7837      	ldrb	r7, [r6, #0]
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b3c2:	7870      	ldrb	r0, [r6, #1]
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b3c4:	f1c2 0c18 	rsb	ip, r2, #24
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b3c8:	f1c2 0e10 	rsb	lr, r2, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b3cc:	fa07 f70c 	lsl.w	r7, r7, ip
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b3d0:	fa00 f00e 	lsl.w	r0, r0, lr
				cachedBits += 16;
 800b3d4:	3210      	adds	r2, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b3d6:	4307      	orrs	r7, r0
 800b3d8:	3602      	adds	r6, #2
			while (nVals > 0 && cachedBits >= 11 ) {
 800b3da:	2a0a      	cmp	r2, #10
				bitsLeft -= 16;
 800b3dc:	f1aa 0a10 	sub.w	sl, sl, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b3e0:	ea43 0307 	orr.w	r3, r3, r7
 800b3e4:	bfc8      	it	gt
 800b3e6:	9603      	strgt	r6, [sp, #12]
			while (nVals > 0 && cachedBits >= 11 ) {
 800b3e8:	dc13      	bgt.n	800b412 <xmp3fixpt_DecodeHuffman+0x3ca>
 800b3ea:	e7e6      	b.n	800b3ba <xmp3fixpt_DecodeHuffman+0x372>
 800b3ec:	08014f20 	.word	0x08014f20
 800b3f0:	08014ec8 	.word	0x08014ec8
 800b3f4:	08014ec0 	.word	0x08014ec0
 800b3f8:	08014ed0 	.word	0x08014ed0
 800b3fc:	08015020 	.word	0x08015020
 800b400:	080150a0 	.word	0x080150a0
					cachedBits -= maxBits;
 800b404:	1a12      	subs	r2, r2, r0
			while (nVals > 0 && cachedBits >= 11 ) {
 800b406:	2a0a      	cmp	r2, #10
					cache <<= maxBits;
 800b408:	fa03 f300 	lsl.w	r3, r3, r0
					tCurr += cw;
 800b40c:	eb01 0147 	add.w	r1, r1, r7, lsl #1
			while (nVals > 0 && cachedBits >= 11 ) {
 800b410:	dd36      	ble.n	800b480 <xmp3fixpt_DecodeHuffman+0x438>
				maxBits = GetMaxbits(tCurr[0]);
 800b412:	8808      	ldrh	r0, [r1, #0]
 800b414:	f000 000f 	and.w	r0, r0, #15
				cw = tCurr[(cache >> (32 - maxBits)) + 1];
 800b418:	f1c0 0720 	rsb	r7, r0, #32
 800b41c:	fa23 f707 	lsr.w	r7, r3, r7
 800b420:	3701      	adds	r7, #1
 800b422:	f831 7017 	ldrh.w	r7, [r1, r7, lsl #1]
				if (!len) {
 800b426:	ea5f 3e17 	movs.w	lr, r7, lsr #12
 800b42a:	d0eb      	beq.n	800b404 <xmp3fixpt_DecodeHuffman+0x3bc>
 800b42c:	f3c7 2003 	ubfx	r0, r7, #8, #4
 800b430:	f3c7 1703 	ubfx	r7, r7, #4, #4
				if (x == 15 && tabType == loopLinbits) {
 800b434:	2f0f      	cmp	r7, #15
				cachedBits -= len;
 800b436:	eba2 020e 	sub.w	r2, r2, lr
				cache <<= len;
 800b43a:	fa03 f30e 	lsl.w	r3, r3, lr
				y = GetCWY(cw);
 800b43e:	4601      	mov	r1, r0
				if (x == 15 && tabType == loopLinbits) {
 800b440:	d04a      	beq.n	800b4d8 <xmp3fixpt_DecodeHuffman+0x490>
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800b442:	b12f      	cbz	r7, 800b450 <xmp3fixpt_DecodeHuffman+0x408>
 800b444:	f003 4e00 	and.w	lr, r3, #2147483648	; 0x80000000
 800b448:	3a01      	subs	r2, #1
 800b44a:	ea4e 0707 	orr.w	r7, lr, r7
 800b44e:	005b      	lsls	r3, r3, #1
				if (y == 15 && tabType == loopLinbits) {
 800b450:	280f      	cmp	r0, #15
 800b452:	f000 8087 	beq.w	800b564 <xmp3fixpt_DecodeHuffman+0x51c>
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800b456:	b121      	cbz	r1, 800b462 <xmp3fixpt_DecodeHuffman+0x41a>
 800b458:	f003 4000 	and.w	r0, r3, #2147483648	; 0x80000000
 800b45c:	3a01      	subs	r2, #1
 800b45e:	4301      	orrs	r1, r0
 800b460:	005b      	lsls	r3, r3, #1
				if (cachedBits < padBits)
 800b462:	454a      	cmp	r2, r9
 800b464:	f6ff af7d 	blt.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
				*xy++ = x;
 800b468:	4620      	mov	r0, r4
				nVals -= 2;
 800b46a:	3d02      	subs	r5, #2
			while (nVals > 0 && cachedBits >= 11 ) {
 800b46c:	2d00      	cmp	r5, #0
				*xy++ = x;
 800b46e:	f840 7b08 	str.w	r7, [r0], #8
				*xy++ = y;
 800b472:	6061      	str	r1, [r4, #4]
			while (nVals > 0 && cachedBits >= 11 ) {
 800b474:	f77f af6a 	ble.w	800b34c <xmp3fixpt_DecodeHuffman+0x304>
 800b478:	2a0a      	cmp	r2, #10
				*xy++ = y;
 800b47a:	4604      	mov	r4, r0
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800b47c:	4659      	mov	r1, fp
			while (nVals > 0 && cachedBits >= 11 ) {
 800b47e:	dcc8      	bgt.n	800b412 <xmp3fixpt_DecodeHuffman+0x3ca>
			if (bitsLeft >= 16) {
 800b480:	f1ba 0f0f 	cmp.w	sl, #15
 800b484:	9e03      	ldr	r6, [sp, #12]
 800b486:	dc9b      	bgt.n	800b3c0 <xmp3fixpt_DecodeHuffman+0x378>
				if (cachedBits + bitsLeft <= 0)	return -1;
 800b488:	eb0a 0002 	add.w	r0, sl, r2
 800b48c:	2800      	cmp	r0, #0
 800b48e:	f77f af68 	ble.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b492:	f1ba 0f00 	cmp.w	sl, #0
 800b496:	dd11      	ble.n	800b4bc <xmp3fixpt_DecodeHuffman+0x474>
 800b498:	7837      	ldrb	r7, [r6, #0]
 800b49a:	f1c2 0e18 	rsb	lr, r2, #24
 800b49e:	fa07 f70e 	lsl.w	r7, r7, lr
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b4a2:	f1ba 0f08 	cmp.w	sl, #8
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b4a6:	ea43 0307 	orr.w	r3, r3, r7
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b4aa:	f340 80f8 	ble.w	800b69e <xmp3fixpt_DecodeHuffman+0x656>
 800b4ae:	7877      	ldrb	r7, [r6, #1]
 800b4b0:	f1c2 0210 	rsb	r2, r2, #16
 800b4b4:	fa07 f202 	lsl.w	r2, r7, r2
 800b4b8:	4313      	orrs	r3, r2
 800b4ba:	3602      	adds	r6, #2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800b4bc:	1e42      	subs	r2, r0, #1
 800b4be:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
 800b4c2:	fa47 f202 	asr.w	r2, r7, r2
 800b4c6:	4013      	ands	r3, r2
				padBits = 11;
 800b4c8:	f04f 090b 	mov.w	r9, #11
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800b4cc:	f100 020b 	add.w	r2, r0, #11
				bitsLeft = 0;
 800b4d0:	f04f 0a00 	mov.w	sl, #0
 800b4d4:	9603      	str	r6, [sp, #12]
 800b4d6:	e79c      	b.n	800b412 <xmp3fixpt_DecodeHuffman+0x3ca>
				if (x == 15 && tabType == loopLinbits) {
 800b4d8:	9e01      	ldr	r6, [sp, #4]
 800b4da:	2e03      	cmp	r6, #3
 800b4dc:	d1b2      	bne.n	800b444 <xmp3fixpt_DecodeHuffman+0x3fc>
					minBits = linBits + 1 + (y ? 1 : 0);
 800b4de:	9e0c      	ldr	r6, [sp, #48]	; 0x30
					if (cachedBits + bitsLeft < minBits)
 800b4e0:	eb02 070a 	add.w	r7, r2, sl
					minBits = linBits + 1 + (y ? 1 : 0);
 800b4e4:	2800      	cmp	r0, #0
 800b4e6:	bf18      	it	ne
 800b4e8:	3601      	addne	r6, #1
					if (cachedBits + bitsLeft < minBits)
 800b4ea:	42be      	cmp	r6, r7
 800b4ec:	9609      	str	r6, [sp, #36]	; 0x24
 800b4ee:	f73f af38 	bgt.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
					while (cachedBits < minBits) {
 800b4f2:	42b2      	cmp	r2, r6
 800b4f4:	da2e      	bge.n	800b554 <xmp3fixpt_DecodeHuffman+0x50c>
 800b4f6:	43d7      	mvns	r7, r2
 800b4f8:	46be      	mov	lr, r7
 800b4fa:	9712      	str	r7, [sp, #72]	; 0x48
 800b4fc:	9f03      	ldr	r7, [sp, #12]
 800b4fe:	eb0e 0806 	add.w	r8, lr, r6
 800b502:	eb07 08d8 	add.w	r8, r7, r8, lsr #3
 800b506:	463e      	mov	r6, r7
 800b508:	f108 0801 	add.w	r8, r8, #1
 800b50c:	f1c2 0c18 	rsb	ip, r2, #24
 800b510:	46be      	mov	lr, r7
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b512:	f81e 7b01 	ldrb.w	r7, [lr], #1
 800b516:	fa07 f70c 	lsl.w	r7, r7, ip
					while (cachedBits < minBits) {
 800b51a:	45c6      	cmp	lr, r8
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b51c:	ea43 0307 	orr.w	r3, r3, r7
 800b520:	f1ac 0c08 	sub.w	ip, ip, #8
					while (cachedBits < minBits) {
 800b524:	d1f5      	bne.n	800b512 <xmp3fixpt_DecodeHuffman+0x4ca>
 800b526:	9603      	str	r6, [sp, #12]
 800b528:	9e12      	ldr	r6, [sp, #72]	; 0x48
 800b52a:	4637      	mov	r7, r6
 800b52c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800b52e:	4437      	add	r7, r6
 800b530:	ea4f 08d7 	mov.w	r8, r7, lsr #3
 800b534:	9e03      	ldr	r6, [sp, #12]
 800b536:	f1aa 0708 	sub.w	r7, sl, #8
 800b53a:	f108 0c01 	add.w	ip, r8, #1
 800b53e:	ebc8 7e48 	rsb	lr, r8, r8, lsl #29
 800b542:	3208      	adds	r2, #8
 800b544:	4466      	add	r6, ip
					if (bitsLeft < 0) {
 800b546:	eb17 0ace 	adds.w	sl, r7, lr, lsl #3
 800b54a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800b54e:	9603      	str	r6, [sp, #12]
 800b550:	f100 8095 	bmi.w	800b67e <xmp3fixpt_DecodeHuffman+0x636>
					x += (int)(cache >> (32 - linBits));
 800b554:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 800b556:	fa23 f706 	lsr.w	r7, r3, r6
					cachedBits -= linBits;
 800b55a:	9e08      	ldr	r6, [sp, #32]
					x += (int)(cache >> (32 - linBits));
 800b55c:	370f      	adds	r7, #15
					cachedBits -= linBits;
 800b55e:	1b92      	subs	r2, r2, r6
					cache <<= linBits;
 800b560:	40b3      	lsls	r3, r6
 800b562:	e76e      	b.n	800b442 <xmp3fixpt_DecodeHuffman+0x3fa>
				if (y == 15 && tabType == loopLinbits) {
 800b564:	9901      	ldr	r1, [sp, #4]
 800b566:	2903      	cmp	r1, #3
 800b568:	d001      	beq.n	800b56e <xmp3fixpt_DecodeHuffman+0x526>
 800b56a:	4601      	mov	r1, r0
 800b56c:	e774      	b.n	800b458 <xmp3fixpt_DecodeHuffman+0x410>
					if (cachedBits + bitsLeft < minBits)
 800b56e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800b570:	eb02 010a 	add.w	r1, r2, sl
 800b574:	428e      	cmp	r6, r1
 800b576:	f73f aef4 	bgt.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
					while (cachedBits < minBits) {
 800b57a:	4296      	cmp	r6, r2
 800b57c:	dd1e      	ble.n	800b5bc <xmp3fixpt_DecodeHuffman+0x574>
 800b57e:	9908      	ldr	r1, [sp, #32]
 800b580:	9e03      	ldr	r6, [sp, #12]
 800b582:	eba1 0c02 	sub.w	ip, r1, r2
 800b586:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
 800b58a:	f10c 0e01 	add.w	lr, ip, #1
 800b58e:	44b6      	add	lr, r6
 800b590:	f1c2 0018 	rsb	r0, r2, #24
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b594:	f816 1b01 	ldrb.w	r1, [r6], #1
 800b598:	4081      	lsls	r1, r0
					while (cachedBits < minBits) {
 800b59a:	4576      	cmp	r6, lr
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b59c:	ea43 0301 	orr.w	r3, r3, r1
 800b5a0:	f1a0 0008 	sub.w	r0, r0, #8
					while (cachedBits < minBits) {
 800b5a4:	d1f6      	bne.n	800b594 <xmp3fixpt_DecodeHuffman+0x54c>
 800b5a6:	f1aa 0108 	sub.w	r1, sl, #8
 800b5aa:	ebcc 704c 	rsb	r0, ip, ip, lsl #29
 800b5ae:	3208      	adds	r2, #8
					if (bitsLeft < 0) {
 800b5b0:	eb11 0ac0 	adds.w	sl, r1, r0, lsl #3
 800b5b4:	9603      	str	r6, [sp, #12]
 800b5b6:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
 800b5ba:	d456      	bmi.n	800b66a <xmp3fixpt_DecodeHuffman+0x622>
					y += (int)(cache >> (32 - linBits));
 800b5bc:	990e      	ldr	r1, [sp, #56]	; 0x38
					cachedBits -= linBits;
 800b5be:	9808      	ldr	r0, [sp, #32]
					y += (int)(cache >> (32 - linBits));
 800b5c0:	fa23 f101 	lsr.w	r1, r3, r1
					cachedBits -= linBits;
 800b5c4:	1a12      	subs	r2, r2, r0
					y += (int)(cache >> (32 - linBits));
 800b5c6:	310f      	adds	r1, #15
					cache <<= linBits;
 800b5c8:	4083      	lsls	r3, r0
 800b5ca:	e744      	b.n	800b456 <xmp3fixpt_DecodeHuffman+0x40e>
	if (sis->winSwitchFlag && sis->blockType == 2) {
 800b5cc:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800b5ce:	2b02      	cmp	r3, #2
 800b5d0:	f47f ad6c 	bne.w	800b0ac <xmp3fixpt_DecodeHuffman+0x64>
		if (sis->mixedBlock == 0) {
 800b5d4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b5d6:	2b00      	cmp	r3, #0
 800b5d8:	f040 80e4 	bne.w	800b7a4 <xmp3fixpt_DecodeHuffman+0x75c>
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 800b5dc:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800b5de:	6b49      	ldr	r1, [r1, #52]	; 0x34
 800b5e0:	3201      	adds	r2, #1
 800b5e2:	f1a3 33aa 	sub.w	r3, r3, #2863311530	; 0xaaaaaaaa
 800b5e6:	fb83 0302 	smull	r0, r3, r3, r2
 800b5ea:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
 800b5ee:	eb01 0343 	add.w	r3, r1, r3, lsl #1
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800b5f2:	f44f 7510 	mov.w	r5, #576	; 0x240
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 800b5f6:	f9b3 002e 	ldrsh.w	r0, [r3, #46]	; 0x2e
 800b5fa:	4626      	mov	r6, r4
 800b5fc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800b600:	e569      	b.n	800b0d6 <xmp3fixpt_DecodeHuffman+0x8e>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800b602:	9c06      	ldr	r4, [sp, #24]
 800b604:	7822      	ldrb	r2, [r4, #0]
 800b606:	f1c1 0320 	rsb	r3, r1, #32
 800b60a:	409a      	lsls	r2, r3
 800b60c:	4623      	mov	r3, r4
 800b60e:	3301      	adds	r3, #1
 800b610:	9301      	str	r3, [sp, #4]
 800b612:	e609      	b.n	800b228 <xmp3fixpt_DecodeHuffman+0x1e0>
			if (cachedBits + bitsLeft <= 0) return i;
 800b614:	eb0b 0301 	add.w	r3, fp, r1
 800b618:	2b00      	cmp	r3, #0
 800b61a:	f77f ae70 	ble.w	800b2fe <xmp3fixpt_DecodeHuffman+0x2b6>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b61e:	f1bb 0f00 	cmp.w	fp, #0
 800b622:	dd13      	ble.n	800b64c <xmp3fixpt_DecodeHuffman+0x604>
 800b624:	9801      	ldr	r0, [sp, #4]
 800b626:	7800      	ldrb	r0, [r0, #0]
 800b628:	f1c1 0418 	rsb	r4, r1, #24
 800b62c:	40a0      	lsls	r0, r4
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b62e:	f1bb 0f08 	cmp.w	fp, #8
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b632:	ea42 0200 	orr.w	r2, r2, r0
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b636:	f340 80ad 	ble.w	800b794 <xmp3fixpt_DecodeHuffman+0x74c>
 800b63a:	9c01      	ldr	r4, [sp, #4]
 800b63c:	7860      	ldrb	r0, [r4, #1]
 800b63e:	f1c1 0110 	rsb	r1, r1, #16
 800b642:	fa00 f101 	lsl.w	r1, r0, r1
 800b646:	430a      	orrs	r2, r1
 800b648:	1ca1      	adds	r1, r4, #2
 800b64a:	9101      	str	r1, [sp, #4]
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800b64c:	1e59      	subs	r1, r3, #1
 800b64e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800b652:	fa40 f101 	asr.w	r1, r0, r1
 800b656:	400a      	ands	r2, r1
			padBits = 10;
 800b658:	f04f 0c0a 	mov.w	ip, #10
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800b65c:	f103 010a 	add.w	r1, r3, #10
			bitsLeft = 0;
 800b660:	f04f 0b00 	mov.w	fp, #0
 800b664:	e607      	b.n	800b276 <xmp3fixpt_DecodeHuffman+0x22e>
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800b666:	4606      	mov	r6, r0
 800b668:	e5ed      	b.n	800b246 <xmp3fixpt_DecodeHuffman+0x1fe>
						cachedBits += bitsLeft;
 800b66a:	4452      	add	r2, sl
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800b66c:	1e51      	subs	r1, r2, #1
 800b66e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800b672:	fa40 f101 	asr.w	r1, r0, r1
 800b676:	400b      	ands	r3, r1
						bitsLeft = 0;
 800b678:	f04f 0a00 	mov.w	sl, #0
 800b67c:	e79e      	b.n	800b5bc <xmp3fixpt_DecodeHuffman+0x574>
						cachedBits += bitsLeft;
 800b67e:	4452      	add	r2, sl
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800b680:	1e57      	subs	r7, r2, #1
 800b682:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
 800b686:	fa46 f707 	asr.w	r7, r6, r7
 800b68a:	403b      	ands	r3, r7
						bitsLeft = 0;
 800b68c:	f04f 0a00 	mov.w	sl, #0
 800b690:	e760      	b.n	800b554 <xmp3fixpt_DecodeHuffman+0x50c>
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
 800b692:	9b02      	ldr	r3, [sp, #8]
		return 0;
 800b694:	2100      	movs	r1, #0
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
 800b696:	428b      	cmp	r3, r1
 800b698:	f6bf ad90 	bge.w	800b1bc <xmp3fixpt_DecodeHuffman+0x174>
 800b69c:	e661      	b.n	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b69e:	3601      	adds	r6, #1
 800b6a0:	e70c      	b.n	800b4bc <xmp3fixpt_DecodeHuffman+0x474>
		maxBits = GetMaxbits(tBase[0]);
 800b6a2:	f83c 001e 	ldrh.w	r0, [ip, lr, lsl #1]
 800b6a6:	f000 000f 	and.w	r0, r0, #15
 800b6aa:	f1c0 0020 	rsb	r0, r0, #32
		padBits = 0;
 800b6ae:	2100      	movs	r1, #0
 800b6b0:	4627      	mov	r7, r4
			if (bitsLeft >= 16) {
 800b6b2:	f1bb 0f0f 	cmp.w	fp, #15
 800b6b6:	dd46      	ble.n	800b746 <xmp3fixpt_DecodeHuffman+0x6fe>
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b6b8:	7834      	ldrb	r4, [r6, #0]
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b6ba:	f896 e001 	ldrb.w	lr, [r6, #1]
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b6be:	f1c2 0818 	rsb	r8, r2, #24
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b6c2:	f1c2 0c10 	rsb	ip, r2, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b6c6:	fa04 f408 	lsl.w	r4, r4, r8
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b6ca:	fa0e fe0c 	lsl.w	lr, lr, ip
 800b6ce:	ea44 040e 	orr.w	r4, r4, lr
				bitsLeft -= 16;
 800b6d2:	f1ab 0b10 	sub.w	fp, fp, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b6d6:	3602      	adds	r6, #2
 800b6d8:	4323      	orrs	r3, r4
				cachedBits += 16;
 800b6da:	3210      	adds	r2, #16
 800b6dc:	f107 0e08 	add.w	lr, r7, #8
 800b6e0:	e001      	b.n	800b6e6 <xmp3fixpt_DecodeHuffman+0x69e>
			while (nVals > 0 && cachedBits >= 11 ) {
 800b6e2:	2a0a      	cmp	r2, #10
 800b6e4:	dd54      	ble.n	800b790 <xmp3fixpt_DecodeHuffman+0x748>
				cw = tBase[cache >> (32 - maxBits)];
 800b6e6:	fa23 f400 	lsr.w	r4, r3, r0
 800b6ea:	eb0a 0444 	add.w	r4, sl, r4, lsl #1
 800b6ee:	8864      	ldrh	r4, [r4, #2]
				len = GetHLen(cw);
 800b6f0:	ea4f 3c14 	mov.w	ip, r4, lsr #12
				cache <<= len;
 800b6f4:	fa03 f30c 	lsl.w	r3, r3, ip
 800b6f8:	f3c4 1703 	ubfx	r7, r4, #4, #4
				cachedBits -= len;
 800b6fc:	eba2 020c 	sub.w	r2, r2, ip
				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800b700:	f003 4c00 	and.w	ip, r3, #2147483648	; 0x80000000
 800b704:	b11f      	cbz	r7, 800b70e <xmp3fixpt_DecodeHuffman+0x6c6>
 800b706:	ea4c 0707 	orr.w	r7, ip, r7
 800b70a:	005b      	lsls	r3, r3, #1
 800b70c:	3a01      	subs	r2, #1
 800b70e:	f3c4 2403 	ubfx	r4, r4, #8, #4
				y = GetCWY(cw);		if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800b712:	f003 4c00 	and.w	ip, r3, #2147483648	; 0x80000000
 800b716:	b11c      	cbz	r4, 800b720 <xmp3fixpt_DecodeHuffman+0x6d8>
 800b718:	ea4c 0404 	orr.w	r4, ip, r4
 800b71c:	005b      	lsls	r3, r3, #1
 800b71e:	3a01      	subs	r2, #1
				if (cachedBits < padBits)
 800b720:	428a      	cmp	r2, r1
				nVals -= 2;
 800b722:	f1a5 0502 	sub.w	r5, r5, #2
 800b726:	46f4      	mov	ip, lr
				if (cachedBits < padBits)
 800b728:	f6ff ae1b 	blt.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
			while (nVals > 0 && cachedBits >= 11 ) {
 800b72c:	2d00      	cmp	r5, #0
				*xy++ = x;
 800b72e:	f84e 7c08 	str.w	r7, [lr, #-8]
				*xy++ = y;
 800b732:	f84e 4c04 	str.w	r4, [lr, #-4]
 800b736:	f10e 0e08 	add.w	lr, lr, #8
			while (nVals > 0 && cachedBits >= 11 ) {
 800b73a:	dcd2      	bgt.n	800b6e2 <xmp3fixpt_DecodeHuffman+0x69a>
		bitsLeft += (cachedBits - padBits);
 800b73c:	1a51      	subs	r1, r2, r1
		return (startBits - bitsLeft);
 800b73e:	9b02      	ldr	r3, [sp, #8]
		bitsLeft += (cachedBits - padBits);
 800b740:	4459      	add	r1, fp
		return (startBits - bitsLeft);
 800b742:	1a59      	subs	r1, r3, r1
 800b744:	e607      	b.n	800b356 <xmp3fixpt_DecodeHuffman+0x30e>
				if (cachedBits + bitsLeft <= 0)	return -1;
 800b746:	eb0b 0102 	add.w	r1, fp, r2
 800b74a:	2900      	cmp	r1, #0
 800b74c:	f77f ae09 	ble.w	800b362 <xmp3fixpt_DecodeHuffman+0x31a>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b750:	f1bb 0f00 	cmp.w	fp, #0
 800b754:	dd10      	ble.n	800b778 <xmp3fixpt_DecodeHuffman+0x730>
 800b756:	7834      	ldrb	r4, [r6, #0]
 800b758:	f1c2 0e18 	rsb	lr, r2, #24
 800b75c:	fa04 f40e 	lsl.w	r4, r4, lr
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b760:	f1bb 0f08 	cmp.w	fp, #8
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b764:	ea43 0304 	orr.w	r3, r3, r4
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800b768:	dd18      	ble.n	800b79c <xmp3fixpt_DecodeHuffman+0x754>
 800b76a:	7874      	ldrb	r4, [r6, #1]
 800b76c:	f1c2 0210 	rsb	r2, r2, #16
 800b770:	fa04 f202 	lsl.w	r2, r4, r2
 800b774:	4313      	orrs	r3, r2
 800b776:	3602      	adds	r6, #2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800b778:	1e4a      	subs	r2, r1, #1
 800b77a:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 800b77e:	fa44 f202 	asr.w	r2, r4, r2
 800b782:	4013      	ands	r3, r2
				bitsLeft = 0;
 800b784:	f04f 0b00 	mov.w	fp, #0
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800b788:	f101 020b 	add.w	r2, r1, #11
				padBits = 11;
 800b78c:	210b      	movs	r1, #11
 800b78e:	e7a5      	b.n	800b6dc <xmp3fixpt_DecodeHuffman+0x694>
 800b790:	4667      	mov	r7, ip
 800b792:	e78e      	b.n	800b6b2 <xmp3fixpt_DecodeHuffman+0x66a>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b794:	9901      	ldr	r1, [sp, #4]
 800b796:	3101      	adds	r1, #1
 800b798:	9101      	str	r1, [sp, #4]
 800b79a:	e757      	b.n	800b64c <xmp3fixpt_DecodeHuffman+0x604>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800b79c:	3601      	adds	r6, #1
 800b79e:	e7eb      	b.n	800b778 <xmp3fixpt_DecodeHuffman+0x730>
		return 0;
 800b7a0:	2700      	movs	r7, #0
 800b7a2:	e5ac      	b.n	800b2fe <xmp3fixpt_DecodeHuffman+0x2b6>
			if (fh->ver == MPEG1) {
 800b7a4:	780b      	ldrb	r3, [r1, #0]
 800b7a6:	b993      	cbnz	r3, 800b7ce <xmp3fixpt_DecodeHuffman+0x786>
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800b7a8:	9a24      	ldr	r2, [sp, #144]	; 0x90
 800b7aa:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b7ac:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800b7ae:	4413      	add	r3, r2
 800b7b0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800b7b2:	011b      	lsls	r3, r3, #4
 800b7b4:	4402      	add	r2, r0
 800b7b6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800b7ba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800b7bc:	4413      	add	r3, r2
 800b7be:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 800b7c0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800b7c2:	3301      	adds	r3, #1
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800b7c4:	f44f 7510 	mov.w	r5, #576	; 0x240
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800b7c8:	f932 0013 	ldrsh.w	r0, [r2, r3, lsl #1]
 800b7cc:	e483      	b.n	800b0d6 <xmp3fixpt_DecodeHuffman+0x8e>
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 800b7ce:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 800b7d0:	f9b2 3036 	ldrsh.w	r3, [r2, #54]	; 0x36
 800b7d4:	f9b2 1034 	ldrsh.w	r1, [r2, #52]	; 0x34
				r1Start = fh->sfBand->l[6] + 2*w;
 800b7d8:	f9b2 000c 	ldrsh.w	r0, [r2, #12]
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 800b7dc:	1a5b      	subs	r3, r3, r1
				r1Start = fh->sfBand->l[6] + 2*w;
 800b7de:	eb00 0043 	add.w	r0, r0, r3, lsl #1
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800b7e2:	f44f 7510 	mov.w	r5, #576	; 0x240
 800b7e6:	4626      	mov	r6, r4
 800b7e8:	e475      	b.n	800b0d6 <xmp3fixpt_DecodeHuffman+0x8e>
 800b7ea:	bf00      	nop

0800b7ec <WinPrevious.part.0>:
 * 
 * Notes:       produces 9 output samples from 18 input samples via symmetry
 *              all blocks gain at least 1 guard bit via window (long blocks get extra
 *                sign bit, short blocks can have one addition but max gain < 1.0)
 **************************************************************************************/
static void WinPrevious(int *xPrev, int *xPrevWin, int btPrev)
 800b7ec:	b4f0      	push	{r4, r5, r6, r7}

	xp = xPrev;
	/* mapping (see IMDCT12x3): xPrev[0-2] = sum[6-8], xPrev[3-8] = sum[12-17] */
	if (btPrev == 2) {
		/* this could be reordered for minimum loads/stores */
		wpLo = imdctWin[btPrev];
 800b7ee:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
 800b7f2:	4e33      	ldr	r6, [pc, #204]	; (800b8c0 <WinPrevious.part.0+0xd4>)
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800b7f4:	6884      	ldr	r4, [r0, #8]
 800b7f6:	0115      	lsls	r5, r2, #4
 800b7f8:	19ab      	adds	r3, r5, r6
 800b7fa:	699a      	ldr	r2, [r3, #24]
 800b7fc:	fb82 7404 	smull	r7, r4, r2, r4
 800b800:	6982      	ldr	r2, [r0, #24]
 800b802:	59ad      	ldr	r5, [r5, r6]
 800b804:	fb85 6202 	smull	r6, r2, r5, r2
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 800b808:	4414      	add	r4, r2
 800b80a:	600c      	str	r4, [r1, #0]
 800b80c:	6842      	ldr	r2, [r0, #4]
 800b80e:	69dc      	ldr	r4, [r3, #28]
 800b810:	fb84 5202 	smull	r5, r2, r4, r2
 800b814:	69c4      	ldr	r4, [r0, #28]
 800b816:	685d      	ldr	r5, [r3, #4]
 800b818:	fb85 6404 	smull	r6, r4, r5, r4
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 800b81c:	4422      	add	r2, r4
 800b81e:	604a      	str	r2, [r1, #4]
 800b820:	6802      	ldr	r2, [r0, #0]
 800b822:	6a1c      	ldr	r4, [r3, #32]
 800b824:	fb84 5202 	smull	r5, r2, r4, r2
 800b828:	6a04      	ldr	r4, [r0, #32]
 800b82a:	689d      	ldr	r5, [r3, #8]
 800b82c:	fb85 6404 	smull	r6, r4, r5, r4
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 800b830:	4422      	add	r2, r4
 800b832:	608a      	str	r2, [r1, #8]
 800b834:	6802      	ldr	r2, [r0, #0]
 800b836:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800b838:	fb84 5202 	smull	r5, r2, r4, r2
 800b83c:	6a04      	ldr	r4, [r0, #32]
 800b83e:	68dd      	ldr	r5, [r3, #12]
 800b840:	fb85 6404 	smull	r6, r4, r5, r4
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 800b844:	4422      	add	r2, r4
 800b846:	60ca      	str	r2, [r1, #12]
 800b848:	6842      	ldr	r2, [r0, #4]
 800b84a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800b84c:	fb84 5202 	smull	r5, r2, r4, r2
 800b850:	69c4      	ldr	r4, [r0, #28]
 800b852:	691d      	ldr	r5, [r3, #16]
 800b854:	fb85 6404 	smull	r6, r4, r5, r4
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 800b858:	4422      	add	r2, r4
 800b85a:	610a      	str	r2, [r1, #16]
 800b85c:	6882      	ldr	r2, [r0, #8]
 800b85e:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 800b860:	fb84 5202 	smull	r5, r2, r4, r2
 800b864:	6984      	ldr	r4, [r0, #24]
 800b866:	695d      	ldr	r5, [r3, #20]
 800b868:	fb85 6404 	smull	r6, r4, r5, r4
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 800b86c:	4422      	add	r2, r4
 800b86e:	614a      	str	r2, [r1, #20]
 800b870:	6942      	ldr	r2, [r0, #20]
 800b872:	699c      	ldr	r4, [r3, #24]
 800b874:	fb84 5202 	smull	r5, r2, r4, r2
		xPrevWin[ 6] = MULSHIFT32(wpLo[ 6], xPrev[5]);
 800b878:	618a      	str	r2, [r1, #24]
 800b87a:	6902      	ldr	r2, [r0, #16]
 800b87c:	69dc      	ldr	r4, [r3, #28]
 800b87e:	fb84 5202 	smull	r5, r2, r4, r2
		xPrevWin[ 7] = MULSHIFT32(wpLo[ 7], xPrev[4]);
 800b882:	61ca      	str	r2, [r1, #28]
 800b884:	68c2      	ldr	r2, [r0, #12]
 800b886:	6a1c      	ldr	r4, [r3, #32]
 800b888:	fb84 5202 	smull	r5, r2, r4, r2
		xPrevWin[ 8] = MULSHIFT32(wpLo[ 8], xPrev[3]);
 800b88c:	620a      	str	r2, [r1, #32]
 800b88e:	68c2      	ldr	r2, [r0, #12]
 800b890:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800b892:	fb84 5202 	smull	r5, r2, r4, r2
		xPrevWin[ 9] = MULSHIFT32(wpLo[ 9], xPrev[3]);
 800b896:	624a      	str	r2, [r1, #36]	; 0x24
 800b898:	6902      	ldr	r2, [r0, #16]
 800b89a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800b89c:	fb84 5202 	smull	r5, r2, r4, r2
		xPrevWin[10] = MULSHIFT32(wpLo[10], xPrev[4]);
 800b8a0:	628a      	str	r2, [r1, #40]	; 0x28
 800b8a2:	6942      	ldr	r2, [r0, #20]
 800b8a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b8a6:	fb83 0202 	smull	r0, r2, r3, r2
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 800b8aa:	2300      	movs	r3, #0
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
 800b8ac:	62ca      	str	r2, [r1, #44]	; 0x2c
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 800b8ae:	644b      	str	r3, [r1, #68]	; 0x44
 800b8b0:	640b      	str	r3, [r1, #64]	; 0x40
 800b8b2:	63cb      	str	r3, [r1, #60]	; 0x3c
 800b8b4:	638b      	str	r3, [r1, #56]	; 0x38
 800b8b6:	634b      	str	r3, [r1, #52]	; 0x34
 800b8b8:	630b      	str	r3, [r1, #48]	; 0x30
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
			*xpwLo++ = MULSHIFT32(wLo, x);
			*xpwHi-- = MULSHIFT32(wHi, x);
		}
	}
}
 800b8ba:	bcf0      	pop	{r4, r5, r6, r7}
 800b8bc:	4770      	bx	lr
 800b8be:	bf00      	nop
 800b8c0:	08017858 	.word	0x08017858

0800b8c4 <FreqInvertRescale>:
 *              rescaled (as necessary) previous samples
 *
 * Return:      updated mOut (from new outputs y)
 **************************************************************************************/
static int FreqInvertRescale(int *y, int *xPrev, int blockIdx, int es)
{
 800b8c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b8c8:	4686      	mov	lr, r0
 800b8ca:	b091      	sub	sp, #68	; 0x44
	int i, d, mOut;
	int y0, y1, y2, y3, y4, y5, y6, y7, y8;

	if (es == 0) {
 800b8cc:	bbc3      	cbnz	r3, 800b940 <FreqInvertRescale+0x7c>
		/* fast case - frequency invert only (no rescaling) - can fuse into overlap-add for speed, if desired */
		if (blockIdx & 0x01) {
 800b8ce:	f012 0001 	ands.w	r0, r2, #1
 800b8d2:	d032      	beq.n	800b93a <FreqInvertRescale+0x76>
			y6 = *y;	y += 2*NBANDS;
			y7 = *y;	y += 2*NBANDS;
			y8 = *y;	y += 2*NBANDS;

			y -= 18*NBANDS;
			*y = -y0;	y += 2*NBANDS;
 800b8d4:	f8de 2080 	ldr.w	r2, [lr, #128]	; 0x80
 800b8d8:	9201      	str	r2, [sp, #4]
			*y = -y1;	y += 2*NBANDS;
 800b8da:	f8de 2180 	ldr.w	r2, [lr, #384]	; 0x180
			y7 = *y;	y += 2*NBANDS;
 800b8de:	f8de 0780 	ldr.w	r0, [lr, #1920]	; 0x780
			y3 = *y;	y += 2*NBANDS;
 800b8e2:	f8de 7380 	ldr.w	r7, [lr, #896]	; 0x380
			y4 = *y;	y += 2*NBANDS;
 800b8e6:	f8de 6480 	ldr.w	r6, [lr, #1152]	; 0x480
			y5 = *y;	y += 2*NBANDS;
 800b8ea:	f8de 5580 	ldr.w	r5, [lr, #1408]	; 0x580
			y6 = *y;	y += 2*NBANDS;
 800b8ee:	f8de 4680 	ldr.w	r4, [lr, #1664]	; 0x680
			y8 = *y;	y += 2*NBANDS;
 800b8f2:	f8de 1880 	ldr.w	r1, [lr, #2176]	; 0x880
			*y = -y1;	y += 2*NBANDS;
 800b8f6:	f1c2 0c00 	rsb	ip, r2, #0
			*y = -y2;	y += 2*NBANDS;
 800b8fa:	f8de 2280 	ldr.w	r2, [lr, #640]	; 0x280
			*y = -y1;	y += 2*NBANDS;
 800b8fe:	f8ce c180 	str.w	ip, [lr, #384]	; 0x180
			*y = -y2;	y += 2*NBANDS;
 800b902:	f1c2 0800 	rsb	r8, r2, #0
			*y = -y0;	y += 2*NBANDS;
 800b906:	9a01      	ldr	r2, [sp, #4]
			*y = -y2;	y += 2*NBANDS;
 800b908:	f8ce 8280 	str.w	r8, [lr, #640]	; 0x280
			*y = -y3;	y += 2*NBANDS;
			*y = -y4;	y += 2*NBANDS;
			*y = -y5;	y += 2*NBANDS;
			*y = -y6;	y += 2*NBANDS;
			*y = -y7;	y += 2*NBANDS;
 800b90c:	f1c0 0900 	rsb	r9, r0, #0
			*y = -y3;	y += 2*NBANDS;
 800b910:	427f      	negs	r7, r7
			*y = -y4;	y += 2*NBANDS;
 800b912:	4276      	negs	r6, r6
			*y = -y5;	y += 2*NBANDS;
 800b914:	426d      	negs	r5, r5
			*y = -y6;	y += 2*NBANDS;
 800b916:	4264      	negs	r4, r4
			*y = -y8;	y += 2*NBANDS;
 800b918:	4249      	negs	r1, r1
			*y = -y0;	y += 2*NBANDS;
 800b91a:	4252      	negs	r2, r2
		}
		return 0;
 800b91c:	4618      	mov	r0, r3
			*y = -y3;	y += 2*NBANDS;
 800b91e:	f8ce 7380 	str.w	r7, [lr, #896]	; 0x380
			*y = -y4;	y += 2*NBANDS;
 800b922:	f8ce 6480 	str.w	r6, [lr, #1152]	; 0x480
			*y = -y5;	y += 2*NBANDS;
 800b926:	f8ce 5580 	str.w	r5, [lr, #1408]	; 0x580
			*y = -y6;	y += 2*NBANDS;
 800b92a:	f8ce 4680 	str.w	r4, [lr, #1664]	; 0x680
			*y = -y7;	y += 2*NBANDS;
 800b92e:	f8ce 9780 	str.w	r9, [lr, #1920]	; 0x780
			*y = -y8;	y += 2*NBANDS;
 800b932:	f8ce 1880 	str.w	r1, [lr, #2176]	; 0x880
			*y = -y0;	y += 2*NBANDS;
 800b936:	f8ce 2080 	str.w	r2, [lr, #128]	; 0x80
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
			}
		}
		return mOut;
	}
}
 800b93a:	b011      	add	sp, #68	; 0x44
 800b93c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (blockIdx & 0x01) {
 800b940:	07d2      	lsls	r2, r2, #31
 800b942:	468b      	mov	fp, r1
 800b944:	f140 8237 	bpl.w	800bdb6 <FreqInvertRescale+0x4f2>
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b948:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b94c:	6800      	ldr	r0, [r0, #0]
 800b94e:	f1c3 081f 	rsb	r8, r3, #31
 800b952:	2601      	movs	r6, #1
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b954:	4249      	negs	r1, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b956:	fa06 f608 	lsl.w	r6, r6, r8
 800b95a:	f106 3aff 	add.w	sl, r6, #4294967295
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b95e:	17cd      	asrs	r5, r1, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b960:	17c4      	asrs	r4, r0, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b962:	fa41 fc08 	asr.w	ip, r1, r8
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b966:	fa40 f608 	asr.w	r6, r0, r8
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b96a:	ea8a 0205 	eor.w	r2, sl, r5
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b96e:	ea8a 0704 	eor.w	r7, sl, r4
 800b972:	42a6      	cmp	r6, r4
 800b974:	bf08      	it	eq
 800b976:	4607      	moveq	r7, r0
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b978:	45ac      	cmp	ip, r5
 800b97a:	bf08      	it	eq
 800b97c:	460a      	moveq	r2, r1
 800b97e:	409a      	lsls	r2, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b980:	fa07 f103 	lsl.w	r1, r7, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b984:	f8ce 2080 	str.w	r2, [lr, #128]	; 0x80
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b988:	f8ce 1000 	str.w	r1, [lr]
 800b98c:	9104      	str	r1, [sp, #16]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800b98e:	f8db 1000 	ldr.w	r1, [fp]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b992:	9208      	str	r2, [sp, #32]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800b994:	17c8      	asrs	r0, r1, #31
 800b996:	fa41 f408 	asr.w	r4, r1, r8
 800b99a:	ea8a 0200 	eor.w	r2, sl, r0
 800b99e:	4284      	cmp	r4, r0
 800b9a0:	bf08      	it	eq
 800b9a2:	460a      	moveq	r2, r1
 800b9a4:	409a      	lsls	r2, r3
 800b9a6:	f8cb 2000 	str.w	r2, [fp]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9aa:	f8de 5180 	ldr.w	r5, [lr, #384]	; 0x180
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9ae:	f8de 2100 	ldr.w	r2, [lr, #256]	; 0x100
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9b2:	426d      	negs	r5, r5
 800b9b4:	ea4f 79e5 	mov.w	r9, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9b8:	17d7      	asrs	r7, r2, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9ba:	fa45 f608 	asr.w	r6, r5, r8
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9be:	ea8a 0107 	eor.w	r1, sl, r7
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9c2:	ea8a 0009 	eor.w	r0, sl, r9
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9c6:	fa42 f408 	asr.w	r4, r2, r8
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9ca:	45b1      	cmp	r9, r6
 800b9cc:	bf0c      	ite	eq
 800b9ce:	46a9      	moveq	r9, r5
 800b9d0:	4681      	movne	r9, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9d2:	42a7      	cmp	r7, r4
 800b9d4:	bf18      	it	ne
 800b9d6:	460a      	movne	r2, r1
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9d8:	fa09 f903 	lsl.w	r9, r9, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9dc:	fa02 f403 	lsl.w	r4, r2, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9e0:	f8ce 9180 	str.w	r9, [lr, #384]	; 0x180
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9e4:	f8ce 4100 	str.w	r4, [lr, #256]	; 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800b9e8:	f8db 2004 	ldr.w	r2, [fp, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800b9ec:	9401      	str	r4, [sp, #4]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800b9ee:	17d1      	asrs	r1, r2, #31
 800b9f0:	ea8a 0001 	eor.w	r0, sl, r1
 800b9f4:	fa42 f408 	asr.w	r4, r2, r8
 800b9f8:	42a1      	cmp	r1, r4
 800b9fa:	bf18      	it	ne
 800b9fc:	4602      	movne	r2, r0
 800b9fe:	409a      	lsls	r2, r3
 800ba00:	f8cb 2004 	str.w	r2, [fp, #4]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba04:	f8de 2280 	ldr.w	r2, [lr, #640]	; 0x280
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba08:	f8de 1200 	ldr.w	r1, [lr, #512]	; 0x200
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba0c:	4252      	negs	r2, r2
 800ba0e:	17d4      	asrs	r4, r2, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba10:	17c8      	asrs	r0, r1, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba12:	fa42 fc08 	asr.w	ip, r2, r8
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba16:	ea8a 0600 	eor.w	r6, sl, r0
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba1a:	ea8a 0504 	eor.w	r5, sl, r4
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba1e:	fa41 f708 	asr.w	r7, r1, r8
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba22:	4564      	cmp	r4, ip
 800ba24:	bf08      	it	eq
 800ba26:	4615      	moveq	r5, r2
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba28:	42b8      	cmp	r0, r7
 800ba2a:	bf18      	it	ne
 800ba2c:	4631      	movne	r1, r6
 800ba2e:	fa01 f703 	lsl.w	r7, r1, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba32:	409d      	lsls	r5, r3
 800ba34:	f8ce 5280 	str.w	r5, [lr, #640]	; 0x280
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba38:	f8ce 7200 	str.w	r7, [lr, #512]	; 0x200
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800ba3c:	f8db 2008 	ldr.w	r2, [fp, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba40:	9703      	str	r7, [sp, #12]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800ba42:	17d1      	asrs	r1, r2, #31
 800ba44:	ea8a 0001 	eor.w	r0, sl, r1
 800ba48:	fa42 f408 	asr.w	r4, r2, r8
 800ba4c:	42a1      	cmp	r1, r4
 800ba4e:	bf18      	it	ne
 800ba50:	4602      	movne	r2, r0
 800ba52:	409a      	lsls	r2, r3
 800ba54:	f8cb 2008 	str.w	r2, [fp, #8]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba58:	f8de 1380 	ldr.w	r1, [lr, #896]	; 0x380
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba5c:	f8de 4300 	ldr.w	r4, [lr, #768]	; 0x300
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba60:	9505      	str	r5, [sp, #20]
 800ba62:	4249      	negs	r1, r1
 800ba64:	17c8      	asrs	r0, r1, #31
 800ba66:	ea8a 0700 	eor.w	r7, sl, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba6a:	17e2      	asrs	r2, r4, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba6c:	fa41 fc08 	asr.w	ip, r1, r8
 800ba70:	4560      	cmp	r0, ip
 800ba72:	bf18      	it	ne
 800ba74:	4639      	movne	r1, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba76:	ea8a 0502 	eor.w	r5, sl, r2
 800ba7a:	fa44 f608 	asr.w	r6, r4, r8
 800ba7e:	42b2      	cmp	r2, r6
 800ba80:	bf18      	it	ne
 800ba82:	462c      	movne	r4, r5
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba84:	fa01 fc03 	lsl.w	ip, r1, r3
 800ba88:	4661      	mov	r1, ip
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba8a:	fa04 fc03 	lsl.w	ip, r4, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba8e:	f8ce 1380 	str.w	r1, [lr, #896]	; 0x380
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba92:	f8ce c300 	str.w	ip, [lr, #768]	; 0x300
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800ba96:	f8db 200c 	ldr.w	r2, [fp, #12]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800ba9a:	910a      	str	r1, [sp, #40]	; 0x28
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800ba9c:	17d1      	asrs	r1, r2, #31
 800ba9e:	ea8a 0001 	eor.w	r0, sl, r1
 800baa2:	fa42 f408 	asr.w	r4, r2, r8
 800baa6:	42a1      	cmp	r1, r4
 800baa8:	bf18      	it	ne
 800baaa:	4602      	movne	r2, r0
 800baac:	409a      	lsls	r2, r3
 800baae:	f8cb 200c 	str.w	r2, [fp, #12]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bab2:	f8de 4480 	ldr.w	r4, [lr, #1152]	; 0x480
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bab6:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800baba:	4264      	negs	r4, r4
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800babc:	f8de 5400 	ldr.w	r5, [lr, #1024]	; 0x400
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bac0:	17e1      	asrs	r1, r4, #31
 800bac2:	ea8a 0701 	eor.w	r7, sl, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bac6:	17ea      	asrs	r2, r5, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bac8:	fa44 fc08 	asr.w	ip, r4, r8
 800bacc:	4561      	cmp	r1, ip
 800bace:	bf18      	it	ne
 800bad0:	463c      	movne	r4, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bad2:	ea8a 0002 	eor.w	r0, sl, r2
 800bad6:	fa45 f608 	asr.w	r6, r5, r8
 800bada:	42b2      	cmp	r2, r6
 800badc:	bf18      	it	ne
 800bade:	4605      	movne	r5, r0
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bae0:	fa04 fc03 	lsl.w	ip, r4, r3
 800bae4:	4666      	mov	r6, ip
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bae6:	fa05 fc03 	lsl.w	ip, r5, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800baea:	f8ce 6480 	str.w	r6, [lr, #1152]	; 0x480
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800baee:	f8ce c400 	str.w	ip, [lr, #1024]	; 0x400
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800baf2:	f8db 2010 	ldr.w	r2, [fp, #16]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800baf6:	9602      	str	r6, [sp, #8]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800baf8:	17d1      	asrs	r1, r2, #31
 800bafa:	ea8a 0001 	eor.w	r0, sl, r1
 800bafe:	fa42 f408 	asr.w	r4, r2, r8
 800bb02:	42a1      	cmp	r1, r4
 800bb04:	bf18      	it	ne
 800bb06:	4602      	movne	r2, r0
 800bb08:	409a      	lsls	r2, r3
 800bb0a:	f8cb 2010 	str.w	r2, [fp, #16]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb0e:	f8de 7500 	ldr.w	r7, [lr, #1280]	; 0x500
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb12:	f8de 5580 	ldr.w	r5, [lr, #1408]	; 0x580
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb16:	17fa      	asrs	r2, r7, #31
 800bb18:	ea8a 0102 	eor.w	r1, sl, r2
 800bb1c:	fa47 f008 	asr.w	r0, r7, r8
 800bb20:	4282      	cmp	r2, r0
 800bb22:	bf18      	it	ne
 800bb24:	460f      	movne	r7, r1
 800bb26:	fa07 f203 	lsl.w	r2, r7, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb2a:	426d      	negs	r5, r5
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb2c:	f8ce 2500 	str.w	r2, [lr, #1280]	; 0x500
 800bb30:	920b      	str	r2, [sp, #44]	; 0x2c
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb32:	17ea      	asrs	r2, r5, #31
 800bb34:	ea8a 0102 	eor.w	r1, sl, r2
 800bb38:	fa45 f008 	asr.w	r0, r5, r8
 800bb3c:	4282      	cmp	r2, r0
 800bb3e:	bf18      	it	ne
 800bb40:	460d      	movne	r5, r1
 800bb42:	fa05 f003 	lsl.w	r0, r5, r3
 800bb46:	f8ce 0580 	str.w	r0, [lr, #1408]	; 0x580
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bb4a:	f8db 2014 	ldr.w	r2, [fp, #20]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb4e:	900c      	str	r0, [sp, #48]	; 0x30
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bb50:	17d1      	asrs	r1, r2, #31
 800bb52:	ea8a 0001 	eor.w	r0, sl, r1
 800bb56:	fa42 f408 	asr.w	r4, r2, r8
 800bb5a:	42a1      	cmp	r1, r4
 800bb5c:	bf18      	it	ne
 800bb5e:	4602      	movne	r2, r0
 800bb60:	409a      	lsls	r2, r3
 800bb62:	f8cb 2014 	str.w	r2, [fp, #20]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb66:	f8de 6600 	ldr.w	r6, [lr, #1536]	; 0x600
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb6a:	f8de 2680 	ldr.w	r2, [lr, #1664]	; 0x680
 800bb6e:	4250      	negs	r0, r2
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb70:	17f2      	asrs	r2, r6, #31
 800bb72:	ea8a 0402 	eor.w	r4, sl, r2
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb76:	17c1      	asrs	r1, r0, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb78:	9406      	str	r4, [sp, #24]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb7a:	fa40 f708 	asr.w	r7, r0, r8
 800bb7e:	ea8a 0501 	eor.w	r5, sl, r1
 800bb82:	42b9      	cmp	r1, r7
 800bb84:	bf0c      	ite	eq
 800bb86:	4601      	moveq	r1, r0
 800bb88:	4629      	movne	r1, r5
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb8a:	9d06      	ldr	r5, [sp, #24]
 800bb8c:	fa46 f408 	asr.w	r4, r6, r8
 800bb90:	42a2      	cmp	r2, r4
 800bb92:	bf18      	it	ne
 800bb94:	462e      	movne	r6, r5
 800bb96:	fa06 f503 	lsl.w	r5, r6, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bb9a:	fa01 f403 	lsl.w	r4, r1, r3
 800bb9e:	f8ce 4680 	str.w	r4, [lr, #1664]	; 0x680
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bba2:	f8ce 5600 	str.w	r5, [lr, #1536]	; 0x600
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bba6:	f8db 2018 	ldr.w	r2, [fp, #24]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbaa:	940d      	str	r4, [sp, #52]	; 0x34
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bbac:	17d1      	asrs	r1, r2, #31
 800bbae:	ea8a 0001 	eor.w	r0, sl, r1
 800bbb2:	fa42 f408 	asr.w	r4, r2, r8
 800bbb6:	42a1      	cmp	r1, r4
 800bbb8:	bf18      	it	ne
 800bbba:	4602      	movne	r2, r0
 800bbbc:	409a      	lsls	r2, r3
 800bbbe:	f8cb 2018 	str.w	r2, [fp, #24]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbc2:	f8de 1700 	ldr.w	r1, [lr, #1792]	; 0x700
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbc6:	f8de 2780 	ldr.w	r2, [lr, #1920]	; 0x780
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbca:	9506      	str	r5, [sp, #24]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbcc:	4252      	negs	r2, r2
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbce:	17c8      	asrs	r0, r1, #31
 800bbd0:	ea8a 0600 	eor.w	r6, sl, r0
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbd4:	17d4      	asrs	r4, r2, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbd6:	9607      	str	r6, [sp, #28]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbd8:	ea8a 0504 	eor.w	r5, sl, r4
 800bbdc:	fa42 f708 	asr.w	r7, r2, r8
 800bbe0:	42bc      	cmp	r4, r7
 800bbe2:	bf18      	it	ne
 800bbe4:	462a      	movne	r2, r5
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbe6:	9c07      	ldr	r4, [sp, #28]
 800bbe8:	fa41 f608 	asr.w	r6, r1, r8
 800bbec:	42b0      	cmp	r0, r6
 800bbee:	bf18      	it	ne
 800bbf0:	4621      	movne	r1, r4
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbf2:	fa02 f703 	lsl.w	r7, r2, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbf6:	fa01 f203 	lsl.w	r2, r1, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbfa:	f8ce 7780 	str.w	r7, [lr, #1920]	; 0x780
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bbfe:	f8ce 2700 	str.w	r2, [lr, #1792]	; 0x700
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bc02:	970e      	str	r7, [sp, #56]	; 0x38
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bc04:	9207      	str	r2, [sp, #28]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bc06:	f8db 201c 	ldr.w	r2, [fp, #28]
	sign = x >> (sizeof(int) * 8 - 1);
 800bc0a:	9e01      	ldr	r6, [sp, #4]
 800bc0c:	9f03      	ldr	r7, [sp, #12]
 800bc0e:	17d1      	asrs	r1, r2, #31
 800bc10:	fa42 f508 	asr.w	r5, r2, r8
 800bc14:	ea8a 0401 	eor.w	r4, sl, r1
 800bc18:	ea4f 70e9 	mov.w	r0, r9, asr #31
 800bc1c:	42a9      	cmp	r1, r5
 800bc1e:	bf08      	it	eq
 800bc20:	4614      	moveq	r4, r2
 800bc22:	17f1      	asrs	r1, r6, #31
	x ^= sign;
 800bc24:	ea89 0500 	eor.w	r5, r9, r0
 800bc28:	ea86 0201 	eor.w	r2, r6, r1
	x -= sign;
 800bc2c:	1a28      	subs	r0, r5, r0
	sign = x >> (sizeof(int) * 8 - 1);
 800bc2e:	17fd      	asrs	r5, r7, #31
	x -= sign;
 800bc30:	1a52      	subs	r2, r2, r1
	x ^= sign;
 800bc32:	ea87 0105 	eor.w	r1, r7, r5
	x -= sign;
 800bc36:	1b49      	subs	r1, r1, r5
	sign = x >> (sizeof(int) * 8 - 1);
 800bc38:	9d05      	ldr	r5, [sp, #20]
 800bc3a:	409c      	lsls	r4, r3
 800bc3c:	f8cb 401c 	str.w	r4, [fp, #28]
 800bc40:	17ef      	asrs	r7, r5, #31
 800bc42:	9c09      	ldr	r4, [sp, #36]	; 0x24
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bc44:	f8de 6880 	ldr.w	r6, [lr, #2176]	; 0x880
	x ^= sign;
 800bc48:	407d      	eors	r5, r7
 800bc4a:	4302      	orrs	r2, r0
	x -= sign;
 800bc4c:	1bed      	subs	r5, r5, r7
 800bc4e:	430a      	orrs	r2, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800bc50:	17e0      	asrs	r0, r4, #31
 800bc52:	990a      	ldr	r1, [sp, #40]	; 0x28
 800bc54:	432a      	orrs	r2, r5
 800bc56:	4275      	negs	r5, r6
 800bc58:	9501      	str	r5, [sp, #4]
	x ^= sign;
 800bc5a:	4044      	eors	r4, r0
	sign = x >> (sizeof(int) * 8 - 1);
 800bc5c:	9d02      	ldr	r5, [sp, #8]
 800bc5e:	17cf      	asrs	r7, r1, #31
	x -= sign;
 800bc60:	1a24      	subs	r4, r4, r0
	sign = x >> (sizeof(int) * 8 - 1);
 800bc62:	17ee      	asrs	r6, r5, #31
	x ^= sign;
 800bc64:	4079      	eors	r1, r7
 800bc66:	4322      	orrs	r2, r4
 800bc68:	9c01      	ldr	r4, [sp, #4]
	sign = x >> (sizeof(int) * 8 - 1);
 800bc6a:	9603      	str	r6, [sp, #12]
	x -= sign;
 800bc6c:	1bc9      	subs	r1, r1, r7
	sign = x >> (sizeof(int) * 8 - 1);
 800bc6e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bc70:	f8de 7800 	ldr.w	r7, [lr, #2048]	; 0x800
 800bc74:	ea4f 70ec 	mov.w	r0, ip, asr #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bc78:	ea4f 79e4 	mov.w	r9, r4, asr #31
	x ^= sign;
 800bc7c:	9c02      	ldr	r4, [sp, #8]
 800bc7e:	ea8c 0500 	eor.w	r5, ip, r0
 800bc82:	430a      	orrs	r2, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bc84:	ea4f 7ce7 	mov.w	ip, r7, asr #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bc88:	ea8a 0109 	eor.w	r1, sl, r9
	sign = x >> (sizeof(int) * 8 - 1);
 800bc8c:	17f7      	asrs	r7, r6, #31
 800bc8e:	9705      	str	r7, [sp, #20]
 800bc90:	9102      	str	r1, [sp, #8]
	x ^= sign;
 800bc92:	4627      	mov	r7, r4
 800bc94:	9901      	ldr	r1, [sp, #4]
 800bc96:	9c03      	ldr	r4, [sp, #12]
 800bc98:	407c      	eors	r4, r7
 800bc9a:	fa41 f708 	asr.w	r7, r1, r8
 800bc9e:	9701      	str	r7, [sp, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bca0:	f8de 7800 	ldr.w	r7, [lr, #2048]	; 0x800
 800bca4:	fa47 f708 	asr.w	r7, r7, r8
 800bca8:	970a      	str	r7, [sp, #40]	; 0x28
 800bcaa:	9f05      	ldr	r7, [sp, #20]
	x -= sign;
 800bcac:	1a2d      	subs	r5, r5, r0
	x ^= sign;
 800bcae:	407e      	eors	r6, r7
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bcb0:	432a      	orrs	r2, r5
 800bcb2:	9f02      	ldr	r7, [sp, #8]
 800bcb4:	9d01      	ldr	r5, [sp, #4]
 800bcb6:	9609      	str	r6, [sp, #36]	; 0x24
	x -= sign;
 800bcb8:	9e03      	ldr	r6, [sp, #12]
 800bcba:	45a9      	cmp	r9, r5
 800bcbc:	bf18      	it	ne
 800bcbe:	4639      	movne	r1, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bcc0:	f8de 5800 	ldr.w	r5, [lr, #2048]	; 0x800
 800bcc4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800bcc6:	ea8c 000a 	eor.w	r0, ip, sl
 800bcca:	1ba4      	subs	r4, r4, r6
	sign = x >> (sizeof(int) * 8 - 1);
 800bccc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	x -= sign;
 800bcce:	9403      	str	r4, [sp, #12]
 800bcd0:	45bc      	cmp	ip, r7
 800bcd2:	bf08      	it	eq
 800bcd4:	4628      	moveq	r0, r5
	sign = x >> (sizeof(int) * 8 - 1);
 800bcd6:	9d06      	ldr	r5, [sp, #24]
 800bcd8:	17f4      	asrs	r4, r6, #31
 800bcda:	ea4f 79e5 	mov.w	r9, r5, asr #31
	x ^= sign;
 800bcde:	ea86 0504 	eor.w	r5, r6, r4
	x -= sign;
 800bce2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800bce4:	9f05      	ldr	r7, [sp, #20]
 800bce6:	1bf7      	subs	r7, r6, r7
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bce8:	9e03      	ldr	r6, [sp, #12]
 800bcea:	4332      	orrs	r2, r6
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bcec:	fa00 f603 	lsl.w	r6, r0, r3
 800bcf0:	9601      	str	r6, [sp, #4]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bcf2:	4099      	lsls	r1, r3
 800bcf4:	9102      	str	r1, [sp, #8]
 800bcf6:	1b2d      	subs	r5, r5, r4
	sign = x >> (sizeof(int) * 8 - 1);
 800bcf8:	990d      	ldr	r1, [sp, #52]	; 0x34
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bcfa:	9c01      	ldr	r4, [sp, #4]
 800bcfc:	f8ce 4800 	str.w	r4, [lr, #2048]	; 0x800
 800bd00:	9c07      	ldr	r4, [sp, #28]
	x ^= sign;
 800bd02:	9e06      	ldr	r6, [sp, #24]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bd04:	9802      	ldr	r0, [sp, #8]
 800bd06:	f8ce 0880 	str.w	r0, [lr, #2176]	; 0x880
	sign = x >> (sizeof(int) * 8 - 1);
 800bd0a:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 800bd0e:	433a      	orrs	r2, r7
 800bd10:	17e7      	asrs	r7, r4, #31
	x ^= sign;
 800bd12:	ea81 040c 	eor.w	r4, r1, ip
	sign = x >> (sizeof(int) * 8 - 1);
 800bd16:	9908      	ldr	r1, [sp, #32]
	x ^= sign;
 800bd18:	ea86 0609 	eor.w	r6, r6, r9
 800bd1c:	4315      	orrs	r5, r2
	sign = x >> (sizeof(int) * 8 - 1);
 800bd1e:	17ca      	asrs	r2, r1, #31
	x -= sign;
 800bd20:	eba6 0909 	sub.w	r9, r6, r9
	sign = x >> (sizeof(int) * 8 - 1);
 800bd24:	4616      	mov	r6, r2
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bd26:	f8db 2020 	ldr.w	r2, [fp, #32]
 800bd2a:	9203      	str	r2, [sp, #12]
	x ^= sign;
 800bd2c:	9a07      	ldr	r2, [sp, #28]
 800bd2e:	4620      	mov	r0, r4
	sign = x >> (sizeof(int) * 8 - 1);
 800bd30:	9c04      	ldr	r4, [sp, #16]
	x ^= sign;
 800bd32:	ea82 0e07 	eor.w	lr, r2, r7
 800bd36:	9a04      	ldr	r2, [sp, #16]
	sign = x >> (sizeof(int) * 8 - 1);
 800bd38:	17e4      	asrs	r4, r4, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bd3a:	ea45 0509 	orr.w	r5, r5, r9
	x ^= sign;
 800bd3e:	4062      	eors	r2, r4
 800bd40:	ea86 0901 	eor.w	r9, r6, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800bd44:	990e      	ldr	r1, [sp, #56]	; 0x38
	x -= sign;
 800bd46:	eba0 0c0c 	sub.w	ip, r0, ip
 800bd4a:	1b14      	subs	r4, r2, r4
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bd4c:	9803      	ldr	r0, [sp, #12]
 800bd4e:	eba9 0206 	sub.w	r2, r9, r6
 800bd52:	ebae 0e07 	sub.w	lr, lr, r7
	sign = x >> (sizeof(int) * 8 - 1);
 800bd56:	9e01      	ldr	r6, [sp, #4]
 800bd58:	17cf      	asrs	r7, r1, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bd5a:	4314      	orrs	r4, r2
	x ^= sign;
 800bd5c:	460a      	mov	r2, r1
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bd5e:	9903      	ldr	r1, [sp, #12]
 800bd60:	17c0      	asrs	r0, r0, #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bd62:	ea45 050c 	orr.w	r5, r5, ip
	sign = x >> (sizeof(int) * 8 - 1);
 800bd66:	ea4f 79e6 	mov.w	r9, r6, asr #31
 800bd6a:	ea45 050e 	orr.w	r5, r5, lr
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bd6e:	4606      	mov	r6, r0
 800bd70:	fa41 fe08 	asr.w	lr, r1, r8
 800bd74:	ea8a 0800 	eor.w	r8, sl, r0
	x ^= sign;
 800bd78:	9901      	ldr	r1, [sp, #4]
	sign = x >> (sizeof(int) * 8 - 1);
 800bd7a:	9802      	ldr	r0, [sp, #8]
	x ^= sign;
 800bd7c:	407a      	eors	r2, r7
	sign = x >> (sizeof(int) * 8 - 1);
 800bd7e:	ea4f 7ce0 	mov.w	ip, r0, asr #31
	x ^= sign;
 800bd82:	ea81 0009 	eor.w	r0, r1, r9
 800bd86:	9902      	ldr	r1, [sp, #8]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bd88:	4325      	orrs	r5, r4
	x -= sign;
 800bd8a:	1bd2      	subs	r2, r2, r7
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bd8c:	9c03      	ldr	r4, [sp, #12]
 800bd8e:	eba0 0009 	sub.w	r0, r0, r9
	x ^= sign;
 800bd92:	ea81 010c 	eor.w	r1, r1, ip
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bd96:	432a      	orrs	r2, r5
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bd98:	4576      	cmp	r6, lr
 800bd9a:	bf18      	it	ne
 800bd9c:	4644      	movne	r4, r8
	x -= sign;
 800bd9e:	eba1 0c0c 	sub.w	ip, r1, ip
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bda2:	4302      	orrs	r2, r0
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bda4:	fa04 f303 	lsl.w	r3, r4, r3
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bda8:	ea42 000c 	orr.w	r0, r2, ip
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bdac:	f8cb 3020 	str.w	r3, [fp, #32]
}
 800bdb0:	b011      	add	sp, #68	; 0x44
 800bdb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bdb6:	f1c3 091f 	rsb	r9, r3, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdba:	6800      	ldr	r0, [r0, #0]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdbc:	f8de 4080 	ldr.w	r4, [lr, #128]	; 0x80
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdc0:	2201      	movs	r2, #1
 800bdc2:	fa02 f209 	lsl.w	r2, r2, r9
 800bdc6:	f102 3aff 	add.w	sl, r2, #4294967295
 800bdca:	17c1      	asrs	r1, r0, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdcc:	17e2      	asrs	r2, r4, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdce:	ea8a 0701 	eor.w	r7, sl, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdd2:	ea8a 0502 	eor.w	r5, sl, r2
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdd6:	fa40 fc09 	asr.w	ip, r0, r9
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdda:	fa44 f609 	asr.w	r6, r4, r9
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdde:	4561      	cmp	r1, ip
 800bde0:	bf18      	it	ne
 800bde2:	4638      	movne	r0, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bde4:	42b2      	cmp	r2, r6
 800bde6:	bf18      	it	ne
 800bde8:	462c      	movne	r4, r5
 800bdea:	fa04 f103 	lsl.w	r1, r4, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdee:	fa00 f203 	lsl.w	r2, r0, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdf2:	f8ce 1080 	str.w	r1, [lr, #128]	; 0x80
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bdf6:	f8ce 2000 	str.w	r2, [lr]
 800bdfa:	9208      	str	r2, [sp, #32]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bdfc:	f8db 2000 	ldr.w	r2, [fp]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be00:	9109      	str	r1, [sp, #36]	; 0x24
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800be02:	17d1      	asrs	r1, r2, #31
 800be04:	ea8a 0001 	eor.w	r0, sl, r1
 800be08:	fa42 f409 	asr.w	r4, r2, r9
 800be0c:	42a1      	cmp	r1, r4
 800be0e:	bf18      	it	ne
 800be10:	4602      	movne	r2, r0
 800be12:	409a      	lsls	r2, r3
 800be14:	f8cb 2000 	str.w	r2, [fp]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be18:	f8de 2100 	ldr.w	r2, [lr, #256]	; 0x100
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be1c:	f8de 0180 	ldr.w	r0, [lr, #384]	; 0x180
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be20:	ea4f 78e2 	mov.w	r8, r2, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be24:	17c7      	asrs	r7, r0, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be26:	fa42 f609 	asr.w	r6, r2, r9
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be2a:	ea8a 0107 	eor.w	r1, sl, r7
 800be2e:	fa40 f409 	asr.w	r4, r0, r9
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be32:	ea8a 0508 	eor.w	r5, sl, r8
 800be36:	45b0      	cmp	r8, r6
 800be38:	bf0c      	ite	eq
 800be3a:	4690      	moveq	r8, r2
 800be3c:	46a8      	movne	r8, r5
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be3e:	42a7      	cmp	r7, r4
 800be40:	bf0c      	ite	eq
 800be42:	4602      	moveq	r2, r0
 800be44:	460a      	movne	r2, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be46:	fa08 f803 	lsl.w	r8, r8, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be4a:	fa02 f403 	lsl.w	r4, r2, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be4e:	f8ce 8100 	str.w	r8, [lr, #256]	; 0x100
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be52:	f8ce 4180 	str.w	r4, [lr, #384]	; 0x180
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800be56:	f8db 2004 	ldr.w	r2, [fp, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be5a:	9401      	str	r4, [sp, #4]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800be5c:	17d1      	asrs	r1, r2, #31
 800be5e:	ea8a 0001 	eor.w	r0, sl, r1
 800be62:	fa42 f409 	asr.w	r4, r2, r9
 800be66:	42a1      	cmp	r1, r4
 800be68:	bf18      	it	ne
 800be6a:	4602      	movne	r2, r0
 800be6c:	409a      	lsls	r2, r3
 800be6e:	f8cb 2004 	str.w	r2, [fp, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be72:	f8de 2200 	ldr.w	r2, [lr, #512]	; 0x200
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be76:	f8de 1280 	ldr.w	r1, [lr, #640]	; 0x280
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be7a:	17d4      	asrs	r4, r2, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be7c:	17c8      	asrs	r0, r1, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be7e:	ea8a 0c04 	eor.w	ip, sl, r4
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be82:	ea8a 0500 	eor.w	r5, sl, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be86:	fa42 f709 	asr.w	r7, r2, r9
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be8a:	fa41 f609 	asr.w	r6, r1, r9
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be8e:	42bc      	cmp	r4, r7
 800be90:	bf18      	it	ne
 800be92:	4662      	movne	r2, ip
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be94:	42b0      	cmp	r0, r6
 800be96:	bf18      	it	ne
 800be98:	4629      	movne	r1, r5
 800be9a:	fa01 f703 	lsl.w	r7, r1, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800be9e:	fa02 f503 	lsl.w	r5, r2, r3
 800bea2:	f8ce 5200 	str.w	r5, [lr, #512]	; 0x200
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bea6:	f8ce 7280 	str.w	r7, [lr, #640]	; 0x280
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800beaa:	f8db 2008 	ldr.w	r2, [fp, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800beae:	970a      	str	r7, [sp, #40]	; 0x28
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800beb0:	17d1      	asrs	r1, r2, #31
 800beb2:	ea8a 0001 	eor.w	r0, sl, r1
 800beb6:	fa42 f409 	asr.w	r4, r2, r9
 800beba:	42a1      	cmp	r1, r4
 800bebc:	bf18      	it	ne
 800bebe:	4602      	movne	r2, r0
 800bec0:	409a      	lsls	r2, r3
 800bec2:	f8cb 2008 	str.w	r2, [fp, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bec6:	f8de 6300 	ldr.w	r6, [lr, #768]	; 0x300
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800beca:	f8de 2380 	ldr.w	r2, [lr, #896]	; 0x380
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bece:	9507      	str	r5, [sp, #28]
 800bed0:	17f0      	asrs	r0, r6, #31
 800bed2:	ea8a 0700 	eor.w	r7, sl, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bed6:	17d1      	asrs	r1, r2, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bed8:	fa46 fc09 	asr.w	ip, r6, r9
 800bedc:	4560      	cmp	r0, ip
 800bede:	bf18      	it	ne
 800bee0:	463e      	movne	r6, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bee2:	ea8a 0401 	eor.w	r4, sl, r1
 800bee6:	fa42 f509 	asr.w	r5, r2, r9
 800beea:	42a9      	cmp	r1, r5
 800beec:	bf18      	it	ne
 800beee:	4622      	movne	r2, r4
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bef0:	fa06 fc03 	lsl.w	ip, r6, r3
 800bef4:	4660      	mov	r0, ip
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bef6:	fa02 fc03 	lsl.w	ip, r2, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800befa:	f8ce 0300 	str.w	r0, [lr, #768]	; 0x300
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800befe:	f8ce c380 	str.w	ip, [lr, #896]	; 0x380
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bf02:	f8db 200c 	ldr.w	r2, [fp, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf06:	900b      	str	r0, [sp, #44]	; 0x2c
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bf08:	17d1      	asrs	r1, r2, #31
 800bf0a:	ea8a 0001 	eor.w	r0, sl, r1
 800bf0e:	fa42 f409 	asr.w	r4, r2, r9
 800bf12:	42a1      	cmp	r1, r4
 800bf14:	bf18      	it	ne
 800bf16:	4602      	movne	r2, r0
 800bf18:	409a      	lsls	r2, r3
 800bf1a:	f8cb 200c 	str.w	r2, [fp, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf1e:	f8de 4400 	ldr.w	r4, [lr, #1024]	; 0x400
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf22:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
 800bf26:	f8de 2480 	ldr.w	r2, [lr, #1152]	; 0x480
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf2a:	17e0      	asrs	r0, r4, #31
 800bf2c:	ea8a 0700 	eor.w	r7, sl, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf30:	17d1      	asrs	r1, r2, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf32:	fa44 fc09 	asr.w	ip, r4, r9
 800bf36:	4560      	cmp	r0, ip
 800bf38:	bf18      	it	ne
 800bf3a:	463c      	movne	r4, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf3c:	ea8a 0501 	eor.w	r5, sl, r1
 800bf40:	fa42 f609 	asr.w	r6, r2, r9
 800bf44:	42b1      	cmp	r1, r6
 800bf46:	bf18      	it	ne
 800bf48:	462a      	movne	r2, r5
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf4a:	fa04 fc03 	lsl.w	ip, r4, r3
 800bf4e:	4661      	mov	r1, ip
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf50:	fa02 fc03 	lsl.w	ip, r2, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf54:	f8ce 1400 	str.w	r1, [lr, #1024]	; 0x400
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf58:	f8ce c480 	str.w	ip, [lr, #1152]	; 0x480
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bf5c:	f8db 2010 	ldr.w	r2, [fp, #16]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf60:	910d      	str	r1, [sp, #52]	; 0x34
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bf62:	17d1      	asrs	r1, r2, #31
 800bf64:	ea8a 0001 	eor.w	r0, sl, r1
 800bf68:	fa42 f409 	asr.w	r4, r2, r9
 800bf6c:	42a1      	cmp	r1, r4
 800bf6e:	bf18      	it	ne
 800bf70:	4602      	movne	r2, r0
 800bf72:	409a      	lsls	r2, r3
 800bf74:	f8cb 2010 	str.w	r2, [fp, #16]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf78:	f8de 0500 	ldr.w	r0, [lr, #1280]	; 0x500
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf7c:	f8de 5580 	ldr.w	r5, [lr, #1408]	; 0x580
 800bf80:	f8cd c008 	str.w	ip, [sp, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf84:	17c2      	asrs	r2, r0, #31
 800bf86:	ea8a 0102 	eor.w	r1, sl, r2
 800bf8a:	fa40 f409 	asr.w	r4, r0, r9
 800bf8e:	42a2      	cmp	r2, r4
 800bf90:	bf18      	it	ne
 800bf92:	4608      	movne	r0, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf94:	17ea      	asrs	r2, r5, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf96:	fa00 fc03 	lsl.w	ip, r0, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bf9a:	ea8a 0102 	eor.w	r1, sl, r2
 800bf9e:	fa45 f009 	asr.w	r0, r5, r9
 800bfa2:	4282      	cmp	r2, r0
 800bfa4:	bf18      	it	ne
 800bfa6:	460d      	movne	r5, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfa8:	f8ce c500 	str.w	ip, [lr, #1280]	; 0x500
 800bfac:	f8cd c00c 	str.w	ip, [sp, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfb0:	fa05 fc03 	lsl.w	ip, r5, r3
 800bfb4:	f8ce c580 	str.w	ip, [lr, #1408]	; 0x580
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bfb8:	f8db 2014 	ldr.w	r2, [fp, #20]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfbc:	f8cd c010 	str.w	ip, [sp, #16]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800bfc0:	17d1      	asrs	r1, r2, #31
 800bfc2:	ea8a 0001 	eor.w	r0, sl, r1
 800bfc6:	fa42 f409 	asr.w	r4, r2, r9
 800bfca:	42a1      	cmp	r1, r4
 800bfcc:	bf18      	it	ne
 800bfce:	4602      	movne	r2, r0
 800bfd0:	409a      	lsls	r2, r3
 800bfd2:	f8cb 2014 	str.w	r2, [fp, #20]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfd6:	f8de 1600 	ldr.w	r1, [lr, #1536]	; 0x600
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfda:	f8de 2680 	ldr.w	r2, [lr, #1664]	; 0x680
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfde:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 800bfe2:	ea8a 060c 	eor.w	r6, sl, ip
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfe6:	17d0      	asrs	r0, r2, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bfe8:	fa41 f709 	asr.w	r7, r1, r9
 800bfec:	45bc      	cmp	ip, r7
 800bfee:	bf18      	it	ne
 800bff0:	4631      	movne	r1, r6
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800bff2:	ea8a 0400 	eor.w	r4, sl, r0
 800bff6:	fa42 f509 	asr.w	r5, r2, r9
 800bffa:	42a8      	cmp	r0, r5
 800bffc:	bf18      	it	ne
 800bffe:	4622      	movne	r2, r4
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c000:	fa01 fc03 	lsl.w	ip, r1, r3
 800c004:	4661      	mov	r1, ip
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c006:	fa02 fc03 	lsl.w	ip, r2, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c00a:	f8ce 1600 	str.w	r1, [lr, #1536]	; 0x600
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c00e:	f8ce c680 	str.w	ip, [lr, #1664]	; 0x680
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c012:	f8db 2018 	ldr.w	r2, [fp, #24]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c016:	9105      	str	r1, [sp, #20]
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c018:	17d1      	asrs	r1, r2, #31
 800c01a:	ea8a 0001 	eor.w	r0, sl, r1
 800c01e:	fa42 f409 	asr.w	r4, r2, r9
 800c022:	42a1      	cmp	r1, r4
 800c024:	bf18      	it	ne
 800c026:	4602      	movne	r2, r0
 800c028:	409a      	lsls	r2, r3
 800c02a:	f8cb 2018 	str.w	r2, [fp, #24]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c02e:	f8de 5700 	ldr.w	r5, [lr, #1792]	; 0x700
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c032:	f8de 2780 	ldr.w	r2, [lr, #1920]	; 0x780
 800c036:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c03a:	17e8      	asrs	r0, r5, #31
 800c03c:	ea8a 0700 	eor.w	r7, sl, r0
 800c040:	fa45 fc09 	asr.w	ip, r5, r9
 800c044:	4560      	cmp	r0, ip
 800c046:	bf18      	it	ne
 800c048:	463d      	movne	r5, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c04a:	17d1      	asrs	r1, r2, #31
 800c04c:	ea8a 0401 	eor.w	r4, sl, r1
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c050:	fa05 fc03 	lsl.w	ip, r5, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c054:	fa42 f609 	asr.w	r6, r2, r9
 800c058:	42b1      	cmp	r1, r6
 800c05a:	bf18      	it	ne
 800c05c:	4622      	movne	r2, r4
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c05e:	4660      	mov	r0, ip
 800c060:	f8ce 0700 	str.w	r0, [lr, #1792]	; 0x700
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c064:	fa02 fc03 	lsl.w	ip, r2, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c068:	900f      	str	r0, [sp, #60]	; 0x3c
	sign = x >> (sizeof(int) * 8 - 1);
 800c06a:	9801      	ldr	r0, [sp, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c06c:	f8ce c780 	str.w	ip, [lr, #1920]	; 0x780
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c070:	f8db 401c 	ldr.w	r4, [fp, #28]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c074:	f8cd c018 	str.w	ip, [sp, #24]
 800c078:	17c5      	asrs	r5, r0, #31
	x ^= sign;
 800c07a:	4068      	eors	r0, r5
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c07c:	17e7      	asrs	r7, r4, #31
	x -= sign;
 800c07e:	1b40      	subs	r0, r0, r5
	sign = x >> (sizeof(int) * 8 - 1);
 800c080:	9d07      	ldr	r5, [sp, #28]
 800c082:	ea4f 76e8 	mov.w	r6, r8, asr #31
 800c086:	ea8a 0107 	eor.w	r1, sl, r7
 800c08a:	fa44 fc09 	asr.w	ip, r4, r9
 800c08e:	4567      	cmp	r7, ip
 800c090:	bf18      	it	ne
 800c092:	460c      	movne	r4, r1
	x ^= sign;
 800c094:	ea88 0206 	eor.w	r2, r8, r6
	sign = x >> (sizeof(int) * 8 - 1);
 800c098:	17e9      	asrs	r1, r5, #31
	x ^= sign;
 800c09a:	404d      	eors	r5, r1
	x -= sign;
 800c09c:	1b92      	subs	r2, r2, r6
	sign = x >> (sizeof(int) * 8 - 1);
 800c09e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	x -= sign;
 800c0a0:	1a6f      	subs	r7, r5, r1
 800c0a2:	409c      	lsls	r4, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c0a4:	4302      	orrs	r2, r0
	sign = x >> (sizeof(int) * 8 - 1);
 800c0a6:	980b      	ldr	r0, [sp, #44]	; 0x2c
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c0a8:	f8cb 401c 	str.w	r4, [fp, #28]
 800c0ac:	17f5      	asrs	r5, r6, #31
 800c0ae:	9c0c      	ldr	r4, [sp, #48]	; 0x30
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c0b0:	433a      	orrs	r2, r7
 800c0b2:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 800c0b4:	ea4f 78e0 	mov.w	r8, r0, asr #31
	x ^= sign;
 800c0b8:	ea86 0105 	eor.w	r1, r6, r5
	x -= sign;
 800c0bc:	1b49      	subs	r1, r1, r5
	x ^= sign;
 800c0be:	ea80 0608 	eor.w	r6, r0, r8
	sign = x >> (sizeof(int) * 8 - 1);
 800c0c2:	17e5      	asrs	r5, r4, #31
 800c0c4:	17f8      	asrs	r0, r7, #31
 800c0c6:	4311      	orrs	r1, r2
	x ^= sign;
 800c0c8:	ea84 0205 	eor.w	r2, r4, r5
 800c0cc:	ea87 0400 	eor.w	r4, r7, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c0d0:	f8de 7800 	ldr.w	r7, [lr, #2048]	; 0x800
	x -= sign;
 800c0d4:	1b52      	subs	r2, r2, r5
 800c0d6:	ea4f 7ce7 	mov.w	ip, r7, asr #31
	sign = x >> (sizeof(int) * 8 - 1);
 800c0da:	9d02      	ldr	r5, [sp, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c0dc:	f8de 7880 	ldr.w	r7, [lr, #2176]	; 0x880
	x -= sign;
 800c0e0:	eba6 0608 	sub.w	r6, r6, r8
	sign = x >> (sizeof(int) * 8 - 1);
 800c0e4:	ea4f 78e5 	mov.w	r8, r5, asr #31
 800c0e8:	17fd      	asrs	r5, r7, #31
 800c0ea:	9501      	str	r5, [sp, #4]
	x ^= sign;
 800c0ec:	9d02      	ldr	r5, [sp, #8]
 800c0ee:	4331      	orrs	r1, r6
 800c0f0:	4311      	orrs	r1, r2
 800c0f2:	ea85 0208 	eor.w	r2, r5, r8
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c0f6:	ea8c 050a 	eor.w	r5, ip, sl
 800c0fa:	462f      	mov	r7, r5
 800c0fc:	f8de 5800 	ldr.w	r5, [lr, #2048]	; 0x800
	sign = x >> (sizeof(int) * 8 - 1);
 800c100:	9e03      	ldr	r6, [sp, #12]
	x -= sign;
 800c102:	1a24      	subs	r4, r4, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c104:	9801      	ldr	r0, [sp, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c106:	fa45 f509 	asr.w	r5, r5, r9
 800c10a:	9502      	str	r5, [sp, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c10c:	4321      	orrs	r1, r4
 800c10e:	ea8a 0500 	eor.w	r5, sl, r0
	sign = x >> (sizeof(int) * 8 - 1);
 800c112:	9c04      	ldr	r4, [sp, #16]
 800c114:	f8de 0880 	ldr.w	r0, [lr, #2176]	; 0x880
	x -= sign;
 800c118:	eba2 0208 	sub.w	r2, r2, r8
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c11c:	46b8      	mov	r8, r7
 800c11e:	f8de 7800 	ldr.w	r7, [lr, #2048]	; 0x800
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c122:	fa40 f009 	asr.w	r0, r0, r9
	sign = x >> (sizeof(int) * 8 - 1);
 800c126:	17e4      	asrs	r4, r4, #31
 800c128:	9007      	str	r0, [sp, #28]
	x ^= sign;
 800c12a:	9803      	ldr	r0, [sp, #12]
	sign = x >> (sizeof(int) * 8 - 1);
 800c12c:	9403      	str	r4, [sp, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c12e:	463c      	mov	r4, r7
 800c130:	9f02      	ldr	r7, [sp, #8]
 800c132:	45bc      	cmp	ip, r7
 800c134:	bf08      	it	eq
 800c136:	46a0      	moveq	r8, r4
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c138:	f8de 7880 	ldr.w	r7, [lr, #2176]	; 0x880
 800c13c:	9c01      	ldr	r4, [sp, #4]
 800c13e:	46bc      	mov	ip, r7
 800c140:	9f07      	ldr	r7, [sp, #28]
 800c142:	17f6      	asrs	r6, r6, #31
 800c144:	42bc      	cmp	r4, r7
 800c146:	bf18      	it	ne
 800c148:	46ac      	movne	ip, r5
 800c14a:	9d05      	ldr	r5, [sp, #20]
	x ^= sign;
 800c14c:	4070      	eors	r0, r6
	x -= sign;
 800c14e:	1b80      	subs	r0, r0, r6
 800c150:	4667      	mov	r7, ip
 800c152:	430a      	orrs	r2, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800c154:	ea4f 7ce5 	mov.w	ip, r5, asr #31
	x ^= sign;
 800c158:	9903      	ldr	r1, [sp, #12]
 800c15a:	9d04      	ldr	r5, [sp, #16]
 800c15c:	409f      	lsls	r7, r3
 800c15e:	4302      	orrs	r2, r0
	x -= sign;
 800c160:	9803      	ldr	r0, [sp, #12]
 800c162:	9702      	str	r7, [sp, #8]
	x ^= sign;
 800c164:	404d      	eors	r5, r1
 800c166:	9f05      	ldr	r7, [sp, #20]
	x -= sign;
 800c168:	1a2c      	subs	r4, r5, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c16a:	fa08 f803 	lsl.w	r8, r8, r3
	sign = x >> (sizeof(int) * 8 - 1);
 800c16e:	980e      	ldr	r0, [sp, #56]	; 0x38
 800c170:	4646      	mov	r6, r8
	x ^= sign;
 800c172:	ea87 010c 	eor.w	r1, r7, ip
	sign = x >> (sizeof(int) * 8 - 1);
 800c176:	ea4f 78e0 	mov.w	r8, r0, asr #31
 800c17a:	9601      	str	r6, [sp, #4]
	x -= sign;
 800c17c:	eba1 0c0c 	sub.w	ip, r1, ip
 800c180:	f8ce 6800 	str.w	r6, [lr, #2048]	; 0x800
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c184:	ea42 0104 	orr.w	r1, r2, r4
	sign = x >> (sizeof(int) * 8 - 1);
 800c188:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 800c18a:	9f02      	ldr	r7, [sp, #8]
 800c18c:	9c06      	ldr	r4, [sp, #24]
 800c18e:	f8ce 7880 	str.w	r7, [lr, #2176]	; 0x880
	x ^= sign;
 800c192:	ea80 0e08 	eor.w	lr, r0, r8
	sign = x >> (sizeof(int) * 8 - 1);
 800c196:	17f7      	asrs	r7, r6, #31
	x -= sign;
 800c198:	ebae 0208 	sub.w	r2, lr, r8
	x ^= sign;
 800c19c:	4635      	mov	r5, r6
	sign = x >> (sizeof(int) * 8 - 1);
 800c19e:	ea4f 78e4 	mov.w	r8, r4, asr #31
 800c1a2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800c1a4:	9c08      	ldr	r4, [sp, #32]
 800c1a6:	ea4f 7ee6 	mov.w	lr, r6, asr #31
 800c1aa:	ea41 010c 	orr.w	r1, r1, ip
 800c1ae:	ea4f 7ce4 	mov.w	ip, r4, asr #31
	x ^= sign;
 800c1b2:	ea84 000c 	eor.w	r0, r4, ip
 800c1b6:	ea86 040e 	eor.w	r4, r6, lr
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c1ba:	f8db 6020 	ldr.w	r6, [fp, #32]
 800c1be:	407d      	eors	r5, r7
	x -= sign;
 800c1c0:	1bed      	subs	r5, r5, r7
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c1c2:	4311      	orrs	r1, r2
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c1c4:	17f7      	asrs	r7, r6, #31
	x ^= sign;
 800c1c6:	9a06      	ldr	r2, [sp, #24]
	sign = x >> (sizeof(int) * 8 - 1);
 800c1c8:	9e01      	ldr	r6, [sp, #4]
	x -= sign;
 800c1ca:	eba0 0c0c 	sub.w	ip, r0, ip
	x ^= sign;
 800c1ce:	9801      	ldr	r0, [sp, #4]
	sign = x >> (sizeof(int) * 8 - 1);
 800c1d0:	17f6      	asrs	r6, r6, #31
	x ^= sign;
 800c1d2:	ea82 0208 	eor.w	r2, r2, r8
	x -= sign;
 800c1d6:	eba2 0208 	sub.w	r2, r2, r8
 800c1da:	ea8a 0807 	eor.w	r8, sl, r7
	x ^= sign;
 800c1de:	ea80 0a06 	eor.w	sl, r0, r6
	sign = x >> (sizeof(int) * 8 - 1);
 800c1e2:	9802      	ldr	r0, [sp, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c1e4:	4329      	orrs	r1, r5
	x -= sign;
 800c1e6:	eba4 040e 	sub.w	r4, r4, lr
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c1ea:	f8db 5020 	ldr.w	r5, [fp, #32]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c1ee:	ea4c 0c04 	orr.w	ip, ip, r4
 800c1f2:	430a      	orrs	r2, r1
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c1f4:	f8db 4020 	ldr.w	r4, [fp, #32]
	sign = x >> (sizeof(int) * 8 - 1);
 800c1f8:	17c1      	asrs	r1, r0, #31
 800c1fa:	fa45 f509 	asr.w	r5, r5, r9
	x -= sign;
 800c1fe:	ebaa 0a06 	sub.w	sl, sl, r6
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c202:	ea42 020c 	orr.w	r2, r2, ip
	x ^= sign;
 800c206:	4048      	eors	r0, r1
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c208:	42af      	cmp	r7, r5
 800c20a:	bf18      	it	ne
 800c20c:	4644      	movne	r4, r8
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c20e:	ea42 020a 	orr.w	r2, r2, sl
	x -= sign;
 800c212:	1a40      	subs	r0, r0, r1
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c214:	fa04 f303 	lsl.w	r3, r4, r3
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800c218:	4310      	orrs	r0, r2
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800c21a:	f8cb 3020 	str.w	r3, [fp, #32]
}
 800c21e:	b011      	add	sp, #68	; 0x44
 800c220:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c224 <xmp3fixpt_IMDCT>:
 *              updated hi->nonZeroBound index for this channel
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
int IMDCT(MP3DecInfo *mp3DecInfo, int gr, int ch)
{
 800c224:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c228:	b0d9      	sub	sp, #356	; 0x164
 800c22a:	910c      	str	r1, [sp, #48]	; 0x30
 800c22c:	920a      	str	r2, [sp, #40]	; 0x28
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	BlockCount bc;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 800c22e:	2800      	cmp	r0, #0
 800c230:	f001 863c 	beq.w	800deac <xmp3fixpt_IMDCT+0x1c88>
 800c234:	6803      	ldr	r3, [r0, #0]
 800c236:	2b00      	cmp	r3, #0
 800c238:	f001 8638 	beq.w	800deac <xmp3fixpt_IMDCT+0x1c88>
 800c23c:	6844      	ldr	r4, [r0, #4]
 800c23e:	942c      	str	r4, [sp, #176]	; 0xb0
 800c240:	4625      	mov	r5, r4
 800c242:	2c00      	cmp	r4, #0
 800c244:	f001 8632 	beq.w	800deac <xmp3fixpt_IMDCT+0x1c88>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 800c248:	68c4      	ldr	r4, [r0, #12]
 800c24a:	940d      	str	r4, [sp, #52]	; 0x34
 800c24c:	4626      	mov	r6, r4
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 800c24e:	2c00      	cmp	r4, #0
 800c250:	f001 862c 	beq.w	800deac <xmp3fixpt_IMDCT+0x1c88>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 800c254:	6940      	ldr	r0, [r0, #20]
 800c256:	900b      	str	r0, [sp, #44]	; 0x2c
 800c258:	2800      	cmp	r0, #0
 800c25a:	f001 8627 	beq.w	800deac <xmp3fixpt_IMDCT+0x1c88>
 800c25e:	4617      	mov	r7, r2
	/* anti-aliasing done on whole long blocks only
	 * for mixed blocks, nBfly always 1, except 3 for 8 kHz MPEG 2.5 (see sfBandTab) 
     *   nLongBlocks = number of blocks with (possibly) non-zero power 
	 *   nBfly = number of butterflies to do (nLongBlocks - 1, unless no long blocks)
	 */
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800c260:	781a      	ldrb	r2, [r3, #0]
 800c262:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c264:	f8df e318 	ldr.w	lr, [pc, #792]	; 800c580 <xmp3fixpt_IMDCT+0x35c>
	if (si->sis[gr][ch].blockType != 2) {
 800c268:	4608      	mov	r0, r1
 800c26a:	00c9      	lsls	r1, r1, #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800c26c:	2a00      	cmp	r2, #0
	if (si->sis[gr][ch].blockType != 2) {
 800c26e:	912d      	str	r1, [sp, #180]	; 0xb4
 800c270:	eb01 0200 	add.w	r2, r1, r0
 800c274:	ea4f 01c7 	mov.w	r1, r7, lsl #3
 800c278:	460c      	mov	r4, r1
 800c27a:	912b      	str	r1, [sp, #172]	; 0xac
 800c27c:	ea4f 1202 	mov.w	r2, r2, lsl #4
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800c280:	bf14      	ite	ne
 800c282:	2106      	movne	r1, #6
 800c284:	2108      	moveq	r1, #8
	if (si->sis[gr][ch].blockType != 2) {
 800c286:	19e0      	adds	r0, r4, r7
 800c288:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800c28c:	f933 3011 	ldrsh.w	r3, [r3, r1, lsl #1]
	if (si->sis[gr][ch].blockType != 2) {
 800c290:	442a      	add	r2, r5
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800c292:	fb8e 1503 	smull	r1, r5, lr, r3
 800c296:	17d9      	asrs	r1, r3, #31
	if (si->sis[gr][ch].blockType != 2) {
 800c298:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800c29a:	ebc1 01a5 	rsb	r1, r1, r5, asr #2
 800c29e:	b209      	sxth	r1, r1
	if (si->sis[gr][ch].blockType != 2) {
 800c2a0:	2b02      	cmp	r3, #2
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800c2a2:	910e      	str	r1, [sp, #56]	; 0x38
	if (si->sis[gr][ch].blockType != 2) {
 800c2a4:	f001 85d8 	beq.w	800de58 <xmp3fixpt_IMDCT+0x1c34>
		/* all long transforms */
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 800c2a8:	f507 6390 	add.w	r3, r7, #1152	; 0x480
 800c2ac:	f240 2226 	movw	r2, #550	; 0x226
 800c2b0:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 800c2b4:	4293      	cmp	r3, r2
 800c2b6:	f340 8604 	ble.w	800cec2 <xmp3fixpt_IMDCT+0xc9e>
 800c2ba:	0203      	lsls	r3, r0, #8
 800c2bc:	930f      	str	r3, [sp, #60]	; 0x3c
		/* all short transforms */
		bc.nBlocksLong = 0;
		nBfly = 0;
	}
 
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 800c2be:	18f3      	adds	r3, r6, r3
 800c2c0:	932e      	str	r3, [sp, #184]	; 0xb8
 800c2c2:	f240 2336 	movw	r3, #566	; 0x236
 800c2c6:	9310      	str	r3, [sp, #64]	; 0x40
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 800c2c8:	2320      	movs	r3, #32
 800c2ca:	931b      	str	r3, [sp, #108]	; 0x6c
 800c2cc:	21f8      	movs	r1, #248	; 0xf8
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 800c2ce:	231f      	movs	r3, #31
 800c2d0:	4aaa      	ldr	r2, [pc, #680]	; (800c57c <xmp3fixpt_IMDCT+0x358>)
 800c2d2:	440b      	add	r3, r1
 800c2d4:	68d1      	ldr	r1, [r2, #12]
 800c2d6:	9107      	str	r1, [sp, #28]
 800c2d8:	6911      	ldr	r1, [r2, #16]
 800c2da:	9106      	str	r1, [sp, #24]
 800c2dc:	6951      	ldr	r1, [r2, #20]
 800c2de:	9105      	str	r1, [sp, #20]
 800c2e0:	6991      	ldr	r1, [r2, #24]
 800c2e2:	9104      	str	r1, [sp, #16]
 800c2e4:	69d1      	ldr	r1, [r2, #28]
 800c2e6:	9103      	str	r1, [sp, #12]
 800c2e8:	6a11      	ldr	r1, [r2, #32]
 800c2ea:	9102      	str	r1, [sp, #8]
 800c2ec:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800c2ee:	9101      	str	r1, [sp, #4]
 800c2f0:	6a91      	ldr	r1, [r2, #40]	; 0x28
 800c2f2:	9100      	str	r1, [sp, #0]
 800c2f4:	e892 5100 	ldmia.w	r2, {r8, ip, lr}
 800c2f8:	992e      	ldr	r1, [sp, #184]	; 0xb8
 800c2fa:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 800c2fc:	6ad7      	ldr	r7, [r2, #44]	; 0x2c
 800c2fe:	6b16      	ldr	r6, [r2, #48]	; 0x30
 800c300:	6b55      	ldr	r5, [r2, #52]	; 0x34
 800c302:	6b94      	ldr	r4, [r2, #56]	; 0x38
 800c304:	9008      	str	r0, [sp, #32]
 800c306:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800c30a:	9309      	str	r3, [sp, #36]	; 0x24
 800c30c:	460b      	mov	r3, r1
		x += 18;
 800c30e:	3348      	adds	r3, #72	; 0x48
		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 800c310:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800c314:	f8d3 9000 	ldr.w	r9, [r3]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800c318:	4611      	mov	r1, r2
 800c31a:	fb88 a101 	smull	sl, r1, r8, r1
 800c31e:	46ca      	mov	sl, r9
 800c320:	fb8c ba0a 	smull	fp, sl, ip, sl
		x[-1] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c324:	eba1 010a 	sub.w	r1, r1, sl
 800c328:	0049      	lsls	r1, r1, #1
 800c32a:	f843 1c04 	str.w	r1, [r3, #-4]
 800c32e:	fb88 1909 	smull	r1, r9, r8, r9
 800c332:	fb8c 1202 	smull	r1, r2, ip, r2
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c336:	eb09 0102 	add.w	r1, r9, r2
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 800c33a:	f853 2c08 	ldr.w	r2, [r3, #-8]
 800c33e:	f8d3 9004 	ldr.w	r9, [r3, #4]
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c342:	0049      	lsls	r1, r1, #1
 800c344:	6019      	str	r1, [r3, #0]
 800c346:	4611      	mov	r1, r2
 800c348:	fb8e a101 	smull	sl, r1, lr, r1
 800c34c:	46ca      	mov	sl, r9
 800c34e:	9807      	ldr	r0, [sp, #28]
 800c350:	fb80 ba0a 	smull	fp, sl, r0, sl
		x[-2] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c354:	eba1 010a 	sub.w	r1, r1, sl
 800c358:	0049      	lsls	r1, r1, #1
 800c35a:	f843 1c08 	str.w	r1, [r3, #-8]
 800c35e:	fb8e 1909 	smull	r1, r9, lr, r9
 800c362:	fb80 1202 	smull	r1, r2, r0, r2
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c366:	eb09 0102 	add.w	r1, r9, r2
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 800c36a:	f853 2c0c 	ldr.w	r2, [r3, #-12]
 800c36e:	f8d3 9008 	ldr.w	r9, [r3, #8]
 800c372:	9806      	ldr	r0, [sp, #24]
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c374:	0049      	lsls	r1, r1, #1
 800c376:	6059      	str	r1, [r3, #4]
 800c378:	4611      	mov	r1, r2
 800c37a:	fb80 a101 	smull	sl, r1, r0, r1
 800c37e:	46ca      	mov	sl, r9
 800c380:	9805      	ldr	r0, [sp, #20]
 800c382:	fb80 ba0a 	smull	fp, sl, r0, sl
		x[-3] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c386:	eba1 010a 	sub.w	r1, r1, sl
 800c38a:	0049      	lsls	r1, r1, #1
 800c38c:	f843 1c0c 	str.w	r1, [r3, #-12]
 800c390:	9806      	ldr	r0, [sp, #24]
 800c392:	fb80 1909 	smull	r1, r9, r0, r9
 800c396:	9805      	ldr	r0, [sp, #20]
 800c398:	fb80 1202 	smull	r1, r2, r0, r2
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c39c:	eb09 0102 	add.w	r1, r9, r2
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 800c3a0:	f853 2c10 	ldr.w	r2, [r3, #-16]
 800c3a4:	f8d3 900c 	ldr.w	r9, [r3, #12]
 800c3a8:	9804      	ldr	r0, [sp, #16]
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c3aa:	0049      	lsls	r1, r1, #1
 800c3ac:	6099      	str	r1, [r3, #8]
 800c3ae:	4611      	mov	r1, r2
 800c3b0:	fb80 a101 	smull	sl, r1, r0, r1
 800c3b4:	46ca      	mov	sl, r9
 800c3b6:	9803      	ldr	r0, [sp, #12]
 800c3b8:	fb80 ba0a 	smull	fp, sl, r0, sl
		x[-4] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c3bc:	eba1 010a 	sub.w	r1, r1, sl
 800c3c0:	0049      	lsls	r1, r1, #1
 800c3c2:	f843 1c10 	str.w	r1, [r3, #-16]
 800c3c6:	9804      	ldr	r0, [sp, #16]
 800c3c8:	fb80 1909 	smull	r1, r9, r0, r9
 800c3cc:	9803      	ldr	r0, [sp, #12]
 800c3ce:	fb80 1202 	smull	r1, r2, r0, r2
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c3d2:	eb09 0102 	add.w	r1, r9, r2
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 800c3d6:	f853 2c14 	ldr.w	r2, [r3, #-20]
 800c3da:	f8d3 9010 	ldr.w	r9, [r3, #16]
 800c3de:	9802      	ldr	r0, [sp, #8]
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c3e0:	0049      	lsls	r1, r1, #1
 800c3e2:	60d9      	str	r1, [r3, #12]
 800c3e4:	4611      	mov	r1, r2
 800c3e6:	fb80 a101 	smull	sl, r1, r0, r1
 800c3ea:	46ca      	mov	sl, r9
 800c3ec:	9801      	ldr	r0, [sp, #4]
 800c3ee:	fb80 ba0a 	smull	fp, sl, r0, sl
		x[-5] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c3f2:	eba1 010a 	sub.w	r1, r1, sl
 800c3f6:	0049      	lsls	r1, r1, #1
 800c3f8:	f843 1c14 	str.w	r1, [r3, #-20]
 800c3fc:	9802      	ldr	r0, [sp, #8]
 800c3fe:	fb80 1909 	smull	r1, r9, r0, r9
 800c402:	9801      	ldr	r0, [sp, #4]
 800c404:	fb80 1202 	smull	r1, r2, r0, r2
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c408:	eb09 0102 	add.w	r1, r9, r2
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 800c40c:	f853 2c18 	ldr.w	r2, [r3, #-24]
 800c410:	f8d3 9014 	ldr.w	r9, [r3, #20]
 800c414:	9800      	ldr	r0, [sp, #0]
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c416:	0049      	lsls	r1, r1, #1
 800c418:	6119      	str	r1, [r3, #16]
 800c41a:	4611      	mov	r1, r2
 800c41c:	fb80 a101 	smull	sl, r1, r0, r1
 800c420:	46ca      	mov	sl, r9
 800c422:	fb87 ba0a 	smull	fp, sl, r7, sl
		x[-6] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c426:	eba1 010a 	sub.w	r1, r1, sl
 800c42a:	0049      	lsls	r1, r1, #1
 800c42c:	f843 1c18 	str.w	r1, [r3, #-24]
 800c430:	fb80 1909 	smull	r1, r9, r0, r9
 800c434:	fb87 1202 	smull	r1, r2, r7, r2
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c438:	eb09 0102 	add.w	r1, r9, r2
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 800c43c:	f853 2c1c 	ldr.w	r2, [r3, #-28]
 800c440:	f8d3 9018 	ldr.w	r9, [r3, #24]
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c444:	0049      	lsls	r1, r1, #1
 800c446:	6159      	str	r1, [r3, #20]
 800c448:	4611      	mov	r1, r2
 800c44a:	fb86 a101 	smull	sl, r1, r6, r1
 800c44e:	46ca      	mov	sl, r9
 800c450:	fb85 ba0a 	smull	fp, sl, r5, sl
		x[-7] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c454:	eba1 010a 	sub.w	r1, r1, sl
 800c458:	0049      	lsls	r1, r1, #1
 800c45a:	f843 1c1c 	str.w	r1, [r3, #-28]
 800c45e:	fb86 1909 	smull	r1, r9, r6, r9
 800c462:	fb85 1202 	smull	r1, r2, r5, r2
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c466:	eb09 0102 	add.w	r1, r9, r2
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 800c46a:	f853 9c20 	ldr.w	r9, [r3, #-32]
 800c46e:	69da      	ldr	r2, [r3, #28]
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c470:	0049      	lsls	r1, r1, #1
 800c472:	6199      	str	r1, [r3, #24]
 800c474:	4649      	mov	r1, r9
 800c476:	fb84 a101 	smull	sl, r1, r4, r1
 800c47a:	4692      	mov	sl, r2
 800c47c:	9808      	ldr	r0, [sp, #32]
 800c47e:	fb80 ba0a 	smull	fp, sl, r0, sl
		x[-8] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 800c482:	eba1 010a 	sub.w	r1, r1, sl
 800c486:	0049      	lsls	r1, r1, #1
 800c488:	f843 1c20 	str.w	r1, [r3, #-32]
 800c48c:	fb84 1202 	smull	r1, r2, r4, r2
 800c490:	fb80 1909 	smull	r1, r9, r0, r9
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 800c494:	444a      	add	r2, r9
 800c496:	0052      	lsls	r2, r2, #1
 800c498:	61da      	str	r2, [r3, #28]
	for (k = nBfly; k > 0; k--) {
 800c49a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c49c:	4293      	cmp	r3, r2
 800c49e:	f47f af36 	bne.w	800c30e <xmp3fixpt_IMDCT+0xea>
 800c4a2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c4a4:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 800c4a6:	990a      	ldr	r1, [sp, #40]	; 0x28
 800c4a8:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800c4aa:	4413      	add	r3, r2
 800c4ac:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800c4ae:	011b      	lsls	r3, r3, #4
 800c4b0:	440a      	add	r2, r1
 800c4b2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c4b6:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800c4b8:	4413      	add	r3, r2
 800c4ba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c4bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c4be:	9326      	str	r3, [sp, #152]	; 0x98
 800c4c0:	460b      	mov	r3, r1
 800c4c2:	009d      	lsls	r5, r3, #2
 800c4c4:	442c      	add	r4, r5
	bc.prevType = mi->prevType[ch];
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
	bc.gbIn = hi->gb[ch];

	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c4c6:	9e2d      	ldr	r6, [sp, #180]	; 0xb4
 800c4c8:	9233      	str	r2, [sp, #204]	; 0xcc
 800c4ca:	4611      	mov	r1, r2
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 800c4cc:	f504 5290 	add.w	r2, r4, #4608	; 0x1200
 800c4d0:	9f10      	ldr	r7, [sp, #64]	; 0x40
 800c4d2:	9331      	str	r3, [sp, #196]	; 0xc4
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c4d4:	1871      	adds	r1, r6, r1
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 800c4d6:	6813      	ldr	r3, [r2, #0]
 800c4d8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 800c4da:	4829      	ldr	r0, [pc, #164]	; (800c580 <xmp3fixpt_IMDCT+0x35c>)
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 800c4dc:	429f      	cmp	r7, r3
 800c4de:	4435      	add	r5, r6
 800c4e0:	bfb8      	it	lt
 800c4e2:	461f      	movlt	r7, r3
 800c4e4:	462e      	mov	r6, r5
 800c4e6:	6017      	str	r7, [r2, #0]
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 800c4e8:	f506 55d8 	add.w	r5, r6, #6912	; 0x1b00
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c4ec:	010b      	lsls	r3, r1, #4
 800c4ee:	9a31      	ldr	r2, [sp, #196]	; 0xc4
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 800c4f0:	9530      	str	r5, [sp, #192]	; 0xc0
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 800c4f2:	f107 0111 	add.w	r1, r7, #17
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c4f6:	9f2b      	ldr	r7, [sp, #172]	; 0xac
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 800c4f8:	9d26      	ldr	r5, [sp, #152]	; 0x98
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 800c4fa:	962f      	str	r6, [sp, #188]	; 0xbc
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c4fc:	18ba      	adds	r2, r7, r2
 800c4fe:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800c500:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 800c502:	2d00      	cmp	r5, #0
 800c504:	9d26      	ldr	r5, [sp, #152]	; 0x98
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c506:	4437      	add	r7, r6
 800c508:	972a      	str	r7, [sp, #168]	; 0xa8
 800c50a:	f103 0328 	add.w	r3, r3, #40	; 0x28
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 800c50e:	9f0e      	ldr	r7, [sp, #56]	; 0x38
	bc.gbIn = hi->gb[ch];
 800c510:	f241 2c08 	movw	ip, #4616	; 0x1208
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 800c514:	bf08      	it	eq
 800c516:	462f      	moveq	r7, r5
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 800c518:	fb80 e001 	smull	lr, r0, r0, r1
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c51c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 800c520:	9726      	str	r7, [sp, #152]	; 0x98
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c522:	eb06 12c2 	add.w	r2, r6, r2, lsl #7
	bc.prevType = mi->prevType[ch];
 800c526:	9f2f      	ldr	r7, [sp, #188]	; 0xbc
	bc.gbIn = hi->gb[ch];
 800c528:	f854 400c 	ldr.w	r4, [r4, ip]
 800c52c:	9418      	str	r4, [sp, #96]	; 0x60
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 800c52e:	17c9      	asrs	r1, r1, #31
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c530:	46b6      	mov	lr, r6
	bc.prevType = mi->prevType[ch];
 800c532:	f641 3608 	movw	r6, #6920	; 0x1b08
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 800c536:	f641 3510 	movw	r5, #6928	; 0x1b10
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 800c53a:	ebc1 01a0 	rsb	r1, r1, r0, asr #2
	bc.prevType = mi->prevType[ch];
 800c53e:	59bc      	ldr	r4, [r7, r6]
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 800c540:	9123      	str	r1, [sp, #140]	; 0x8c
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c542:	992c      	ldr	r1, [sp, #176]	; 0xb0
	bc.prevType = mi->prevType[ch];
 800c544:	9414      	str	r4, [sp, #80]	; 0x50
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 800c546:	597c      	ldr	r4, [r7, r5]
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 800c548:	9d30      	ldr	r5, [sp, #192]	; 0xc0
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 800c54a:	9409      	str	r4, [sp, #36]	; 0x24
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c54c:	18cb      	adds	r3, r1, r3
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 800c54e:	682c      	ldr	r4, [r5, #0]
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c550:	931c      	str	r3, [sp, #112]	; 0x70
 800c552:	f502 5390 	add.w	r3, r2, #4608	; 0x1200
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 800c556:	9424      	str	r4, [sp, #144]	; 0x90
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800c558:	9332      	str	r3, [sp, #200]	; 0xc8
	for(i = 0; i < bc->nBlocksLong; i++) {
 800c55a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800c55c:	2a00      	cmp	r2, #0
 800c55e:	f341 849c 	ble.w	800de9a <xmp3fixpt_IMDCT+0x1c76>
 800c562:	2200      	movs	r2, #0
 800c564:	9203      	str	r2, [sp, #12]
 800c566:	9201      	str	r2, [sp, #4]
 800c568:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 800c56a:	9f2a      	ldr	r7, [sp, #168]	; 0xa8
 800c56c:	9702      	str	r7, [sp, #8]
 800c56e:	3248      	adds	r2, #72	; 0x48
 800c570:	f103 0b24 	add.w	fp, r3, #36	; 0x24
 800c574:	9200      	str	r2, [sp, #0]
 800c576:	46d9      	mov	r9, fp
 800c578:	e3c0      	b.n	800ccfc <xmp3fixpt_IMDCT+0xad8>
 800c57a:	bf00      	nop
 800c57c:	080176c8 	.word	0x080176c8
 800c580:	38e38e39 	.word	0x38e38e39
			acc1 = (*xCurr--) - acc1;
 800c584:	9d00      	ldr	r5, [sp, #0]
 800c586:	f855 3c04 	ldr.w	r3, [r5, #-4]
			acc1 = (*xCurr--) - acc1;
 800c58a:	f855 2c10 	ldr.w	r2, [r5, #-16]
 800c58e:	f855 1c18 	ldr.w	r1, [r5, #-24]
			acc1 = (*xCurr--) - acc1;
 800c592:	9305      	str	r3, [sp, #20]
 800c594:	4628      	mov	r0, r5
			acc1 = (*xCurr--) - acc1;
 800c596:	f855 7c08 	ldr.w	r7, [r5, #-8]
			acc1 = (*xCurr--) - acc1;
 800c59a:	f855 6c0c 	ldr.w	r6, [r5, #-12]
 800c59e:	f855 4c14 	ldr.w	r4, [r5, #-20]
			acc1 = (*xCurr--) - acc1;
 800c5a2:	f855 3c20 	ldr.w	r3, [r5, #-32]
 800c5a6:	9204      	str	r2, [sp, #16]
 800c5a8:	9106      	str	r1, [sp, #24]
			acc1 = (*xCurr--) - acc1;
 800c5aa:	f855 2c24 	ldr.w	r2, [r5, #-36]
 800c5ae:	f855 1c1c 	ldr.w	r1, [r5, #-28]
			acc1 = (*xCurr--) - acc1;
 800c5b2:	f855 5c28 	ldr.w	r5, [r5, #-40]
 800c5b6:	9507      	str	r5, [sp, #28]
			acc1 = (*xCurr--) - acc1;
 800c5b8:	f850 5c2c 	ldr.w	r5, [r0, #-44]
 800c5bc:	950a      	str	r5, [sp, #40]	; 0x28
			acc1 = (*xCurr--) - acc1;
 800c5be:	f850 5c30 	ldr.w	r5, [r0, #-48]
			acc1 = (*xCurr--) - acc1;
 800c5c2:	f850 0c34 	ldr.w	r0, [r0, #-52]
 800c5c6:	900b      	str	r0, [sp, #44]	; 0x2c
			acc1 = (*xCurr--) - acc1;
 800c5c8:	9800      	ldr	r0, [sp, #0]
 800c5ca:	4686      	mov	lr, r0
 800c5cc:	f850 0c38 	ldr.w	r0, [r0, #-56]
 800c5d0:	9010      	str	r0, [sp, #64]	; 0x40
			acc1 = (*xCurr--) - acc1;
 800c5d2:	f85e 0c3c 	ldr.w	r0, [lr, #-60]
 800c5d6:	9011      	str	r0, [sp, #68]	; 0x44
			acc1 = (*xCurr--) - acc1;
 800c5d8:	f85e 0c40 	ldr.w	r0, [lr, #-64]
 800c5dc:	9012      	str	r0, [sp, #72]	; 0x48
			acc1 = (*xCurr--) - acc1;
 800c5de:	f85e 0c44 	ldr.w	r0, [lr, #-68]
 800c5e2:	9013      	str	r0, [sp, #76]	; 0x4c
			acc1 = (*xCurr--) - acc1;
 800c5e4:	f85e 0c48 	ldr.w	r0, [lr, #-72]
 800c5e8:	901d      	str	r0, [sp, #116]	; 0x74
 800c5ea:	9805      	ldr	r0, [sp, #20]
 800c5ec:	eba7 0a00 	sub.w	sl, r7, r0
 800c5f0:	9f04      	ldr	r7, [sp, #16]
			acc1 = (*xCurr--) - acc1;
 800c5f2:	eba6 060a 	sub.w	r6, r6, sl
			acc1 = (*xCurr--) - acc1;
 800c5f6:	eba7 0b06 	sub.w	fp, r7, r6
 800c5fa:	9f06      	ldr	r7, [sp, #24]
			acc1 = (*xCurr--) - acc1;
 800c5fc:	eba4 040b 	sub.w	r4, r4, fp
			acc1 = (*xCurr--) - acc1;
 800c600:	1b3f      	subs	r7, r7, r4
			acc1 = (*xCurr--) - acc1;
 800c602:	1bc9      	subs	r1, r1, r7
			acc1 = (*xCurr--) - acc1;
 800c604:	1a5b      	subs	r3, r3, r1
			acc1 = (*xCurr--) - acc1;
 800c606:	1ad2      	subs	r2, r2, r3
			acc1 = (*xCurr--) - acc1;
 800c608:	930f      	str	r3, [sp, #60]	; 0x3c
 800c60a:	9b07      	ldr	r3, [sp, #28]
 800c60c:	9708      	str	r7, [sp, #32]
 800c60e:	4686      	mov	lr, r0
 800c610:	1a98      	subs	r0, r3, r2
			acc2 = acc1 - acc2;
 800c612:	4673      	mov	r3, lr
 800c614:	1af3      	subs	r3, r6, r3
			acc1 = (*xCurr--) - acc1;
 800c616:	9e0a      	ldr	r6, [sp, #40]	; 0x28
			acc2 = acc1 - acc2;
 800c618:	930e      	str	r3, [sp, #56]	; 0x38
 800c61a:	1ae3      	subs	r3, r4, r3
			acc1 = (*xCurr--) - acc1;
 800c61c:	1a36      	subs	r6, r6, r0
			acc2 = acc1 - acc2;
 800c61e:	930d      	str	r3, [sp, #52]	; 0x34
 800c620:	1acb      	subs	r3, r1, r3
			acc1 = (*xCurr--) - acc1;
 800c622:	990b      	ldr	r1, [sp, #44]	; 0x2c
			acc2 = acc1 - acc2;
 800c624:	930c      	str	r3, [sp, #48]	; 0x30
			acc1 = (*xCurr--) - acc1;
 800c626:	1bad      	subs	r5, r5, r6
			acc2 = acc1 - acc2;
 800c628:	1ad3      	subs	r3, r2, r3
			acc1 = (*xCurr--) - acc1;
 800c62a:	1b49      	subs	r1, r1, r5
			acc2 = acc1 - acc2;
 800c62c:	9319      	str	r3, [sp, #100]	; 0x64
			acc1 = (*xCurr--) - acc1;
 800c62e:	9a10      	ldr	r2, [sp, #64]	; 0x40
			acc1 = (*xCurr--) - acc1;
 800c630:	9c11      	ldr	r4, [sp, #68]	; 0x44
			acc2 = acc1 - acc2;
 800c632:	1af3      	subs	r3, r6, r3
 800c634:	931a      	str	r3, [sp, #104]	; 0x68
 800c636:	1acb      	subs	r3, r1, r3
 800c638:	461e      	mov	r6, r3
			acc1 = (*xCurr--) - acc1;
 800c63a:	1a52      	subs	r2, r2, r1
			acc2 = acc1 - acc2;
 800c63c:	9304      	str	r3, [sp, #16]
			acc1 = (*xCurr--) - acc1;
 800c63e:	9b12      	ldr	r3, [sp, #72]	; 0x48
			acc1 = (*xCurr--) - acc1;
 800c640:	1aa4      	subs	r4, r4, r2
			acc1 = (*xCurr--) - acc1;
 800c642:	eba3 0e04 	sub.w	lr, r3, r4
			acc2 = acc1 - acc2;
 800c646:	1ba3      	subs	r3, r4, r6
 800c648:	4619      	mov	r1, r3
 800c64a:	9306      	str	r3, [sp, #24]
			acc1 = (*xCurr--) - acc1;
 800c64c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c64e:	eba3 060e 	sub.w	r6, r3, lr
			acc1 = (*xCurr--) - acc1;
 800c652:	9b1d      	ldr	r3, [sp, #116]	; 0x74
			acc2 = acc1 - acc2;
 800c654:	eba6 0c01 	sub.w	ip, r6, r1
			acc1 = (*xCurr--) - acc1;
 800c658:	1b9e      	subs	r6, r3, r6
		es = 0;
 800c65a:	2300      	movs	r3, #0
 800c65c:	9307      	str	r3, [sp, #28]
	xBuf[0] >>= 1;
 800c65e:	1073      	asrs	r3, r6, #1
	a3 = x1 + x5;
 800c660:	990f      	ldr	r1, [sp, #60]	; 0x3c
	xBuf[9] >>= 1;
 800c662:	ea4f 066c 	mov.w	r6, ip, asr #1
 800c666:	960a      	str	r6, [sp, #40]	; 0x28
 800c668:	462e      	mov	r6, r5
	a1 = x0 - x6;
 800c66a:	9d08      	ldr	r5, [sp, #32]
	a5 = x2 + x4;
 800c66c:	1817      	adds	r7, r2, r0
	a3 = x1 + x5;
 800c66e:	eb0e 0401 	add.w	r4, lr, r1
	a4 = x2 - x4;
 800c672:	1a10      	subs	r0, r2, r0
	a3 = x1 + x5;
 800c674:	4621      	mov	r1, r4
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 800c676:	eba0 000a 	sub.w	r0, r0, sl
	a7 = x1 + x7;
 800c67a:	eb0e 080b 	add.w	r8, lr, fp
	a6 = x2 + x8;
 800c67e:	4452      	add	r2, sl
	a1 = x0 - x6;
 800c680:	461c      	mov	r4, r3
 800c682:	1b5b      	subs	r3, r3, r5
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 800c684:	9010      	str	r0, [sp, #64]	; 0x40
	a1 = x0 - x6;
 800c686:	930b      	str	r3, [sp, #44]	; 0x2c
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 800c688:	eba1 0c08 	sub.w	ip, r1, r8
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 800c68c:	eba2 0a07 	sub.w	sl, r2, r7
 800c690:	48c9      	ldr	r0, [pc, #804]	; (800c9b8 <xmp3fixpt_IMDCT+0x794>)
 800c692:	fb80 5606 	smull	r5, r6, r0, r6
	a2 = x1 - x5;
 800c696:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800c698:	4dc7      	ldr	r5, [pc, #796]	; (800c9b8 <xmp3fixpt_IMDCT+0x794>)
 800c69a:	ebae 0303 	sub.w	r3, lr, r3
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 800c69e:	eba3 0b0b 	sub.w	fp, r3, fp
 800c6a2:	4658      	mov	r0, fp
 800c6a4:	fb85 3000 	smull	r3, r0, r5, r0
 800c6a8:	4dc4      	ldr	r5, [pc, #784]	; (800c9bc <xmp3fixpt_IMDCT+0x798>)
 800c6aa:	46be      	mov	lr, r7
 800c6ac:	fb85 3e0e 	smull	r3, lr, r5, lr
 800c6b0:	4dc3      	ldr	r5, [pc, #780]	; (800c9c0 <xmp3fixpt_IMDCT+0x79c>)
 800c6b2:	fb85 3202 	smull	r3, r2, r5, r2
 800c6b6:	4dc1      	ldr	r5, [pc, #772]	; (800c9bc <xmp3fixpt_IMDCT+0x798>)
 800c6b8:	fb85 3a0a 	smull	r3, sl, r5, sl
 800c6bc:	4dc0      	ldr	r5, [pc, #768]	; (800c9c0 <xmp3fixpt_IMDCT+0x79c>)
 800c6be:	fb85 3707 	smull	r3, r7, r5, r7
 800c6c2:	f105 5570 	add.w	r5, r5, #1006632960	; 0x3c000000
 800c6c6:	f505 254c 	add.w	r5, r5, #835584	; 0xcc000
 800c6ca:	46e3      	mov	fp, ip
 800c6cc:	f205 25cb 	addw	r5, r5, #715	; 0x2cb
 800c6d0:	fb85 3b0b 	smull	r3, fp, r5, fp
 800c6d4:	4dbb      	ldr	r5, [pc, #748]	; (800c9c4 <xmp3fixpt_IMDCT+0x7a0>)
 800c6d6:	fb85 3808 	smull	r3, r8, r5, r8
 800c6da:	460d      	mov	r5, r1
 800c6dc:	49ba      	ldr	r1, [pc, #744]	; (800c9c8 <xmp3fixpt_IMDCT+0x7a4>)
 800c6de:	fb81 3505 	smull	r3, r5, r1, r5
 800c6e2:	49b8      	ldr	r1, [pc, #736]	; (800c9c4 <xmp3fixpt_IMDCT+0x7a0>)
 800c6e4:	fb81 3c0c 	smull	r3, ip, r1, ip
	a17 = ( m7 << 1) - (m8 << 1);
 800c6e8:	007f      	lsls	r7, r7, #1
 800c6ea:	ebc7 034a 	rsb	r3, r7, sl, lsl #1
	a12 = x[0] +  (x[6] >> 1);
 800c6ee:	9f08      	ldr	r7, [sp, #32]
	a15 = a1   +  ( a11 >> 1);
 800c6f0:	9910      	ldr	r1, [sp, #64]	; 0x40
	a16 = ( m5 << 1) + (m6 << 1);
 800c6f2:	0052      	lsls	r2, r2, #1
 800c6f4:	eb02 0e4e 	add.w	lr, r2, lr, lsl #1
	a12 = x[0] +  (x[6] >> 1);
 800c6f8:	eb04 0a67 	add.w	sl, r4, r7, asr #1
	a13 = a12  +  (  m1 << 1);
 800c6fc:	0076      	lsls	r6, r6, #1
	a20 = (m11 << 1) - (m12 << 1);
 800c6fe:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
	a14 = a12  -  (  m1 << 1);
 800c702:	ebaa 0706 	sub.w	r7, sl, r6
	a20 = (m11 << 1) - (m12 << 1);
 800c706:	ebcc 0545 	rsb	r5, ip, r5, lsl #1
	a13 = a12  +  (  m1 << 1);
 800c70a:	4456      	add	r6, sl
	a18 = a16 + a17;
 800c70c:	eb0e 0c03 	add.w	ip, lr, r3
	a19 = ( m9 << 1) + (m10 << 1);
 800c710:	ea4f 0248 	mov.w	r2, r8, lsl #1
 800c714:	eb02 024b 	add.w	r2, r2, fp, lsl #1
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c718:	ea4f 0840 	mov.w	r8, r0, lsl #1
	a26 = a14 - a18;
 800c71c:	eba7 0b0c 	sub.w	fp, r7, ip
	a22 = a13 + a16;
 800c720:	eb06 000e 	add.w	r0, r6, lr
	a27 = a13 - a18;
 800c724:	eba6 0c0c 	sub.w	ip, r6, ip
	a25 = a13 + a17;
 800c728:	441e      	add	r6, r3
	a24 = a14 + a17;
 800c72a:	443b      	add	r3, r7
 800c72c:	930f      	str	r3, [sp, #60]	; 0x3c
	x0 = a22 + a19;			x[0] = x0;
 800c72e:	4410      	add	r0, r2
 800c730:	9008      	str	r0, [sp, #32]
	x2 = a24 + a20;			x[2] = x2;
 800c732:	980f      	ldr	r0, [sp, #60]	; 0x3c
	a15 = a1   +  ( a11 >> 1);
 800c734:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
	x2 = a24 + a20;			x[2] = x2;
 800c736:	4428      	add	r0, r5
 800c738:	900f      	str	r0, [sp, #60]	; 0x3c
	x4 = a1 - a11;			x[4] = x4;
 800c73a:	980b      	ldr	r0, [sp, #44]	; 0x2c
	a23 = a14 + a16;
 800c73c:	44be      	add	lr, r7
	a15 = a1   +  ( a11 >> 1);
 800c73e:	eb04 0761 	add.w	r7, r4, r1, asr #1
	a21 = a20 - a19;
 800c742:	eba5 0a02 	sub.w	sl, r5, r2
	x6 = a25 - a20;			x[6] = x6;
 800c746:	1b76      	subs	r6, r6, r5
	x8 = a23 - a19;			x[8] = x8;
 800c748:	ebae 0202 	sub.w	r2, lr, r2
	x4 = a1 - a11;			x[4] = x4;
 800c74c:	1a40      	subs	r0, r0, r1
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c74e:	eb07 0108 	add.w	r1, r7, r8
	x7 = a15 - (m3 << 1);	x[7] = x7;
 800c752:	eba7 0708 	sub.w	r7, r7, r8
	x6 = a25 - a20;			x[6] = x6;
 800c756:	9611      	str	r6, [sp, #68]	; 0x44
	x8 = a23 - a19;			x[8] = x8;
 800c758:	9213      	str	r2, [sp, #76]	; 0x4c
	a5 = x2 + x4;
 800c75a:	9e19      	ldr	r6, [sp, #100]	; 0x64
	a3 = x1 + x5;
 800c75c:	9a06      	ldr	r2, [sp, #24]
	x4 = a1 - a11;			x[4] = x4;
 800c75e:	9010      	str	r0, [sp, #64]	; 0x40
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c760:	910b      	str	r1, [sp, #44]	; 0x2c
	x7 = a15 - (m3 << 1);	x[7] = x7;
 800c762:	9712      	str	r7, [sp, #72]	; 0x48
	a5 = x2 + x4;
 800c764:	9904      	ldr	r1, [sp, #16]
	a3 = x1 + x5;
 800c766:	9f0c      	ldr	r7, [sp, #48]	; 0x30
	a7 = x1 + x7;
 800c768:	980e      	ldr	r0, [sp, #56]	; 0x38
	a3 = x1 + x5;
 800c76a:	4417      	add	r7, r2
	a7 = x1 + x7;
 800c76c:	4410      	add	r0, r2
	a4 = x2 - x4;
 800c76e:	1b8d      	subs	r5, r1, r6
	a5 = x2 + x4;
 800c770:	4632      	mov	r2, r6
	a6 = x2 + x8;
 800c772:	9e05      	ldr	r6, [sp, #20]
	a5 = x2 + x4;
 800c774:	440a      	add	r2, r1
	a6 = x2 + x8;
 800c776:	4631      	mov	r1, r6
 800c778:	9e04      	ldr	r6, [sp, #16]
 800c77a:	440e      	add	r6, r1
	x3 = a26 - a21;			x[3] = x3;
 800c77c:	ebab 030a 	sub.w	r3, fp, sl
	a6 = x2 + x8;
 800c780:	4631      	mov	r1, r6
	x0 = a22 + a19;			x[0] = x0;
 800c782:	9e08      	ldr	r6, [sp, #32]
 800c784:	9634      	str	r6, [sp, #208]	; 0xd0
	x3 = a26 - a21;			x[3] = x3;
 800c786:	461c      	mov	r4, r3
	x6 = a25 - a20;			x[6] = x6;
 800c788:	9e11      	ldr	r6, [sp, #68]	; 0x44
 800c78a:	963a      	str	r6, [sp, #232]	; 0xe8
	x5 = a27 + a21;			x[5] = x5;
 800c78c:	eb0c 030a 	add.w	r3, ip, sl
 800c790:	9339      	str	r3, [sp, #228]	; 0xe4
 800c792:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
	x8 = a23 - a19;			x[8] = x8;
 800c796:	9e13      	ldr	r6, [sp, #76]	; 0x4c
	x5 = a27 + a21;			x[5] = x5;
 800c798:	931a      	str	r3, [sp, #104]	; 0x68
	x2 = a24 + a20;			x[2] = x2;
 800c79a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	x3 = a26 - a21;			x[3] = x3;
 800c79c:	9419      	str	r4, [sp, #100]	; 0x64
 800c79e:	9437      	str	r4, [sp, #220]	; 0xdc
	x2 = a24 + a20;			x[2] = x2;
 800c7a0:	9336      	str	r3, [sp, #216]	; 0xd8
	x8 = a23 - a19;			x[8] = x8;
 800c7a2:	963c      	str	r6, [sp, #240]	; 0xf0
	x4 = a1 - a11;			x[4] = x4;
 800c7a4:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800c7a6:	9438      	str	r4, [sp, #224]	; 0xe0
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 800c7a8:	9c05      	ldr	r4, [sp, #20]
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c7aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	x7 = a15 - (m3 << 1);	x[7] = x7;
 800c7ac:	9e12      	ldr	r6, [sp, #72]	; 0x48
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c7ae:	9335      	str	r3, [sp, #212]	; 0xd4
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 800c7b0:	1b2d      	subs	r5, r5, r4
 800c7b2:	9504      	str	r5, [sp, #16]
	a1 = x0 - x6;
 800c7b4:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800c7b6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	x7 = a15 - (m3 << 1);	x[7] = x7;
 800c7b8:	963b      	str	r6, [sp, #236]	; 0xec
	a1 = x0 - x6;
 800c7ba:	eba5 0e04 	sub.w	lr, r5, r4
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 800c7be:	1a3b      	subs	r3, r7, r0
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 800c7c0:	eba1 0a02 	sub.w	sl, r1, r2
 800c7c4:	4d7c      	ldr	r5, [pc, #496]	; (800c9b8 <xmp3fixpt_IMDCT+0x794>)
 800c7c6:	fb85 6c0c 	smull	r6, ip, r5, ip
	a2 = x1 - x5;
 800c7ca:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800c7cc:	9c06      	ldr	r4, [sp, #24]
 800c7ce:	1b64      	subs	r4, r4, r5
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 800c7d0:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 800c7d2:	1b66      	subs	r6, r4, r5
 800c7d4:	4d78      	ldr	r5, [pc, #480]	; (800c9b8 <xmp3fixpt_IMDCT+0x794>)
 800c7d6:	fb85 4606 	smull	r4, r6, r5, r6
 800c7da:	4d78      	ldr	r5, [pc, #480]	; (800c9bc <xmp3fixpt_IMDCT+0x798>)
 800c7dc:	4693      	mov	fp, r2
 800c7de:	fb85 4b0b 	smull	r4, fp, r5, fp
 800c7e2:	4d77      	ldr	r5, [pc, #476]	; (800c9c0 <xmp3fixpt_IMDCT+0x79c>)
 800c7e4:	fb85 4101 	smull	r4, r1, r5, r1
 800c7e8:	4d74      	ldr	r5, [pc, #464]	; (800c9bc <xmp3fixpt_IMDCT+0x798>)
 800c7ea:	4654      	mov	r4, sl
 800c7ec:	fb85 8404 	smull	r8, r4, r5, r4
 800c7f0:	4d73      	ldr	r5, [pc, #460]	; (800c9c0 <xmp3fixpt_IMDCT+0x79c>)
 800c7f2:	fb85 8202 	smull	r8, r2, r5, r2
 800c7f6:	f105 5570 	add.w	r5, r5, #1006632960	; 0x3c000000
 800c7fa:	f505 254c 	add.w	r5, r5, #835584	; 0xcc000
 800c7fe:	4698      	mov	r8, r3
 800c800:	f205 25cb 	addw	r5, r5, #715	; 0x2cb
 800c804:	fb85 a808 	smull	sl, r8, r5, r8
 800c808:	4d6e      	ldr	r5, [pc, #440]	; (800c9c4 <xmp3fixpt_IMDCT+0x7a0>)
 800c80a:	fb85 a000 	smull	sl, r0, r5, r0
 800c80e:	f1a5 552f 	sub.w	r5, r5, #734003200	; 0x2bc00000
 800c812:	f5a5 25ea 	sub.w	r5, r5, #479232	; 0x75000
 800c816:	3de9      	subs	r5, #233	; 0xe9
 800c818:	fb85 a707 	smull	sl, r7, r5, r7
 800c81c:	4d69      	ldr	r5, [pc, #420]	; (800c9c4 <xmp3fixpt_IMDCT+0x7a0>)
 800c81e:	fb85 a303 	smull	sl, r3, r5, r3
	a16 = ( m5 << 1) + (m6 << 1);
 800c822:	0049      	lsls	r1, r1, #1
 800c824:	eb01 0b4b 	add.w	fp, r1, fp, lsl #1
	a12 = x[0] +  (x[6] >> 1);
 800c828:	990a      	ldr	r1, [sp, #40]	; 0x28
 800c82a:	468a      	mov	sl, r1
 800c82c:	990d      	ldr	r1, [sp, #52]	; 0x34
	a17 = ( m7 << 1) - (m8 << 1);
 800c82e:	0052      	lsls	r2, r2, #1
 800c830:	ebc2 0244 	rsb	r2, r2, r4, lsl #1
	a13 = a12  +  (  m1 << 1);
 800c834:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
	a12 = x[0] +  (x[6] >> 1);
 800c838:	eb0a 0461 	add.w	r4, sl, r1, asr #1
	a20 = (m11 << 1) - (m12 << 1);
 800c83c:	005b      	lsls	r3, r3, #1
 800c83e:	ebc3 0747 	rsb	r7, r3, r7, lsl #1
	a18 = a16 + a17;
 800c842:	eb0b 0102 	add.w	r1, fp, r2
	a14 = a12  -  (  m1 << 1);
 800c846:	eba4 030c 	sub.w	r3, r4, ip
	a13 = a12  +  (  m1 << 1);
 800c84a:	44a4      	add	ip, r4
	a26 = a14 - a18;
 800c84c:	1a5d      	subs	r5, r3, r1
	a19 = ( m9 << 1) + (m10 << 1);
 800c84e:	0040      	lsls	r0, r0, #1
	a27 = a13 - a18;
 800c850:	ebac 0101 	sub.w	r1, ip, r1
	a19 = ( m9 << 1) + (m10 << 1);
 800c854:	eb00 0848 	add.w	r8, r0, r8, lsl #1
	a27 = a13 - a18;
 800c858:	9105      	str	r1, [sp, #20]
	a15 = a1   +  ( a11 >> 1);
 800c85a:	9904      	ldr	r1, [sp, #16]
	a21 = a20 - a19;
 800c85c:	eba7 0008 	sub.w	r0, r7, r8
	a22 = a13 + a16;
 800c860:	eb0c 0a0b 	add.w	sl, ip, fp
	a25 = a13 + a17;
 800c864:	4494      	add	ip, r2
	a24 = a14 + a17;
 800c866:	441a      	add	r2, r3
	a15 = a1   +  ( a11 >> 1);
 800c868:	eb0e 0461 	add.w	r4, lr, r1, asr #1
	x6 = a25 - a20;			x[6] = x6;
 800c86c:	ebac 0c07 	sub.w	ip, ip, r7
	x3 = a26 - a21;			x[3] = x3;
 800c870:	1a29      	subs	r1, r5, r0
	a23 = a14 + a16;
 800c872:	445b      	add	r3, fp
	x5 = a27 + a21;			x[5] = x5;
 800c874:	9d05      	ldr	r5, [sp, #20]
	x6 = a25 - a20;			x[6] = x6;
 800c876:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
	x2 = a24 + a20;			x[2] = x2;
 800c87a:	19d7      	adds	r7, r2, r7
 800c87c:	463a      	mov	r2, r7
	x8 = a23 - a19;			x[8] = x8;
 800c87e:	eba3 0708 	sub.w	r7, r3, r8
	x4 = a1 - a11;			x[4] = x4;
 800c882:	9b04      	ldr	r3, [sp, #16]
	x2 = a24 + a20;			x[2] = x2;
 800c884:	9206      	str	r2, [sp, #24]
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c886:	0076      	lsls	r6, r6, #1
	x5 = a27 + a21;			x[5] = x5;
 800c888:	4405      	add	r5, r0
	x2 = a24 + a20;			x[2] = x2;
 800c88a:	923f      	str	r2, [sp, #252]	; 0xfc
	if (btPrev == 0 && btCurr == 0) {
 800c88c:	9a16      	ldr	r2, [sp, #88]	; 0x58
	x3 = a26 - a21;			x[3] = x3;
 800c88e:	9104      	str	r1, [sp, #16]
	x5 = a27 + a21;			x[5] = x5;
 800c890:	4628      	mov	r0, r5
	x0 = a22 + a19;			x[0] = x0;
 800c892:	44c2      	add	sl, r8
	x4 = a1 - a11;			x[4] = x4;
 800c894:	ebae 0803 	sub.w	r8, lr, r3
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c898:	19a3      	adds	r3, r4, r6
	x7 = a15 - (m3 << 1);	x[7] = x7;
 800c89a:	1ba6      	subs	r6, r4, r6
	x3 = a26 - a21;			x[3] = x3;
 800c89c:	9140      	str	r1, [sp, #256]	; 0x100
	x5 = a27 + a21;			x[5] = x5;
 800c89e:	900a      	str	r0, [sp, #40]	; 0x28
 800c8a0:	9042      	str	r0, [sp, #264]	; 0x108
	x0 = a22 + a19;			x[0] = x0;
 800c8a2:	f8cd a0f4 	str.w	sl, [sp, #244]	; 0xf4
	x6 = a25 - a20;			x[6] = x6;
 800c8a6:	f8cd c10c 	str.w	ip, [sp, #268]	; 0x10c
	x8 = a23 - a19;			x[8] = x8;
 800c8aa:	9745      	str	r7, [sp, #276]	; 0x114
	x4 = a1 - a11;			x[4] = x4;
 800c8ac:	f8cd 8104 	str.w	r8, [sp, #260]	; 0x104
	x1 = a15 + (m3 << 1);	x[1] = x1;
 800c8b0:	9305      	str	r3, [sp, #20]
 800c8b2:	933e      	str	r3, [sp, #248]	; 0xf8
	x7 = a15 - (m3 << 1);	x[7] = x7;
 800c8b4:	9644      	str	r6, [sp, #272]	; 0x110
	if (btPrev == 0 && btCurr == 0) {
 800c8b6:	2a00      	cmp	r2, #0
 800c8b8:	f040 8519 	bne.w	800d2ee <xmp3fixpt_IMDCT+0x10ca>
 800c8bc:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800c8be:	2a00      	cmp	r2, #0
 800c8c0:	f040 8326 	bne.w	800cf10 <xmp3fixpt_IMDCT+0xcec>
 800c8c4:	4638      	mov	r0, r7
 800c8c6:	4b41      	ldr	r3, [pc, #260]	; (800c9cc <xmp3fixpt_IMDCT+0x7a8>)
 800c8c8:	fb83 2000 	smull	r2, r0, r3, r0
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800c8cc:	9f17      	ldr	r7, [sp, #92]	; 0x5c
			xe >>= 2;
 800c8ce:	9a13      	ldr	r2, [sp, #76]	; 0x4c
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800c8d0:	6839      	ldr	r1, [r7, #0]
			xe >>= 2;
 800c8d2:	1093      	asrs	r3, r2, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800c8d4:	181c      	adds	r4, r3, r0
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800c8d6:	424a      	negs	r2, r1
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800c8d8:	1ac0      	subs	r0, r0, r3
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800c8da:	603c      	str	r4, [r7, #0]
			t = s - d;
 800c8dc:	1a12      	subs	r2, r2, r0
 800c8de:	4b3c      	ldr	r3, [pc, #240]	; (800c9d0 <xmp3fixpt_IMDCT+0x7ac>)
 800c8e0:	fb82 4303 	smull	r4, r3, r2, r3
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800c8e4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800c8e8:	483a      	ldr	r0, [pc, #232]	; (800c9d4 <xmp3fixpt_IMDCT+0x7b0>)
 800c8ea:	fb82 4000 	smull	r4, r0, r2, r0
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800c8ee:	ebc1 0180 	rsb	r1, r1, r0, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800c8f2:	17cf      	asrs	r7, r1, #31
	x ^= sign;
 800c8f4:	ea87 0e01 	eor.w	lr, r7, r1
			y[(17-i)*NBANDS] =  yHi;
 800c8f8:	9c02      	ldr	r4, [sp, #8]
 800c8fa:	9727      	str	r7, [sp, #156]	; 0x9c
 800c8fc:	17df      	asrs	r7, r3, #31
	sign = x >> (sizeof(int) * 8 - 1);
 800c8fe:	17da      	asrs	r2, r3, #31
	x ^= sign;
 800c900:	f8cd e094 	str.w	lr, [sp, #148]	; 0x94
 800c904:	ea87 0e03 	eor.w	lr, r7, r3
			y[(i)*NBANDS]    = 	yLo;
 800c908:	6023      	str	r3, [r4, #0]
	sign = x >> (sizeof(int) * 8 - 1);
 800c90a:	9229      	str	r2, [sp, #164]	; 0xa4
			y[(17-i)*NBANDS] =  yHi;
 800c90c:	f8c4 1880 	str.w	r1, [r4, #2176]	; 0x880
	x ^= sign;
 800c910:	f8cd e0a0 	str.w	lr, [sp, #160]	; 0xa0
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800c914:	4b30      	ldr	r3, [pc, #192]	; (800c9d8 <xmp3fixpt_IMDCT+0x7b4>)
 800c916:	fb83 2606 	smull	r2, r6, r3, r6
			xe >>= 2;
 800c91a:	9f12      	ldr	r7, [sp, #72]	; 0x48
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800c91c:	f859 3c20 	ldr.w	r3, [r9, #-32]
 800c920:	482e      	ldr	r0, [pc, #184]	; (800c9dc <xmp3fixpt_IMDCT+0x7b8>)
			xe >>= 2;
 800c922:	10bf      	asrs	r7, r7, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800c924:	19ba      	adds	r2, r7, r6
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800c926:	4259      	negs	r1, r3
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800c928:	1bf6      	subs	r6, r6, r7
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800c92a:	f849 2c20 	str.w	r2, [r9, #-32]
			t = s - d;
 800c92e:	1b89      	subs	r1, r1, r6
 800c930:	fb81 2000 	smull	r2, r0, r1, r0
 800c934:	4a2a      	ldr	r2, [pc, #168]	; (800c9e0 <xmp3fixpt_IMDCT+0x7bc>)
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800c936:	eb06 0680 	add.w	r6, r6, r0, lsl #2
 800c93a:	fb81 0202 	smull	r0, r2, r1, r2
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800c93e:	ebc3 0382 	rsb	r3, r3, r2, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800c942:	17df      	asrs	r7, r3, #31
 800c944:	4639      	mov	r1, r7
 800c946:	17f7      	asrs	r7, r6, #31
 800c948:	4638      	mov	r0, r7
	x ^= sign;
 800c94a:	ea81 0e03 	eor.w	lr, r1, r3
 800c94e:	f8cd e07c 	str.w	lr, [sp, #124]	; 0x7c
 800c952:	ea80 0e06 	eor.w	lr, r0, r6
			y[(17-i)*NBANDS] =  yHi;
 800c956:	4627      	mov	r7, r4
 800c958:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
			y[(i)*NBANDS]    = 	yLo;
 800c95c:	f8c4 6080 	str.w	r6, [r4, #128]	; 0x80
 800c960:	9120      	str	r1, [sp, #128]	; 0x80
 800c962:	9022      	str	r0, [sp, #136]	; 0x88
 800c964:	f8cd e084 	str.w	lr, [sp, #132]	; 0x84
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800c968:	4d1e      	ldr	r5, [pc, #120]	; (800c9e4 <xmp3fixpt_IMDCT+0x7c0>)
 800c96a:	fb85 3c0c 	smull	r3, ip, r5, ip
			xe >>= 2;
 800c96e:	9d11      	ldr	r5, [sp, #68]	; 0x44
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800c970:	f859 2c1c 	ldr.w	r2, [r9, #-28]
 800c974:	4b1c      	ldr	r3, [pc, #112]	; (800c9e8 <xmp3fixpt_IMDCT+0x7c4>)
			xe >>= 2;
 800c976:	10ad      	asrs	r5, r5, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800c978:	eb05 010c 	add.w	r1, r5, ip
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800c97c:	4250      	negs	r0, r2
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800c97e:	ebac 0505 	sub.w	r5, ip, r5
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800c982:	f849 1c1c 	str.w	r1, [r9, #-28]
			t = s - d;
 800c986:	1b40      	subs	r0, r0, r5
 800c988:	461c      	mov	r4, r3
 800c98a:	fb80 1404 	smull	r1, r4, r0, r4
 800c98e:	4917      	ldr	r1, [pc, #92]	; (800c9ec <xmp3fixpt_IMDCT+0x7c8>)
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800c990:	eb05 0584 	add.w	r5, r5, r4, lsl #2
 800c994:	fb80 4101 	smull	r4, r1, r0, r1
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800c998:	ebc2 0281 	rsb	r2, r2, r1, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800c99c:	17d6      	asrs	r6, r2, #31
	x ^= sign;
 800c99e:	ea86 0e02 	eor.w	lr, r6, r2
 800c9a2:	17e8      	asrs	r0, r5, #31
	sign = x >> (sizeof(int) * 8 - 1);
 800c9a4:	17e9      	asrs	r1, r5, #31
	x ^= sign;
 800c9a6:	f8cd e048 	str.w	lr, [sp, #72]	; 0x48
 800c9aa:	ea80 0e05 	eor.w	lr, r0, r5
	sign = x >> (sizeof(int) * 8 - 1);
 800c9ae:	9116      	str	r1, [sp, #88]	; 0x58
			y[(17-i)*NBANDS] =  yHi;
 800c9b0:	f8c7 2780 	str.w	r2, [r7, #1920]	; 0x780
 800c9b4:	e01c      	b.n	800c9f0 <xmp3fixpt_IMDCT+0x7cc>
 800c9b6:	bf00      	nop
 800c9b8:	6ed9eba1 	.word	0x6ed9eba1
 800c9bc:	620dbe8b 	.word	0x620dbe8b
 800c9c0:	163a1a7e 	.word	0x163a1a7e
 800c9c4:	7e0e2e32 	.word	0x7e0e2e32
 800c9c8:	5246dd49 	.word	0x5246dd49
 800c9cc:	0b27eb5c 	.word	0x0b27eb5c
 800c9d0:	42aace8b 	.word	0x42aace8b
 800c9d4:	c2e92724 	.word	0xc2e92724
 800c9d8:	2120fb83 	.word	0x2120fb83
 800c9dc:	47311c28 	.word	0x47311c28
 800c9e0:	c95f619a 	.word	0xc95f619a
 800c9e4:	36185aee 	.word	0x36185aee
 800c9e8:	4a868feb 	.word	0x4a868feb
 800c9ec:	d0859d8c 	.word	0xd0859d8c
			y[(i)*NBANDS]    = 	yLo;
 800c9f0:	f8c7 5100 	str.w	r5, [r7, #256]	; 0x100
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800c9f4:	990a      	ldr	r1, [sp, #40]	; 0x28
	x ^= sign;
 800c9f6:	9613      	str	r6, [sp, #76]	; 0x4c
 800c9f8:	f8cd e054 	str.w	lr, [sp, #84]	; 0x54
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800c9fc:	4ab1      	ldr	r2, [pc, #708]	; (800ccc4 <xmp3fixpt_IMDCT+0xaa0>)
 800c9fe:	fb82 0101 	smull	r0, r1, r2, r1
			xe >>= 2;
 800ca02:	981a      	ldr	r0, [sp, #104]	; 0x68
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800ca04:	f859 4c18 	ldr.w	r4, [r9, #-24]
 800ca08:	f102 7249 	add.w	r2, r2, #52690944	; 0x3240000
			xe >>= 2;
 800ca0c:	ea4f 0ca0 	mov.w	ip, r0, asr #2
 800ca10:	f502 3211 	add.w	r2, r2, #148480	; 0x24400
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800ca14:	eb0c 0001 	add.w	r0, ip, r1
 800ca18:	f202 326f 	addw	r2, r2, #879	; 0x36f
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800ca1c:	eba1 010c 	sub.w	r1, r1, ip
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800ca20:	4265      	negs	r5, r4
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800ca22:	f849 0c18 	str.w	r0, [r9, #-24]
			t = s - d;
 800ca26:	1a6d      	subs	r5, r5, r1
 800ca28:	4616      	mov	r6, r2
 800ca2a:	fb85 0606 	smull	r0, r6, r5, r6
 800ca2e:	48a6      	ldr	r0, [pc, #664]	; (800ccc8 <xmp3fixpt_IMDCT+0xaa4>)
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800ca30:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 800ca34:	fb85 6000 	smull	r6, r0, r5, r0
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800ca38:	ebc4 0080 	rsb	r0, r4, r0, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800ca3c:	17c6      	asrs	r6, r0, #31
 800ca3e:	17cd      	asrs	r5, r1, #31
 800ca40:	960d      	str	r6, [sp, #52]	; 0x34
	x ^= sign;
 800ca42:	17c6      	asrs	r6, r0, #31
	sign = x >> (sizeof(int) * 8 - 1);
 800ca44:	462c      	mov	r4, r5
	x ^= sign;
 800ca46:	ea86 0e00 	eor.w	lr, r6, r0
 800ca4a:	f8cd e030 	str.w	lr, [sp, #48]	; 0x30
 800ca4e:	ea84 0e01 	eor.w	lr, r4, r1
			y[(i)*NBANDS]    = 	yLo;
 800ca52:	f8c7 1180 	str.w	r1, [r7, #384]	; 0x180
			y[(17-i)*NBANDS] =  yHi;
 800ca56:	f8c7 0700 	str.w	r0, [r7, #1792]	; 0x700
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800ca5a:	4645      	mov	r5, r8
	x ^= sign;
 800ca5c:	9411      	str	r4, [sp, #68]	; 0x44
 800ca5e:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800ca62:	499a      	ldr	r1, [pc, #616]	; (800cccc <xmp3fixpt_IMDCT+0xaa8>)
 800ca64:	fb81 0505 	smull	r0, r5, r1, r5
			xe >>= 2;
 800ca68:	9910      	ldr	r1, [sp, #64]	; 0x40
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800ca6a:	f859 6c14 	ldr.w	r6, [r9, #-20]
 800ca6e:	4c98      	ldr	r4, [pc, #608]	; (800ccd0 <xmp3fixpt_IMDCT+0xaac>)
			xe >>= 2;
 800ca70:	1088      	asrs	r0, r1, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800ca72:	1941      	adds	r1, r0, r5
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800ca74:	eba5 0800 	sub.w	r8, r5, r0
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800ca78:	4275      	negs	r5, r6
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800ca7a:	f849 1c14 	str.w	r1, [r9, #-20]
			t = s - d;
 800ca7e:	eba5 0508 	sub.w	r5, r5, r8
 800ca82:	fb85 1404 	smull	r1, r4, r5, r4
 800ca86:	f04f 4160 	mov.w	r1, #3758096384	; 0xe0000000
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800ca8a:	eb08 0484 	add.w	r4, r8, r4, lsl #2
 800ca8e:	fb85 0101 	smull	r0, r1, r5, r1
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800ca92:	ebc6 0181 	rsb	r1, r6, r1, lsl #2
			y[(17-i)*NBANDS] =  yHi;
 800ca96:	f8c7 1680 	str.w	r1, [r7, #1664]	; 0x680
			y[(i)*NBANDS]    = 	yLo;
 800ca9a:	463e      	mov	r6, r7
 800ca9c:	f8c7 4200 	str.w	r4, [r7, #512]	; 0x200
	x ^= sign;
 800caa0:	17cf      	asrs	r7, r1, #31
 800caa2:	ea87 0e01 	eor.w	lr, r7, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800caa6:	17c8      	asrs	r0, r1, #31
	x ^= sign;
 800caa8:	17e1      	asrs	r1, r4, #31
	sign = x >> (sizeof(int) * 8 - 1);
 800caaa:	17e5      	asrs	r5, r4, #31
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800caac:	f8dd b010 	ldr.w	fp, [sp, #16]
	x ^= sign;
 800cab0:	f8cd e010 	str.w	lr, [sp, #16]
 800cab4:	ea84 0e01 	eor.w	lr, r4, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800cab8:	900a      	str	r0, [sp, #40]	; 0x28
 800caba:	951a      	str	r5, [sp, #104]	; 0x68
	x ^= sign;
 800cabc:	f8cd e074 	str.w	lr, [sp, #116]	; 0x74
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800cac0:	4984      	ldr	r1, [pc, #528]	; (800ccd4 <xmp3fixpt_IMDCT+0xab0>)
 800cac2:	fb81 0b0b 	smull	r0, fp, r1, fp
			xe >>= 2;
 800cac6:	9c19      	ldr	r4, [sp, #100]	; 0x64
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cac8:	f859 5c10 	ldr.w	r5, [r9, #-16]
			xe >>= 2;
 800cacc:	10a0      	asrs	r0, r4, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cace:	eb0b 0100 	add.w	r1, fp, r0
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cad2:	426c      	negs	r4, r5
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800cad4:	ebab 0000 	sub.w	r0, fp, r0
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cad8:	f849 1c10 	str.w	r1, [r9, #-16]
			t = s - d;
 800cadc:	1a24      	subs	r4, r4, r0
 800cade:	fb84 1202 	smull	r1, r2, r4, r2
 800cae2:	497d      	ldr	r1, [pc, #500]	; (800ccd8 <xmp3fixpt_IMDCT+0xab4>)
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800cae4:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800cae8:	fb84 0101 	smull	r0, r1, r4, r1
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800caec:	ebc5 0181 	rsb	r1, r5, r1, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800caf0:	17d4      	asrs	r4, r2, #31
 800caf2:	ea4f 7ee1 	mov.w	lr, r1, asr #31
 800caf6:	4625      	mov	r5, r4
	x ^= sign;
 800caf8:	ea81 0c0e 	eor.w	ip, r1, lr
 800cafc:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
 800cb00:	ea82 0c05 	eor.w	ip, r2, r5
			y[(i)*NBANDS]    = 	yLo;
 800cb04:	f8c6 2280 	str.w	r2, [r6, #640]	; 0x280
			y[(17-i)*NBANDS] =  yHi;
 800cb08:	f8c6 1600 	str.w	r1, [r6, #1536]	; 0x600
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800cb0c:	9f06      	ldr	r7, [sp, #24]
	x ^= sign;
 800cb0e:	951e      	str	r5, [sp, #120]	; 0x78
 800cb10:	f8cd c064 	str.w	ip, [sp, #100]	; 0x64
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800cb14:	4a71      	ldr	r2, [pc, #452]	; (800ccdc <xmp3fixpt_IMDCT+0xab8>)
 800cb16:	fb82 1707 	smull	r1, r7, r2, r7
			xe >>= 2;
 800cb1a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cb1c:	f859 4c0c 	ldr.w	r4, [r9, #-12]
			xe >>= 2;
 800cb20:	10a9      	asrs	r1, r5, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cb22:	19cd      	adds	r5, r1, r7
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cb24:	4260      	negs	r0, r4
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800cb26:	1a79      	subs	r1, r7, r1
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cb28:	f849 5c0c 	str.w	r5, [r9, #-12]
			t = s - d;
 800cb2c:	1a40      	subs	r0, r0, r1
 800cb2e:	fb80 2303 	smull	r2, r3, r0, r3
 800cb32:	4a6b      	ldr	r2, [pc, #428]	; (800cce0 <xmp3fixpt_IMDCT+0xabc>)
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800cb34:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 800cb38:	fb80 1202 	smull	r1, r2, r0, r2
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800cb3c:	ebc4 0282 	rsb	r2, r4, r2, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800cb40:	17d6      	asrs	r6, r2, #31
 800cb42:	ea4f 78e3 	mov.w	r8, r3, asr #31
			y[(17-i)*NBANDS] =  yHi;
 800cb46:	9f02      	ldr	r7, [sp, #8]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800cb48:	f8dd b014 	ldr.w	fp, [sp, #20]
			y[(i)*NBANDS]    = 	yLo;
 800cb4c:	f8c7 3300 	str.w	r3, [r7, #768]	; 0x300
	x ^= sign;
 800cb50:	ea86 0c02 	eor.w	ip, r6, r2
 800cb54:	f8cd c018 	str.w	ip, [sp, #24]
 800cb58:	ea88 0c03 	eor.w	ip, r8, r3
			y[(17-i)*NBANDS] =  yHi;
 800cb5c:	f8c7 2580 	str.w	r2, [r7, #1408]	; 0x580
 800cb60:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800cb64:	4b5f      	ldr	r3, [pc, #380]	; (800cce4 <xmp3fixpt_IMDCT+0xac0>)
 800cb66:	fb83 2b0b 	smull	r2, fp, r3, fp
			xe >>= 2;
 800cb6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cb6c:	f859 0c08 	ldr.w	r0, [r9, #-8]
			xe >>= 2;
 800cb70:	109a      	asrs	r2, r3, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cb72:	eb02 030b 	add.w	r3, r2, fp
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cb76:	4241      	negs	r1, r0
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800cb78:	ebab 0b02 	sub.w	fp, fp, r2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cb7c:	f849 3c08 	str.w	r3, [r9, #-8]
			t = s - d;
 800cb80:	eba1 010b 	sub.w	r1, r1, fp
 800cb84:	4a58      	ldr	r2, [pc, #352]	; (800cce8 <xmp3fixpt_IMDCT+0xac4>)
 800cb86:	fb81 3202 	smull	r3, r2, r1, r2
 800cb8a:	4b58      	ldr	r3, [pc, #352]	; (800ccec <xmp3fixpt_IMDCT+0xac8>)
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800cb8c:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
 800cb90:	fb81 4303 	smull	r4, r3, r1, r3
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800cb94:	ebc0 0383 	rsb	r3, r0, r3, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800cb98:	17d4      	asrs	r4, r2, #31
 800cb9a:	17dd      	asrs	r5, r3, #31
			y[(17-i)*NBANDS] =  yHi;
 800cb9c:	f8c7 3500 	str.w	r3, [r7, #1280]	; 0x500
			y[(i)*NBANDS]    = 	yLo;
 800cba0:	f8c7 2380 	str.w	r2, [r7, #896]	; 0x380
	x ^= sign;
 800cba4:	ea82 0b04 	eor.w	fp, r2, r4
 800cba8:	406b      	eors	r3, r5
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800cbaa:	4a51      	ldr	r2, [pc, #324]	; (800ccf0 <xmp3fixpt_IMDCT+0xacc>)
 800cbac:	fb82 1a0a 	smull	r1, sl, r2, sl
			xe >>= 2;
 800cbb0:	9a08      	ldr	r2, [sp, #32]
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cbb2:	f859 7c04 	ldr.w	r7, [r9, #-4]
 800cbb6:	f8df c140 	ldr.w	ip, [pc, #320]	; 800ccf8 <xmp3fixpt_IMDCT+0xad4>
			xe >>= 2;
 800cbba:	1092      	asrs	r2, r2, #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cbbc:	eb0a 0102 	add.w	r1, sl, r2
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 800cbc0:	4278      	negs	r0, r7
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 800cbc2:	ebaa 0202 	sub.w	r2, sl, r2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800cbc6:	f849 1c04 	str.w	r1, [r9, #-4]
			t = s - d;
 800cbca:	1a80      	subs	r0, r0, r2
 800cbcc:	fb80 1c0c 	smull	r1, ip, r0, ip
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 800cbd0:	eb02 028c 	add.w	r2, r2, ip, lsl #2
 800cbd4:	4947      	ldr	r1, [pc, #284]	; (800ccf4 <xmp3fixpt_IMDCT+0xad0>)
 800cbd6:	9205      	str	r2, [sp, #20]
 800cbd8:	fb80 c101 	smull	ip, r1, r0, r1
	x -= sign;
 800cbdc:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800cbde:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800cbe0:	eba2 0c00 	sub.w	ip, r2, r0
 800cbe4:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 800cbe6:	9820      	ldr	r0, [sp, #128]	; 0x80
 800cbe8:	1a10      	subs	r0, r2, r0
			mOut |= FASTABS(yHi);
 800cbea:	ea4c 0c00 	orr.w	ip, ip, r0
 800cbee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800cbf0:	980d      	ldr	r0, [sp, #52]	; 0x34
 800cbf2:	1a10      	subs	r0, r2, r0
 800cbf4:	9a04      	ldr	r2, [sp, #16]
			yHi = (s + (MULSHIFT32(t, *wp++) << 2));
 800cbf6:	ebc7 0181 	rsb	r1, r7, r1, lsl #2
			mOut |= FASTABS(yHi);
 800cbfa:	ea4c 0000 	orr.w	r0, ip, r0
 800cbfe:	9f10      	ldr	r7, [sp, #64]	; 0x40
 800cc00:	4694      	mov	ip, r2
 800cc02:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800cc04:	eba7 0e0e 	sub.w	lr, r7, lr
 800cc08:	ebac 0c02 	sub.w	ip, ip, r2
 800cc0c:	9f06      	ldr	r7, [sp, #24]
 800cc0e:	9a21      	ldr	r2, [sp, #132]	; 0x84
 800cc10:	ea40 000c 	orr.w	r0, r0, ip
 800cc14:	1bbe      	subs	r6, r7, r6
 800cc16:	ea40 000e 	orr.w	r0, r0, lr
	sign = x >> (sizeof(int) * 8 - 1);
 800cc1a:	17cf      	asrs	r7, r1, #31
 800cc1c:	4330      	orrs	r0, r6
	x ^= sign;
 800cc1e:	ea81 0607 	eor.w	r6, r1, r7
	x -= sign;
 800cc22:	1bf7      	subs	r7, r6, r7
 800cc24:	9e22      	ldr	r6, [sp, #136]	; 0x88
 800cc26:	1b5b      	subs	r3, r3, r5
 800cc28:	1b96      	subs	r6, r2, r6
 800cc2a:	9d27      	ldr	r5, [sp, #156]	; 0x9c
 800cc2c:	9a25      	ldr	r2, [sp, #148]	; 0x94
 800cc2e:	4303      	orrs	r3, r0
 800cc30:	eba2 0e05 	sub.w	lr, r2, r5
 800cc34:	431f      	orrs	r7, r3
 800cc36:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800cc38:	9d29      	ldr	r5, [sp, #164]	; 0xa4
 800cc3a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800cc3c:	4337      	orrs	r7, r6
 800cc3e:	9e15      	ldr	r6, [sp, #84]	; 0x54
 800cc40:	1b50      	subs	r0, r2, r5
 800cc42:	ea4e 0000 	orr.w	r0, lr, r0
 800cc46:	1af5      	subs	r5, r6, r3
 800cc48:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800cc4a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800cc4c:	4307      	orrs	r7, r0
 800cc4e:	1ad3      	subs	r3, r2, r3
 800cc50:	432f      	orrs	r7, r5
 800cc52:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 800cc54:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 800cc56:	431f      	orrs	r7, r3
 800cc58:	1b50      	subs	r0, r2, r5
 800cc5a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800cc5c:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800cc5e:	4307      	orrs	r7, r0
 800cc60:	1ad6      	subs	r6, r2, r3
 800cc62:	4337      	orrs	r7, r6
 800cc64:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	sign = x >> (sizeof(int) * 8 - 1);
 800cc66:	9e05      	ldr	r6, [sp, #20]
			y[(17-i)*NBANDS] =  yHi;
 800cc68:	9802      	ldr	r0, [sp, #8]
	x -= sign;
 800cc6a:	eba3 0808 	sub.w	r8, r3, r8
	sign = x >> (sizeof(int) * 8 - 1);
 800cc6e:	17f3      	asrs	r3, r6, #31
	x ^= sign;
 800cc70:	ea86 0503 	eor.w	r5, r6, r3
	x -= sign;
 800cc74:	1aeb      	subs	r3, r5, r3
 800cc76:	ebab 0404 	sub.w	r4, fp, r4
 800cc7a:	4605      	mov	r5, r0
			mOut |= FASTABS(yHi);
 800cc7c:	ea47 0708 	orr.w	r7, r7, r8
 800cc80:	433c      	orrs	r4, r7
			y[(17-i)*NBANDS] =  yHi;
 800cc82:	f8c0 1480 	str.w	r1, [r0, #1152]	; 0x480
			mOut |= FASTABS(yHi);
 800cc86:	431c      	orrs	r4, r3
			y[(i)*NBANDS]    = 	yLo;
 800cc88:	f8c5 6400 	str.w	r6, [r5, #1024]	; 0x400
 800cc8c:	4605      	mov	r5, r0
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 800cc8e:	9e01      	ldr	r6, [sp, #4]
 800cc90:	9b07      	ldr	r3, [sp, #28]
 800cc92:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800cc94:	4632      	mov	r2, r6
 800cc96:	4628      	mov	r0, r5
 800cc98:	f7fe fe14 	bl	800b8c4 <FreqInvertRescale>
 800cc9c:	9a00      	ldr	r2, [sp, #0]
 800cc9e:	3248      	adds	r2, #72	; 0x48
 800cca0:	9200      	str	r2, [sp, #0]
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 800cca2:	9a03      	ldr	r2, [sp, #12]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 800cca4:	4320      	orrs	r0, r4
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 800cca6:	4302      	orrs	r2, r0
 800cca8:	9203      	str	r2, [sp, #12]
 800ccaa:	462a      	mov	r2, r5
 800ccac:	3204      	adds	r2, #4
	for(i = 0; i < bc->nBlocksLong; i++) {
 800ccae:	4633      	mov	r3, r6
 800ccb0:	9202      	str	r2, [sp, #8]
 800ccb2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800ccb4:	3301      	adds	r3, #1
 800ccb6:	429a      	cmp	r2, r3
 800ccb8:	9301      	str	r3, [sp, #4]
 800ccba:	f109 0924 	add.w	r9, r9, #36	; 0x24
 800ccbe:	f000 831f 	beq.w	800d300 <xmp3fixpt_IMDCT+0x10dc>
 800ccc2:	e01b      	b.n	800ccfc <xmp3fixpt_IMDCT+0xad8>
 800ccc4:	496af3e2 	.word	0x496af3e2
 800ccc8:	d8243ea0 	.word	0xd8243ea0
 800cccc:	5a82799a 	.word	0x5a82799a
 800ccd0:	4d413ccc 	.word	0x4d413ccc
 800ccd4:	68d9f964 	.word	0x68d9f964
 800ccd8:	e7dbc161 	.word	0xe7dbc161
 800ccdc:	7401e4c1 	.word	0x7401e4c1
 800cce0:	ef7a6275 	.word	0xef7a6275
 800cce4:	7ba3751d 	.word	0x7ba3751d
 800cce8:	47311c28 	.word	0x47311c28
 800ccec:	f6a09e67 	.word	0xf6a09e67
 800ccf0:	7f834ed0 	.word	0x7f834ed0
 800ccf4:	fd16d8dd 	.word	0xfd16d8dd
 800ccf8:	42aace8b 	.word	0x42aace8b
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 800ccfc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800ccfe:	6993      	ldr	r3, [r2, #24]
		currWinIdx = sis->blockType;
 800cd00:	6952      	ldr	r2, [r2, #20]
 800cd02:	9215      	str	r2, [sp, #84]	; 0x54
 800cd04:	f1a9 0124 	sub.w	r1, r9, #36	; 0x24
 800cd08:	9117      	str	r1, [sp, #92]	; 0x5c
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 800cd0a:	b12b      	cbz	r3, 800cd18 <xmp3fixpt_IMDCT+0xaf4>
			currWinIdx = 0;
 800cd0c:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800cd0e:	9901      	ldr	r1, [sp, #4]
 800cd10:	428b      	cmp	r3, r1
 800cd12:	bfc8      	it	gt
 800cd14:	2200      	movgt	r2, #0
 800cd16:	9215      	str	r2, [sp, #84]	; 0x54
		prevWinIdx = bc->prevType;
 800cd18:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800cd1a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800cd1c:	9901      	ldr	r1, [sp, #4]
 800cd1e:	428a      	cmp	r2, r1
 800cd20:	bfc8      	it	gt
 800cd22:	2300      	movgt	r3, #0
 800cd24:	9316      	str	r3, [sp, #88]	; 0x58
	if (gb < 7) {
 800cd26:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800cd28:	2b06      	cmp	r3, #6
 800cd2a:	f73f ac2b 	bgt.w	800c584 <xmp3fixpt_IMDCT+0x360>
			xPrev[i] >>= es;
 800cd2e:	f859 6c1c 	ldr.w	r6, [r9, #-28]
 800cd32:	960a      	str	r6, [sp, #40]	; 0x28
 800cd34:	e919 0030 	ldmdb	r9, {r4, r5}
		es = 7 - gb;
 800cd38:	9e18      	ldr	r6, [sp, #96]	; 0x60
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd3a:	9a00      	ldr	r2, [sp, #0]
			xPrev[i] >>= es;
 800cd3c:	f859 1c10 	ldr.w	r1, [r9, #-16]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd40:	f852 3c04 	ldr.w	r3, [r2, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd44:	f852 0c08 	ldr.w	r0, [r2, #-8]
			xPrev[i] >>= es;
 800cd48:	f859 2c14 	ldr.w	r2, [r9, #-20]
		es = 7 - gb;
 800cd4c:	f1c6 0607 	rsb	r6, r6, #7
			xPrev[i] >>= es;
 800cd50:	4135      	asrs	r5, r6
		es = 7 - gb;
 800cd52:	4637      	mov	r7, r6
			xPrev[i] >>= es;
 800cd54:	f849 5c04 	str.w	r5, [r9, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd58:	9d00      	ldr	r5, [sp, #0]
 800cd5a:	9707      	str	r7, [sp, #28]
 800cd5c:	413b      	asrs	r3, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd5e:	4138      	asrs	r0, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd60:	f855 6c0c 	ldr.w	r6, [r5, #-12]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd64:	9305      	str	r3, [sp, #20]
			xPrev[i] >>= es;
 800cd66:	413c      	asrs	r4, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd68:	eba0 0a03 	sub.w	sl, r0, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd6c:	9800      	ldr	r0, [sp, #0]
			xPrev[i] >>= es;
 800cd6e:	f859 3c0c 	ldr.w	r3, [r9, #-12]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd72:	f855 5c10 	ldr.w	r5, [r5, #-16]
			xPrev[i] >>= es;
 800cd76:	f849 4c08 	str.w	r4, [r9, #-8]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd7a:	f850 4c14 	ldr.w	r4, [r0, #-20]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd7e:	f850 0c18 	ldr.w	r0, [r0, #-24]
			xPrev[i] >>= es;
 800cd82:	413b      	asrs	r3, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd84:	413e      	asrs	r6, r7
			xPrev[i] >>= es;
 800cd86:	f849 3c0c 	str.w	r3, [r9, #-12]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd8a:	eba6 060a 	sub.w	r6, r6, sl
 800cd8e:	9b00      	ldr	r3, [sp, #0]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd90:	413d      	asrs	r5, r7
 800cd92:	eba5 0b06 	sub.w	fp, r5, r6
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd96:	fa44 fe07 	asr.w	lr, r4, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd9a:	469c      	mov	ip, r3
			xPrev[i] >>= es;
 800cd9c:	4139      	asrs	r1, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cd9e:	ebae 0e0b 	sub.w	lr, lr, fp
			acc1 = ((*xCurr--) >> es) - acc1;
 800cda2:	4138      	asrs	r0, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cda4:	f853 5c1c 	ldr.w	r5, [r3, #-28]
 800cda8:	461c      	mov	r4, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdaa:	f853 3c20 	ldr.w	r3, [r3, #-32]
			xPrev[i] >>= es;
 800cdae:	f849 1c10 	str.w	r1, [r9, #-16]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdb2:	eba0 010e 	sub.w	r1, r0, lr
 800cdb6:	9108      	str	r1, [sp, #32]
 800cdb8:	f85c 1c28 	ldr.w	r1, [ip, #-40]
 800cdbc:	9100      	str	r1, [sp, #0]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdbe:	fa45 f807 	asr.w	r8, r5, r7
			xPrev[i] >>= es;
 800cdc2:	4639      	mov	r1, r7
 800cdc4:	413a      	asrs	r2, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdc6:	9f08      	ldr	r7, [sp, #32]
 800cdc8:	f854 4c24 	ldr.w	r4, [r4, #-36]
			xPrev[i] >>= es;
 800cdcc:	f849 2c14 	str.w	r2, [r9, #-20]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdd0:	eba8 0807 	sub.w	r8, r8, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdd4:	410b      	asrs	r3, r1
 800cdd6:	eba3 0008 	sub.w	r0, r3, r8
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdda:	410c      	asrs	r4, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 800cddc:	900f      	str	r0, [sp, #60]	; 0x3c
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdde:	1a24      	subs	r4, r4, r0
			xPrev[i] >>= es;
 800cde0:	f859 2c18 	ldr.w	r2, [r9, #-24]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cde4:	9800      	ldr	r0, [sp, #0]
 800cde6:	f85c 5c30 	ldr.w	r5, [ip, #-48]
 800cdea:	9404      	str	r4, [sp, #16]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdec:	460f      	mov	r7, r1
 800cdee:	4663      	mov	r3, ip
 800cdf0:	f85c 1c2c 	ldr.w	r1, [ip, #-44]
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdf4:	4138      	asrs	r0, r7
			xPrev[i] >>= es;
 800cdf6:	4694      	mov	ip, r2
 800cdf8:	fa4c f207 	asr.w	r2, ip, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800cdfc:	1b00      	subs	r0, r0, r4
			xPrev[i] >>= es;
 800cdfe:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800ce00:	f849 2c18 	str.w	r2, [r9, #-24]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce04:	fa41 fc07 	asr.w	ip, r1, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce08:	461a      	mov	r2, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce0a:	f853 1c34 	ldr.w	r1, [r3, #-52]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce0e:	f853 3c38 	ldr.w	r3, [r3, #-56]
 800ce12:	9306      	str	r3, [sp, #24]
			xPrev[i] >>= es;
 800ce14:	413c      	asrs	r4, r7
 800ce16:	463b      	mov	r3, r7
 800ce18:	4627      	mov	r7, r4
			acc2 = acc1 - acc2;
 800ce1a:	9c05      	ldr	r4, [sp, #20]
			xPrev[i] >>= es;
 800ce1c:	f849 7c1c 	str.w	r7, [r9, #-28]
 800ce20:	f859 7c20 	ldr.w	r7, [r9, #-32]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce24:	9200      	str	r2, [sp, #0]
			acc2 = acc1 - acc2;
 800ce26:	1b34      	subs	r4, r6, r4
 800ce28:	940e      	str	r4, [sp, #56]	; 0x38
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce2a:	f852 6c3c 	ldr.w	r6, [r2, #-60]
			acc2 = acc1 - acc2;
 800ce2e:	ebae 0404 	sub.w	r4, lr, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce32:	fa41 fe03 	asr.w	lr, r1, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce36:	f852 1c40 	ldr.w	r1, [r2, #-64]
			acc2 = acc1 - acc2;
 800ce3a:	940d      	str	r4, [sp, #52]	; 0x34
			xPrev[i] >>= es;
 800ce3c:	463a      	mov	r2, r7
 800ce3e:	fa42 f703 	asr.w	r7, r2, r3
 800ce42:	f849 7c20 	str.w	r7, [r9, #-32]
			acc2 = acc1 - acc2;
 800ce46:	9f04      	ldr	r7, [sp, #16]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce48:	9a06      	ldr	r2, [sp, #24]
			acc2 = acc1 - acc2;
 800ce4a:	eba8 0404 	sub.w	r4, r8, r4
 800ce4e:	940c      	str	r4, [sp, #48]	; 0x30
 800ce50:	1b3c      	subs	r4, r7, r4
 800ce52:	9419      	str	r4, [sp, #100]	; 0x64
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce54:	fa46 f403 	asr.w	r4, r6, r3
 800ce58:	9e00      	ldr	r6, [sp, #0]
 800ce5a:	f856 7c44 	ldr.w	r7, [r6, #-68]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce5e:	f856 6c48 	ldr.w	r6, [r6, #-72]
 800ce62:	960a      	str	r6, [sp, #40]	; 0x28
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce64:	ebac 0c00 	sub.w	ip, ip, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce68:	411d      	asrs	r5, r3
			acc2 = acc1 - acc2;
 800ce6a:	9e19      	ldr	r6, [sp, #100]	; 0x64
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce6c:	9706      	str	r7, [sp, #24]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce6e:	eba5 050c 	sub.w	r5, r5, ip
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce72:	ebae 0805 	sub.w	r8, lr, r5
			acc2 = acc1 - acc2;
 800ce76:	ebac 0606 	sub.w	r6, ip, r6
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce7a:	fa41 fe03 	asr.w	lr, r1, r3
 800ce7e:	411a      	asrs	r2, r3
			acc2 = acc1 - acc2;
 800ce80:	eba8 0306 	sub.w	r3, r8, r6
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce84:	eba2 0208 	sub.w	r2, r2, r8
			xPrev[i] >>= es;
 800ce88:	f859 7c24 	ldr.w	r7, [r9, #-36]
			acc2 = acc1 - acc2;
 800ce8c:	961a      	str	r6, [sp, #104]	; 0x68
 800ce8e:	9304      	str	r3, [sp, #16]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce90:	9906      	ldr	r1, [sp, #24]
			acc2 = acc1 - acc2;
 800ce92:	9b04      	ldr	r3, [sp, #16]
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce94:	9e07      	ldr	r6, [sp, #28]
 800ce96:	1aa4      	subs	r4, r4, r2
			acc2 = acc1 - acc2;
 800ce98:	1ae3      	subs	r3, r4, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 800ce9a:	fa41 f806 	asr.w	r8, r1, r6
			acc2 = acc1 - acc2;
 800ce9e:	9306      	str	r3, [sp, #24]
 800cea0:	4619      	mov	r1, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 800cea2:	4633      	mov	r3, r6
 800cea4:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800cea6:	ebae 0e04 	sub.w	lr, lr, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 800ceaa:	eba8 080e 	sub.w	r8, r8, lr
			acc1 = ((*xCurr--) >> es) - acc1;
 800ceae:	411e      	asrs	r6, r3
			xPrev[i] >>= es;
 800ceb0:	411f      	asrs	r7, r3
			acc2 = acc1 - acc2;
 800ceb2:	eba8 0c01 	sub.w	ip, r8, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 800ceb6:	eba6 0608 	sub.w	r6, r6, r8
			xPrev[i] >>= es;
 800ceba:	f849 7c24 	str.w	r7, [r9, #-36]
 800cebe:	f7ff bbce 	b.w	800c65e <xmp3fixpt_IMDCT+0x43a>
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 800cec2:	3307      	adds	r3, #7
 800cec4:	fb8e 2403 	smull	r2, r4, lr, r3
 800cec8:	17db      	asrs	r3, r3, #31
 800ceca:	ebc3 03a4 	rsb	r3, r3, r4, asr #2
 800cece:	00d9      	lsls	r1, r3, #3
 800ced0:	18cd      	adds	r5, r1, r3
 800ced2:	006d      	lsls	r5, r5, #1
 800ced4:	f105 0208 	add.w	r2, r5, #8
 800ced8:	9210      	str	r2, [sp, #64]	; 0x40
 800ceda:	1c5a      	adds	r2, r3, #1
 800cedc:	921b      	str	r2, [sp, #108]	; 0x6c
 800cede:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800cee0:	4638      	mov	r0, r7
 800cee2:	4634      	mov	r4, r6
 800cee4:	4402      	add	r2, r0
 800cee6:	0210      	lsls	r0, r2, #8
 800cee8:	900f      	str	r0, [sp, #60]	; 0x3c
	for (k = nBfly; k > 0; k--) {
 800ceea:	2b00      	cmp	r3, #0
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 800ceec:	4420      	add	r0, r4
 800ceee:	902e      	str	r0, [sp, #184]	; 0xb8
	for (k = nBfly; k > 0; k--) {
 800cef0:	f73f a9ee 	bgt.w	800c2d0 <xmp3fixpt_IMDCT+0xac>
 800cef4:	990c      	ldr	r1, [sp, #48]	; 0x30
 800cef6:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 800cef8:	440b      	add	r3, r1
 800cefa:	011b      	lsls	r3, r3, #4
 800cefc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800cf00:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800cf02:	4413      	add	r3, r2
 800cf04:	460a      	mov	r2, r1
 800cf06:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cf08:	9326      	str	r3, [sp, #152]	; 0x98
 800cf0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800cf0c:	f7ff bad9 	b.w	800c4c2 <xmp3fixpt_IMDCT+0x29e>
		wpLo = imdctWin[btPrev] + 18;
 800cf10:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800cf12:	49d8      	ldr	r1, [pc, #864]	; (800d274 <xmp3fixpt_IMDCT+0x1050>)
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cf14:	f859 4c24 	ldr.w	r4, [r9, #-36]
		wpLo = imdctWin[btPrev] + 18;
 800cf18:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 800cf1c:	eb01 1202 	add.w	r2, r1, r2, lsl #4
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800cf20:	4625      	mov	r5, r4
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cf22:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 800cf26:	6c90      	ldr	r0, [r2, #72]	; 0x48
 800cf28:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cf2c:	9546      	str	r5, [sp, #280]	; 0x118
 800cf2e:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cf32:	9457      	str	r4, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cf34:	f859 4c20 	ldr.w	r4, [r9, #-32]
 800cf38:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800cf3c:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 800cf3e:	4625      	mov	r5, r4
 800cf40:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cf44:	9547      	str	r5, [sp, #284]	; 0x11c
 800cf46:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cf4a:	9456      	str	r4, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cf4c:	f859 4c1c 	ldr.w	r4, [r9, #-28]
 800cf50:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 800cf54:	6d10      	ldr	r0, [r2, #80]	; 0x50
 800cf56:	4625      	mov	r5, r4
 800cf58:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cf5c:	9548      	str	r5, [sp, #288]	; 0x120
 800cf5e:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cf62:	9455      	str	r4, [sp, #340]	; 0x154
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cf64:	f859 4c18 	ldr.w	r4, [r9, #-24]
 800cf68:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 800cf6c:	6d50      	ldr	r0, [r2, #84]	; 0x54
 800cf6e:	4625      	mov	r5, r4
 800cf70:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cf74:	9549      	str	r5, [sp, #292]	; 0x124
 800cf76:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cf7a:	9454      	str	r4, [sp, #336]	; 0x150
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cf7c:	f859 4c14 	ldr.w	r4, [r9, #-20]
 800cf80:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
 800cf82:	6d90      	ldr	r0, [r2, #88]	; 0x58
 800cf84:	4625      	mov	r5, r4
 800cf86:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cf8a:	954a      	str	r5, [sp, #296]	; 0x128
 800cf8c:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cf90:	9453      	str	r4, [sp, #332]	; 0x14c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cf92:	f859 4c10 	ldr.w	r4, [r9, #-16]
 800cf96:	6f93      	ldr	r3, [r2, #120]	; 0x78
 800cf98:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 800cf9a:	4625      	mov	r5, r4
 800cf9c:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cfa0:	954b      	str	r5, [sp, #300]	; 0x12c
 800cfa2:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cfa6:	9452      	str	r4, [sp, #328]	; 0x148
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cfa8:	f859 4c0c 	ldr.w	r4, [r9, #-12]
 800cfac:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800cfae:	6e10      	ldr	r0, [r2, #96]	; 0x60
 800cfb0:	4625      	mov	r5, r4
 800cfb2:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cfb6:	954c      	str	r5, [sp, #304]	; 0x130
 800cfb8:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cfbc:	9451      	str	r4, [sp, #324]	; 0x144
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cfbe:	f859 4c08 	ldr.w	r4, [r9, #-8]
 800cfc2:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800cfc4:	6e50      	ldr	r0, [r2, #100]	; 0x64
 800cfc6:	4625      	mov	r5, r4
 800cfc8:	fb80 e505 	smull	lr, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cfcc:	954d      	str	r5, [sp, #308]	; 0x134
 800cfce:	fb83 0404 	smull	r0, r4, r3, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cfd2:	9450      	str	r4, [sp, #320]	; 0x140
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800cfd4:	f859 3c04 	ldr.w	r3, [r9, #-4]
 800cfd8:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800cfda:	6e94      	ldr	r4, [r2, #104]	; 0x68
 800cfdc:	461a      	mov	r2, r3
 800cfde:	fb84 5202 	smull	r5, r2, r4, r2
			*xpwLo++ = MULSHIFT32(wLo, x);
 800cfe2:	924e      	str	r2, [sp, #312]	; 0x138
 800cfe4:	fb80 2303 	smull	r2, r3, r0, r3
			*xpwHi-- = MULSHIFT32(wHi, x);
 800cfe8:	934f      	str	r3, [sp, #316]	; 0x13c
		wp = imdctWin[btCurr];
 800cfea:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800cfec:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
 800cff0:	0124      	lsls	r4, r4, #4
 800cff2:	4638      	mov	r0, r7
 800cff4:	eb01 0b04 	add.w	fp, r1, r4
 800cff8:	4b9f      	ldr	r3, [pc, #636]	; (800d278 <xmp3fixpt_IMDCT+0x1054>)
 800cffa:	fb83 2000 	smull	r2, r0, r3, r0
			xe >>= 2;
 800cffe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800d000:	ea4f 0ea3 	mov.w	lr, r3, asr #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d004:	eb00 030e 	add.w	r3, r0, lr
 800d008:	f849 3c24 	str.w	r3, [r9, #-36]
 800d00c:	590b      	ldr	r3, [r1, r4]
			d = xe - xo;
 800d00e:	ebae 0000 	sub.w	r0, lr, r0
 800d012:	fb80 2303 	smull	r2, r3, r0, r3
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d016:	9946      	ldr	r1, [sp, #280]	; 0x118
 800d018:	f8db 2044 	ldr.w	r2, [fp, #68]	; 0x44
 800d01c:	440b      	add	r3, r1
 800d01e:	009b      	lsls	r3, r3, #2
 800d020:	fb80 1202 	smull	r1, r2, r0, r2
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d024:	9957      	ldr	r1, [sp, #348]	; 0x15c
			y[(i)*NBANDS]    = yLo;
 800d026:	9f02      	ldr	r7, [sp, #8]
 800d028:	4894      	ldr	r0, [pc, #592]	; (800d27c <xmp3fixpt_IMDCT+0x1058>)
 800d02a:	603b      	str	r3, [r7, #0]
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d02c:	440a      	add	r2, r1
 800d02e:	0092      	lsls	r2, r2, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d030:	17d5      	asrs	r5, r2, #31
 800d032:	17dc      	asrs	r4, r3, #31
	x ^= sign;
 800d034:	4063      	eors	r3, r4
 800d036:	ea82 0105 	eor.w	r1, r2, r5
	x -= sign;
 800d03a:	1b1b      	subs	r3, r3, r4
 800d03c:	1b49      	subs	r1, r1, r5
			y[(17-i)*NBANDS] = yHi;
 800d03e:	463c      	mov	r4, r7
 800d040:	f8c7 2880 	str.w	r2, [r7, #2176]	; 0x880
			mOut |= FASTABS(yHi);
 800d044:	4319      	orrs	r1, r3
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d046:	fb80 3606 	smull	r3, r6, r0, r6
			xe >>= 2;
 800d04a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800d04c:	109f      	asrs	r7, r3, #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d04e:	19f3      	adds	r3, r6, r7
 800d050:	f849 3c20 	str.w	r3, [r9, #-32]
 800d054:	f8db 3004 	ldr.w	r3, [fp, #4]
			d = xe - xo;
 800d058:	1bbe      	subs	r6, r7, r6
 800d05a:	461a      	mov	r2, r3
 800d05c:	fb86 3202 	smull	r3, r2, r6, r2
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d060:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 800d062:	f8db 0040 	ldr.w	r0, [fp, #64]	; 0x40
 800d066:	4413      	add	r3, r2
 800d068:	009a      	lsls	r2, r3, #2
 800d06a:	fb86 3000 	smull	r3, r0, r6, r0
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d06e:	9b56      	ldr	r3, [sp, #344]	; 0x158
			y[(i)*NBANDS]    = yLo;
 800d070:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d074:	4418      	add	r0, r3
 800d076:	0080      	lsls	r0, r0, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d078:	17d3      	asrs	r3, r2, #31
			y[(i)*NBANDS]    = yLo;
 800d07a:	4627      	mov	r7, r4
	x ^= sign;
 800d07c:	405a      	eors	r2, r3
	sign = x >> (sizeof(int) * 8 - 1);
 800d07e:	17c4      	asrs	r4, r0, #31
	x -= sign;
 800d080:	1ad3      	subs	r3, r2, r3
	x ^= sign;
 800d082:	ea80 0504 	eor.w	r5, r0, r4
			mOut |= FASTABS(yLo);
 800d086:	4319      	orrs	r1, r3
	x -= sign;
 800d088:	1b2c      	subs	r4, r5, r4
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d08a:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
			y[(17-i)*NBANDS] = yHi;
 800d08e:	f8c7 0800 	str.w	r0, [r7, #2048]	; 0x800
			mOut |= FASTABS(yHi);
 800d092:	4321      	orrs	r1, r4
 800d094:	4a7a      	ldr	r2, [pc, #488]	; (800d280 <xmp3fixpt_IMDCT+0x105c>)
 800d096:	fb82 3c0c 	smull	r3, ip, r2, ip
			xe >>= 2;
 800d09a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800d09c:	109e      	asrs	r6, r3, #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d09e:	eb0c 0306 	add.w	r3, ip, r6
 800d0a2:	f849 3c1c 	str.w	r3, [r9, #-28]
 800d0a6:	f8db 3008 	ldr.w	r3, [fp, #8]
			d = xe - xo;
 800d0aa:	eba6 060c 	sub.w	r6, r6, ip
 800d0ae:	461a      	mov	r2, r3
 800d0b0:	fb86 3202 	smull	r3, r2, r6, r2
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d0b4:	9b48      	ldr	r3, [sp, #288]	; 0x120
 800d0b6:	f8db 003c 	ldr.w	r0, [fp, #60]	; 0x3c
 800d0ba:	4413      	add	r3, r2
 800d0bc:	009b      	lsls	r3, r3, #2
 800d0be:	4602      	mov	r2, r0
 800d0c0:	fb86 0202 	smull	r0, r2, r6, r2
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d0c4:	9855      	ldr	r0, [sp, #340]	; 0x154
			y[(i)*NBANDS]    = yLo;
 800d0c6:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d0ca:	4402      	add	r2, r0
 800d0cc:	0092      	lsls	r2, r2, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d0ce:	17dd      	asrs	r5, r3, #31
 800d0d0:	17d0      	asrs	r0, r2, #31
	x ^= sign;
 800d0d2:	406b      	eors	r3, r5
	x -= sign;
 800d0d4:	1b5b      	subs	r3, r3, r5
	x ^= sign;
 800d0d6:	ea82 0500 	eor.w	r5, r2, r0
			mOut |= FASTABS(yLo);
 800d0da:	430b      	orrs	r3, r1
	x -= sign;
 800d0dc:	1a2d      	subs	r5, r5, r0
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d0de:	4c69      	ldr	r4, [pc, #420]	; (800d284 <xmp3fixpt_IMDCT+0x1060>)
 800d0e0:	990a      	ldr	r1, [sp, #40]	; 0x28
			y[(17-i)*NBANDS] = yHi;
 800d0e2:	f8c7 2780 	str.w	r2, [r7, #1920]	; 0x780
			mOut |= FASTABS(yHi);
 800d0e6:	432b      	orrs	r3, r5
 800d0e8:	fb84 2101 	smull	r2, r1, r4, r1
			xe >>= 2;
 800d0ec:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800d0ee:	ea4f 0ca2 	mov.w	ip, r2, asr #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d0f2:	eb01 020c 	add.w	r2, r1, ip
 800d0f6:	f849 2c18 	str.w	r2, [r9, #-24]
 800d0fa:	f8db 200c 	ldr.w	r2, [fp, #12]
			d = xe - xo;
 800d0fe:	ebac 0101 	sub.w	r1, ip, r1
 800d102:	4610      	mov	r0, r2
 800d104:	fb81 2000 	smull	r2, r0, r1, r0
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d108:	9a49      	ldr	r2, [sp, #292]	; 0x124
 800d10a:	f8db 4038 	ldr.w	r4, [fp, #56]	; 0x38
 800d10e:	4402      	add	r2, r0
 800d110:	0092      	lsls	r2, r2, #2
 800d112:	fb81 0404 	smull	r0, r4, r1, r4
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d116:	9954      	ldr	r1, [sp, #336]	; 0x150
			y[(i)*NBANDS]    = yLo;
 800d118:	f8c7 2180 	str.w	r2, [r7, #384]	; 0x180
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d11c:	4421      	add	r1, r4
 800d11e:	0089      	lsls	r1, r1, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d120:	17d5      	asrs	r5, r2, #31
 800d122:	17cc      	asrs	r4, r1, #31
	x ^= sign;
 800d124:	406a      	eors	r2, r5
	x -= sign;
 800d126:	1b52      	subs	r2, r2, r5
	x ^= sign;
 800d128:	ea81 0604 	eor.w	r6, r1, r4
			mOut |= FASTABS(yLo);
 800d12c:	4313      	orrs	r3, r2
	x -= sign;
 800d12e:	1b34      	subs	r4, r6, r4
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d130:	4855      	ldr	r0, [pc, #340]	; (800d288 <xmp3fixpt_IMDCT+0x1064>)
			y[(17-i)*NBANDS] = yHi;
 800d132:	f8c7 1700 	str.w	r1, [r7, #1792]	; 0x700
 800d136:	4645      	mov	r5, r8
			mOut |= FASTABS(yHi);
 800d138:	4323      	orrs	r3, r4
 800d13a:	fb80 2505 	smull	r2, r5, r0, r5
			xe >>= 2;
 800d13e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800d140:	ea4f 08a2 	mov.w	r8, r2, asr #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d144:	eb05 0208 	add.w	r2, r5, r8
 800d148:	f849 2c14 	str.w	r2, [r9, #-20]
 800d14c:	f8db 1010 	ldr.w	r1, [fp, #16]
			d = xe - xo;
 800d150:	eba8 0805 	sub.w	r8, r8, r5
 800d154:	fb88 2101 	smull	r2, r1, r8, r1
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d158:	9a4a      	ldr	r2, [sp, #296]	; 0x128
 800d15a:	f8db 5034 	ldr.w	r5, [fp, #52]	; 0x34
 800d15e:	4411      	add	r1, r2
 800d160:	0089      	lsls	r1, r1, #2
 800d162:	fb88 2505 	smull	r2, r5, r8, r5
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d166:	9a53      	ldr	r2, [sp, #332]	; 0x14c
			y[(i)*NBANDS]    = yLo;
 800d168:	f8c7 1200 	str.w	r1, [r7, #512]	; 0x200
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d16c:	4415      	add	r5, r2
 800d16e:	00ad      	lsls	r5, r5, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d170:	17c8      	asrs	r0, r1, #31
 800d172:	17ea      	asrs	r2, r5, #31
	x ^= sign;
 800d174:	4041      	eors	r1, r0
	x -= sign;
 800d176:	1a09      	subs	r1, r1, r0
	x ^= sign;
 800d178:	ea85 0002 	eor.w	r0, r5, r2
	x -= sign;
 800d17c:	1a82      	subs	r2, r0, r2
			mOut |= FASTABS(yLo);
 800d17e:	430b      	orrs	r3, r1
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d180:	4e42      	ldr	r6, [pc, #264]	; (800d28c <xmp3fixpt_IMDCT+0x1068>)
 800d182:	9804      	ldr	r0, [sp, #16]
			y[(17-i)*NBANDS] = yHi;
 800d184:	f8c7 5680 	str.w	r5, [r7, #1664]	; 0x680
			mOut |= FASTABS(yHi);
 800d188:	4313      	orrs	r3, r2
 800d18a:	fb86 2000 	smull	r2, r0, r6, r0
			xe >>= 2;
 800d18e:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800d190:	1092      	asrs	r2, r2, #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d192:	1881      	adds	r1, r0, r2
 800d194:	f849 1c10 	str.w	r1, [r9, #-16]
 800d198:	f8db 4014 	ldr.w	r4, [fp, #20]
			d = xe - xo;
 800d19c:	1a10      	subs	r0, r2, r0
 800d19e:	fb80 2404 	smull	r2, r4, r0, r4
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d1a2:	9a4b      	ldr	r2, [sp, #300]	; 0x12c
 800d1a4:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
 800d1a8:	4414      	add	r4, r2
 800d1aa:	00a4      	lsls	r4, r4, #2
 800d1ac:	460a      	mov	r2, r1
 800d1ae:	fb80 1202 	smull	r1, r2, r0, r2
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d1b2:	9852      	ldr	r0, [sp, #328]	; 0x148
			y[(i)*NBANDS]    = yLo;
 800d1b4:	f8c7 4280 	str.w	r4, [r7, #640]	; 0x280
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d1b8:	4410      	add	r0, r2
 800d1ba:	0080      	lsls	r0, r0, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d1bc:	17e2      	asrs	r2, r4, #31
 800d1be:	17c1      	asrs	r1, r0, #31
	x ^= sign;
 800d1c0:	4054      	eors	r4, r2
	x -= sign;
 800d1c2:	1aa4      	subs	r4, r4, r2
	x ^= sign;
 800d1c4:	ea80 0601 	eor.w	r6, r0, r1
			y[(17-i)*NBANDS] = yHi;
 800d1c8:	9a02      	ldr	r2, [sp, #8]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d1ca:	4d31      	ldr	r5, [pc, #196]	; (800d290 <xmp3fixpt_IMDCT+0x106c>)
 800d1cc:	9f06      	ldr	r7, [sp, #24]
 800d1ce:	f8c2 0600 	str.w	r0, [r2, #1536]	; 0x600
			mOut |= FASTABS(yLo);
 800d1d2:	4323      	orrs	r3, r4
	x -= sign;
 800d1d4:	1a76      	subs	r6, r6, r1
			mOut |= FASTABS(yHi);
 800d1d6:	4333      	orrs	r3, r6
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d1d8:	fb85 2707 	smull	r2, r7, r5, r7
			xe >>= 2;
 800d1dc:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800d1de:	1089      	asrs	r1, r1, #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d1e0:	187a      	adds	r2, r7, r1
 800d1e2:	f849 2c0c 	str.w	r2, [r9, #-12]
 800d1e6:	f8db 2018 	ldr.w	r2, [fp, #24]
			d = xe - xo;
 800d1ea:	1bcf      	subs	r7, r1, r7
 800d1ec:	4611      	mov	r1, r2
 800d1ee:	fb87 2101 	smull	r2, r1, r7, r1
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d1f2:	9a4c      	ldr	r2, [sp, #304]	; 0x130
 800d1f4:	f8db 002c 	ldr.w	r0, [fp, #44]	; 0x2c
 800d1f8:	440a      	add	r2, r1
 800d1fa:	0092      	lsls	r2, r2, #2
 800d1fc:	4601      	mov	r1, r0
 800d1fe:	fb87 0101 	smull	r0, r1, r7, r1
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d202:	9c51      	ldr	r4, [sp, #324]	; 0x144
			y[(i)*NBANDS]    = yLo;
 800d204:	9f02      	ldr	r7, [sp, #8]
 800d206:	4823      	ldr	r0, [pc, #140]	; (800d294 <xmp3fixpt_IMDCT+0x1070>)
 800d208:	f8c7 2300 	str.w	r2, [r7, #768]	; 0x300
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d20c:	4421      	add	r1, r4
 800d20e:	0089      	lsls	r1, r1, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d210:	17d5      	asrs	r5, r2, #31
 800d212:	17cc      	asrs	r4, r1, #31
	x ^= sign;
 800d214:	406a      	eors	r2, r5
	x -= sign;
 800d216:	1b52      	subs	r2, r2, r5
	x ^= sign;
 800d218:	ea81 0504 	eor.w	r5, r1, r4
			mOut |= FASTABS(yLo);
 800d21c:	4313      	orrs	r3, r2
	x -= sign;
 800d21e:	1b2c      	subs	r4, r5, r4
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d220:	9a05      	ldr	r2, [sp, #20]
			y[(17-i)*NBANDS] = yHi;
 800d222:	f8c7 1580 	str.w	r1, [r7, #1408]	; 0x580
			mOut |= FASTABS(yHi);
 800d226:	4323      	orrs	r3, r4
 800d228:	fb80 1202 	smull	r1, r2, r0, r2
			xe >>= 2;
 800d22c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800d22e:	1088      	asrs	r0, r1, #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d230:	1811      	adds	r1, r2, r0
 800d232:	f849 1c08 	str.w	r1, [r9, #-8]
 800d236:	f8db 101c 	ldr.w	r1, [fp, #28]
			d = xe - xo;
 800d23a:	1a82      	subs	r2, r0, r2
 800d23c:	4608      	mov	r0, r1
 800d23e:	fb82 1000 	smull	r1, r0, r2, r0
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d242:	994d      	ldr	r1, [sp, #308]	; 0x134
 800d244:	f8db 4028 	ldr.w	r4, [fp, #40]	; 0x28
 800d248:	4401      	add	r1, r0
 800d24a:	0089      	lsls	r1, r1, #2
 800d24c:	4620      	mov	r0, r4
 800d24e:	fb82 4000 	smull	r4, r0, r2, r0
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d252:	9a50      	ldr	r2, [sp, #320]	; 0x140
			y[(i)*NBANDS]    = yLo;
 800d254:	f8c7 1380 	str.w	r1, [r7, #896]	; 0x380
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d258:	4410      	add	r0, r2
 800d25a:	0080      	lsls	r0, r0, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d25c:	17cc      	asrs	r4, r1, #31
 800d25e:	17c2      	asrs	r2, r0, #31
	x ^= sign;
 800d260:	4061      	eors	r1, r4
	x -= sign;
 800d262:	1b09      	subs	r1, r1, r4
	x ^= sign;
 800d264:	ea80 0602 	eor.w	r6, r0, r2
			mOut |= FASTABS(yLo);
 800d268:	430b      	orrs	r3, r1
	x -= sign;
 800d26a:	1ab6      	subs	r6, r6, r2
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d26c:	4d0a      	ldr	r5, [pc, #40]	; (800d298 <xmp3fixpt_IMDCT+0x1074>)
			y[(17-i)*NBANDS] = yHi;
 800d26e:	f8c7 0500 	str.w	r0, [r7, #1280]	; 0x500
 800d272:	e013      	b.n	800d29c <xmp3fixpt_IMDCT+0x1078>
 800d274:	08017858 	.word	0x08017858
 800d278:	0b27eb5c 	.word	0x0b27eb5c
 800d27c:	2120fb83 	.word	0x2120fb83
 800d280:	36185aee 	.word	0x36185aee
 800d284:	496af3e2 	.word	0x496af3e2
 800d288:	5a82799a 	.word	0x5a82799a
 800d28c:	68d9f964 	.word	0x68d9f964
 800d290:	7401e4c1 	.word	0x7401e4c1
 800d294:	7ba3751d 	.word	0x7ba3751d
 800d298:	7f834ed0 	.word	0x7f834ed0
			mOut |= FASTABS(yHi);
 800d29c:	4333      	orrs	r3, r6
 800d29e:	fb85 2a0a 	smull	r2, sl, r5, sl
			xe >>= 2;
 800d2a2:	9a08      	ldr	r2, [sp, #32]
 800d2a4:	1092      	asrs	r2, r2, #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 800d2a6:	eb0a 0102 	add.w	r1, sl, r2
 800d2aa:	f849 1c04 	str.w	r1, [r9, #-4]
 800d2ae:	f8db 0020 	ldr.w	r0, [fp, #32]
			d = xe - xo;
 800d2b2:	eba2 0a0a 	sub.w	sl, r2, sl
 800d2b6:	fb8a 2000 	smull	r2, r0, sl, r0
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 800d2ba:	994e      	ldr	r1, [sp, #312]	; 0x138
 800d2bc:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
 800d2c0:	4401      	add	r1, r0
 800d2c2:	0089      	lsls	r1, r1, #2
 800d2c4:	fb8a 0202 	smull	r0, r2, sl, r2
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d2c8:	984f      	ldr	r0, [sp, #316]	; 0x13c
			y[(i)*NBANDS]    = yLo;
 800d2ca:	f8c7 1400 	str.w	r1, [r7, #1024]	; 0x400
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 800d2ce:	4402      	add	r2, r0
 800d2d0:	0092      	lsls	r2, r2, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d2d2:	17c8      	asrs	r0, r1, #31
 800d2d4:	17d5      	asrs	r5, r2, #31
	x ^= sign;
 800d2d6:	4041      	eors	r1, r0
	x -= sign;
 800d2d8:	1a0c      	subs	r4, r1, r0
	x ^= sign;
 800d2da:	ea82 0005 	eor.w	r0, r2, r5
	x -= sign;
 800d2de:	1b40      	subs	r0, r0, r5
			mOut |= FASTABS(yLo);
 800d2e0:	4323      	orrs	r3, r4
			y[(17-i)*NBANDS] = yHi;
 800d2e2:	f8c7 2480 	str.w	r2, [r7, #1152]	; 0x480
			mOut |= FASTABS(yHi);
 800d2e6:	ea40 0403 	orr.w	r4, r0, r3
 800d2ea:	463d      	mov	r5, r7
 800d2ec:	e4cf      	b.n	800cc8e <xmp3fixpt_IMDCT+0xa6a>
	if (btPrev == 2) {
 800d2ee:	2a02      	cmp	r2, #2
 800d2f0:	f47f ae0e 	bne.w	800cf10 <xmp3fixpt_IMDCT+0xcec>
 800d2f4:	a946      	add	r1, sp, #280	; 0x118
 800d2f6:	9817      	ldr	r0, [sp, #92]	; 0x5c
 800d2f8:	f7fe fa78 	bl	800b7ec <WinPrevious.part.0>
 800d2fc:	4912      	ldr	r1, [pc, #72]	; (800d348 <xmp3fixpt_IMDCT+0x1124>)
 800d2fe:	e674      	b.n	800cfea <xmp3fixpt_IMDCT+0xdc6>
 800d300:	9932      	ldr	r1, [sp, #200]	; 0xc8
 800d302:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 800d304:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800d308:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800d30c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 800d310:	9901      	ldr	r1, [sp, #4]
 800d312:	9328      	str	r3, [sp, #160]	; 0xa0
	for (   ; i < bc->nBlocksTotal; i++) {
 800d314:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800d316:	4618      	mov	r0, r3
 800d318:	4288      	cmp	r0, r1
 800d31a:	f340 8391 	ble.w	800da40 <xmp3fixpt_IMDCT+0x181c>
 800d31e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800d320:	f8df 8024 	ldr.w	r8, [pc, #36]	; 800d348 <xmp3fixpt_IMDCT+0x1124>
 800d324:	9129      	str	r1, [sp, #164]	; 0xa4
 800d326:	2b06      	cmp	r3, #6
		es = 7 - gb;
 800d328:	f1c3 0307 	rsb	r3, r3, #7
 800d32c:	9327      	str	r3, [sp, #156]	; 0x9c
 800d32e:	bfc8      	it	gt
 800d330:	2300      	movgt	r3, #0
 800d332:	f102 0b48 	add.w	fp, r2, #72	; 0x48
 800d336:	9325      	str	r3, [sp, #148]	; 0x94
 800d338:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 800d33a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800d33c:	f103 0924 	add.w	r9, r3, #36	; 0x24
 800d340:	eb02 0381 	add.w	r3, r2, r1, lsl #2
 800d344:	9300      	str	r3, [sp, #0]
 800d346:	e1ed      	b.n	800d724 <xmp3fixpt_IMDCT+0x1500>
 800d348:	08017858 	.word	0x08017858
		wpLo = imdctWin[btPrev] + 18;
 800d34c:	eb0a 0aca 	add.w	sl, sl, sl, lsl #3
 800d350:	eb08 1a0a 	add.w	sl, r8, sl, lsl #4
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d354:	f859 0c24 	ldr.w	r0, [r9, #-36]
 800d358:	f8da 208c 	ldr.w	r2, [sl, #140]	; 0x8c
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d35c:	f8da 1048 	ldr.w	r1, [sl, #72]	; 0x48
 800d360:	4603      	mov	r3, r0
 800d362:	fb81 4303 	smull	r4, r3, r1, r3
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d366:	9346      	str	r3, [sp, #280]	; 0x118
 800d368:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d36c:	9057      	str	r0, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d36e:	f859 0c20 	ldr.w	r0, [r9, #-32]
 800d372:	f8da 2088 	ldr.w	r2, [sl, #136]	; 0x88
 800d376:	f8da 104c 	ldr.w	r1, [sl, #76]	; 0x4c
 800d37a:	4604      	mov	r4, r0
 800d37c:	fb81 5404 	smull	r5, r4, r1, r4
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d380:	9447      	str	r4, [sp, #284]	; 0x11c
 800d382:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d386:	9056      	str	r0, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d388:	f859 0c1c 	ldr.w	r0, [r9, #-28]
 800d38c:	f8da 2084 	ldr.w	r2, [sl, #132]	; 0x84
 800d390:	f8da 1050 	ldr.w	r1, [sl, #80]	; 0x50
 800d394:	4604      	mov	r4, r0
 800d396:	fb81 5404 	smull	r5, r4, r1, r4
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d39a:	9448      	str	r4, [sp, #288]	; 0x120
 800d39c:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d3a0:	9055      	str	r0, [sp, #340]	; 0x154
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d3a2:	f859 0c18 	ldr.w	r0, [r9, #-24]
 800d3a6:	f8da 2080 	ldr.w	r2, [sl, #128]	; 0x80
 800d3aa:	f8da 1054 	ldr.w	r1, [sl, #84]	; 0x54
 800d3ae:	4604      	mov	r4, r0
 800d3b0:	fb81 5404 	smull	r5, r4, r1, r4
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d3b4:	9449      	str	r4, [sp, #292]	; 0x124
 800d3b6:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d3ba:	9054      	str	r0, [sp, #336]	; 0x150
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d3bc:	f859 0c14 	ldr.w	r0, [r9, #-20]
 800d3c0:	f8da 207c 	ldr.w	r2, [sl, #124]	; 0x7c
 800d3c4:	f8da 1058 	ldr.w	r1, [sl, #88]	; 0x58
 800d3c8:	4604      	mov	r4, r0
 800d3ca:	fb81 5404 	smull	r5, r4, r1, r4
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d3ce:	944a      	str	r4, [sp, #296]	; 0x128
 800d3d0:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d3d4:	9053      	str	r0, [sp, #332]	; 0x14c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d3d6:	f859 0c10 	ldr.w	r0, [r9, #-16]
 800d3da:	f8da 2078 	ldr.w	r2, [sl, #120]	; 0x78
 800d3de:	f8da 105c 	ldr.w	r1, [sl, #92]	; 0x5c
 800d3e2:	4604      	mov	r4, r0
 800d3e4:	fb81 5404 	smull	r5, r4, r1, r4
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d3e8:	944b      	str	r4, [sp, #300]	; 0x12c
 800d3ea:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d3ee:	9052      	str	r0, [sp, #328]	; 0x148
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d3f0:	f859 0c0c 	ldr.w	r0, [r9, #-12]
 800d3f4:	f8da 2074 	ldr.w	r2, [sl, #116]	; 0x74
 800d3f8:	f8da 1060 	ldr.w	r1, [sl, #96]	; 0x60
 800d3fc:	4604      	mov	r4, r0
 800d3fe:	fb81 5404 	smull	r5, r4, r1, r4
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d402:	944c      	str	r4, [sp, #304]	; 0x130
 800d404:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d408:	9051      	str	r0, [sp, #324]	; 0x144
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d40a:	f859 0c08 	ldr.w	r0, [r9, #-8]
 800d40e:	f8da 2070 	ldr.w	r2, [sl, #112]	; 0x70
 800d412:	f8da 1064 	ldr.w	r1, [sl, #100]	; 0x64
 800d416:	4604      	mov	r4, r0
 800d418:	fb81 5404 	smull	r5, r4, r1, r4
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d41c:	944d      	str	r4, [sp, #308]	; 0x134
 800d41e:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d422:	9050      	str	r0, [sp, #320]	; 0x140
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800d424:	f859 2c04 	ldr.w	r2, [r9, #-4]
 800d428:	f8da 006c 	ldr.w	r0, [sl, #108]	; 0x6c
 800d42c:	f8da 4068 	ldr.w	r4, [sl, #104]	; 0x68
 800d430:	4611      	mov	r1, r2
 800d432:	fb84 5101 	smull	r5, r1, r4, r1
			*xpwLo++ = MULSHIFT32(wLo, x);
 800d436:	914e      	str	r1, [sp, #312]	; 0x138
 800d438:	fb80 1202 	smull	r1, r2, r0, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 800d43c:	924f      	str	r2, [sp, #316]	; 0x13c
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 800d43e:	9a00      	ldr	r2, [sp, #0]
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d440:	f8d8 0120 	ldr.w	r0, [r8, #288]	; 0x120
		yLo = (xPrevWin[ 0+i] << 2);
 800d444:	009b      	lsls	r3, r3, #2
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 800d446:	f842 3b04 	str.w	r3, [r2], #4
 800d44a:	4616      	mov	r6, r2
		yLo = (xPrevWin[ 3+i] << 2);
 800d44c:	9a49      	ldr	r2, [sp, #292]	; 0x124
	sign = x >> (sizeof(int) * 8 - 1);
 800d44e:	17d9      	asrs	r1, r3, #31
 800d450:	0092      	lsls	r2, r2, #2
	x ^= sign;
 800d452:	404b      	eors	r3, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800d454:	ea4f 7ce2 	mov.w	ip, r2, asr #31
	x -= sign;
 800d458:	1a5b      	subs	r3, r3, r1
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 800d45a:	f8c6 217c 	str.w	r2, [r6, #380]	; 0x17c
	x ^= sign;
 800d45e:	ea82 0a0c 	eor.w	sl, r2, ip
	x -= sign;
 800d462:	931b      	str	r3, [sp, #108]	; 0x6c
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d464:	9a08      	ldr	r2, [sp, #32]
 800d466:	fb80 3202 	smull	r3, r2, r0, r2
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d46a:	9b4c      	ldr	r3, [sp, #304]	; 0x130
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 800d46c:	f8d8 112c 	ldr.w	r1, [r8, #300]	; 0x12c
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d470:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d474:	17da      	asrs	r2, r3, #31
	x ^= sign;
 800d476:	ea83 0402 	eor.w	r4, r3, r2
	x -= sign;
 800d47a:	1aa4      	subs	r4, r4, r2
 800d47c:	941c      	str	r4, [sp, #112]	; 0x70
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 800d47e:	f8c6 32fc 	str.w	r3, [r6, #764]	; 0x2fc
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d482:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 800d484:	fb81 3404 	smull	r3, r4, r1, r4
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 800d488:	9a4f      	ldr	r2, [sp, #316]	; 0x13c
 800d48a:	f8d8 3138 	ldr.w	r3, [r8, #312]	; 0x138
 800d48e:	eb04 0282 	add.w	r2, r4, r2, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d492:	17d4      	asrs	r4, r2, #31
	x ^= sign;
 800d494:	ea82 0504 	eor.w	r5, r2, r4
	x -= sign;
 800d498:	1b2d      	subs	r5, r5, r4
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 800d49a:	f8c6 247c 	str.w	r2, [r6, #1148]	; 0x47c
 800d49e:	951d      	str	r5, [sp, #116]	; 0x74
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d4a0:	9c07      	ldr	r4, [sp, #28]
 800d4a2:	fb83 2404 	smull	r2, r4, r3, r4
 800d4a6:	9d02      	ldr	r5, [sp, #8]
 800d4a8:	fb80 3505 	smull	r3, r5, r0, r5
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 800d4ac:	9b52      	ldr	r3, [sp, #328]	; 0x148
 800d4ae:	f8d8 2144 	ldr.w	r2, [r8, #324]	; 0x144
 800d4b2:	442c      	add	r4, r5
 800d4b4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d4b8:	17d8      	asrs	r0, r3, #31
	x ^= sign;
 800d4ba:	ea83 0400 	eor.w	r4, r3, r0
	x -= sign;
 800d4be:	1a20      	subs	r0, r4, r0
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 800d4c0:	f8c6 35fc 	str.w	r3, [r6, #1532]	; 0x5fc
 800d4c4:	901e      	str	r0, [sp, #120]	; 0x78
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d4c6:	9b06      	ldr	r3, [sp, #24]
 800d4c8:	fb82 0303 	smull	r0, r3, r2, r3
 800d4cc:	9805      	ldr	r0, [sp, #20]
 800d4ce:	fb81 2000 	smull	r2, r0, r1, r0
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 800d4d2:	9a55      	ldr	r2, [sp, #340]	; 0x154
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d4d4:	f8d8 7124 	ldr.w	r7, [r8, #292]	; 0x124
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 800d4d8:	4403      	add	r3, r0
 800d4da:	eb03 0382 	add.w	r3, r3, r2, lsl #2
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 800d4de:	f8c6 377c 	str.w	r3, [r6, #1916]	; 0x77c
		yLo = (xPrevWin[ 0+i] << 2);
 800d4e2:	9947      	ldr	r1, [sp, #284]	; 0x11c
 800d4e4:	0089      	lsls	r1, r1, #2
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 800d4e6:	67f1      	str	r1, [r6, #124]	; 0x7c
		yLo = (xPrevWin[ 3+i] << 2);
 800d4e8:	9a4a      	ldr	r2, [sp, #296]	; 0x128
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 800d4ea:	4634      	mov	r4, r6
	sign = x >> (sizeof(int) * 8 - 1);
 800d4ec:	17d8      	asrs	r0, r3, #31
		yLo = (xPrevWin[ 3+i] << 2);
 800d4ee:	0092      	lsls	r2, r2, #2
 800d4f0:	17d6      	asrs	r6, r2, #31
	x ^= sign;
 800d4f2:	4043      	eors	r3, r0
	x -= sign;
 800d4f4:	1a1b      	subs	r3, r3, r0
	sign = x >> (sizeof(int) * 8 - 1);
 800d4f6:	ea4f 7ee1 	mov.w	lr, r1, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 800d4fa:	f8c4 21fc 	str.w	r2, [r4, #508]	; 0x1fc
	x ^= sign;
 800d4fe:	4072      	eors	r2, r6
 800d500:	9400      	str	r4, [sp, #0]
 800d502:	9220      	str	r2, [sp, #128]	; 0x80
 800d504:	ea81 010e 	eor.w	r1, r1, lr
	x -= sign;
 800d508:	931f      	str	r3, [sp, #124]	; 0x7c
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d50a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800d50c:	fb87 3000 	smull	r3, r0, r7, r0
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d510:	9b4d      	ldr	r3, [sp, #308]	; 0x134
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 800d512:	f8d8 2130 	ldr.w	r2, [r8, #304]	; 0x130
 800d516:	920c      	str	r2, [sp, #48]	; 0x30
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d518:	eb00 0083 	add.w	r0, r0, r3, lsl #2
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 800d51c:	9a00      	ldr	r2, [sp, #0]
 800d51e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d520:	f8c2 037c 	str.w	r0, [r2, #892]	; 0x37c
	sign = x >> (sizeof(int) * 8 - 1);
 800d524:	17c4      	asrs	r4, r0, #31
	x ^= sign;
 800d526:	ea80 0504 	eor.w	r5, r0, r4
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d52a:	980c      	ldr	r0, [sp, #48]	; 0x30
	x -= sign;
 800d52c:	1b2d      	subs	r5, r5, r4
 800d52e:	9521      	str	r5, [sp, #132]	; 0x84
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d530:	4604      	mov	r4, r0
 800d532:	fb84 0303 	smull	r0, r3, r4, r3
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 800d536:	9c50      	ldr	r4, [sp, #320]	; 0x140
 800d538:	f8d8 013c 	ldr.w	r0, [r8, #316]	; 0x13c
 800d53c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d540:	17dc      	asrs	r4, r3, #31
	x ^= sign;
 800d542:	ea83 0504 	eor.w	r5, r3, r4
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 800d546:	f8c2 34fc 	str.w	r3, [r2, #1276]	; 0x4fc
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d54a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
	x -= sign;
 800d54c:	1b2c      	subs	r4, r5, r4
 800d54e:	9422      	str	r4, [sp, #136]	; 0x88
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d550:	4614      	mov	r4, r2
 800d552:	fb80 3404 	smull	r3, r4, r0, r4
 800d556:	9d04      	ldr	r5, [sp, #16]
 800d558:	fb87 3505 	smull	r3, r5, r7, r5
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 800d55c:	9853      	ldr	r0, [sp, #332]	; 0x14c
 800d55e:	f8d8 3148 	ldr.w	r3, [r8, #328]	; 0x148
 800d562:	442c      	add	r4, r5
 800d564:	eb04 0080 	add.w	r0, r4, r0, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d568:	17c4      	asrs	r4, r0, #31
	x ^= sign;
 800d56a:	ea80 0504 	eor.w	r5, r0, r4
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d56e:	4617      	mov	r7, r2
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 800d570:	9a00      	ldr	r2, [sp, #0]
	x -= sign;
 800d572:	1b2d      	subs	r5, r5, r4
 800d574:	f8c2 067c 	str.w	r0, [r2, #1660]	; 0x67c
 800d578:	951a      	str	r5, [sp, #104]	; 0x68
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d57a:	fb83 0707 	smull	r0, r7, r3, r7
 800d57e:	9c04      	ldr	r4, [sp, #16]
 800d580:	980c      	ldr	r0, [sp, #48]	; 0x30
 800d582:	fb80 3404 	smull	r3, r4, r0, r4
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 800d586:	9b56      	ldr	r3, [sp, #344]	; 0x158
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d588:	f8d8 0128 	ldr.w	r0, [r8, #296]	; 0x128
 800d58c:	9004      	str	r0, [sp, #16]
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 800d58e:	4427      	add	r7, r4
 800d590:	eb07 0783 	add.w	r7, r7, r3, lsl #2
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 800d594:	f8c2 77fc 	str.w	r7, [r2, #2044]	; 0x7fc
		yLo = (xPrevWin[ 0+i] << 2);
 800d598:	9b48      	ldr	r3, [sp, #288]	; 0x120
 800d59a:	009b      	lsls	r3, r3, #2
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 800d59c:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
		yLo = (xPrevWin[ 3+i] << 2);
 800d5a0:	984b      	ldr	r0, [sp, #300]	; 0x12c
	x -= sign;
 800d5a2:	9a20      	ldr	r2, [sp, #128]	; 0x80
 800d5a4:	0080      	lsls	r0, r0, #2
 800d5a6:	eba1 010e 	sub.w	r1, r1, lr
 800d5aa:	ebaa 0c0c 	sub.w	ip, sl, ip
	sign = x >> (sizeof(int) * 8 - 1);
 800d5ae:	17dc      	asrs	r4, r3, #31
	x -= sign;
 800d5b0:	1b92      	subs	r2, r2, r6
	sign = x >> (sizeof(int) * 8 - 1);
 800d5b2:	17c5      	asrs	r5, r0, #31
 800d5b4:	ea4c 0c01 	orr.w	ip, ip, r1
	x ^= sign;
 800d5b8:	4063      	eors	r3, r4
	sign = x >> (sizeof(int) * 8 - 1);
 800d5ba:	17f9      	asrs	r1, r7, #31
	x ^= sign;
 800d5bc:	ea80 0605 	eor.w	r6, r0, r5
 800d5c0:	ea4c 0c02 	orr.w	ip, ip, r2
	x -= sign;
 800d5c4:	1b1c      	subs	r4, r3, r4
	x ^= sign;
 800d5c6:	ea87 0301 	eor.w	r3, r7, r1
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 800d5ca:	9f00      	ldr	r7, [sp, #0]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d5cc:	f8dd e02c 	ldr.w	lr, [sp, #44]	; 0x2c
 800d5d0:	f8c7 027c 	str.w	r0, [r7, #636]	; 0x27c
 800d5d4:	ea4c 0404 	orr.w	r4, ip, r4
	x -= sign;
 800d5d8:	1b75      	subs	r5, r6, r5
 800d5da:	1a5f      	subs	r7, r3, r1
 800d5dc:	ea44 0605 	orr.w	r6, r4, r5
 800d5e0:	960a      	str	r6, [sp, #40]	; 0x28
 800d5e2:	970b      	str	r7, [sp, #44]	; 0x2c
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d5e4:	9904      	ldr	r1, [sp, #16]
 800d5e6:	fb81 3e0e 	smull	r3, lr, r1, lr
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d5ea:	9b4e      	ldr	r3, [sp, #312]	; 0x138
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 800d5ec:	9f00      	ldr	r7, [sp, #0]
 800d5ee:	9e08      	ldr	r6, [sp, #32]
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 800d5f0:	f8d8 1134 	ldr.w	r1, [r8, #308]	; 0x134
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 800d5f4:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d5f8:	17da      	asrs	r2, r3, #31
	x ^= sign;
 800d5fa:	ea83 0002 	eor.w	r0, r3, r2
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 800d5fe:	f8c7 33fc 	str.w	r3, [r7, #1020]	; 0x3fc
	x -= sign;
 800d602:	1a83      	subs	r3, r0, r2
 800d604:	9308      	str	r3, [sp, #32]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d606:	fb81 3606 	smull	r3, r6, r1, r6
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 800d60a:	9b51      	ldr	r3, [sp, #324]	; 0x144
 800d60c:	f8d8 0140 	ldr.w	r0, [r8, #320]	; 0x140
 800d610:	eb06 0683 	add.w	r6, r6, r3, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d614:	17f4      	asrs	r4, r6, #31
	x ^= sign;
 800d616:	ea86 0504 	eor.w	r5, r6, r4
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 800d61a:	f8c7 657c 	str.w	r6, [r7, #1404]	; 0x57c
	x -= sign;
 800d61e:	1b2e      	subs	r6, r5, r4
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d620:	9b06      	ldr	r3, [sp, #24]
	x -= sign;
 800d622:	9606      	str	r6, [sp, #24]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d624:	fb80 2303 	smull	r2, r3, r0, r3
 800d628:	9d05      	ldr	r5, [sp, #20]
 800d62a:	9804      	ldr	r0, [sp, #16]
 800d62c:	fb80 2505 	smull	r2, r5, r0, r5
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 800d630:	9854      	ldr	r0, [sp, #336]	; 0x150
 800d632:	f8d8 214c 	ldr.w	r2, [r8, #332]	; 0x14c
 800d636:	9c07      	ldr	r4, [sp, #28]
 800d638:	442b      	add	r3, r5
 800d63a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
	sign = x >> (sizeof(int) * 8 - 1);
 800d63e:	17c3      	asrs	r3, r0, #31
	x ^= sign;
 800d640:	ea80 0503 	eor.w	r5, r0, r3
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 800d644:	f8c7 06fc 	str.w	r0, [r7, #1788]	; 0x6fc
	x -= sign;
 800d648:	eba5 0a03 	sub.w	sl, r5, r3
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d64c:	fb82 3404 	smull	r3, r4, r2, r4
 800d650:	f8dd e008 	ldr.w	lr, [sp, #8]
 800d654:	fb81 3e0e 	smull	r3, lr, r1, lr
		*xPrev++ = xBuf[i] >> 2;
 800d658:	9816      	ldr	r0, [sp, #88]	; 0x58
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 800d65a:	9b57      	ldr	r3, [sp, #348]	; 0x15c
		*xPrev++ = xBuf[i] >> 2;
 800d65c:	9919      	ldr	r1, [sp, #100]	; 0x64
 800d65e:	1080      	asrs	r0, r0, #2
 800d660:	9002      	str	r0, [sp, #8]
		*xPrev++ = xBuf[i] >> 2;
 800d662:	980f      	ldr	r0, [sp, #60]	; 0x3c
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 800d664:	4474      	add	r4, lr
		*xPrev++ = xBuf[i] >> 2;
 800d666:	ea4f 0ca0 	mov.w	ip, r0, asr #2
 800d66a:	9810      	ldr	r0, [sp, #64]	; 0x40
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 800d66c:	eb04 0483 	add.w	r4, r4, r3, lsl #2
		*xPrev++ = xBuf[i] >> 2;
 800d670:	9b17      	ldr	r3, [sp, #92]	; 0x5c
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 800d672:	f8c7 487c 	str.w	r4, [r7, #2172]	; 0x87c
		*xPrev++ = xBuf[i] >> 2;
 800d676:	ea4f 0ea0 	mov.w	lr, r0, asr #2
 800d67a:	9811      	ldr	r0, [sp, #68]	; 0x44
		*xPrev++ = xBuf[i] >> 2;
 800d67c:	9f02      	ldr	r7, [sp, #8]
 800d67e:	f849 7c24 	str.w	r7, [r9, #-36]
 800d682:	109b      	asrs	r3, r3, #2
 800d684:	9304      	str	r3, [sp, #16]
		*xPrev++ = xBuf[i] >> 2;
 800d686:	1083      	asrs	r3, r0, #2
 800d688:	9812      	ldr	r0, [sp, #72]	; 0x48
		*xPrev++ = xBuf[i] >> 2;
 800d68a:	9f04      	ldr	r7, [sp, #16]
		*xPrev++ = xBuf[i] >> 2;
 800d68c:	9307      	str	r3, [sp, #28]
 800d68e:	1086      	asrs	r6, r0, #2
 800d690:	9813      	ldr	r0, [sp, #76]	; 0x4c
		*xPrev++ = xBuf[i] >> 2;
 800d692:	f849 7c20 	str.w	r7, [r9, #-32]
 800d696:	1089      	asrs	r1, r1, #2
 800d698:	9105      	str	r1, [sp, #20]
		*xPrev++ = xBuf[i] >> 2;
 800d69a:	1082      	asrs	r2, r0, #2
 800d69c:	9815      	ldr	r0, [sp, #84]	; 0x54
		*xPrev++ = xBuf[i] >> 2;
 800d69e:	9f05      	ldr	r7, [sp, #20]
 800d6a0:	f849 7c1c 	str.w	r7, [r9, #-28]
		*xPrev++ = xBuf[i] >> 2;
 800d6a4:	1083      	asrs	r3, r0, #2
 800d6a6:	9f07      	ldr	r7, [sp, #28]
 800d6a8:	f849 ec14 	str.w	lr, [r9, #-20]
 800d6ac:	e909 000c 	stmdb	r9, {r2, r3}
 800d6b0:	f849 7c10 	str.w	r7, [r9, #-16]
 800d6b4:	f849 6c0c 	str.w	r6, [r9, #-12]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 800d6b8:	990d      	ldr	r1, [sp, #52]	; 0x34
		*xPrev++ = xBuf[i] >> 2;
 800d6ba:	f849 cc18 	str.w	ip, [r9, #-24]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 800d6be:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800d6c0:	9a01      	ldr	r2, [sp, #4]
 800d6c2:	980e      	ldr	r0, [sp, #56]	; 0x38
 800d6c4:	f7fe f8fe 	bl	800b8c4 <FreqInvertRescale>
	sign = x >> (sizeof(int) * 8 - 1);
 800d6c8:	17e5      	asrs	r5, r4, #31
 800d6ca:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800d6cc:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800d6ce:	9921      	ldr	r1, [sp, #132]	; 0x84
 800d6d0:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
	for (   ; i < bc->nBlocksTotal; i++) {
 800d6d2:	9b01      	ldr	r3, [sp, #4]
	x ^= sign;
 800d6d4:	406c      	eors	r4, r5
	x -= sign;
 800d6d6:	1b64      	subs	r4, r4, r5
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 800d6d8:	ea46 0500 	orr.w	r5, r6, r0
 800d6dc:	4315      	orrs	r5, r2
 800d6de:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800d6e0:	981e      	ldr	r0, [sp, #120]	; 0x78
 800d6e2:	4315      	orrs	r5, r2
 800d6e4:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 800d6e6:	4315      	orrs	r5, r2
 800d6e8:	430d      	orrs	r5, r1
 800d6ea:	9922      	ldr	r1, [sp, #136]	; 0x88
 800d6ec:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 800d6ee:	430d      	orrs	r5, r1
 800d6f0:	9908      	ldr	r1, [sp, #32]
 800d6f2:	46b6      	mov	lr, r6
 800d6f4:	9e06      	ldr	r6, [sp, #24]
 800d6f6:	430d      	orrs	r5, r1
 800d6f8:	4335      	orrs	r5, r6
 800d6fa:	4305      	orrs	r5, r0
 800d6fc:	4315      	orrs	r5, r2
 800d6fe:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800d700:	4315      	orrs	r5, r2
 800d702:	433d      	orrs	r5, r7
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 800d704:	9a03      	ldr	r2, [sp, #12]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 800d706:	ea45 050a 	orr.w	r5, r5, sl
 800d70a:	432c      	orrs	r4, r5
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 800d70c:	4322      	orrs	r2, r4
 800d70e:	9203      	str	r2, [sp, #12]
	for (   ; i < bc->nBlocksTotal; i++) {
 800d710:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 800d712:	3301      	adds	r3, #1
 800d714:	429a      	cmp	r2, r3
 800d716:	9301      	str	r3, [sp, #4]
 800d718:	f10b 0b48 	add.w	fp, fp, #72	; 0x48
 800d71c:	f109 0924 	add.w	r9, r9, #36	; 0x24
 800d720:	f000 8186 	beq.w	800da30 <xmp3fixpt_IMDCT+0x180c>
 800d724:	f1a9 0324 	sub.w	r3, r9, #36	; 0x24
 800d728:	930d      	str	r3, [sp, #52]	; 0x34
		prevWinIdx = bc->prevType;
 800d72a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d72c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800d72e:	9901      	ldr	r1, [sp, #4]
 800d730:	428a      	cmp	r2, r1
 800d732:	bfc8      	it	gt
 800d734:	2300      	movgt	r3, #0
 800d736:	469a      	mov	sl, r3
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 800d738:	9b00      	ldr	r3, [sp, #0]
 800d73a:	930e      	str	r3, [sp, #56]	; 0x38
	if (gb < 7) {
 800d73c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800d73e:	2b06      	cmp	r3, #6
 800d740:	f300 8084 	bgt.w	800d84c <xmp3fixpt_IMDCT+0x1628>
			xCurr[i+0] >>= es;
 800d744:	9927      	ldr	r1, [sp, #156]	; 0x9c
 800d746:	f85b 2c48 	ldr.w	r2, [fp, #-72]
			xCurr[i+1] >>= es;
 800d74a:	f85b 3c44 	ldr.w	r3, [fp, #-68]
			xCurr[i+0] >>= es;
 800d74e:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d750:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d752:	f84b 2c48 	str.w	r2, [fp, #-72]
			xCurr[i+1] >>= es;
 800d756:	f84b 3c44 	str.w	r3, [fp, #-68]
			*xPrev++ >>= es;
 800d75a:	f859 3c24 	ldr.w	r3, [r9, #-36]
 800d75e:	410b      	asrs	r3, r1
 800d760:	f849 3c24 	str.w	r3, [r9, #-36]
			xCurr[i+0] >>= es;
 800d764:	f85b 2c40 	ldr.w	r2, [fp, #-64]
			xCurr[i+1] >>= es;
 800d768:	f85b 3c3c 	ldr.w	r3, [fp, #-60]
			xCurr[i+0] >>= es;
 800d76c:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d76e:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d770:	f84b 2c40 	str.w	r2, [fp, #-64]
			xCurr[i+1] >>= es;
 800d774:	f84b 3c3c 	str.w	r3, [fp, #-60]
			*xPrev++ >>= es;
 800d778:	f859 3c20 	ldr.w	r3, [r9, #-32]
 800d77c:	410b      	asrs	r3, r1
 800d77e:	f849 3c20 	str.w	r3, [r9, #-32]
			xCurr[i+0] >>= es;
 800d782:	f85b 2c38 	ldr.w	r2, [fp, #-56]
			xCurr[i+1] >>= es;
 800d786:	f85b 3c34 	ldr.w	r3, [fp, #-52]
			xCurr[i+0] >>= es;
 800d78a:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d78c:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d78e:	f84b 2c38 	str.w	r2, [fp, #-56]
			xCurr[i+1] >>= es;
 800d792:	f84b 3c34 	str.w	r3, [fp, #-52]
			*xPrev++ >>= es;
 800d796:	f859 3c1c 	ldr.w	r3, [r9, #-28]
 800d79a:	410b      	asrs	r3, r1
 800d79c:	f849 3c1c 	str.w	r3, [r9, #-28]
			xCurr[i+0] >>= es;
 800d7a0:	f85b 2c30 	ldr.w	r2, [fp, #-48]
			xCurr[i+1] >>= es;
 800d7a4:	f85b 3c2c 	ldr.w	r3, [fp, #-44]
			xCurr[i+0] >>= es;
 800d7a8:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d7aa:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d7ac:	f84b 2c30 	str.w	r2, [fp, #-48]
			xCurr[i+1] >>= es;
 800d7b0:	f84b 3c2c 	str.w	r3, [fp, #-44]
			*xPrev++ >>= es;
 800d7b4:	f859 3c18 	ldr.w	r3, [r9, #-24]
 800d7b8:	410b      	asrs	r3, r1
 800d7ba:	f849 3c18 	str.w	r3, [r9, #-24]
			xCurr[i+0] >>= es;
 800d7be:	f85b 2c28 	ldr.w	r2, [fp, #-40]
			xCurr[i+1] >>= es;
 800d7c2:	f85b 3c24 	ldr.w	r3, [fp, #-36]
			xCurr[i+0] >>= es;
 800d7c6:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d7c8:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d7ca:	f84b 2c28 	str.w	r2, [fp, #-40]
			xCurr[i+1] >>= es;
 800d7ce:	f84b 3c24 	str.w	r3, [fp, #-36]
			*xPrev++ >>= es;
 800d7d2:	f859 3c14 	ldr.w	r3, [r9, #-20]
 800d7d6:	410b      	asrs	r3, r1
 800d7d8:	f849 3c14 	str.w	r3, [r9, #-20]
			xCurr[i+0] >>= es;
 800d7dc:	f85b 3c20 	ldr.w	r3, [fp, #-32]
 800d7e0:	410b      	asrs	r3, r1
 800d7e2:	f84b 3c20 	str.w	r3, [fp, #-32]
			xCurr[i+1] >>= es;
 800d7e6:	f85b 3c1c 	ldr.w	r3, [fp, #-28]
 800d7ea:	410b      	asrs	r3, r1
 800d7ec:	f84b 3c1c 	str.w	r3, [fp, #-28]
			*xPrev++ >>= es;
 800d7f0:	f859 3c10 	ldr.w	r3, [r9, #-16]
 800d7f4:	410b      	asrs	r3, r1
 800d7f6:	f849 3c10 	str.w	r3, [r9, #-16]
			xCurr[i+0] >>= es;
 800d7fa:	f85b 2c18 	ldr.w	r2, [fp, #-24]
			xCurr[i+1] >>= es;
 800d7fe:	f85b 3c14 	ldr.w	r3, [fp, #-20]
			xCurr[i+0] >>= es;
 800d802:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d804:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d806:	f84b 2c18 	str.w	r2, [fp, #-24]
			xCurr[i+1] >>= es;
 800d80a:	f84b 3c14 	str.w	r3, [fp, #-20]
			*xPrev++ >>= es;
 800d80e:	f859 3c0c 	ldr.w	r3, [r9, #-12]
 800d812:	410b      	asrs	r3, r1
 800d814:	f849 3c0c 	str.w	r3, [r9, #-12]
			xCurr[i+0] >>= es;
 800d818:	f85b 2c10 	ldr.w	r2, [fp, #-16]
			xCurr[i+1] >>= es;
 800d81c:	f85b 3c0c 	ldr.w	r3, [fp, #-12]
			xCurr[i+0] >>= es;
 800d820:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d822:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d824:	f84b 2c10 	str.w	r2, [fp, #-16]
			xCurr[i+1] >>= es;
 800d828:	f84b 3c0c 	str.w	r3, [fp, #-12]
			*xPrev++ >>= es;
 800d82c:	f859 3c08 	ldr.w	r3, [r9, #-8]
 800d830:	410b      	asrs	r3, r1
 800d832:	f849 3c08 	str.w	r3, [r9, #-8]
			xCurr[i+1] >>= es;
 800d836:	e91b 000c 	ldmdb	fp, {r2, r3}
 800d83a:	410b      	asrs	r3, r1
			xCurr[i+0] >>= es;
 800d83c:	410a      	asrs	r2, r1
			xCurr[i+1] >>= es;
 800d83e:	e90b 000c 	stmdb	fp, {r2, r3}
			*xPrev++ >>= es;
 800d842:	f859 3c04 	ldr.w	r3, [r9, #-4]
 800d846:	410b      	asrs	r3, r1
 800d848:	f849 3c04 	str.w	r3, [r9, #-4]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 800d84c:	f85b 4c0c 	ldr.w	r4, [fp, #-12]
 800d850:	f85b 7c18 	ldr.w	r7, [fp, #-24]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 800d854:	f85b 2c24 	ldr.w	r2, [fp, #-36]
 800d858:	f85b 1c30 	ldr.w	r1, [fp, #-48]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 800d85c:	f85b 3c3c 	ldr.w	r3, [fp, #-60]
 800d860:	f85b 0c48 	ldr.w	r0, [fp, #-72]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800d864:	4e85      	ldr	r6, [pc, #532]	; (800da7c <xmp3fixpt_IMDCT+0x1858>)
	x4 -= x5;
 800d866:	1b3f      	subs	r7, r7, r4
	x3 -= x4;
 800d868:	1bd2      	subs	r2, r2, r7
	x2 -= x3;
 800d86a:	1a89      	subs	r1, r1, r2
	x1 -= x2;
 800d86c:	1a5b      	subs	r3, r3, r1
	x3 -= x5;
 800d86e:	1b12      	subs	r2, r2, r4
	x0 -= x1;
 800d870:	1ac0      	subs	r0, r0, r3
	x1 -= x3;
 800d872:	1a9b      	subs	r3, r3, r2
	x0 >>= 1;
 800d874:	1040      	asrs	r0, r0, #1
	x1 >>= 1;
 800d876:	105b      	asrs	r3, r3, #1
 800d878:	fb86 5101 	smull	r5, r1, r6, r1
	a0 = MULSHIFT32(c3_0, x2) << 1;
 800d87c:	0049      	lsls	r1, r1, #1
	a1 = x0 + (x4 >> 1);
 800d87e:	eb00 0c67 	add.w	ip, r0, r7, asr #1
	a2 = x0 - x4;
 800d882:	1bc7      	subs	r7, r0, r7
	x0 = a1 + a0;
 800d884:	eb01 000c 	add.w	r0, r1, ip
 800d888:	9002      	str	r0, [sp, #8]
	x4 = a1 - a0;
 800d88a:	ebac 0c01 	sub.w	ip, ip, r1
 800d88e:	fb86 1202 	smull	r1, r2, r6, r2
	a0 = MULSHIFT32(c3_0, x3) << 1;
 800d892:	0052      	lsls	r2, r2, #1
	a1 = x1 + (x5 >> 1);
 800d894:	eb03 0664 	add.w	r6, r3, r4, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 800d898:	eb02 0e06 	add.w	lr, r2, r6
 800d89c:	4d78      	ldr	r5, [pc, #480]	; (800da80 <xmp3fixpt_IMDCT+0x185c>)
 800d89e:	fb85 1e0e 	smull	r1, lr, r5, lr
	a2 = x1 - x5;
 800d8a2:	1b1b      	subs	r3, r3, r4
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 800d8a4:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800d8a8:	4c76      	ldr	r4, [pc, #472]	; (800da84 <xmp3fixpt_IMDCT+0x1860>)
 800d8aa:	fb84 1303 	smull	r1, r3, r4, r3
	x3 = MULSHIFT32(c6[1], a2) << 2;
 800d8ae:	009b      	lsls	r3, r3, #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 800d8b0:	1ab6      	subs	r6, r6, r2
	x3 = MULSHIFT32(c6[1], a2) << 2;
 800d8b2:	9304      	str	r3, [sp, #16]
 800d8b4:	4974      	ldr	r1, [pc, #464]	; (800da88 <xmp3fixpt_IMDCT+0x1864>)
 800d8b6:	fb81 2606 	smull	r2, r6, r1, r6
	x4 -= x5;
 800d8ba:	f85b 3c08 	ldr.w	r3, [fp, #-8]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 800d8be:	f85b 5c14 	ldr.w	r5, [fp, #-20]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 800d8c2:	f85b 1c20 	ldr.w	r1, [fp, #-32]
 800d8c6:	f85b 0c2c 	ldr.w	r0, [fp, #-44]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 800d8ca:	f85b 2c38 	ldr.w	r2, [fp, #-56]
 800d8ce:	f85b 4c44 	ldr.w	r4, [fp, #-68]
	x4 -= x5;
 800d8d2:	1aed      	subs	r5, r5, r3
	x3 -= x4;
 800d8d4:	1b49      	subs	r1, r1, r5
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 800d8d6:	00b6      	lsls	r6, r6, #2
	x2 -= x3;
 800d8d8:	1a40      	subs	r0, r0, r1
	x3 -= x5;
 800d8da:	1ac9      	subs	r1, r1, r3
	*out = x4 + x5;	out++;
 800d8dc:	eb0c 0306 	add.w	r3, ip, r6
 800d8e0:	9307      	str	r3, [sp, #28]
	*out = x4 - x5;	out++;
 800d8e2:	ebac 0306 	sub.w	r3, ip, r6
	*out = x0 + x1;	out++;
 800d8e6:	9e02      	ldr	r6, [sp, #8]
	*out = x4 - x5;	out++;
 800d8e8:	9308      	str	r3, [sp, #32]
	*out = x0 + x1;	out++;
 800d8ea:	eb06 030e 	add.w	r3, r6, lr
 800d8ee:	9306      	str	r3, [sp, #24]
	*out = x0 - x1;
 800d8f0:	eba6 030e 	sub.w	r3, r6, lr
	*out = x2 + x3;	out++;
 800d8f4:	9e04      	ldr	r6, [sp, #16]
	*out = x0 - x1;
 800d8f6:	930b      	str	r3, [sp, #44]	; 0x2c
	x1 -= x2;
 800d8f8:	1a12      	subs	r2, r2, r0
	*out = x2 + x3;	out++;
 800d8fa:	19bb      	adds	r3, r7, r6
	x0 -= x1;
 800d8fc:	1aa4      	subs	r4, r4, r2
	*out = x2 + x3;	out++;
 800d8fe:	931a      	str	r3, [sp, #104]	; 0x68
	x1 -= x3;
 800d900:	1a52      	subs	r2, r2, r1
	*out = x2 - x3;	out++;
 800d902:	1bbb      	subs	r3, r7, r6
	x0 >>= 1;
 800d904:	1064      	asrs	r4, r4, #1
	x1 >>= 1;
 800d906:	1052      	asrs	r2, r2, #1
	*out = x2 - x3;	out++;
 800d908:	930a      	str	r3, [sp, #40]	; 0x28
 800d90a:	4e5c      	ldr	r6, [pc, #368]	; (800da7c <xmp3fixpt_IMDCT+0x1858>)
 800d90c:	fb86 3000 	smull	r3, r0, r6, r0
	a0 = MULSHIFT32(c3_0, x2) << 1;
 800d910:	0040      	lsls	r0, r0, #1
	a1 = x0 + (x4 >> 1);
 800d912:	eb04 0c65 	add.w	ip, r4, r5, asr #1
	a2 = x0 - x4;
 800d916:	1b64      	subs	r4, r4, r5
	x0 = a1 + a0;
 800d918:	eb00 050c 	add.w	r5, r0, ip
	x4 = a1 - a0;
 800d91c:	ebac 0c00 	sub.w	ip, ip, r0
 800d920:	fb86 3101 	smull	r3, r1, r6, r1
	a1 = x1 + (x5 >> 1);
 800d924:	f85b 3c08 	ldr.w	r3, [fp, #-8]
 800d928:	4e55      	ldr	r6, [pc, #340]	; (800da80 <xmp3fixpt_IMDCT+0x185c>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 800d92a:	0049      	lsls	r1, r1, #1
	a1 = x1 + (x5 >> 1);
 800d92c:	eb02 0e63 	add.w	lr, r2, r3, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 800d930:	eb01 030e 	add.w	r3, r1, lr
 800d934:	4618      	mov	r0, r3
 800d936:	fb86 3000 	smull	r3, r0, r6, r0
	a2 = x1 - x5;
 800d93a:	f85b 3c08 	ldr.w	r3, [fp, #-8]
 800d93e:	1ad2      	subs	r2, r2, r3
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 800d940:	0083      	lsls	r3, r0, #2
 800d942:	9304      	str	r3, [sp, #16]
 800d944:	484f      	ldr	r0, [pc, #316]	; (800da84 <xmp3fixpt_IMDCT+0x1860>)
 800d946:	fb80 3202 	smull	r3, r2, r0, r2
	x3 = MULSHIFT32(c6[1], a2) << 2;
 800d94a:	0090      	lsls	r0, r2, #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 800d94c:	ebae 0e01 	sub.w	lr, lr, r1
 800d950:	4a4d      	ldr	r2, [pc, #308]	; (800da88 <xmp3fixpt_IMDCT+0x1864>)
 800d952:	fb82 3e0e 	smull	r3, lr, r2, lr
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 800d956:	f85b 7c10 	ldr.w	r7, [fp, #-16]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 800d95a:	f85b 3c28 	ldr.w	r3, [fp, #-40]
	x4 -= x5;
 800d95e:	f85b 2c04 	ldr.w	r2, [fp, #-4]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 800d962:	9302      	str	r3, [sp, #8]
 800d964:	f85b 1c1c 	ldr.w	r1, [fp, #-28]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 800d968:	f85b 3c34 	ldr.w	r3, [fp, #-52]
 800d96c:	f85b 6c40 	ldr.w	r6, [fp, #-64]
	x4 -= x5;
 800d970:	1aba      	subs	r2, r7, r2
	x2 -= x3;
 800d972:	9f02      	ldr	r7, [sp, #8]
	x3 -= x4;
 800d974:	920c      	str	r2, [sp, #48]	; 0x30
 800d976:	1a89      	subs	r1, r1, r2
	x2 -= x3;
 800d978:	1a7a      	subs	r2, r7, r1
	x3 -= x5;
 800d97a:	f85b 7c04 	ldr.w	r7, [fp, #-4]
	x1 -= x2;
 800d97e:	1a9b      	subs	r3, r3, r2
	x3 -= x5;
 800d980:	1bc9      	subs	r1, r1, r7
	x0 -= x1;
 800d982:	1af6      	subs	r6, r6, r3
	x1 -= x3;
 800d984:	1a5b      	subs	r3, r3, r1
	x1 >>= 1;
 800d986:	105f      	asrs	r7, r3, #1
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 800d988:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
	x1 >>= 1;
 800d98c:	970f      	str	r7, [sp, #60]	; 0x3c
	*out = x0 + x1;	out++;
 800d98e:	9f04      	ldr	r7, [sp, #16]
	*out = x4 + x5;	out++;
 800d990:	eb0c 030e 	add.w	r3, ip, lr
 800d994:	9319      	str	r3, [sp, #100]	; 0x64
	*out = x0 + x1;	out++;
 800d996:	19eb      	adds	r3, r5, r7
 800d998:	9316      	str	r3, [sp, #88]	; 0x58
	*out = x0 - x1;
 800d99a:	1beb      	subs	r3, r5, r7
 800d99c:	9305      	str	r3, [sp, #20]
	*out = x2 + x3;	out++;
 800d99e:	1823      	adds	r3, r4, r0
	*out = x4 - x5;	out++;
 800d9a0:	ebac 0e0e 	sub.w	lr, ip, lr
	*out = x2 + x3;	out++;
 800d9a4:	9317      	str	r3, [sp, #92]	; 0x5c
	*out = x2 - x3;	out++;
 800d9a6:	1a23      	subs	r3, r4, r0
 800d9a8:	9304      	str	r3, [sp, #16]
	x0 >>= 1;
 800d9aa:	1076      	asrs	r6, r6, #1
	*out = x4 - x5;	out++;
 800d9ac:	f8cd e008 	str.w	lr, [sp, #8]
 800d9b0:	4b32      	ldr	r3, [pc, #200]	; (800da7c <xmp3fixpt_IMDCT+0x1858>)
 800d9b2:	fb83 0202 	smull	r0, r2, r3, r2
	a1 = x0 + (x4 >> 1);
 800d9b6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	a0 = MULSHIFT32(c3_0, x2) << 1;
 800d9b8:	0052      	lsls	r2, r2, #1
	a1 = x0 + (x4 >> 1);
 800d9ba:	eb06 0063 	add.w	r0, r6, r3, asr #1
	x0 = a1 + a0;
 800d9be:	1815      	adds	r5, r2, r0
	a2 = x0 - x4;
 800d9c0:	1af6      	subs	r6, r6, r3
	x4 = a1 - a0;
 800d9c2:	eba0 0e02 	sub.w	lr, r0, r2
 800d9c6:	4b2d      	ldr	r3, [pc, #180]	; (800da7c <xmp3fixpt_IMDCT+0x1858>)
 800d9c8:	fb83 0101 	smull	r0, r1, r3, r1
	a1 = x1 + (x5 >> 1);
 800d9cc:	f85b 3c04 	ldr.w	r3, [fp, #-4]
 800d9d0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
	a0 = MULSHIFT32(c3_0, x3) << 1;
 800d9d2:	0049      	lsls	r1, r1, #1
	a1 = x1 + (x5 >> 1);
 800d9d4:	eb02 0063 	add.w	r0, r2, r3, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 800d9d8:	180c      	adds	r4, r1, r0
 800d9da:	4b29      	ldr	r3, [pc, #164]	; (800da80 <xmp3fixpt_IMDCT+0x185c>)
 800d9dc:	fb83 7404 	smull	r7, r4, r3, r4
	a2 = x1 - x5;
 800d9e0:	f85b 3c04 	ldr.w	r3, [fp, #-4]
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 800d9e4:	00a4      	lsls	r4, r4, #2
	a2 = x1 - x5;
 800d9e6:	1ad3      	subs	r3, r2, r3
 800d9e8:	4a26      	ldr	r2, [pc, #152]	; (800da84 <xmp3fixpt_IMDCT+0x1860>)
 800d9ea:	fb82 7303 	smull	r7, r3, r2, r3
 800d9ee:	4a26      	ldr	r2, [pc, #152]	; (800da88 <xmp3fixpt_IMDCT+0x1864>)
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 800d9f0:	1a41      	subs	r1, r0, r1
	x3 = MULSHIFT32(c6[1], a2) << 2;
 800d9f2:	009b      	lsls	r3, r3, #2
 800d9f4:	fb82 0101 	smull	r0, r1, r2, r1
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 800d9f8:	0089      	lsls	r1, r1, #2
	*out = x4 + x5;	out++;
 800d9fa:	eb0e 0201 	add.w	r2, lr, r1
 800d9fe:	9211      	str	r2, [sp, #68]	; 0x44
	*out = x4 - x5;	out++;
 800da00:	ebae 0201 	sub.w	r2, lr, r1
 800da04:	9212      	str	r2, [sp, #72]	; 0x48
	*out = x0 + x1;	out++;
 800da06:	192a      	adds	r2, r5, r4
 800da08:	920f      	str	r2, [sp, #60]	; 0x3c
	*out = x0 - x1;
 800da0a:	1b2a      	subs	r2, r5, r4
 800da0c:	9215      	str	r2, [sp, #84]	; 0x54
	if (btPrev == 2) {
 800da0e:	f1ba 0f02 	cmp.w	sl, #2
	*out = x2 + x3;	out++;
 800da12:	eb06 0203 	add.w	r2, r6, r3
	*out = x2 - x3;	out++;
 800da16:	eba6 0303 	sub.w	r3, r6, r3
	*out = x2 + x3;	out++;
 800da1a:	9210      	str	r2, [sp, #64]	; 0x40
	*out = x2 - x3;	out++;
 800da1c:	9313      	str	r3, [sp, #76]	; 0x4c
	if (btPrev == 2) {
 800da1e:	f47f ac95 	bne.w	800d34c <xmp3fixpt_IMDCT+0x1128>
 800da22:	4652      	mov	r2, sl
 800da24:	a946      	add	r1, sp, #280	; 0x118
 800da26:	980d      	ldr	r0, [sp, #52]	; 0x34
 800da28:	f7fd fee0 	bl	800b7ec <WinPrevious.part.0>
 800da2c:	9b46      	ldr	r3, [sp, #280]	; 0x118
 800da2e:	e506      	b.n	800d43e <xmp3fixpt_IMDCT+0x121a>
 800da30:	9a29      	ldr	r2, [sp, #164]	; 0xa4
 800da32:	1a9b      	subs	r3, r3, r2
 800da34:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800da36:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800da3a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800da3e:	9328      	str	r3, [sp, #160]	; 0xa0
	for (   ; i < bc->nBlocksPrev; i++) {
 800da40:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800da42:	9801      	ldr	r0, [sp, #4]
 800da44:	461a      	mov	r2, r3
 800da46:	4282      	cmp	r2, r0
 800da48:	f340 8224 	ble.w	800de94 <xmp3fixpt_IMDCT+0x1c70>
 800da4c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800da4e:	f8df 803c 	ldr.w	r8, [pc, #60]	; 800da8c <xmp3fixpt_IMDCT+0x1868>
 800da52:	9928      	ldr	r1, [sp, #160]	; 0xa0
		if (i < bc->prevWinSwitch)
 800da54:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
 800da58:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 800da5c:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
	for (   ; i < bc->nBlocksPrev; i++) {
 800da5e:	9000      	str	r0, [sp, #0]
 800da60:	eb08 1202 	add.w	r2, r8, r2, lsl #4
 800da64:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800da68:	9211      	str	r2, [sp, #68]	; 0x44
 800da6a:	f1a3 0b04 	sub.w	fp, r3, #4
 800da6e:	07c2      	lsls	r2, r0, #31
 800da70:	9205      	str	r2, [sp, #20]
 800da72:	f101 0a24 	add.w	sl, r1, #36	; 0x24
 800da76:	46d8      	mov	r8, fp
 800da78:	4602      	mov	r2, r0
 800da7a:	e1a5      	b.n	800ddc8 <xmp3fixpt_IMDCT+0x1ba4>
 800da7c:	6ed9eba1 	.word	0x6ed9eba1
 800da80:	7ba3751d 	.word	0x7ba3751d
 800da84:	5a82799a 	.word	0x5a82799a
 800da88:	2120fb83 	.word	0x2120fb83
 800da8c:	08017858 	.word	0x08017858
	if (btPrev == 2) {
 800da90:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800da92:	2b02      	cmp	r3, #2
 800da94:	f000 81a0 	beq.w	800ddd8 <xmp3fixpt_IMDCT+0x1bb4>
 800da98:	9b11      	ldr	r3, [sp, #68]	; 0x44
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800da9a:	f85a 4c24 	ldr.w	r4, [sl, #-36]
 800da9e:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800daa2:	6c98      	ldr	r0, [r3, #72]	; 0x48
 800daa4:	4621      	mov	r1, r4
 800daa6:	fb80 5101 	smull	r5, r1, r0, r1
			*xpwLo++ = MULSHIFT32(wLo, x);
 800daaa:	9146      	str	r1, [sp, #280]	; 0x118
 800daac:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 800dab0:	9457      	str	r4, [sp, #348]	; 0x15c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800dab2:	f85a 5c20 	ldr.w	r5, [sl, #-32]
 800dab6:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
 800daba:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 800dabc:	462a      	mov	r2, r5
 800dabe:	fb84 6202 	smull	r6, r2, r4, r2
			*xpwLo++ = MULSHIFT32(wLo, x);
 800dac2:	9247      	str	r2, [sp, #284]	; 0x11c
 800dac4:	fb80 4505 	smull	r4, r5, r0, r5
			*xpwHi-- = MULSHIFT32(wHi, x);
 800dac8:	9556      	str	r5, [sp, #344]	; 0x158
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800daca:	f85a 5c1c 	ldr.w	r5, [sl, #-28]
 800dace:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
 800dad2:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800dad4:	462e      	mov	r6, r5
 800dad6:	fb84 7606 	smull	r7, r6, r4, r6
			*xpwLo++ = MULSHIFT32(wLo, x);
 800dada:	9648      	str	r6, [sp, #288]	; 0x120
 800dadc:	fb80 4505 	smull	r4, r5, r0, r5
			*xpwHi-- = MULSHIFT32(wHi, x);
 800dae0:	9555      	str	r5, [sp, #340]	; 0x154
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800dae2:	f85a 5c18 	ldr.w	r5, [sl, #-24]
 800dae6:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 800daea:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800daec:	462e      	mov	r6, r5
 800daee:	fb84 7606 	smull	r7, r6, r4, r6
			*xpwLo++ = MULSHIFT32(wLo, x);
 800daf2:	9649      	str	r6, [sp, #292]	; 0x124
 800daf4:	fb80 4505 	smull	r4, r5, r0, r5
			*xpwHi-- = MULSHIFT32(wHi, x);
 800daf8:	9554      	str	r5, [sp, #336]	; 0x150
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800dafa:	f85a 5c14 	ldr.w	r5, [sl, #-20]
 800dafe:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
 800db00:	6d9c      	ldr	r4, [r3, #88]	; 0x58
 800db02:	462e      	mov	r6, r5
 800db04:	fb84 7606 	smull	r7, r6, r4, r6
			*xpwLo++ = MULSHIFT32(wLo, x);
 800db08:	964a      	str	r6, [sp, #296]	; 0x128
 800db0a:	fb80 4505 	smull	r4, r5, r0, r5
			*xpwHi-- = MULSHIFT32(wHi, x);
 800db0e:	9553      	str	r5, [sp, #332]	; 0x14c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800db10:	f85a 5c10 	ldr.w	r5, [sl, #-16]
 800db14:	6f98      	ldr	r0, [r3, #120]	; 0x78
 800db16:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
 800db18:	462e      	mov	r6, r5
 800db1a:	fb84 7606 	smull	r7, r6, r4, r6
			*xpwLo++ = MULSHIFT32(wLo, x);
 800db1e:	964b      	str	r6, [sp, #300]	; 0x12c
 800db20:	fb80 4505 	smull	r4, r5, r0, r5
			*xpwHi-- = MULSHIFT32(wHi, x);
 800db24:	9552      	str	r5, [sp, #328]	; 0x148
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800db26:	f85a 5c0c 	ldr.w	r5, [sl, #-12]
 800db2a:	6f58      	ldr	r0, [r3, #116]	; 0x74
 800db2c:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 800db2e:	462e      	mov	r6, r5
 800db30:	fb84 7606 	smull	r7, r6, r4, r6
			*xpwLo++ = MULSHIFT32(wLo, x);
 800db34:	964c      	str	r6, [sp, #304]	; 0x130
 800db36:	fb80 4505 	smull	r4, r5, r0, r5
			*xpwHi-- = MULSHIFT32(wHi, x);
 800db3a:	9551      	str	r5, [sp, #324]	; 0x144
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800db3c:	f85a 5c08 	ldr.w	r5, [sl, #-8]
 800db40:	6f18      	ldr	r0, [r3, #112]	; 0x70
 800db42:	6e5c      	ldr	r4, [r3, #100]	; 0x64
 800db44:	462e      	mov	r6, r5
 800db46:	fb84 7606 	smull	r7, r6, r4, r6
			*xpwLo++ = MULSHIFT32(wLo, x);
 800db4a:	964d      	str	r6, [sp, #308]	; 0x134
 800db4c:	fb80 4505 	smull	r4, r5, r0, r5
			*xpwHi-- = MULSHIFT32(wHi, x);
 800db50:	9550      	str	r5, [sp, #320]	; 0x140
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 800db52:	f85a 0c04 	ldr.w	r0, [sl, #-4]
 800db56:	6edc      	ldr	r4, [r3, #108]	; 0x6c
 800db58:	6e9d      	ldr	r5, [r3, #104]	; 0x68
 800db5a:	4603      	mov	r3, r0
 800db5c:	fb85 6303 	smull	r6, r3, r5, r3
			*xpwLo++ = MULSHIFT32(wLo, x);
 800db60:	934e      	str	r3, [sp, #312]	; 0x138
 800db62:	fb84 3000 	smull	r3, r0, r4, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 800db66:	904f      	str	r0, [sp, #316]	; 0x13c
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800db68:	008b      	lsls	r3, r1, #2
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800db6a:	9905      	ldr	r1, [sp, #20]
			y[2*j+0][i] = xp;
 800db6c:	f848 3f04 	str.w	r3, [r8, #4]!
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800db70:	17c9      	asrs	r1, r1, #31
 800db72:	460d      	mov	r5, r1
 800db74:	ea81 0282 	eor.w	r2, r1, r2, lsl #2
 800db78:	9900      	ldr	r1, [sp, #0]
			y[2*j+0][i] = xp;
 800db7a:	930a      	str	r3, [sp, #40]	; 0x28
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800db7c:	f001 0401 	and.w	r4, r1, #1
			xPrev[j] = 0;
 800db80:	f04f 0e00 	mov.w	lr, #0
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800db84:	1911      	adds	r1, r2, r4
			y[2*j+1][i] = xp;
 800db86:	f8c8 1080 	str.w	r1, [r8, #128]	; 0x80
			xPrev[j] = 0;
 800db8a:	f84a ec24 	str.w	lr, [sl, #-36]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800db8e:	9b48      	ldr	r3, [sp, #288]	; 0x120
			y[2*j+1][i] = xp;
 800db90:	910b      	str	r1, [sp, #44]	; 0x2c
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800db92:	009b      	lsls	r3, r3, #2
			y[2*j+0][i] = xp;
 800db94:	f8c8 3100 	str.w	r3, [r8, #256]	; 0x100
			xp = xPrevWin[2*j+1] << 2;
 800db98:	9e49      	ldr	r6, [sp, #292]	; 0x124
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800db9a:	ea85 0686 	eor.w	r6, r5, r6, lsl #2
 800db9e:	19a0      	adds	r0, r4, r6
			y[2*j+1][i] = xp;
 800dba0:	f8c8 0180 	str.w	r0, [r8, #384]	; 0x180
			xPrev[j] = 0;
 800dba4:	f84a ec20 	str.w	lr, [sl, #-32]
			y[2*j+1][i] = xp;
 800dba8:	900c      	str	r0, [sp, #48]	; 0x30
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dbaa:	984a      	ldr	r0, [sp, #296]	; 0x128
 800dbac:	0080      	lsls	r0, r0, #2
			y[2*j+0][i] = xp;
 800dbae:	f8c8 0200 	str.w	r0, [r8, #512]	; 0x200
			xp = xPrevWin[2*j+1] << 2;
 800dbb2:	9e4b      	ldr	r6, [sp, #300]	; 0x12c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dbb4:	ea85 0686 	eor.w	r6, r5, r6, lsl #2
 800dbb8:	19a6      	adds	r6, r4, r6
			y[2*j+1][i] = xp;
 800dbba:	f8c8 6280 	str.w	r6, [r8, #640]	; 0x280
			xPrev[j] = 0;
 800dbbe:	f84a ec1c 	str.w	lr, [sl, #-28]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dbc2:	994c      	ldr	r1, [sp, #304]	; 0x130
			y[2*j+1][i] = xp;
 800dbc4:	960d      	str	r6, [sp, #52]	; 0x34
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dbc6:	0089      	lsls	r1, r1, #2
			y[2*j+0][i] = xp;
 800dbc8:	f8c8 1300 	str.w	r1, [r8, #768]	; 0x300
			xp = xPrevWin[2*j+1] << 2;
 800dbcc:	9a4d      	ldr	r2, [sp, #308]	; 0x134
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dbce:	ea85 0682 	eor.w	r6, r5, r2, lsl #2
 800dbd2:	19a7      	adds	r7, r4, r6
			y[2*j+1][i] = xp;
 800dbd4:	f8c8 7380 	str.w	r7, [r8, #896]	; 0x380
			xPrev[j] = 0;
 800dbd8:	f84a ec18 	str.w	lr, [sl, #-24]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dbdc:	9a4e      	ldr	r2, [sp, #312]	; 0x138
			y[2*j+1][i] = xp;
 800dbde:	970e      	str	r7, [sp, #56]	; 0x38
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dbe0:	0092      	lsls	r2, r2, #2
			y[2*j+0][i] = xp;
 800dbe2:	f8c8 2400 	str.w	r2, [r8, #1024]	; 0x400
			xp = xPrevWin[2*j+1] << 2;
 800dbe6:	9e4f      	ldr	r6, [sp, #316]	; 0x13c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dbe8:	ea85 0686 	eor.w	r6, r5, r6, lsl #2
 800dbec:	19a6      	adds	r6, r4, r6
			y[2*j+1][i] = xp;
 800dbee:	f8c8 6480 	str.w	r6, [r8, #1152]	; 0x480
			xPrev[j] = 0;
 800dbf2:	f84a ec14 	str.w	lr, [sl, #-20]
			y[2*j+1][i] = xp;
 800dbf6:	960f      	str	r6, [sp, #60]	; 0x3c
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dbf8:	9e50      	ldr	r6, [sp, #320]	; 0x140
 800dbfa:	ea4f 0c86 	mov.w	ip, r6, lsl #2
			y[2*j+0][i] = xp;
 800dbfe:	f8c8 c500 	str.w	ip, [r8, #1280]	; 0x500
			xp = xPrevWin[2*j+1] << 2;
 800dc02:	9f51      	ldr	r7, [sp, #324]	; 0x144
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dc04:	9502      	str	r5, [sp, #8]
 800dc06:	ea85 0787 	eor.w	r7, r5, r7, lsl #2
 800dc0a:	19e7      	adds	r7, r4, r7
			y[2*j+1][i] = xp;
 800dc0c:	f8c8 7580 	str.w	r7, [r8, #1408]	; 0x580
			xPrev[j] = 0;
 800dc10:	f84a ec10 	str.w	lr, [sl, #-16]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dc14:	9e52      	ldr	r6, [sp, #328]	; 0x148
			y[2*j+1][i] = xp;
 800dc16:	9706      	str	r7, [sp, #24]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dc18:	00b6      	lsls	r6, r6, #2
			y[2*j+0][i] = xp;
 800dc1a:	f8c8 6600 	str.w	r6, [r8, #1536]	; 0x600
			xp = xPrevWin[2*j+1] << 2;
 800dc1e:	9f53      	ldr	r7, [sp, #332]	; 0x14c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dc20:	9d02      	ldr	r5, [sp, #8]
			y[2*j+0][i] = xp;
 800dc22:	9604      	str	r6, [sp, #16]
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dc24:	ea85 0787 	eor.w	r7, r5, r7, lsl #2
 800dc28:	19e6      	adds	r6, r4, r7
			y[2*j+1][i] = xp;
 800dc2a:	f8c8 6680 	str.w	r6, [r8, #1664]	; 0x680
			xPrev[j] = 0;
 800dc2e:	f84a ec0c 	str.w	lr, [sl, #-12]
			y[2*j+1][i] = xp;
 800dc32:	9607      	str	r6, [sp, #28]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dc34:	9e54      	ldr	r6, [sp, #336]	; 0x150
 800dc36:	00b6      	lsls	r6, r6, #2
			y[2*j+0][i] = xp;
 800dc38:	f8c8 6700 	str.w	r6, [r8, #1792]	; 0x700
			xp = xPrevWin[2*j+1] << 2;
 800dc3c:	9f55      	ldr	r7, [sp, #340]	; 0x154
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dc3e:	ea85 0787 	eor.w	r7, r5, r7, lsl #2
 800dc42:	19e7      	adds	r7, r4, r7
	sign = x >> (sizeof(int) * 8 - 1);
 800dc44:	ea4f 79e3 	mov.w	r9, r3, asr #31
 800dc48:	463d      	mov	r5, r7
 800dc4a:	ea4f 7be0 	mov.w	fp, r0, asr #31
			nonZero |= xp;
 800dc4e:	ea43 0700 	orr.w	r7, r3, r0
	x ^= sign;
 800dc52:	ea83 0309 	eor.w	r3, r3, r9
	x -= sign;
 800dc56:	eba3 0309 	sub.w	r3, r3, r9
	x ^= sign;
 800dc5a:	ea80 000b 	eor.w	r0, r0, fp
	sign = x >> (sizeof(int) * 8 - 1);
 800dc5e:	ea4f 79e1 	mov.w	r9, r1, asr #31
			y[2*j+1][i] = xp;
 800dc62:	f8c8 5780 	str.w	r5, [r8, #1920]	; 0x780
 800dc66:	9508      	str	r5, [sp, #32]
	x -= sign;
 800dc68:	eba0 000b 	sub.w	r0, r0, fp
	sign = x >> (sizeof(int) * 8 - 1);
 800dc6c:	9d04      	ldr	r5, [sp, #16]
			xPrev[j] = 0;
 800dc6e:	f84a ec08 	str.w	lr, [sl, #-8]
			nonZero |= xp;
 800dc72:	430f      	orrs	r7, r1
 800dc74:	ea4f 7be2 	mov.w	fp, r2, asr #31
	x ^= sign;
 800dc78:	ea81 0109 	eor.w	r1, r1, r9
	x -= sign;
 800dc7c:	eba1 0109 	sub.w	r1, r1, r9
			mOut |= FASTABS(xp);
 800dc80:	4318      	orrs	r0, r3
	sign = x >> (sizeof(int) * 8 - 1);
 800dc82:	ea4f 79ec 	mov.w	r9, ip, asr #31
			nonZero |= xp;
 800dc86:	4317      	orrs	r7, r2
	x ^= sign;
 800dc88:	ea82 020b 	eor.w	r2, r2, fp
	x -= sign;
 800dc8c:	eba2 0b0b 	sub.w	fp, r2, fp
	x ^= sign;
 800dc90:	ea8c 0309 	eor.w	r3, ip, r9
	sign = x >> (sizeof(int) * 8 - 1);
 800dc94:	17ea      	asrs	r2, r5, #31
			mOut |= FASTABS(xp);
 800dc96:	4308      	orrs	r0, r1
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dc98:	9956      	ldr	r1, [sp, #344]	; 0x158
	x -= sign;
 800dc9a:	eba3 0309 	sub.w	r3, r3, r9
			mOut |= FASTABS(xp);
 800dc9e:	ea40 000b 	orr.w	r0, r0, fp
	x ^= sign;
 800dca2:	ea85 0902 	eor.w	r9, r5, r2
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 800dca6:	0089      	lsls	r1, r1, #2
			mOut |= FASTABS(xp);
 800dca8:	4318      	orrs	r0, r3
			nonZero |= xp;
 800dcaa:	ea47 070c 	orr.w	r7, r7, ip
	x -= sign;
 800dcae:	eba9 0902 	sub.w	r9, r9, r2
	sign = x >> (sizeof(int) * 8 - 1);
 800dcb2:	ea4f 7ce6 	mov.w	ip, r6, asr #31
 800dcb6:	432f      	orrs	r7, r5
	x ^= sign;
 800dcb8:	ea86 020c 	eor.w	r2, r6, ip
	sign = x >> (sizeof(int) * 8 - 1);
 800dcbc:	9d0d      	ldr	r5, [sp, #52]	; 0x34
			y[2*j+0][i] = xp;
 800dcbe:	f8c8 1800 	str.w	r1, [r8, #2048]	; 0x800
 800dcc2:	ea4f 7be1 	mov.w	fp, r1, asr #31
			mOut |= FASTABS(xp);
 800dcc6:	ea40 0909 	orr.w	r9, r0, r9
 800dcca:	980c      	ldr	r0, [sp, #48]	; 0x30
	x -= sign;
 800dccc:	eba2 0c0c 	sub.w	ip, r2, ip
			nonZero |= xp;
 800dcd0:	433e      	orrs	r6, r7
	x ^= sign;
 800dcd2:	ea81 020b 	eor.w	r2, r1, fp
	x -= sign;
 800dcd6:	eba2 0b0b 	sub.w	fp, r2, fp
	sign = x >> (sizeof(int) * 8 - 1);
 800dcda:	17ef      	asrs	r7, r5, #31
	x ^= sign;
 800dcdc:	4602      	mov	r2, r0
 800dcde:	430e      	orrs	r6, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800dce0:	17c3      	asrs	r3, r0, #31
	x ^= sign;
 800dce2:	ea85 0107 	eor.w	r1, r5, r7
 800dce6:	4316      	orrs	r6, r2
 800dce8:	462a      	mov	r2, r5
	sign = x >> (sizeof(int) * 8 - 1);
 800dcea:	9d0e      	ldr	r5, [sp, #56]	; 0x38
			mOut |= FASTABS(xp);
 800dcec:	ea49 090c 	orr.w	r9, r9, ip
	x ^= sign;
 800dcf0:	4058      	eors	r0, r3
	x -= sign;
 800dcf2:	1ac3      	subs	r3, r0, r3
	sign = x >> (sizeof(int) * 8 - 1);
 800dcf4:	ea4f 7ce5 	mov.w	ip, r5, asr #31
 800dcf8:	ea49 090b 	orr.w	r9, r9, fp
	x -= sign;
 800dcfc:	1bcf      	subs	r7, r1, r7
			nonZero |= xp;
 800dcfe:	4316      	orrs	r6, r2
	x ^= sign;
 800dd00:	4629      	mov	r1, r5
			mOut |= FASTABS(xp);
 800dd02:	ea49 0903 	orr.w	r9, r9, r3
 800dd06:	ea85 030c 	eor.w	r3, r5, ip
	sign = x >> (sizeof(int) * 8 - 1);
 800dd0a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
			xp = xPrevWin[2*j+1] << 2;
 800dd0c:	9a57      	ldr	r2, [sp, #348]	; 0x15c
			nonZero |= xp;
 800dd0e:	430e      	orrs	r6, r1
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dd10:	9902      	ldr	r1, [sp, #8]
 800dd12:	17e8      	asrs	r0, r5, #31
			mOut |= FASTABS(xp);
 800dd14:	ea49 0907 	orr.w	r9, r9, r7
 800dd18:	9f06      	ldr	r7, [sp, #24]
	x ^= sign;
 800dd1a:	ea85 0b00 	eor.w	fp, r5, r0
			nonZero |= xp;
 800dd1e:	432e      	orrs	r6, r5
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dd20:	ea81 0582 	eor.w	r5, r1, r2, lsl #2
 800dd24:	9a06      	ldr	r2, [sp, #24]
	x -= sign;
 800dd26:	eba3 0c0c 	sub.w	ip, r3, ip
	sign = x >> (sizeof(int) * 8 - 1);
 800dd2a:	17fb      	asrs	r3, r7, #31
	x ^= sign;
 800dd2c:	ea82 0103 	eor.w	r1, r2, r3
	sign = x >> (sizeof(int) * 8 - 1);
 800dd30:	9f07      	ldr	r7, [sp, #28]
	x -= sign;
 800dd32:	1acb      	subs	r3, r1, r3
	x ^= sign;
 800dd34:	9907      	ldr	r1, [sp, #28]
			mOut |= FASTABS(xp);
 800dd36:	ea49 090c 	orr.w	r9, r9, ip
	x -= sign;
 800dd3a:	ebab 0000 	sub.w	r0, fp, r0
	sign = x >> (sizeof(int) * 8 - 1);
 800dd3e:	17ff      	asrs	r7, r7, #31
			nonZero |= xp;
 800dd40:	4316      	orrs	r6, r2
			mOut |= FASTABS(xp);
 800dd42:	ea49 0900 	orr.w	r9, r9, r0
	x ^= sign;
 800dd46:	ea81 0207 	eor.w	r2, r1, r7
	sign = x >> (sizeof(int) * 8 - 1);
 800dd4a:	9808      	ldr	r0, [sp, #32]
	x -= sign;
 800dd4c:	1bd7      	subs	r7, r2, r7
	x ^= sign;
 800dd4e:	9a08      	ldr	r2, [sp, #32]
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 800dd50:	4425      	add	r5, r4
			nonZero |= xp;
 800dd52:	430e      	orrs	r6, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800dd54:	17c4      	asrs	r4, r0, #31
			mOut |= FASTABS(xp);
 800dd56:	ea49 0903 	orr.w	r9, r9, r3
	x ^= sign;
 800dd5a:	ea82 0c04 	eor.w	ip, r2, r4
			nonZero |= xp;
 800dd5e:	4316      	orrs	r6, r2
	sign = x >> (sizeof(int) * 8 - 1);
 800dd60:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			y[2*j+1][i] = xp;
 800dd62:	f8c8 5880 	str.w	r5, [r8, #2176]	; 0x880
 800dd66:	17e9      	asrs	r1, r5, #31
			mOut |= FASTABS(xp);
 800dd68:	ea49 0907 	orr.w	r9, r9, r7
	x -= sign;
 800dd6c:	ebac 0404 	sub.w	r4, ip, r4
	x ^= sign;
 800dd70:	ea85 0001 	eor.w	r0, r5, r1
	sign = x >> (sizeof(int) * 8 - 1);
 800dd74:	17d3      	asrs	r3, r2, #31
 800dd76:	ea49 0904 	orr.w	r9, r9, r4
 800dd7a:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
			xPrev[j] = 0;
 800dd7c:	f84a ec04 	str.w	lr, [sl, #-4]
	x -= sign;
 800dd80:	1a41      	subs	r1, r0, r1
			nonZero |= xp;
 800dd82:	432e      	orrs	r6, r5
	x ^= sign;
 800dd84:	4610      	mov	r0, r2
 800dd86:	405a      	eors	r2, r3
 800dd88:	4306      	orrs	r6, r0
	x -= sign;
 800dd8a:	1ad3      	subs	r3, r2, r3
	x ^= sign;
 800dd8c:	4622      	mov	r2, r4
		if (nonZero)
 800dd8e:	4332      	orrs	r2, r6
			mOut |= FASTABS(xp);
 800dd90:	ea49 0901 	orr.w	r9, r9, r1
		if (nonZero)
 800dd94:	e89d 0006 	ldmia.w	sp, {r1, r2}
 800dd98:	bf18      	it	ne
 800dd9a:	460a      	movne	r2, r1
 800dd9c:	9201      	str	r2, [sp, #4]
	for (   ; i < bc->nBlocksPrev; i++) {
 800dd9e:	1c4a      	adds	r2, r1, #1
 800dda0:	9905      	ldr	r1, [sp, #20]
 800dda2:	9200      	str	r2, [sp, #0]
	sign = x >> (sizeof(int) * 8 - 1);
 800dda4:	17e7      	asrs	r7, r4, #31
 800dda6:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
	x ^= sign;
 800ddaa:	ea84 0007 	eor.w	r0, r4, r7
			mOut |= FASTABS(xp);
 800ddae:	ea49 0303 	orr.w	r3, r9, r3
	x -= sign;
 800ddb2:	1bc7      	subs	r7, r0, r7
 800ddb4:	9105      	str	r1, [sp, #20]
 800ddb6:	9903      	ldr	r1, [sp, #12]
 800ddb8:	433b      	orrs	r3, r7
 800ddba:	4319      	orrs	r1, r3
	for (   ; i < bc->nBlocksPrev; i++) {
 800ddbc:	9b24      	ldr	r3, [sp, #144]	; 0x90
			mOut |= FASTABS(xp);
 800ddbe:	9103      	str	r1, [sp, #12]
	for (   ; i < bc->nBlocksPrev; i++) {
 800ddc0:	4293      	cmp	r3, r2
 800ddc2:	f10a 0a24 	add.w	sl, sl, #36	; 0x24
 800ddc6:	d00e      	beq.n	800dde6 <xmp3fixpt_IMDCT+0x1bc2>
		if (i < bc->prevWinSwitch)
 800ddc8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ddca:	4293      	cmp	r3, r2
 800ddcc:	f1aa 0024 	sub.w	r0, sl, #36	; 0x24
 800ddd0:	f77f ae5e 	ble.w	800da90 <xmp3fixpt_IMDCT+0x186c>
 800ddd4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800ddd6:	e660      	b.n	800da9a <xmp3fixpt_IMDCT+0x1876>
 800ddd8:	461a      	mov	r2, r3
 800ddda:	a946      	add	r1, sp, #280	; 0x118
 800dddc:	f7fd fd06 	bl	800b7ec <WinPrevious.part.0>
 800dde0:	9946      	ldr	r1, [sp, #280]	; 0x118
 800dde2:	9a47      	ldr	r2, [sp, #284]	; 0x11c
 800dde4:	e6c0      	b.n	800db68 <xmp3fixpt_IMDCT+0x1944>
 800dde6:	4613      	mov	r3, r2
	for (   ; i < 32; i++) {
 800dde8:	2b1f      	cmp	r3, #31
 800ddea:	dc11      	bgt.n	800de10 <xmp3fixpt_IMDCT+0x1bec>
 800ddec:	461c      	mov	r4, r3
 800ddee:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 800ddf0:	461a      	mov	r2, r3
 800ddf2:	eb02 0084 	add.w	r0, r2, r4, lsl #2
			y[j][i] = 0;
 800ddf6:	2100      	movs	r1, #0
 800ddf8:	f500 6210 	add.w	r2, r0, #2304	; 0x900
	for (   ; i < bc->nBlocksPrev; i++) {
 800ddfc:	4603      	mov	r3, r0
			y[j][i] = 0;
 800ddfe:	f843 1b80 	str.w	r1, [r3], #128
		for (j = 0; j < 18; j++) 
 800de02:	429a      	cmp	r2, r3
 800de04:	d1fb      	bne.n	800ddfe <xmp3fixpt_IMDCT+0x1bda>
	for (   ; i < 32; i++) {
 800de06:	3401      	adds	r4, #1
 800de08:	2c20      	cmp	r4, #32
 800de0a:	f100 0004 	add.w	r0, r0, #4
 800de0e:	d1f3      	bne.n	800ddf8 <xmp3fixpt_IMDCT+0x1bd4>
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 800de10:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 800de12:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 800de14:	9931      	ldr	r1, [sp, #196]	; 0xc4
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800de16:	9830      	ldr	r0, [sp, #192]	; 0xc0
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 800de18:	9f2f      	ldr	r7, [sp, #188]	; 0xbc
 800de1a:	4413      	add	r3, r2
 800de1c:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800de1e:	011b      	lsls	r3, r3, #4
 800de20:	440a      	add	r2, r1
 800de22:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800de26:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800de28:	441a      	add	r2, r3
 800de2a:	4613      	mov	r3, r2
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800de2c:	4606      	mov	r6, r0
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 800de2e:	f641 3408 	movw	r4, #6920	; 0x1b08
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
	mi->gb[ch] = bc.gbOut;
 800de32:	f641 3118 	movw	r1, #6936	; 0x1b18
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 800de36:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800de38:	9801      	ldr	r0, [sp, #4]
	__asm__ ("clz %0, %1" : "=r" (numZeros) : "r" (x) : "cc");
 800de3a:	9b03      	ldr	r3, [sp, #12]
 800de3c:	fab3 f383 	clz	r3, r3
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 800de40:	f641 3210 	movw	r2, #6928	; 0x1b10
	bc->gbOut = CLZ(mOut) - 1;
 800de44:	3b01      	subs	r3, #1
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 800de46:	6030      	str	r0, [r6, #0]
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 800de48:	513d      	str	r5, [r7, r4]
	mi->gb[ch] = bc.gbOut;
 800de4a:	507b      	str	r3, [r7, r1]
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 800de4c:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800de4e:	50bb      	str	r3, [r7, r2]

	ASSERT(mi->numPrevIMDCT[ch] <= NBANDS);

	/* output has gained 2 int bits */
	return 0;
 800de50:	2000      	movs	r0, #0
}
 800de52:	b059      	add	sp, #356	; 0x164
 800de54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (si->sis[gr][ch].blockType == 2 && si->sis[gr][ch].mixedBlock) {
 800de58:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800de5a:	931b      	str	r3, [sp, #108]	; 0x6c
 800de5c:	b16b      	cbz	r3, 800de7a <xmp3fixpt_IMDCT+0x1c56>
		nBfly = bc.nBlocksLong - 1;
 800de5e:	1e4b      	subs	r3, r1, #1
 800de60:	460a      	mov	r2, r1
 800de62:	00d9      	lsls	r1, r3, #3
 800de64:	18cd      	adds	r5, r1, r3
 800de66:	006d      	lsls	r5, r5, #1
 800de68:	f105 0008 	add.w	r0, r5, #8
 800de6c:	9010      	str	r0, [sp, #64]	; 0x40
		bc.nBlocksLong = blockCutoff;	
 800de6e:	921b      	str	r2, [sp, #108]	; 0x6c
 800de70:	4638      	mov	r0, r7
 800de72:	4622      	mov	r2, r4
 800de74:	9c0d      	ldr	r4, [sp, #52]	; 0x34
		nBfly = bc.nBlocksLong - 1;
 800de76:	f7ff b835 	b.w	800cee4 <xmp3fixpt_IMDCT+0xcc0>
 800de7a:	0203      	lsls	r3, r0, #8
 800de7c:	930f      	str	r3, [sp, #60]	; 0x3c
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 800de7e:	18f3      	adds	r3, r6, r3
 800de80:	932e      	str	r3, [sp, #184]	; 0xb8
 800de82:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800de84:	9326      	str	r3, [sp, #152]	; 0x98
 800de86:	2308      	movs	r3, #8
 800de88:	9310      	str	r3, [sp, #64]	; 0x40
 800de8a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800de8c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800de8e:	463b      	mov	r3, r7
 800de90:	f7fe bb17 	b.w	800c4c2 <xmp3fixpt_IMDCT+0x29e>
 800de94:	4603      	mov	r3, r0
	for (   ; i < bc->nBlocksPrev; i++) {
 800de96:	9000      	str	r0, [sp, #0]
 800de98:	e7a6      	b.n	800dde8 <xmp3fixpt_IMDCT+0x1bc4>
 800de9a:	461a      	mov	r2, r3
	mOut = 0;
 800de9c:	2300      	movs	r3, #0
	for(i = 0; i < bc->nBlocksLong; i++) {
 800de9e:	9228      	str	r2, [sp, #160]	; 0xa0
	mOut = 0;
 800dea0:	9303      	str	r3, [sp, #12]
	for(i = 0; i < bc->nBlocksLong; i++) {
 800dea2:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 800dea4:	9301      	str	r3, [sp, #4]
 800dea6:	4619      	mov	r1, r3
 800dea8:	f7ff ba34 	b.w	800d314 <xmp3fixpt_IMDCT+0x10f0>
		return -1;
 800deac:	f04f 30ff 	mov.w	r0, #4294967295
 800deb0:	e7cf      	b.n	800de52 <xmp3fixpt_IMDCT+0x1c2e>
 800deb2:	bf00      	nop

0800deb4 <xmp3fixpt_PolyphaseMono>:
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 *                (note max filter gain - see polyCoef[] comments)
 **************************************************************************************/
void PolyphaseMono(short *pcm, int *vbuf, const int *coefBase)
{	
 800deb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
static __inline Word64 MADD64(Word64 sum64, int x, int y)
{
	U64 u;
	u.w64 = sum64;

	__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 800deb8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800debc:	b083      	sub	sp, #12
 800debe:	f04f 0e00 	mov.w	lr, #0
 800dec2:	4684      	mov	ip, r0
	/* special case, output sample 0 */
	coef = coefBase;
	vb1 = vbuf;
	sum1L = rndVal;

	MC0M(0)
 800dec4:	6817      	ldr	r7, [r2, #0]
 800dec6:	6854      	ldr	r4, [r2, #4]
 800dec8:	680e      	ldr	r6, [r1, #0]
 800deca:	6dcd      	ldr	r5, [r1, #92]	; 0x5c
 800decc:	fbc6 3e07 	smlal	r3, lr, r6, r7
 800ded0:	4266      	negs	r6, r4
 800ded2:	4674      	mov	r4, lr
 800ded4:	fbc5 3406 	smlal	r3, r4, r5, r6
	MC0M(1)
 800ded8:	68d5      	ldr	r5, [r2, #12]
 800deda:	684f      	ldr	r7, [r1, #4]
 800dedc:	6d8e      	ldr	r6, [r1, #88]	; 0x58
 800dede:	6890      	ldr	r0, [r2, #8]
 800dee0:	fbc7 3400 	smlal	r3, r4, r7, r0
 800dee4:	426d      	negs	r5, r5
 800dee6:	fbc6 3405 	smlal	r3, r4, r6, r5
	MC0M(2)
 800deea:	6955      	ldr	r5, [r2, #20]
 800deec:	688f      	ldr	r7, [r1, #8]
 800deee:	6d4e      	ldr	r6, [r1, #84]	; 0x54
 800def0:	6910      	ldr	r0, [r2, #16]
 800def2:	fbc7 3400 	smlal	r3, r4, r7, r0
 800def6:	426d      	negs	r5, r5
 800def8:	fbc6 3405 	smlal	r3, r4, r6, r5
	MC0M(3)
 800defc:	69d5      	ldr	r5, [r2, #28]
 800defe:	68cf      	ldr	r7, [r1, #12]
 800df00:	6d0e      	ldr	r6, [r1, #80]	; 0x50
 800df02:	6990      	ldr	r0, [r2, #24]
 800df04:	fbc7 3400 	smlal	r3, r4, r7, r0
 800df08:	426d      	negs	r5, r5
 800df0a:	fbc6 3405 	smlal	r3, r4, r6, r5
	MC0M(4)
 800df0e:	6a55      	ldr	r5, [r2, #36]	; 0x24
 800df10:	690f      	ldr	r7, [r1, #16]
 800df12:	6cce      	ldr	r6, [r1, #76]	; 0x4c
 800df14:	6a10      	ldr	r0, [r2, #32]
 800df16:	fbc7 3400 	smlal	r3, r4, r7, r0
 800df1a:	426d      	negs	r5, r5
 800df1c:	fbc6 3405 	smlal	r3, r4, r6, r5
	MC0M(5)
 800df20:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
 800df22:	694f      	ldr	r7, [r1, #20]
 800df24:	6c8e      	ldr	r6, [r1, #72]	; 0x48
 800df26:	6a90      	ldr	r0, [r2, #40]	; 0x28
 800df28:	fbc7 3400 	smlal	r3, r4, r7, r0
 800df2c:	426d      	negs	r5, r5
 800df2e:	fbc6 3405 	smlal	r3, r4, r6, r5
	MC0M(6)
 800df32:	6b55      	ldr	r5, [r2, #52]	; 0x34
 800df34:	698f      	ldr	r7, [r1, #24]
 800df36:	6c4e      	ldr	r6, [r1, #68]	; 0x44
 800df38:	6b10      	ldr	r0, [r2, #48]	; 0x30
 800df3a:	fbc7 3400 	smlal	r3, r4, r7, r0
 800df3e:	426d      	negs	r5, r5
 800df40:	fbc6 3405 	smlal	r3, r4, r6, r5
	MC0M(7)
 800df44:	6bd5      	ldr	r5, [r2, #60]	; 0x3c
 800df46:	69cf      	ldr	r7, [r1, #28]
 800df48:	6c0e      	ldr	r6, [r1, #64]	; 0x40
 800df4a:	6b90      	ldr	r0, [r2, #56]	; 0x38
 800df4c:	fbc7 3400 	smlal	r3, r4, r7, r0
 800df50:	426d      	negs	r5, r5
 800df52:	fbc6 3405 	smlal	r3, r4, r6, r5

	return u.w64;
}
static __inline Word64 SAR64(Word64 x, int n)
{
	return x >> n;
 800df56:	0d1b      	lsrs	r3, r3, #20
 800df58:	ea43 3304 	orr.w	r3, r3, r4, lsl #12
	sign = x >> 31;
 800df5c:	17dd      	asrs	r5, r3, #31
	if (sign != (x >> 15))
 800df5e:	ebb5 5f63 	cmp.w	r5, r3, asr #21
		x = sign ^ ((1 << 15) - 1);
 800df62:	bf18      	it	ne
 800df64:	f485 45ff 	eorne.w	r5, r5, #32640	; 0x7f80
	/* special case, output sample 16 */
	coef = coefBase + 256;
	vb1 = vbuf + 64*16;
	sum1L = rndVal;

	MC1M(0)
 800df68:	f501 5680 	add.w	r6, r1, #4096	; 0x1000
	x >>= fracBits;
 800df6c:	bf0c      	ite	eq
 800df6e:	119d      	asreq	r5, r3, #6
		x = sign ^ ((1 << 15) - 1);
 800df70:	f085 057f 	eorne.w	r5, r5, #127	; 0x7f
	return (short)x;
 800df74:	f8ac 5000 	strh.w	r5, [ip]
	__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 800df78:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800df7c:	2400      	movs	r4, #0
	MC1M(0)
 800df7e:	6836      	ldr	r6, [r6, #0]
 800df80:	f8d2 5400 	ldr.w	r5, [r2, #1024]	; 0x400
 800df84:	fbc6 3405 	smlal	r3, r4, r6, r5
	MC1M(1)
 800df88:	f241 0504 	movw	r5, #4100	; 0x1004
 800df8c:	f8d2 6404 	ldr.w	r6, [r2, #1028]	; 0x404
 800df90:	594d      	ldr	r5, [r1, r5]
 800df92:	fbc5 3406 	smlal	r3, r4, r5, r6
	MC1M(2)
 800df96:	f241 0508 	movw	r5, #4104	; 0x1008
 800df9a:	f8d2 6408 	ldr.w	r6, [r2, #1032]	; 0x408
 800df9e:	594d      	ldr	r5, [r1, r5]
 800dfa0:	fbc5 3406 	smlal	r3, r4, r5, r6
	MC1M(3)
 800dfa4:	f241 050c 	movw	r5, #4108	; 0x100c
 800dfa8:	f8d2 640c 	ldr.w	r6, [r2, #1036]	; 0x40c
 800dfac:	594d      	ldr	r5, [r1, r5]
 800dfae:	fbc5 3406 	smlal	r3, r4, r5, r6
	MC1M(4)
 800dfb2:	f241 0510 	movw	r5, #4112	; 0x1010
 800dfb6:	f8d2 6410 	ldr.w	r6, [r2, #1040]	; 0x410
 800dfba:	594d      	ldr	r5, [r1, r5]
 800dfbc:	fbc5 3406 	smlal	r3, r4, r5, r6
	MC1M(5)
 800dfc0:	f241 0514 	movw	r5, #4116	; 0x1014
 800dfc4:	f8d2 6414 	ldr.w	r6, [r2, #1044]	; 0x414
 800dfc8:	594d      	ldr	r5, [r1, r5]
 800dfca:	fbc5 3406 	smlal	r3, r4, r5, r6
	MC1M(6)
 800dfce:	f241 0518 	movw	r5, #4120	; 0x1018
 800dfd2:	f8d2 6418 	ldr.w	r6, [r2, #1048]	; 0x418
 800dfd6:	594d      	ldr	r5, [r1, r5]
 800dfd8:	fbc5 3406 	smlal	r3, r4, r5, r6
	MC1M(7)
 800dfdc:	f241 051c 	movw	r5, #4124	; 0x101c
 800dfe0:	f8d2 641c 	ldr.w	r6, [r2, #1052]	; 0x41c
 800dfe4:	594d      	ldr	r5, [r1, r5]
 800dfe6:	fbc5 3406 	smlal	r3, r4, r5, r6
	return x >> n;
 800dfea:	0d1b      	lsrs	r3, r3, #20
 800dfec:	ea43 3304 	orr.w	r3, r3, r4, lsl #12
	sign = x >> 31;
 800dff0:	17dc      	asrs	r4, r3, #31
	if (sign != (x >> 15))
 800dff2:	ebb4 5f63 	cmp.w	r4, r3, asr #21
		x = sign ^ ((1 << 15) - 1);
 800dff6:	bf16      	itet	ne
 800dff8:	f484 43ff 	eorne.w	r3, r4, #32640	; 0x7f80
	x >>= fracBits;
 800dffc:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 800dffe:	f083 037f 	eorne.w	r3, r3, #127	; 0x7f
	return (short)x;
 800e002:	f8ac 3020 	strh.w	r3, [ip, #32]
 800e006:	f502 6388 	add.w	r3, r2, #1088	; 0x440
 800e00a:	f10c 0940 	add.w	r9, ip, #64	; 0x40
 800e00e:	46e6      	mov	lr, ip
 800e010:	f102 0680 	add.w	r6, r2, #128	; 0x80
 800e014:	9301      	str	r3, [sp, #4]
	__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 800e016:	f04f 7800 	mov.w	r8, #33554432	; 0x2000000
 800e01a:	f04f 0c00 	mov.w	ip, #0

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
		sum1L = sum2L = rndVal;

		MC2M(0)
 800e01e:	f856 ac40 	ldr.w	sl, [r6, #-64]
 800e022:	f856 bc3c 	ldr.w	fp, [r6, #-60]
 800e026:	f8d1 5100 	ldr.w	r5, [r1, #256]	; 0x100
 800e02a:	f8d1 715c 	ldr.w	r7, [r1, #348]	; 0x15c
 800e02e:	4642      	mov	r2, r8
 800e030:	4664      	mov	r4, ip
 800e032:	fbc5 240a 	smlal	r2, r4, r5, sl
 800e036:	4643      	mov	r3, r8
 800e038:	4660      	mov	r0, ip
 800e03a:	fbc5 300b 	smlal	r3, r0, r5, fp
 800e03e:	f1cb 0500 	rsb	r5, fp, #0
 800e042:	fbc7 2405 	smlal	r2, r4, r7, r5
 800e046:	fbc7 300a 	smlal	r3, r0, r7, sl
		MC2M(1)
 800e04a:	f856 7c38 	ldr.w	r7, [r6, #-56]
 800e04e:	f856 ac34 	ldr.w	sl, [r6, #-52]
 800e052:	f8d1 b104 	ldr.w	fp, [r1, #260]	; 0x104
 800e056:	f8d1 5158 	ldr.w	r5, [r1, #344]	; 0x158
 800e05a:	fbcb 2407 	smlal	r2, r4, fp, r7
 800e05e:	fbcb 300a 	smlal	r3, r0, fp, sl
 800e062:	f1ca 0a00 	rsb	sl, sl, #0
 800e066:	fbc5 240a 	smlal	r2, r4, r5, sl
 800e06a:	fbc5 3007 	smlal	r3, r0, r5, r7
		MC2M(2)
 800e06e:	f856 7c30 	ldr.w	r7, [r6, #-48]
 800e072:	f856 ac2c 	ldr.w	sl, [r6, #-44]
 800e076:	f8d1 b108 	ldr.w	fp, [r1, #264]	; 0x108
 800e07a:	f8d1 5154 	ldr.w	r5, [r1, #340]	; 0x154
 800e07e:	fbcb 2407 	smlal	r2, r4, fp, r7
 800e082:	fbcb 300a 	smlal	r3, r0, fp, sl
 800e086:	f1ca 0a00 	rsb	sl, sl, #0
 800e08a:	fbc5 240a 	smlal	r2, r4, r5, sl
 800e08e:	fbc5 3007 	smlal	r3, r0, r5, r7
		MC2M(3)
 800e092:	f856 7c28 	ldr.w	r7, [r6, #-40]
 800e096:	f856 ac24 	ldr.w	sl, [r6, #-36]
 800e09a:	f8d1 b10c 	ldr.w	fp, [r1, #268]	; 0x10c
 800e09e:	f8d1 5150 	ldr.w	r5, [r1, #336]	; 0x150
 800e0a2:	fbcb 2407 	smlal	r2, r4, fp, r7
 800e0a6:	fbcb 300a 	smlal	r3, r0, fp, sl
 800e0aa:	f1ca 0a00 	rsb	sl, sl, #0
 800e0ae:	fbc5 240a 	smlal	r2, r4, r5, sl
 800e0b2:	fbc5 3007 	smlal	r3, r0, r5, r7
		MC2M(4)
 800e0b6:	f856 7c20 	ldr.w	r7, [r6, #-32]
 800e0ba:	f856 ac1c 	ldr.w	sl, [r6, #-28]
 800e0be:	f8d1 b110 	ldr.w	fp, [r1, #272]	; 0x110
 800e0c2:	f8d1 514c 	ldr.w	r5, [r1, #332]	; 0x14c
 800e0c6:	fbcb 2407 	smlal	r2, r4, fp, r7
 800e0ca:	fbcb 300a 	smlal	r3, r0, fp, sl
 800e0ce:	f1ca 0a00 	rsb	sl, sl, #0
 800e0d2:	fbc5 240a 	smlal	r2, r4, r5, sl
 800e0d6:	fbc5 3007 	smlal	r3, r0, r5, r7
		MC2M(5)
 800e0da:	f856 ac18 	ldr.w	sl, [r6, #-24]
 800e0de:	f856 5c14 	ldr.w	r5, [r6, #-20]
 800e0e2:	f8d1 b114 	ldr.w	fp, [r1, #276]	; 0x114
 800e0e6:	f8d1 7148 	ldr.w	r7, [r1, #328]	; 0x148
 800e0ea:	fbcb 240a 	smlal	r2, r4, fp, sl
 800e0ee:	fbcb 3005 	smlal	r3, r0, fp, r5
 800e0f2:	426d      	negs	r5, r5
 800e0f4:	fbc7 2405 	smlal	r2, r4, r7, r5
 800e0f8:	fbc7 300a 	smlal	r3, r0, r7, sl
		MC2M(6)
 800e0fc:	f856 ac10 	ldr.w	sl, [r6, #-16]
 800e100:	f856 5c0c 	ldr.w	r5, [r6, #-12]
 800e104:	f8d1 b118 	ldr.w	fp, [r1, #280]	; 0x118
 800e108:	f8d1 7144 	ldr.w	r7, [r1, #324]	; 0x144
 800e10c:	fbcb 240a 	smlal	r2, r4, fp, sl
 800e110:	fbcb 3005 	smlal	r3, r0, fp, r5
 800e114:	426d      	negs	r5, r5
 800e116:	fbc7 2405 	smlal	r2, r4, r7, r5
 800e11a:	fbc7 300a 	smlal	r3, r0, r7, sl
		MC2M(7)
 800e11e:	f856 ac08 	ldr.w	sl, [r6, #-8]
 800e122:	f856 5c04 	ldr.w	r5, [r6, #-4]
 800e126:	f8d1 b11c 	ldr.w	fp, [r1, #284]	; 0x11c
 800e12a:	f8d1 7140 	ldr.w	r7, [r1, #320]	; 0x140
 800e12e:	fbcb 240a 	smlal	r2, r4, fp, sl
 800e132:	fbcb 3005 	smlal	r3, r0, fp, r5
 800e136:	426d      	negs	r5, r5
 800e138:	fbc7 2405 	smlal	r2, r4, r7, r5
 800e13c:	fbc7 300a 	smlal	r3, r0, r7, sl
	return x >> n;
 800e140:	0d12      	lsrs	r2, r2, #20
 800e142:	ea42 3204 	orr.w	r2, r2, r4, lsl #12
	sign = x >> 31;
 800e146:	17d4      	asrs	r4, r2, #31
 800e148:	0d1b      	lsrs	r3, r3, #20
	if (sign != (x >> 15))
 800e14a:	ebb4 5f62 	cmp.w	r4, r2, asr #21
 800e14e:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
	sign = x >> 31;
 800e152:	ea4f 70e3 	mov.w	r0, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 800e156:	bf16      	itet	ne
 800e158:	f484 42ff 	eorne.w	r2, r4, #32640	; 0x7f80
	x >>= fracBits;
 800e15c:	1192      	asreq	r2, r2, #6
		x = sign ^ ((1 << 15) - 1);
 800e15e:	f082 027f 	eorne.w	r2, r2, #127	; 0x7f
	if (sign != (x >> 15))
 800e162:	ebb0 5f63 	cmp.w	r0, r3, asr #21
	x >>= fracBits;
 800e166:	bf08      	it	eq
 800e168:	1198      	asreq	r0, r3, #6
	for (i = 15; i > 0; i--) {
 800e16a:	9b01      	ldr	r3, [sp, #4]
	return (short)x;
 800e16c:	f82e 2f02 	strh.w	r2, [lr, #2]!
		x = sign ^ ((1 << 15) - 1);
 800e170:	bf18      	it	ne
 800e172:	f480 40ff 	eorne.w	r0, r0, #32640	; 0x7f80
 800e176:	f106 0640 	add.w	r6, r6, #64	; 0x40
 800e17a:	bf18      	it	ne
 800e17c:	f080 007f 	eorne.w	r0, r0, #127	; 0x7f
	for (i = 15; i > 0; i--) {
 800e180:	429e      	cmp	r6, r3
	return (short)x;
 800e182:	f829 0d02 	strh.w	r0, [r9, #-2]!
 800e186:	f501 7180 	add.w	r1, r1, #256	; 0x100
	for (i = 15; i > 0; i--) {
 800e18a:	f47f af48 	bne.w	800e01e <xmp3fixpt_PolyphaseMono+0x16a>
		vb1 += 64;
		*(pcm)       = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*i) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		pcm++;
	}
}
 800e18e:	b003      	add	sp, #12
 800e190:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800e194 <xmp3fixpt_PolyphaseStereo>:
 * Notes:       interleaves PCM samples LRLRLR...
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 **************************************************************************************/
void PolyphaseStereo(short *pcm, int *vbuf, const int *coefBase)
{
 800e194:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 800e198:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e19c:	2500      	movs	r5, #0
 800e19e:	b085      	sub	sp, #20
	/* special case, output sample 0 */
	coef = coefBase;
	vb1 = vbuf;
	sum1L = sum1R = rndVal;

	MC0S(0)
 800e1a0:	6816      	ldr	r6, [r2, #0]
 800e1a2:	680f      	ldr	r7, [r1, #0]
 800e1a4:	461c      	mov	r4, r3
 800e1a6:	46ae      	mov	lr, r5
 800e1a8:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e1ac:	6857      	ldr	r7, [r2, #4]
 800e1ae:	f1c7 0c00 	rsb	ip, r7, #0
 800e1b2:	6dcf      	ldr	r7, [r1, #92]	; 0x5c
 800e1b4:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e1b8:	f8d1 7080 	ldr.w	r7, [r1, #128]	; 0x80
 800e1bc:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e1c0:	f8d1 60dc 	ldr.w	r6, [r1, #220]	; 0xdc
 800e1c4:	fbc6 350c 	smlal	r3, r5, r6, ip
	MC0S(1)
 800e1c8:	6896      	ldr	r6, [r2, #8]
 800e1ca:	684f      	ldr	r7, [r1, #4]
 800e1cc:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e1d0:	68d7      	ldr	r7, [r2, #12]
 800e1d2:	f1c7 0c00 	rsb	ip, r7, #0
 800e1d6:	6d8f      	ldr	r7, [r1, #88]	; 0x58
 800e1d8:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e1dc:	f8d1 7084 	ldr.w	r7, [r1, #132]	; 0x84
 800e1e0:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e1e4:	f8d1 60d8 	ldr.w	r6, [r1, #216]	; 0xd8
 800e1e8:	fbc6 350c 	smlal	r3, r5, r6, ip
	MC0S(2)
 800e1ec:	6916      	ldr	r6, [r2, #16]
 800e1ee:	688f      	ldr	r7, [r1, #8]
 800e1f0:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e1f4:	6957      	ldr	r7, [r2, #20]
 800e1f6:	f1c7 0c00 	rsb	ip, r7, #0
 800e1fa:	6d4f      	ldr	r7, [r1, #84]	; 0x54
 800e1fc:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e200:	f8d1 7088 	ldr.w	r7, [r1, #136]	; 0x88
 800e204:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e208:	f8d1 60d4 	ldr.w	r6, [r1, #212]	; 0xd4
 800e20c:	fbc6 350c 	smlal	r3, r5, r6, ip
	MC0S(3)
 800e210:	6996      	ldr	r6, [r2, #24]
 800e212:	68cf      	ldr	r7, [r1, #12]
 800e214:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e218:	69d7      	ldr	r7, [r2, #28]
 800e21a:	f1c7 0c00 	rsb	ip, r7, #0
 800e21e:	6d0f      	ldr	r7, [r1, #80]	; 0x50
 800e220:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e224:	f8d1 708c 	ldr.w	r7, [r1, #140]	; 0x8c
 800e228:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e22c:	f8d1 60d0 	ldr.w	r6, [r1, #208]	; 0xd0
 800e230:	fbc6 350c 	smlal	r3, r5, r6, ip
	MC0S(4)
 800e234:	6a16      	ldr	r6, [r2, #32]
 800e236:	690f      	ldr	r7, [r1, #16]
 800e238:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e23c:	6a57      	ldr	r7, [r2, #36]	; 0x24
 800e23e:	f1c7 0c00 	rsb	ip, r7, #0
 800e242:	6ccf      	ldr	r7, [r1, #76]	; 0x4c
 800e244:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e248:	f8d1 7090 	ldr.w	r7, [r1, #144]	; 0x90
 800e24c:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e250:	f8d1 60cc 	ldr.w	r6, [r1, #204]	; 0xcc
 800e254:	fbc6 350c 	smlal	r3, r5, r6, ip
	MC0S(5)
 800e258:	6a96      	ldr	r6, [r2, #40]	; 0x28
 800e25a:	694f      	ldr	r7, [r1, #20]
 800e25c:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e260:	6ad7      	ldr	r7, [r2, #44]	; 0x2c
 800e262:	f1c7 0c00 	rsb	ip, r7, #0
 800e266:	6c8f      	ldr	r7, [r1, #72]	; 0x48
 800e268:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e26c:	f8d1 7094 	ldr.w	r7, [r1, #148]	; 0x94
 800e270:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e274:	f8d1 60c8 	ldr.w	r6, [r1, #200]	; 0xc8
 800e278:	fbc6 350c 	smlal	r3, r5, r6, ip
	MC0S(6)
 800e27c:	6b16      	ldr	r6, [r2, #48]	; 0x30
 800e27e:	698f      	ldr	r7, [r1, #24]
 800e280:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e284:	6b57      	ldr	r7, [r2, #52]	; 0x34
 800e286:	f1c7 0c00 	rsb	ip, r7, #0
 800e28a:	6c4f      	ldr	r7, [r1, #68]	; 0x44
 800e28c:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e290:	f8d1 7098 	ldr.w	r7, [r1, #152]	; 0x98
 800e294:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e298:	f8d1 60c4 	ldr.w	r6, [r1, #196]	; 0xc4
 800e29c:	fbc6 350c 	smlal	r3, r5, r6, ip
	MC0S(7)
 800e2a0:	6b96      	ldr	r6, [r2, #56]	; 0x38
 800e2a2:	69cf      	ldr	r7, [r1, #28]
 800e2a4:	fbc7 4e06 	smlal	r4, lr, r7, r6
 800e2a8:	6bd7      	ldr	r7, [r2, #60]	; 0x3c
 800e2aa:	f1c7 0c00 	rsb	ip, r7, #0
 800e2ae:	6c0f      	ldr	r7, [r1, #64]	; 0x40
 800e2b0:	fbc7 4e0c 	smlal	r4, lr, r7, ip
 800e2b4:	f8d1 709c 	ldr.w	r7, [r1, #156]	; 0x9c
 800e2b8:	fbc7 3506 	smlal	r3, r5, r7, r6
 800e2bc:	f8d1 60c0 	ldr.w	r6, [r1, #192]	; 0xc0
 800e2c0:	fbc6 350c 	smlal	r3, r5, r6, ip
	return x >> n;
 800e2c4:	0d24      	lsrs	r4, r4, #20
 800e2c6:	ea44 340e 	orr.w	r4, r4, lr, lsl #12
	sign = x >> 31;
 800e2ca:	17e6      	asrs	r6, r4, #31
 800e2cc:	0d1b      	lsrs	r3, r3, #20
 800e2ce:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
	if (sign != (x >> 15))
 800e2d2:	ebb6 5f64 	cmp.w	r6, r4, asr #21
	sign = x >> 31;
 800e2d6:	ea4f 75e3 	mov.w	r5, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 800e2da:	bf16      	itet	ne
 800e2dc:	f486 44ff 	eorne.w	r4, r6, #32640	; 0x7f80
	x >>= fracBits;
 800e2e0:	11a4      	asreq	r4, r4, #6
		x = sign ^ ((1 << 15) - 1);
 800e2e2:	f084 047f 	eorne.w	r4, r4, #127	; 0x7f
	if (sign != (x >> 15))
 800e2e6:	ebb5 5f63 	cmp.w	r5, r3, asr #21
		x = sign ^ ((1 << 15) - 1);
 800e2ea:	bf18      	it	ne
 800e2ec:	f485 43ff 	eorne.w	r3, r5, #32640	; 0x7f80
	return (short)x;
 800e2f0:	8004      	strh	r4, [r0, #0]
	/* special case, output sample 16 */
	coef = coefBase + 256;
	vb1 = vbuf + 64*16;
	sum1L = sum1R = rndVal;

	MC1S(0)
 800e2f2:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
	x >>= fracBits;
 800e2f6:	bf0c      	ite	eq
 800e2f8:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 800e2fa:	f083 037f 	eorne.w	r3, r3, #127	; 0x7f
	__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 800e2fe:	f04f 7e00 	mov.w	lr, #33554432	; 0x2000000
 800e302:	2600      	movs	r6, #0
	return (short)x;
 800e304:	8043      	strh	r3, [r0, #2]
	MC1S(0)
 800e306:	6825      	ldr	r5, [r4, #0]
 800e308:	f8d2 7400 	ldr.w	r7, [r2, #1024]	; 0x400
 800e30c:	4674      	mov	r4, lr
 800e30e:	4633      	mov	r3, r6
 800e310:	fbc5 4307 	smlal	r4, r3, r5, r7
 800e314:	f501 5584 	add.w	r5, r1, #4224	; 0x1080
 800e318:	682d      	ldr	r5, [r5, #0]
 800e31a:	fbc5 e607 	smlal	lr, r6, r5, r7
	MC1S(1)
 800e31e:	f241 0704 	movw	r7, #4100	; 0x1004
 800e322:	f8d2 5404 	ldr.w	r5, [r2, #1028]	; 0x404
 800e326:	59cf      	ldr	r7, [r1, r7]
 800e328:	fbc7 4305 	smlal	r4, r3, r7, r5
 800e32c:	f241 0784 	movw	r7, #4228	; 0x1084
 800e330:	59cf      	ldr	r7, [r1, r7]
 800e332:	fbc7 e605 	smlal	lr, r6, r7, r5
	MC1S(2)
 800e336:	f241 0708 	movw	r7, #4104	; 0x1008
 800e33a:	f8d2 5408 	ldr.w	r5, [r2, #1032]	; 0x408
 800e33e:	59cf      	ldr	r7, [r1, r7]
 800e340:	fbc7 4305 	smlal	r4, r3, r7, r5
 800e344:	f241 0788 	movw	r7, #4232	; 0x1088
 800e348:	59cf      	ldr	r7, [r1, r7]
 800e34a:	fbc7 e605 	smlal	lr, r6, r7, r5
	MC1S(3)
 800e34e:	f241 050c 	movw	r5, #4108	; 0x100c
 800e352:	f8d2 740c 	ldr.w	r7, [r2, #1036]	; 0x40c
 800e356:	594d      	ldr	r5, [r1, r5]
 800e358:	fbc5 4307 	smlal	r4, r3, r5, r7
 800e35c:	f241 0c8c 	movw	ip, #4236	; 0x108c
 800e360:	4675      	mov	r5, lr
 800e362:	f851 e00c 	ldr.w	lr, [r1, ip]
 800e366:	fbce 5607 	smlal	r5, r6, lr, r7
	MC1S(4)
 800e36a:	f241 0e10 	movw	lr, #4112	; 0x1010
 800e36e:	f8d2 7410 	ldr.w	r7, [r2, #1040]	; 0x410
 800e372:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e376:	fbce 4307 	smlal	r4, r3, lr, r7
 800e37a:	f241 0e90 	movw	lr, #4240	; 0x1090
 800e37e:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e382:	fbce 5607 	smlal	r5, r6, lr, r7
	MC1S(5)
 800e386:	f241 0e14 	movw	lr, #4116	; 0x1014
 800e38a:	f8d2 7414 	ldr.w	r7, [r2, #1044]	; 0x414
 800e38e:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e392:	fbce 4307 	smlal	r4, r3, lr, r7
 800e396:	f241 0e94 	movw	lr, #4244	; 0x1094
 800e39a:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e39e:	fbce 5607 	smlal	r5, r6, lr, r7
	MC1S(6)
 800e3a2:	f241 0e18 	movw	lr, #4120	; 0x1018
 800e3a6:	f8d2 7418 	ldr.w	r7, [r2, #1048]	; 0x418
 800e3aa:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e3ae:	fbce 4307 	smlal	r4, r3, lr, r7
 800e3b2:	f241 0e98 	movw	lr, #4248	; 0x1098
 800e3b6:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e3ba:	fbce 5607 	smlal	r5, r6, lr, r7
	MC1S(7)
 800e3be:	f241 0e1c 	movw	lr, #4124	; 0x101c
 800e3c2:	f8d2 741c 	ldr.w	r7, [r2, #1052]	; 0x41c
 800e3c6:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e3ca:	fbce 4307 	smlal	r4, r3, lr, r7
 800e3ce:	f241 0e9c 	movw	lr, #4252	; 0x109c
 800e3d2:	f851 e00e 	ldr.w	lr, [r1, lr]
 800e3d6:	fbce 5607 	smlal	r5, r6, lr, r7
	return x >> n;
 800e3da:	0d24      	lsrs	r4, r4, #20
 800e3dc:	ea44 3403 	orr.w	r4, r4, r3, lsl #12
	sign = x >> 31;
 800e3e0:	17e3      	asrs	r3, r4, #31
	if (sign != (x >> 15))
 800e3e2:	ebb3 5f64 	cmp.w	r3, r4, asr #21
		x = sign ^ ((1 << 15) - 1);
 800e3e6:	bf18      	it	ne
 800e3e8:	f483 44ff 	eorne.w	r4, r3, #32640	; 0x7f80
 800e3ec:	ea4f 5315 	mov.w	r3, r5, lsr #20
 800e3f0:	ea43 3306 	orr.w	r3, r3, r6, lsl #12
	sign = x >> 31;
 800e3f4:	ea4f 75e3 	mov.w	r5, r3, asr #31
	x >>= fracBits;
 800e3f8:	bf0c      	ite	eq
 800e3fa:	11a4      	asreq	r4, r4, #6
		x = sign ^ ((1 << 15) - 1);
 800e3fc:	f084 047f 	eorne.w	r4, r4, #127	; 0x7f
	if (sign != (x >> 15))
 800e400:	ebb5 5f63 	cmp.w	r5, r3, asr #21
		x = sign ^ ((1 << 15) - 1);
 800e404:	bf16      	itet	ne
 800e406:	f485 43ff 	eorne.w	r3, r5, #32640	; 0x7f80
	x >>= fracBits;
 800e40a:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 800e40c:	f083 037f 	eorne.w	r3, r3, #127	; 0x7f
	return (short)x;
 800e410:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
 800e414:	f502 6388 	add.w	r3, r2, #1088	; 0x440
 800e418:	9303      	str	r3, [sp, #12]
 800e41a:	f100 0308 	add.w	r3, r0, #8
 800e41e:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40
 800e422:	f102 0b80 	add.w	fp, r2, #128	; 0x80
 800e426:	9300      	str	r3, [sp, #0]
 800e428:	9001      	str	r0, [sp, #4]
	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
		sum1L = sum2L = rndVal;
		sum1R = sum2R = rndVal;

		MC2S(0)
 800e42a:	f85b cc40 	ldr.w	ip, [fp, #-64]
 800e42e:	f85b 8c3c 	ldr.w	r8, [fp, #-60]
 800e432:	f8d1 0100 	ldr.w	r0, [r1, #256]	; 0x100
 800e436:	f8d1 315c 	ldr.w	r3, [r1, #348]	; 0x15c
	__asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 800e43a:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 800e43e:	f04f 0e00 	mov.w	lr, #0
 800e442:	fbc0 4e0c 	smlal	r4, lr, r0, ip
 800e446:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800e44a:	2600      	movs	r6, #0
 800e44c:	fbc0 2608 	smlal	r2, r6, r0, r8
 800e450:	f1c8 0900 	rsb	r9, r8, #0
 800e454:	fbc3 4e09 	smlal	r4, lr, r3, r9
 800e458:	fbc3 260c 	smlal	r2, r6, r3, ip
 800e45c:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 800e460:	9202      	str	r2, [sp, #8]
 800e462:	f8d1 a180 	ldr.w	sl, [r1, #384]	; 0x180
 800e466:	2700      	movs	r7, #0
 800e468:	fbca 070c 	smlal	r0, r7, sl, ip
 800e46c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e470:	2500      	movs	r5, #0
 800e472:	fbca 3508 	smlal	r3, r5, sl, r8
 800e476:	f8d1 21dc 	ldr.w	r2, [r1, #476]	; 0x1dc
 800e47a:	fbc2 0709 	smlal	r0, r7, r2, r9
 800e47e:	fbc2 350c 	smlal	r3, r5, r2, ip
		MC2S(1)
 800e482:	f85b ac38 	ldr.w	sl, [fp, #-56]
 800e486:	f85b cc34 	ldr.w	ip, [fp, #-52]
 800e48a:	f8d1 9104 	ldr.w	r9, [r1, #260]	; 0x104
 800e48e:	f8d1 8158 	ldr.w	r8, [r1, #344]	; 0x158
 800e492:	fbc9 4e0a 	smlal	r4, lr, r9, sl
 800e496:	9a02      	ldr	r2, [sp, #8]
 800e498:	fbc9 260c 	smlal	r2, r6, r9, ip
 800e49c:	f1cc 0900 	rsb	r9, ip, #0
 800e4a0:	fbc8 4e09 	smlal	r4, lr, r8, r9
 800e4a4:	fbc8 260a 	smlal	r2, r6, r8, sl
 800e4a8:	9202      	str	r2, [sp, #8]
 800e4aa:	f8d1 81d8 	ldr.w	r8, [r1, #472]	; 0x1d8
 800e4ae:	f8d1 2184 	ldr.w	r2, [r1, #388]	; 0x184
 800e4b2:	fbc2 070a 	smlal	r0, r7, r2, sl
 800e4b6:	fbc2 350c 	smlal	r3, r5, r2, ip
 800e4ba:	fbc8 0709 	smlal	r0, r7, r8, r9
 800e4be:	fbc8 350a 	smlal	r3, r5, r8, sl
		MC2S(2)
 800e4c2:	f85b ac30 	ldr.w	sl, [fp, #-48]
 800e4c6:	f85b cc2c 	ldr.w	ip, [fp, #-44]
 800e4ca:	f8d1 9108 	ldr.w	r9, [r1, #264]	; 0x108
 800e4ce:	f8d1 8154 	ldr.w	r8, [r1, #340]	; 0x154
 800e4d2:	fbc9 4e0a 	smlal	r4, lr, r9, sl
 800e4d6:	9a02      	ldr	r2, [sp, #8]
 800e4d8:	fbc9 260c 	smlal	r2, r6, r9, ip
 800e4dc:	f1cc 0900 	rsb	r9, ip, #0
 800e4e0:	fbc8 4e09 	smlal	r4, lr, r8, r9
 800e4e4:	fbc8 260a 	smlal	r2, r6, r8, sl
 800e4e8:	9202      	str	r2, [sp, #8]
 800e4ea:	f8d1 81d4 	ldr.w	r8, [r1, #468]	; 0x1d4
 800e4ee:	f8d1 2188 	ldr.w	r2, [r1, #392]	; 0x188
 800e4f2:	fbc2 070a 	smlal	r0, r7, r2, sl
 800e4f6:	fbc2 350c 	smlal	r3, r5, r2, ip
 800e4fa:	fbc8 0709 	smlal	r0, r7, r8, r9
 800e4fe:	fbc8 350a 	smlal	r3, r5, r8, sl
		MC2S(3)
 800e502:	f85b ac28 	ldr.w	sl, [fp, #-40]
 800e506:	f85b cc24 	ldr.w	ip, [fp, #-36]
 800e50a:	f8d1 910c 	ldr.w	r9, [r1, #268]	; 0x10c
 800e50e:	f8d1 8150 	ldr.w	r8, [r1, #336]	; 0x150
 800e512:	fbc9 4e0a 	smlal	r4, lr, r9, sl
 800e516:	9a02      	ldr	r2, [sp, #8]
 800e518:	fbc9 260c 	smlal	r2, r6, r9, ip
 800e51c:	f1cc 0900 	rsb	r9, ip, #0
 800e520:	fbc8 4e09 	smlal	r4, lr, r8, r9
 800e524:	fbc8 260a 	smlal	r2, r6, r8, sl
 800e528:	9202      	str	r2, [sp, #8]
 800e52a:	f8d1 81d0 	ldr.w	r8, [r1, #464]	; 0x1d0
 800e52e:	f8d1 218c 	ldr.w	r2, [r1, #396]	; 0x18c
 800e532:	fbc2 070a 	smlal	r0, r7, r2, sl
 800e536:	fbc2 350c 	smlal	r3, r5, r2, ip
 800e53a:	fbc8 0709 	smlal	r0, r7, r8, r9
 800e53e:	fbc8 350a 	smlal	r3, r5, r8, sl
		MC2S(4)
 800e542:	f85b ac20 	ldr.w	sl, [fp, #-32]
 800e546:	f85b cc1c 	ldr.w	ip, [fp, #-28]
 800e54a:	f8d1 9110 	ldr.w	r9, [r1, #272]	; 0x110
 800e54e:	f8d1 814c 	ldr.w	r8, [r1, #332]	; 0x14c
 800e552:	fbc9 4e0a 	smlal	r4, lr, r9, sl
 800e556:	9a02      	ldr	r2, [sp, #8]
 800e558:	fbc9 260c 	smlal	r2, r6, r9, ip
 800e55c:	f1cc 0900 	rsb	r9, ip, #0
 800e560:	fbc8 4e09 	smlal	r4, lr, r8, r9
 800e564:	fbc8 260a 	smlal	r2, r6, r8, sl
 800e568:	9202      	str	r2, [sp, #8]
 800e56a:	f8d1 81cc 	ldr.w	r8, [r1, #460]	; 0x1cc
 800e56e:	f8d1 2190 	ldr.w	r2, [r1, #400]	; 0x190
 800e572:	fbc2 070a 	smlal	r0, r7, r2, sl
 800e576:	fbc2 350c 	smlal	r3, r5, r2, ip
 800e57a:	fbc8 0709 	smlal	r0, r7, r8, r9
 800e57e:	fbc8 350a 	smlal	r3, r5, r8, sl
		MC2S(5)
 800e582:	f85b ac18 	ldr.w	sl, [fp, #-24]
 800e586:	f85b cc14 	ldr.w	ip, [fp, #-20]
 800e58a:	f8d1 9114 	ldr.w	r9, [r1, #276]	; 0x114
 800e58e:	f8d1 8148 	ldr.w	r8, [r1, #328]	; 0x148
 800e592:	fbc9 4e0a 	smlal	r4, lr, r9, sl
 800e596:	9a02      	ldr	r2, [sp, #8]
 800e598:	fbc9 260c 	smlal	r2, r6, r9, ip
 800e59c:	f1cc 0900 	rsb	r9, ip, #0
 800e5a0:	fbc8 4e09 	smlal	r4, lr, r8, r9
 800e5a4:	fbc8 260a 	smlal	r2, r6, r8, sl
 800e5a8:	9202      	str	r2, [sp, #8]
 800e5aa:	f8d1 81c8 	ldr.w	r8, [r1, #456]	; 0x1c8
 800e5ae:	f8d1 2194 	ldr.w	r2, [r1, #404]	; 0x194
 800e5b2:	fbc2 070a 	smlal	r0, r7, r2, sl
 800e5b6:	fbc2 350c 	smlal	r3, r5, r2, ip
 800e5ba:	fbc8 0709 	smlal	r0, r7, r8, r9
 800e5be:	fbc8 350a 	smlal	r3, r5, r8, sl
		MC2S(6)
 800e5c2:	f85b ac10 	ldr.w	sl, [fp, #-16]
 800e5c6:	f85b cc0c 	ldr.w	ip, [fp, #-12]
 800e5ca:	f8d1 9118 	ldr.w	r9, [r1, #280]	; 0x118
 800e5ce:	f8d1 8144 	ldr.w	r8, [r1, #324]	; 0x144
 800e5d2:	fbc9 4e0a 	smlal	r4, lr, r9, sl
 800e5d6:	9a02      	ldr	r2, [sp, #8]
 800e5d8:	fbc9 260c 	smlal	r2, r6, r9, ip
 800e5dc:	f1cc 0900 	rsb	r9, ip, #0
 800e5e0:	fbc8 4e09 	smlal	r4, lr, r8, r9
 800e5e4:	fbc8 260a 	smlal	r2, r6, r8, sl
 800e5e8:	9202      	str	r2, [sp, #8]
 800e5ea:	f8d1 81c4 	ldr.w	r8, [r1, #452]	; 0x1c4
 800e5ee:	f8d1 2198 	ldr.w	r2, [r1, #408]	; 0x198
 800e5f2:	fbc2 070a 	smlal	r0, r7, r2, sl
 800e5f6:	fbc2 350c 	smlal	r3, r5, r2, ip
 800e5fa:	fbc8 0709 	smlal	r0, r7, r8, r9
 800e5fe:	fbc8 350a 	smlal	r3, r5, r8, sl
		MC2S(7)
 800e602:	e91b 1400 	ldmdb	fp, {sl, ip}
 800e606:	f8d1 911c 	ldr.w	r9, [r1, #284]	; 0x11c
 800e60a:	f8d1 8140 	ldr.w	r8, [r1, #320]	; 0x140
 800e60e:	fbc9 4e0a 	smlal	r4, lr, r9, sl
 800e612:	9a02      	ldr	r2, [sp, #8]
 800e614:	fbc9 260c 	smlal	r2, r6, r9, ip
 800e618:	f1cc 0900 	rsb	r9, ip, #0
 800e61c:	fbc8 4e09 	smlal	r4, lr, r8, r9
 800e620:	fbc8 260a 	smlal	r2, r6, r8, sl
 800e624:	9202      	str	r2, [sp, #8]
 800e626:	f8d1 81c0 	ldr.w	r8, [r1, #448]	; 0x1c0
 800e62a:	f8d1 219c 	ldr.w	r2, [r1, #412]	; 0x19c
 800e62e:	fbc2 070a 	smlal	r0, r7, r2, sl
 800e632:	fbc2 350c 	smlal	r3, r5, r2, ip
 800e636:	fbc8 0709 	smlal	r0, r7, r8, r9
 800e63a:	fbc8 350a 	smlal	r3, r5, r8, sl
	return x >> n;
 800e63e:	0d24      	lsrs	r4, r4, #20
 800e640:	ea44 340e 	orr.w	r4, r4, lr, lsl #12
	sign = x >> 31;
 800e644:	ea4f 7ee4 	mov.w	lr, r4, asr #31
	if (sign != (x >> 15))
 800e648:	ebbe 5f64 	cmp.w	lr, r4, asr #21
		x = sign ^ ((1 << 15) - 1);
 800e64c:	bf18      	it	ne
 800e64e:	f48e 44ff 	eorne.w	r4, lr, #32640	; 0x7f80
	return (short)x;
 800e652:	9a00      	ldr	r2, [sp, #0]
	x >>= fracBits;
 800e654:	bf0c      	ite	eq
 800e656:	11a4      	asreq	r4, r4, #6
		x = sign ^ ((1 << 15) - 1);
 800e658:	f084 047f 	eorne.w	r4, r4, #127	; 0x7f
	return (short)x;
 800e65c:	f822 4c04 	strh.w	r4, [r2, #-4]
 800e660:	0d00      	lsrs	r0, r0, #20
 800e662:	9a02      	ldr	r2, [sp, #8]
 800e664:	ea40 3007 	orr.w	r0, r0, r7, lsl #12
	sign = x >> 31;
 800e668:	17c7      	asrs	r7, r0, #31
 800e66a:	0d12      	lsrs	r2, r2, #20
 800e66c:	ea42 3206 	orr.w	r2, r2, r6, lsl #12
	if (sign != (x >> 15))
 800e670:	ebb7 5f60 	cmp.w	r7, r0, asr #21
	sign = x >> 31;
 800e674:	ea4f 74e2 	mov.w	r4, r2, asr #31
		x = sign ^ ((1 << 15) - 1);
 800e678:	bf18      	it	ne
 800e67a:	f487 40ff 	eorne.w	r0, r7, #32640	; 0x7f80
	return (short)x;
 800e67e:	9e00      	ldr	r6, [sp, #0]
 800e680:	ea4f 5313 	mov.w	r3, r3, lsr #20
 800e684:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
	x >>= fracBits;
 800e688:	bf0c      	ite	eq
 800e68a:	1180      	asreq	r0, r0, #6
		x = sign ^ ((1 << 15) - 1);
 800e68c:	f080 007f 	eorne.w	r0, r0, #127	; 0x7f
	if (sign != (x >> 15))
 800e690:	ebb4 5f62 	cmp.w	r4, r2, asr #21
		x = sign ^ ((1 << 15) - 1);
 800e694:	bf18      	it	ne
 800e696:	f484 42ff 	eorne.w	r2, r4, #32640	; 0x7f80
	return (short)x;
 800e69a:	f826 0c02 	strh.w	r0, [r6, #-2]
	sign = x >> 31;
 800e69e:	ea4f 70e3 	mov.w	r0, r3, asr #31
	x >>= fracBits;
 800e6a2:	bf0c      	ite	eq
 800e6a4:	1192      	asreq	r2, r2, #6
		x = sign ^ ((1 << 15) - 1);
 800e6a6:	f082 027f 	eorne.w	r2, r2, #127	; 0x7f
	if (sign != (x >> 15))
 800e6aa:	ebb0 5f63 	cmp.w	r0, r3, asr #21
	return (short)x;
 800e6ae:	9c01      	ldr	r4, [sp, #4]
		x = sign ^ ((1 << 15) - 1);
 800e6b0:	bf16      	itet	ne
 800e6b2:	f480 43ff 	eorne.w	r3, r0, #32640	; 0x7f80
	x >>= fracBits;
 800e6b6:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 800e6b8:	f083 037f 	eorne.w	r3, r3, #127	; 0x7f
	return (short)x;
 800e6bc:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
 800e6c0:	9b00      	ldr	r3, [sp, #0]
 800e6c2:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
 800e6c6:	3304      	adds	r3, #4
 800e6c8:	9300      	str	r3, [sp, #0]
 800e6ca:	1f23      	subs	r3, r4, #4
 800e6cc:	9301      	str	r3, [sp, #4]
	for (i = 15; i > 0; i--) {
 800e6ce:	9b03      	ldr	r3, [sp, #12]
 800e6d0:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
 800e6d4:	459b      	cmp	fp, r3
 800e6d6:	f501 7180 	add.w	r1, r1, #256	; 0x100
 800e6da:	f47f aea6 	bne.w	800e42a <xmp3fixpt_PolyphaseStereo+0x296>
		*(pcm + 1)         = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 0) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 1) = ClipToShort((int)SAR64(sum2R, (32-CSHIFT)), DEF_NFRACBITS);
		pcm += 2;
	}
}
 800e6de:	b005      	add	sp, #20
 800e6e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800e6e4 <xmp3fixpt_UnpackScaleFactors>:
 *              updated bitOffset
 *
 * Return:      length (in bytes) of scale factor data, -1 if null input pointers
 **************************************************************************************/
int UnpackScaleFactors(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int bitsAvail, int gr, int ch)
{
 800e6e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e6e8:	b099      	sub	sp, #100	; 0x64
 800e6ea:	f8dd a08c 	ldr.w	sl, [sp, #140]	; 0x8c
	FrameHeader *fh;
	SideInfo *si;
	ScaleFactorInfo *sfi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS)
 800e6ee:	2800      	cmp	r0, #0
 800e6f0:	f000 841f 	beq.w	800ef32 <xmp3fixpt_UnpackScaleFactors+0x84e>
 800e6f4:	6804      	ldr	r4, [r0, #0]
 800e6f6:	2c00      	cmp	r4, #0
 800e6f8:	f000 841b 	beq.w	800ef32 <xmp3fixpt_UnpackScaleFactors+0x84e>
 800e6fc:	6845      	ldr	r5, [r0, #4]
 800e6fe:	9500      	str	r5, [sp, #0]
 800e700:	2d00      	cmp	r5, #0
 800e702:	f000 8416 	beq.w	800ef32 <xmp3fixpt_UnpackScaleFactors+0x84e>
 800e706:	6886      	ldr	r6, [r0, #8]
 800e708:	2e00      	cmp	r6, #0
 800e70a:	f000 8412 	beq.w	800ef32 <xmp3fixpt_UnpackScaleFactors+0x84e>
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));

	/* init GetBits reader */
	startBuf = buf;
	bsi = &bitStreamInfo;
	SetBitstreamPointer(bsi, (bitsAvail + *bitOffset + 7) / 8, buf);
 800e70e:	6815      	ldr	r5, [r2, #0]
 800e710:	9008      	str	r0, [sp, #32]
 800e712:	442b      	add	r3, r5
 800e714:	1ddd      	adds	r5, r3, #7
 800e716:	bf48      	it	mi
 800e718:	f103 050e 	addmi.w	r5, r3, #14
 800e71c:	4617      	mov	r7, r2
 800e71e:	9207      	str	r2, [sp, #28]
 800e720:	9106      	str	r1, [sp, #24]
 800e722:	460a      	mov	r2, r1
 800e724:	a80c      	add	r0, sp, #48	; 0x30
 800e726:	10e9      	asrs	r1, r5, #3
 800e728:	f7fa f872 	bl	8008810 <xmp3fixpt_SetBitstreamPointer>
	if (*bitOffset)
 800e72c:	6839      	ldr	r1, [r7, #0]
 800e72e:	2900      	cmp	r1, #0
 800e730:	f040 81b6 	bne.w	800eaa0 <xmp3fixpt_UnpackScaleFactors+0x3bc>
		GetBits(bsi, *bitOffset);

	if (fh->ver == MPEG1) 
 800e734:	7823      	ldrb	r3, [r4, #0]
 800e736:	2b00      	cmp	r3, #0
 800e738:	f040 80e0 	bne.w	800e8fc <xmp3fixpt_UnpackScaleFactors+0x218>
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 800e73c:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800e73e:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800e740:	00db      	lsls	r3, r3, #3
 800e742:	9301      	str	r3, [sp, #4]
 800e744:	4413      	add	r3, r2
 800e746:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 800e74a:	9202      	str	r2, [sp, #8]
 800e74c:	011b      	lsls	r3, r3, #4
 800e74e:	4452      	add	r2, sl
 800e750:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e754:	9a00      	ldr	r2, [sp, #0]
 800e756:	4413      	add	r3, r2
 800e758:	4a67      	ldr	r2, [pc, #412]	; (800e8f8 <xmp3fixpt_UnpackScaleFactors+0x214>)
 800e75a:	6b59      	ldr	r1, [r3, #52]	; 0x34
	if (sis->blockType == 2) {
 800e75c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 800e75e:	f812 5011 	ldrb.w	r5, [r2, r1, lsl #1]
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 800e762:	eb02 0441 	add.w	r4, r2, r1, lsl #1
	if (sis->blockType == 2) {
 800e766:	2802      	cmp	r0, #2
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 800e768:	7864      	ldrb	r4, [r4, #1]
	if (sis->blockType == 2) {
 800e76a:	f000 82b3 	beq.w	800ecd4 <xmp3fixpt_UnpackScaleFactors+0x5f0>
		if(gr == 0) {
 800e76e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800e770:	2b00      	cmp	r3, #0
 800e772:	f000 81c2 	beq.w	800eafa <xmp3fixpt_UnpackScaleFactors+0x416>
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 800e776:	ea4f 130a 	mov.w	r3, sl, lsl #4
 800e77a:	3308      	adds	r3, #8
 800e77c:	9900      	ldr	r1, [sp, #0]
 800e77e:	eb01 0803 	add.w	r8, r1, r3
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800e782:	58cb      	ldr	r3, [r1, r3]
 800e784:	2b00      	cmp	r3, #0
 800e786:	f000 82f3 	beq.w	800ed70 <xmp3fixpt_UnpackScaleFactors+0x68c>
 800e78a:	ea4f 134a 	mov.w	r3, sl, lsl #5
 800e78e:	eba3 010a 	sub.w	r1, r3, sl
 800e792:	9304      	str	r3, [sp, #16]
 800e794:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800e796:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800e798:	015b      	lsls	r3, r3, #5
 800e79a:	0049      	lsls	r1, r1, #1
 800e79c:	1a9a      	subs	r2, r3, r2
 800e79e:	0092      	lsls	r2, r2, #2
 800e7a0:	9303      	str	r3, [sp, #12]
 800e7a2:	1d0b      	adds	r3, r1, #4
 800e7a4:	1898      	adds	r0, r3, r2
 800e7a6:	4288      	cmp	r0, r1
 800e7a8:	440a      	add	r2, r1
 800e7aa:	dd02      	ble.n	800e7b2 <xmp3fixpt_UnpackScaleFactors+0xce>
 800e7ac:	4293      	cmp	r3, r2
 800e7ae:	f300 838a 	bgt.w	800eec6 <xmp3fixpt_UnpackScaleFactors+0x7e2>
 800e7b2:	5871      	ldr	r1, [r6, r1]
 800e7b4:	9b04      	ldr	r3, [sp, #16]
 800e7b6:	50b1      	str	r1, [r6, r2]
 800e7b8:	9922      	ldr	r1, [sp, #136]	; 0x88
 800e7ba:	9a03      	ldr	r2, [sp, #12]
 800e7bc:	eba3 030a 	sub.w	r3, r3, sl
 800e7c0:	1a52      	subs	r2, r2, r1
 800e7c2:	005b      	lsls	r3, r3, #1
 800e7c4:	18f1      	adds	r1, r6, r3
 800e7c6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800e7ca:	4433      	add	r3, r6
 800e7cc:	790a      	ldrb	r2, [r1, #4]
 800e7ce:	711a      	strb	r2, [r3, #4]
 800e7d0:	794a      	ldrb	r2, [r1, #5]
 800e7d2:	715a      	strb	r2, [r3, #5]
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800e7d4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800e7d8:	2b00      	cmp	r3, #0
 800e7da:	f000 82e6 	beq.w	800edaa <xmp3fixpt_UnpackScaleFactors+0x6c6>
 800e7de:	9b04      	ldr	r3, [sp, #16]
 800e7e0:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800e7e2:	eba3 010a 	sub.w	r1, r3, sl
 800e7e6:	9b03      	ldr	r3, [sp, #12]
 800e7e8:	0049      	lsls	r1, r1, #1
 800e7ea:	1a9a      	subs	r2, r3, r2
 800e7ec:	0092      	lsls	r2, r2, #2
 800e7ee:	f101 030a 	add.w	r3, r1, #10
 800e7f2:	189d      	adds	r5, r3, r2
 800e7f4:	1d88      	adds	r0, r1, #6
 800e7f6:	4285      	cmp	r5, r0
 800e7f8:	440a      	add	r2, r1
 800e7fa:	4431      	add	r1, r6
 800e7fc:	dd03      	ble.n	800e806 <xmp3fixpt_UnpackScaleFactors+0x122>
 800e7fe:	1d90      	adds	r0, r2, #6
 800e800:	4283      	cmp	r3, r0
 800e802:	f300 838a 	bgt.w	800ef1a <xmp3fixpt_UnpackScaleFactors+0x836>
 800e806:	9b04      	ldr	r3, [sp, #16]
 800e808:	9d22      	ldr	r5, [sp, #136]	; 0x88
 800e80a:	f8d1 1006 	ldr.w	r1, [r1, #6]
 800e80e:	18b0      	adds	r0, r6, r2
 800e810:	9a03      	ldr	r2, [sp, #12]
 800e812:	f8c0 1006 	str.w	r1, [r0, #6]
 800e816:	eba3 030a 	sub.w	r3, r3, sl
 800e81a:	005b      	lsls	r3, r3, #1
 800e81c:	1b52      	subs	r2, r2, r5
 800e81e:	18f1      	adds	r1, r6, r3
 800e820:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800e824:	4433      	add	r3, r6
 800e826:	7a8a      	ldrb	r2, [r1, #10]
 800e828:	729a      	strb	r2, [r3, #10]
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800e82a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800e82e:	2b00      	cmp	r3, #0
 800e830:	f000 82d5 	beq.w	800edde <xmp3fixpt_UnpackScaleFactors+0x6fa>
 800e834:	9b04      	ldr	r3, [sp, #16]
 800e836:	9922      	ldr	r1, [sp, #136]	; 0x88
 800e838:	9a03      	ldr	r2, [sp, #12]
 800e83a:	eba3 030a 	sub.w	r3, r3, sl
 800e83e:	005b      	lsls	r3, r3, #1
 800e840:	1a52      	subs	r2, r2, r1
 800e842:	0092      	lsls	r2, r2, #2
 800e844:	f103 010f 	add.w	r1, r3, #15
 800e848:	188d      	adds	r5, r1, r2
 800e84a:	f103 000b 	add.w	r0, r3, #11
 800e84e:	4285      	cmp	r5, r0
 800e850:	441a      	add	r2, r3
 800e852:	dd04      	ble.n	800e85e <xmp3fixpt_UnpackScaleFactors+0x17a>
 800e854:	f102 000b 	add.w	r0, r2, #11
 800e858:	4281      	cmp	r1, r0
 800e85a:	f300 8351 	bgt.w	800ef00 <xmp3fixpt_UnpackScaleFactors+0x81c>
 800e85e:	18f1      	adds	r1, r6, r3
 800e860:	9b04      	ldr	r3, [sp, #16]
 800e862:	9d22      	ldr	r5, [sp, #136]	; 0x88
 800e864:	f8d1 100b 	ldr.w	r1, [r1, #11]
 800e868:	18b0      	adds	r0, r6, r2
 800e86a:	9a03      	ldr	r2, [sp, #12]
 800e86c:	f8c0 100b 	str.w	r1, [r0, #11]
 800e870:	eba3 030a 	sub.w	r3, r3, sl
 800e874:	005b      	lsls	r3, r3, #1
 800e876:	1b52      	subs	r2, r2, r5
 800e878:	18f1      	adds	r1, r6, r3
 800e87a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800e87e:	4433      	add	r3, r6
 800e880:	7bca      	ldrb	r2, [r1, #15]
 800e882:	73da      	strb	r2, [r3, #15]
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800e884:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800e888:	2b00      	cmp	r3, #0
 800e88a:	f000 82c0 	beq.w	800ee0e <xmp3fixpt_UnpackScaleFactors+0x72a>
 800e88e:	9b04      	ldr	r3, [sp, #16]
 800e890:	9922      	ldr	r1, [sp, #136]	; 0x88
 800e892:	9a03      	ldr	r2, [sp, #12]
 800e894:	eba3 030a 	sub.w	r3, r3, sl
 800e898:	005b      	lsls	r3, r3, #1
 800e89a:	1a52      	subs	r2, r2, r1
 800e89c:	0092      	lsls	r2, r2, #2
 800e89e:	f103 0114 	add.w	r1, r3, #20
 800e8a2:	188c      	adds	r4, r1, r2
 800e8a4:	f103 0010 	add.w	r0, r3, #16
 800e8a8:	4284      	cmp	r4, r0
 800e8aa:	441a      	add	r2, r3
 800e8ac:	dd04      	ble.n	800e8b8 <xmp3fixpt_UnpackScaleFactors+0x1d4>
 800e8ae:	f102 0010 	add.w	r0, r2, #16
 800e8b2:	4281      	cmp	r1, r0
 800e8b4:	f300 8316 	bgt.w	800eee4 <xmp3fixpt_UnpackScaleFactors+0x800>
 800e8b8:	18f1      	adds	r1, r6, r3
 800e8ba:	9b04      	ldr	r3, [sp, #16]
 800e8bc:	9c22      	ldr	r4, [sp, #136]	; 0x88
 800e8be:	6909      	ldr	r1, [r1, #16]
 800e8c0:	18b0      	adds	r0, r6, r2
 800e8c2:	9a03      	ldr	r2, [sp, #12]
 800e8c4:	6101      	str	r1, [r0, #16]
 800e8c6:	eba3 030a 	sub.w	r3, r3, sl
 800e8ca:	005b      	lsls	r3, r3, #1
 800e8cc:	1b12      	subs	r2, r2, r4
 800e8ce:	18f1      	adds	r1, r6, r3
 800e8d0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800e8d4:	4433      	add	r3, r6
 800e8d6:	7d0a      	ldrb	r2, [r1, #20]
 800e8d8:	751a      	strb	r2, [r3, #20]
 800e8da:	4622      	mov	r2, r4
		sfis->l[21] = 0;
 800e8dc:	9b03      	ldr	r3, [sp, #12]
 800e8de:	1a9b      	subs	r3, r3, r2
 800e8e0:	9a04      	ldr	r2, [sp, #16]
 800e8e2:	009b      	lsls	r3, r3, #2
 800e8e4:	eba2 020a 	sub.w	r2, r2, sl
 800e8e8:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800e8ec:	441e      	add	r6, r3
 800e8ee:	2300      	movs	r3, #0
 800e8f0:	7573      	strb	r3, [r6, #21]
		sfis->l[22] = 0;
 800e8f2:	75b3      	strb	r3, [r6, #22]
 800e8f4:	e0b2      	b.n	800ea5c <xmp3fixpt_UnpackScaleFactors+0x378>
 800e8f6:	bf00      	nop
 800e8f8:	080171c4 	.word	0x080171c4
	sfCompress = sis->sfCompress;
 800e8fc:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800e8fe:	9a22      	ldr	r2, [sp, #136]	; 0x88
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 800e900:	6a21      	ldr	r1, [r4, #32]
	sfCompress = sis->sfCompress;
 800e902:	00db      	lsls	r3, r3, #3
 800e904:	9301      	str	r3, [sp, #4]
 800e906:	4413      	add	r3, r2
 800e908:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 800e90c:	9202      	str	r2, [sp, #8]
 800e90e:	011b      	lsls	r3, r3, #4
 800e910:	4452      	add	r2, sl
 800e912:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e916:	9a00      	ldr	r2, [sp, #0]
 800e918:	4413      	add	r3, r2
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 800e91a:	f011 0101 	ands.w	r1, r1, #1
	sfCompress = sis->sfCompress;
 800e91e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 800e920:	d003      	beq.n	800e92a <xmp3fixpt_UnpackScaleFactors+0x246>
 800e922:	f1ba 0f01 	cmp.w	sl, #1
 800e926:	f000 811e 	beq.w	800eb66 <xmp3fixpt_UnpackScaleFactors+0x482>
		if (sfCompress < 400) {
 800e92a:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 800e92e:	f280 80bb 	bge.w	800eaa8 <xmp3fixpt_UnpackScaleFactors+0x3c4>
			slen[0] = (sfCompress >> 4) / 5;
 800e932:	48a6      	ldr	r0, [pc, #664]	; (800ebcc <xmp3fixpt_UnpackScaleFactors+0x4e8>)
 800e934:	111a      	asrs	r2, r3, #4
 800e936:	fb80 4002 	smull	r4, r0, r0, r2
 800e93a:	17dc      	asrs	r4, r3, #31
 800e93c:	ebc4 0460 	rsb	r4, r4, r0, asr #1
			slen[1]= (sfCompress >> 4) % 5;
 800e940:	eb04 0084 	add.w	r0, r4, r4, lsl #2
 800e944:	1a12      	subs	r2, r2, r0
	intensityScale = 0;
 800e946:	f04f 0800 	mov.w	r8, #0
			slen[2]= (sfCompress & 0x0f) >> 2;
 800e94a:	f3c3 0081 	ubfx	r0, r3, #2, #2
			slen[3]= (sfCompress & 0x03);
 800e94e:	f003 0303 	and.w	r3, r3, #3
			slen[1]= (sfCompress >> 4) % 5;
 800e952:	9211      	str	r2, [sp, #68]	; 0x44
			slen[0] = (sfCompress >> 4) / 5;
 800e954:	9410      	str	r4, [sp, #64]	; 0x40
			slen[2]= (sfCompress & 0x0f) >> 2;
 800e956:	9012      	str	r0, [sp, #72]	; 0x48
			slen[3]= (sfCompress & 0x03);
 800e958:	9313      	str	r3, [sp, #76]	; 0x4c
	preFlag = 0;
 800e95a:	46c4      	mov	ip, r8
			sfcIdx = 0;
 800e95c:	4642      	mov	r2, r8
	if (sis->blockType == 2) 
 800e95e:	9822      	ldr	r0, [sp, #136]	; 0x88
 800e960:	9b01      	ldr	r3, [sp, #4]
 800e962:	4403      	add	r3, r0
 800e964:	9802      	ldr	r0, [sp, #8]
 800e966:	011b      	lsls	r3, r3, #4
 800e968:	4450      	add	r0, sl
 800e96a:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800e96e:	9800      	ldr	r0, [sp, #0]
 800e970:	4403      	add	r3, r0
 800e972:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 800e974:	2d02      	cmp	r5, #2
 800e976:	f000 81a7 	beq.w	800ecc8 <xmp3fixpt_UnpackScaleFactors+0x5e4>
	btIdx = 0;
 800e97a:	2000      	movs	r0, #0
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];
 800e97c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800e980:	4b93      	ldr	r3, [pc, #588]	; (800ebd0 <xmp3fixpt_UnpackScaleFactors+0x4ec>)
 800e982:	4402      	add	r2, r0
 800e984:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800e988:	f893 2020 	ldrb.w	r2, [r3, #32]
 800e98c:	f893 0021 	ldrb.w	r0, [r3, #33]	; 0x21
 800e990:	9214      	str	r2, [sp, #80]	; 0x50
 800e992:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800e996:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 800e99a:	9317      	str	r3, [sp, #92]	; 0x5c
 800e99c:	ab10      	add	r3, sp, #64	; 0x40
 800e99e:	9015      	str	r0, [sp, #84]	; 0x54
 800e9a0:	9216      	str	r2, [sp, #88]	; 0x58
 800e9a2:	9305      	str	r3, [sp, #20]
	if( (modeExt & 0x01) && (ch == 1) ) {
 800e9a4:	b119      	cbz	r1, 800e9ae <xmp3fixpt_UnpackScaleFactors+0x2ca>
 800e9a6:	f1ba 0f01 	cmp.w	sl, #1
 800e9aa:	f000 80f4 	beq.w	800eb96 <xmp3fixpt_UnpackScaleFactors+0x4b2>
 800e9ae:	ab14      	add	r3, sp, #80	; 0x50
 800e9b0:	930b      	str	r3, [sp, #44]	; 0x2c
	sis->preFlag = preFlag;
 800e9b2:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800e9b4:	9b01      	ldr	r3, [sp, #4]
 800e9b6:	4413      	add	r3, r2
 800e9b8:	9a02      	ldr	r2, [sp, #8]
 800e9ba:	011b      	lsls	r3, r3, #4
 800e9bc:	4452      	add	r2, sl
 800e9be:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e9c2:	9a00      	ldr	r2, [sp, #0]
 800e9c4:	4413      	add	r3, r2
	if(sis->blockType == 2) {
 800e9c6:	2d02      	cmp	r5, #2
	sis->preFlag = preFlag;
 800e9c8:	f8c3 c064 	str.w	ip, [r3, #100]	; 0x64
	if(sis->blockType == 2) {
 800e9cc:	f000 8104 	beq.w	800ebd8 <xmp3fixpt_UnpackScaleFactors+0x4f4>
 800e9d0:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800e9d2:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800e9d4:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800e9d8:	f8cd a08c 	str.w	sl, [sp, #140]	; 0x8c
 800e9dc:	015b      	lsls	r3, r3, #5
 800e9de:	9303      	str	r3, [sp, #12]
 800e9e0:	1a9b      	subs	r3, r3, r2
 800e9e2:	ea4f 124a 	mov.w	r2, sl, lsl #5
 800e9e6:	4611      	mov	r1, r2
 800e9e8:	9204      	str	r2, [sp, #16]
 800e9ea:	009a      	lsls	r2, r3, #2
 800e9ec:	eba1 030a 	sub.w	r3, r1, sl
 800e9f0:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800e9f4:	9309      	str	r3, [sp, #36]	; 0x24
 800e9f6:	f04f 0800 	mov.w	r8, #0
 800e9fa:	3b01      	subs	r3, #1
 800e9fc:	930a      	str	r3, [sp, #40]	; 0x28
 800e9fe:	4647      	mov	r7, r8
 800ea00:	46b1      	mov	r9, r6
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 800ea02:	f85b 6027 	ldr.w	r6, [fp, r7, lsl #2]
			iipTest = (1 << slen[nrIdx]) - 1;
 800ea06:	9b05      	ldr	r3, [sp, #20]
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 800ea08:	2e00      	cmp	r6, #0
			iipTest = (1 << slen[nrIdx]) - 1;
 800ea0a:	f853 5027 	ldr.w	r5, [r3, r7, lsl #2]
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 800ea0e:	dd12      	ble.n	800ea36 <xmp3fixpt_UnpackScaleFactors+0x352>
 800ea10:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ea12:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800ea14:	4443      	add	r3, r8
 800ea16:	eb02 0408 	add.w	r4, r2, r8
 800ea1a:	3b01      	subs	r3, #1
 800ea1c:	4434      	add	r4, r6
 800ea1e:	eb09 0a03 	add.w	sl, r9, r3
 800ea22:	444c      	add	r4, r9
				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
 800ea24:	4629      	mov	r1, r5
 800ea26:	a80c      	add	r0, sp, #48	; 0x30
 800ea28:	f7f9 fef8 	bl	800881c <xmp3fixpt_GetBits>
 800ea2c:	f80a 0f01 	strb.w	r0, [sl, #1]!
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 800ea30:	45a2      	cmp	sl, r4
 800ea32:	d1f7      	bne.n	800ea24 <xmp3fixpt_UnpackScaleFactors+0x340>
 800ea34:	44b0      	add	r8, r6
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 800ea36:	3701      	adds	r7, #1
 800ea38:	2f04      	cmp	r7, #4
 800ea3a:	d1e2      	bne.n	800ea02 <xmp3fixpt_UnpackScaleFactors+0x31e>
		sfis->l[21] = sfis->l[22] = 0;
 800ea3c:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ea3e:	9b03      	ldr	r3, [sp, #12]
 800ea40:	f8dd a08c 	ldr.w	sl, [sp, #140]	; 0x8c
 800ea44:	1a9b      	subs	r3, r3, r2
 800ea46:	9a04      	ldr	r2, [sp, #16]
 800ea48:	009b      	lsls	r3, r3, #2
 800ea4a:	eba2 020a 	sub.w	r2, r2, sl
 800ea4e:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800ea52:	464e      	mov	r6, r9
 800ea54:	441e      	add	r6, r3
 800ea56:	2300      	movs	r3, #0
 800ea58:	75b3      	strb	r3, [r6, #22]
 800ea5a:	7573      	strb	r3, [r6, #21]
	else 
		UnpackSFMPEG2(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], gr, ch, fh->modeExt, &sfi->sfjs);

	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 800ea5c:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ea5e:	9b01      	ldr	r3, [sp, #4]
 800ea60:	9908      	ldr	r1, [sp, #32]

	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 800ea62:	9c07      	ldr	r4, [sp, #28]
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 800ea64:	4413      	add	r3, r2
 800ea66:	9a02      	ldr	r2, [sp, #8]
 800ea68:	011b      	lsls	r3, r3, #4
 800ea6a:	4452      	add	r2, sl
 800ea6c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800ea70:	9a00      	ldr	r2, [sp, #0]
 800ea72:	441a      	add	r2, r3
 800ea74:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800ea76:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800ea78:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
 800ea7c:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 800ea80:	a80c      	add	r0, sp, #48	; 0x30
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 800ea82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 800ea86:	9906      	ldr	r1, [sp, #24]
 800ea88:	6822      	ldr	r2, [r4, #0]
 800ea8a:	f7f9 ff31 	bl	80088f0 <xmp3fixpt_CalcBitsUsed>
	buf += (bitsUsed + *bitOffset) >> 3;
 800ea8e:	6823      	ldr	r3, [r4, #0]
 800ea90:	4418      	add	r0, r3
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 800ea92:	f000 0307 	and.w	r3, r0, #7
 800ea96:	6023      	str	r3, [r4, #0]
	buf += (bitsUsed + *bitOffset) >> 3;
 800ea98:	10c0      	asrs	r0, r0, #3

	return (buf - startBuf);
}
 800ea9a:	b019      	add	sp, #100	; 0x64
 800ea9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		GetBits(bsi, *bitOffset);
 800eaa0:	a80c      	add	r0, sp, #48	; 0x30
 800eaa2:	f7f9 febb 	bl	800881c <xmp3fixpt_GetBits>
 800eaa6:	e645      	b.n	800e734 <xmp3fixpt_UnpackScaleFactors+0x50>
		} else if (sfCompress < 500) {
 800eaa8:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 800eaac:	db44      	blt.n	800eb38 <xmp3fixpt_UnpackScaleFactors+0x454>
			if (sis->mixedBlock) {
 800eaae:	9822      	ldr	r0, [sp, #136]	; 0x88
 800eab0:	9a01      	ldr	r2, [sp, #4]
			slen[0] = sfCompress / 3;
 800eab2:	4c48      	ldr	r4, [pc, #288]	; (800ebd4 <xmp3fixpt_UnpackScaleFactors+0x4f0>)
			if (sis->mixedBlock) {
 800eab4:	4402      	add	r2, r0
 800eab6:	9802      	ldr	r0, [sp, #8]
			sfCompress -= 500;
 800eab8:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
			if (sis->mixedBlock) {
 800eabc:	4450      	add	r0, sl
 800eabe:	0112      	lsls	r2, r2, #4
 800eac0:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
			slen[0] = sfCompress / 3;
 800eac4:	fb84 0403 	smull	r0, r4, r4, r3
			if (sis->mixedBlock) {
 800eac8:	9800      	ldr	r0, [sp, #0]
 800eaca:	4402      	add	r2, r0
			slen[0] = sfCompress / 3;
 800eacc:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
			slen[1] = sfCompress % 3;
 800ead0:	eb04 0044 	add.w	r0, r4, r4, lsl #1
			if (sis->mixedBlock) {
 800ead4:	f8d2 8040 	ldr.w	r8, [r2, #64]	; 0x40
			slen[0] = sfCompress / 3;
 800ead8:	9410      	str	r4, [sp, #64]	; 0x40
			slen[2] = slen[3] = 0;
 800eada:	2200      	movs	r2, #0
			slen[1] = sfCompress % 3;
 800eadc:	1a1b      	subs	r3, r3, r0
 800eade:	9311      	str	r3, [sp, #68]	; 0x44
			slen[2] = slen[3] = 0;
 800eae0:	9213      	str	r2, [sp, #76]	; 0x4c
 800eae2:	9212      	str	r2, [sp, #72]	; 0x48
			if (sis->mixedBlock) {
 800eae4:	f1b8 0f00 	cmp.w	r8, #0
 800eae8:	f000 81ce 	beq.w	800ee88 <xmp3fixpt_UnpackScaleFactors+0x7a4>
	intensityScale = 0;
 800eaec:	4690      	mov	r8, r2
				slen[2] = slen[1];  
 800eaee:	9312      	str	r3, [sp, #72]	; 0x48
				slen[1] = slen[0];
 800eaf0:	9411      	str	r4, [sp, #68]	; 0x44
			preFlag = 1;
 800eaf2:	f04f 0c01 	mov.w	ip, #1
			sfcIdx = 2;
 800eaf6:	2202      	movs	r2, #2
 800eaf8:	e731      	b.n	800e95e <xmp3fixpt_UnpackScaleFactors+0x27a>
 800eafa:	ebca 174a 	rsb	r7, sl, sl, lsl #5
 800eafe:	007f      	lsls	r7, r7, #1
 800eb00:	f107 39ff 	add.w	r9, r7, #4294967295
 800eb04:	f107 080a 	add.w	r8, r7, #10
 800eb08:	44b1      	add	r9, r6
 800eb0a:	44b0      	add	r8, r6
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
 800eb0c:	4629      	mov	r1, r5
 800eb0e:	a80c      	add	r0, sp, #48	; 0x30
 800eb10:	f7f9 fe84 	bl	800881c <xmp3fixpt_GetBits>
 800eb14:	f809 0f01 	strb.w	r0, [r9, #1]!
			for (sfb = 0;  sfb < 11; sfb++) 
 800eb18:	45c8      	cmp	r8, r9
 800eb1a:	d1f7      	bne.n	800eb0c <xmp3fixpt_UnpackScaleFactors+0x428>
 800eb1c:	f107 050b 	add.w	r5, r7, #11
 800eb20:	3715      	adds	r7, #21
 800eb22:	4435      	add	r5, r6
 800eb24:	443e      	add	r6, r7
				sfis->l[sfb] = (char)GetBits(bsi, slen1);
 800eb26:	4621      	mov	r1, r4
 800eb28:	a80c      	add	r0, sp, #48	; 0x30
 800eb2a:	f7f9 fe77 	bl	800881c <xmp3fixpt_GetBits>
 800eb2e:	f805 0b01 	strb.w	r0, [r5], #1
			for (sfb = 11; sfb < 21; sfb++) 
 800eb32:	42ae      	cmp	r6, r5
 800eb34:	d1f7      	bne.n	800eb26 <xmp3fixpt_UnpackScaleFactors+0x442>
 800eb36:	e791      	b.n	800ea5c <xmp3fixpt_UnpackScaleFactors+0x378>
			sfCompress -= 400;
 800eb38:	f5a3 73c8 	sub.w	r3, r3, #400	; 0x190
			slen[0] = (sfCompress >> 2) / 5;
 800eb3c:	4a23      	ldr	r2, [pc, #140]	; (800ebcc <xmp3fixpt_UnpackScaleFactors+0x4e8>)
 800eb3e:	1098      	asrs	r0, r3, #2
 800eb40:	fb82 4200 	smull	r4, r2, r2, r0
 800eb44:	17dc      	asrs	r4, r3, #31
 800eb46:	ebc4 0462 	rsb	r4, r4, r2, asr #1
			slen[1]= (sfCompress >> 2) % 5;
 800eb4a:	eb04 0784 	add.w	r7, r4, r4, lsl #2
			slen[3]= 0;
 800eb4e:	2200      	movs	r2, #0
			slen[2]= (sfCompress & 0x03);
 800eb50:	f003 0303 	and.w	r3, r3, #3
			slen[1]= (sfCompress >> 2) % 5;
 800eb54:	1bc0      	subs	r0, r0, r7
	intensityScale = 0;
 800eb56:	4690      	mov	r8, r2
			slen[3]= 0;
 800eb58:	9213      	str	r2, [sp, #76]	; 0x4c
	preFlag = 0;
 800eb5a:	4694      	mov	ip, r2
			slen[0] = (sfCompress >> 2) / 5;
 800eb5c:	9410      	str	r4, [sp, #64]	; 0x40
			slen[2]= (sfCompress & 0x03);
 800eb5e:	9312      	str	r3, [sp, #72]	; 0x48
			slen[1]= (sfCompress >> 2) % 5;
 800eb60:	9011      	str	r0, [sp, #68]	; 0x44
			sfcIdx = 1;
 800eb62:	2201      	movs	r2, #1
 800eb64:	e6fb      	b.n	800e95e <xmp3fixpt_UnpackScaleFactors+0x27a>
		sfCompress >>= 1;
 800eb66:	105a      	asrs	r2, r3, #1
		if (sfCompress < 180) {
 800eb68:	2ab3      	cmp	r2, #179	; 0xb3
		intensityScale = sfCompress & 0x01;
 800eb6a:	f003 0801 	and.w	r8, r3, #1
		if (sfCompress < 180) {
 800eb6e:	f340 818f 	ble.w	800ee90 <xmp3fixpt_UnpackScaleFactors+0x7ac>
		} else if (sfCompress < 244) {
 800eb72:	2af3      	cmp	r2, #243	; 0xf3
 800eb74:	f300 81e0 	bgt.w	800ef38 <xmp3fixpt_UnpackScaleFactors+0x854>
			sfCompress -= 180;
 800eb78:	f1a2 03b4 	sub.w	r3, r2, #180	; 0xb4
			slen[0] = (sfCompress & 0x3f) >> 4;
 800eb7c:	111c      	asrs	r4, r3, #4
			slen[3] = 0;
 800eb7e:	2200      	movs	r2, #0
			slen[1] = (sfCompress & 0x0f) >> 2;
 800eb80:	f3c3 0081 	ubfx	r0, r3, #2, #2
			slen[2] = (sfCompress & 0x03);
 800eb84:	f003 0303 	and.w	r3, r3, #3
			slen[3] = 0;
 800eb88:	9213      	str	r2, [sp, #76]	; 0x4c
	preFlag = 0;
 800eb8a:	4694      	mov	ip, r2
			slen[0] = (sfCompress & 0x3f) >> 4;
 800eb8c:	9410      	str	r4, [sp, #64]	; 0x40
			slen[1] = (sfCompress & 0x0f) >> 2;
 800eb8e:	9011      	str	r0, [sp, #68]	; 0x44
			slen[2] = (sfCompress & 0x03);
 800eb90:	9312      	str	r3, [sp, #72]	; 0x48
			sfcIdx = 4;
 800eb92:	2204      	movs	r2, #4
 800eb94:	e6e3      	b.n	800e95e <xmp3fixpt_UnpackScaleFactors+0x27a>
 800eb96:	469e      	mov	lr, r3
 800eb98:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800eb9c:	af14      	add	r7, sp, #80	; 0x50
 800eb9e:	f8c6 00fc 	str.w	r0, [r6, #252]	; 0xfc
 800eba2:	f8c6 1100 	str.w	r1, [r6, #256]	; 0x100
 800eba6:	f8c6 2104 	str.w	r2, [r6, #260]	; 0x104
 800ebaa:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
 800ebae:	46be      	mov	lr, r7
 800ebb0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800ebb4:	970b      	str	r7, [sp, #44]	; 0x2c
 800ebb6:	f8c6 010c 	str.w	r0, [r6, #268]	; 0x10c
 800ebba:	f8c6 1110 	str.w	r1, [r6, #272]	; 0x110
 800ebbe:	f8c6 2114 	str.w	r2, [r6, #276]	; 0x114
 800ebc2:	f8c6 3118 	str.w	r3, [r6, #280]	; 0x118
		sfjs->intensityScale = intensityScale;
 800ebc6:	f8c6 80f8 	str.w	r8, [r6, #248]	; 0xf8
 800ebca:	e6f2      	b.n	800e9b2 <xmp3fixpt_UnpackScaleFactors+0x2ce>
 800ebcc:	66666667 	.word	0x66666667
 800ebd0:	080171c4 	.word	0x080171c4
 800ebd4:	55555556 	.word	0x55555556
		if(sis->mixedBlock) {
 800ebd8:	f8d3 8040 	ldr.w	r8, [r3, #64]	; 0x40
 800ebdc:	f1b8 0f00 	cmp.w	r8, #0
 800ebe0:	f000 812e 	beq.w	800ee40 <xmp3fixpt_UnpackScaleFactors+0x75c>
 800ebe4:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ebe6:	9922      	ldr	r1, [sp, #136]	; 0x88
 800ebe8:	ea4f 134a 	mov.w	r3, sl, lsl #5
 800ebec:	0152      	lsls	r2, r2, #5
 800ebee:	9304      	str	r3, [sp, #16]
 800ebf0:	9203      	str	r2, [sp, #12]
 800ebf2:	eba3 030a 	sub.w	r3, r3, sl
 800ebf6:	1a52      	subs	r2, r2, r1
 800ebf8:	005b      	lsls	r3, r3, #1
 800ebfa:	0092      	lsls	r2, r2, #2
 800ebfc:	189f      	adds	r7, r3, r2
 800ebfe:	1d5d      	adds	r5, r3, #5
 800ec00:	3f01      	subs	r7, #1
 800ec02:	4415      	add	r5, r2
 800ec04:	4437      	add	r7, r6
 800ec06:	4435      	add	r5, r6
				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
 800ec08:	4621      	mov	r1, r4
 800ec0a:	a80c      	add	r0, sp, #48	; 0x30
 800ec0c:	f7f9 fe06 	bl	800881c <xmp3fixpt_GetBits>
 800ec10:	f807 0f01 	strb.w	r0, [r7, #1]!
			for (sfb=0; sfb < 6; sfb++) {
 800ec14:	42af      	cmp	r7, r5
 800ec16:	d1f7      	bne.n	800ec08 <xmp3fixpt_UnpackScaleFactors+0x524>
 800ec18:	9a03      	ldr	r2, [sp, #12]
			sfb = 3;  /* start sfb for short */
 800ec1a:	2303      	movs	r3, #3
			nrIdx = 1;
 800ec1c:	f04f 0801 	mov.w	r8, #1
 800ec20:	9922      	ldr	r1, [sp, #136]	; 0x88
 800ec22:	f8cd a08c 	str.w	sl, [sp, #140]	; 0x8c
 800ec26:	1a52      	subs	r2, r2, r1
 800ec28:	9904      	ldr	r1, [sp, #16]
 800ec2a:	0092      	lsls	r2, r2, #2
 800ec2c:	eba1 090a 	sub.w	r9, r1, sl
 800ec30:	eb02 0249 	add.w	r2, r2, r9, lsl #1
 800ec34:	9209      	str	r2, [sp, #36]	; 0x24
 800ec36:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800ec38:	9a05      	ldr	r2, [sp, #20]
 800ec3a:	ea4f 0b88 	mov.w	fp, r8, lsl #2
 800ec3e:	445a      	add	r2, fp
 800ec40:	4459      	add	r1, fp
 800ec42:	468b      	mov	fp, r1
 800ec44:	4691      	mov	r9, r2
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 800ec46:	f85b 7b04 	ldr.w	r7, [fp], #4
			iipTest = (1 << slen[nrIdx]) - 1;
 800ec4a:	f859 4b04 	ldr.w	r4, [r9], #4
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 800ec4e:	2f00      	cmp	r7, #0
 800ec50:	dd21      	ble.n	800ec96 <xmp3fixpt_UnpackScaleFactors+0x5b2>
 800ec52:	441f      	add	r7, r3
 800ec54:	9909      	ldr	r1, [sp, #36]	; 0x24
 800ec56:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800ec5a:	eb07 0547 	add.w	r5, r7, r7, lsl #1
 800ec5e:	440b      	add	r3, r1
 800ec60:	440d      	add	r5, r1
 800ec62:	eb06 0a03 	add.w	sl, r6, r3
 800ec66:	4435      	add	r5, r6
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 800ec68:	4621      	mov	r1, r4
 800ec6a:	a80c      	add	r0, sp, #48	; 0x30
 800ec6c:	f7f9 fdd6 	bl	800881c <xmp3fixpt_GetBits>
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 800ec70:	4621      	mov	r1, r4
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 800ec72:	f88a 0017 	strb.w	r0, [sl, #23]
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 800ec76:	a80c      	add	r0, sp, #48	; 0x30
 800ec78:	f7f9 fdd0 	bl	800881c <xmp3fixpt_GetBits>
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 800ec7c:	4621      	mov	r1, r4
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 800ec7e:	f88a 0018 	strb.w	r0, [sl, #24]
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 800ec82:	a80c      	add	r0, sp, #48	; 0x30
 800ec84:	f7f9 fdca 	bl	800881c <xmp3fixpt_GetBits>
 800ec88:	f10a 0a03 	add.w	sl, sl, #3
 800ec8c:	f88a 0016 	strb.w	r0, [sl, #22]
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 800ec90:	45aa      	cmp	sl, r5
 800ec92:	d1e9      	bne.n	800ec68 <xmp3fixpt_UnpackScaleFactors+0x584>
 800ec94:	463b      	mov	r3, r7
		for (    ; nrIdx <= 3; nrIdx++) {
 800ec96:	f108 0801 	add.w	r8, r8, #1
 800ec9a:	f1b8 0f04 	cmp.w	r8, #4
 800ec9e:	d1d2      	bne.n	800ec46 <xmp3fixpt_UnpackScaleFactors+0x562>
 800eca0:	f8dd a08c 	ldr.w	sl, [sp, #140]	; 0x8c
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 800eca4:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800eca6:	9b03      	ldr	r3, [sp, #12]
 800eca8:	1a9b      	subs	r3, r3, r2
 800ecaa:	9a04      	ldr	r2, [sp, #16]
 800ecac:	009b      	lsls	r3, r3, #2
 800ecae:	eba2 020a 	sub.w	r2, r2, sl
 800ecb2:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800ecb6:	441e      	add	r6, r3
 800ecb8:	2300      	movs	r3, #0
 800ecba:	f886 303d 	strb.w	r3, [r6, #61]	; 0x3d
 800ecbe:	f886 303c 	strb.w	r3, [r6, #60]	; 0x3c
 800ecc2:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
 800ecc6:	e6c9      	b.n	800ea5c <xmp3fixpt_UnpackScaleFactors+0x378>
		btIdx = (sis->mixedBlock ? 2 : 1);
 800ecc8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ecca:	2b00      	cmp	r3, #0
 800eccc:	bf0c      	ite	eq
 800ecce:	2001      	moveq	r0, #1
 800ecd0:	2002      	movne	r0, #2
 800ecd2:	e653      	b.n	800e97c <xmp3fixpt_UnpackScaleFactors+0x298>
		if (sis->mixedBlock) {          
 800ecd4:	f8d3 b040 	ldr.w	fp, [r3, #64]	; 0x40
 800ecd8:	ea4f 134a 	mov.w	r3, sl, lsl #5
 800ecdc:	9304      	str	r3, [sp, #16]
 800ecde:	f1bb 0f00 	cmp.w	fp, #0
 800ece2:	f040 80b5 	bne.w	800ee50 <xmp3fixpt_UnpackScaleFactors+0x76c>
 800ece6:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800ece8:	015b      	lsls	r3, r3, #5
 800ecea:	9303      	str	r3, [sp, #12]
 800ecec:	9b04      	ldr	r3, [sp, #16]
 800ecee:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ecf0:	eba3 080a 	sub.w	r8, r3, sl
 800ecf4:	9b03      	ldr	r3, [sp, #12]
 800ecf6:	eba3 0902 	sub.w	r9, r3, r2
 800ecfa:	ea4f 0848 	mov.w	r8, r8, lsl #1
 800ecfe:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800ed02:	eb08 0309 	add.w	r3, r8, r9
 800ed06:	eb0b 074b 	add.w	r7, fp, fp, lsl #1
 800ed0a:	441f      	add	r7, r3
 800ed0c:	9305      	str	r3, [sp, #20]
 800ed0e:	4437      	add	r7, r6
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 800ed10:	4629      	mov	r1, r5
 800ed12:	a80c      	add	r0, sp, #48	; 0x30
 800ed14:	f7f9 fd82 	bl	800881c <xmp3fixpt_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 800ed18:	4629      	mov	r1, r5
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 800ed1a:	75f8      	strb	r0, [r7, #23]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 800ed1c:	a80c      	add	r0, sp, #48	; 0x30
 800ed1e:	f7f9 fd7d 	bl	800881c <xmp3fixpt_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 800ed22:	4629      	mov	r1, r5
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 800ed24:	7638      	strb	r0, [r7, #24]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 800ed26:	a80c      	add	r0, sp, #48	; 0x30
 800ed28:	f7f9 fd78 	bl	800881c <xmp3fixpt_GetBits>
		for (      ; sfb < 6; sfb++) {
 800ed2c:	f10b 0b01 	add.w	fp, fp, #1
 800ed30:	f1bb 0f06 	cmp.w	fp, #6
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 800ed34:	7678      	strb	r0, [r7, #25]
 800ed36:	f107 0703 	add.w	r7, r7, #3
		for (      ; sfb < 6; sfb++) {
 800ed3a:	d1e9      	bne.n	800ed10 <xmp3fixpt_UnpackScaleFactors+0x62c>
 800ed3c:	9f05      	ldr	r7, [sp, #20]
 800ed3e:	f108 0524 	add.w	r5, r8, #36	; 0x24
 800ed42:	444d      	add	r5, r9
 800ed44:	3712      	adds	r7, #18
 800ed46:	4435      	add	r5, r6
 800ed48:	4437      	add	r7, r6
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 800ed4a:	4621      	mov	r1, r4
 800ed4c:	a80c      	add	r0, sp, #48	; 0x30
 800ed4e:	f7f9 fd65 	bl	800881c <xmp3fixpt_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 800ed52:	4621      	mov	r1, r4
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 800ed54:	75f8      	strb	r0, [r7, #23]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 800ed56:	a80c      	add	r0, sp, #48	; 0x30
 800ed58:	f7f9 fd60 	bl	800881c <xmp3fixpt_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 800ed5c:	4621      	mov	r1, r4
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 800ed5e:	7638      	strb	r0, [r7, #24]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 800ed60:	a80c      	add	r0, sp, #48	; 0x30
 800ed62:	f7f9 fd5b 	bl	800881c <xmp3fixpt_GetBits>
 800ed66:	3703      	adds	r7, #3
 800ed68:	75b8      	strb	r0, [r7, #22]
		for (      ; sfb < 12; sfb++) {
 800ed6a:	42af      	cmp	r7, r5
 800ed6c:	d1ed      	bne.n	800ed4a <xmp3fixpt_UnpackScaleFactors+0x666>
 800ed6e:	e799      	b.n	800eca4 <xmp3fixpt_UnpackScaleFactors+0x5c0>
 800ed70:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ed72:	9922      	ldr	r1, [sp, #136]	; 0x88
 800ed74:	ea4f 134a 	mov.w	r3, sl, lsl #5
 800ed78:	0152      	lsls	r2, r2, #5
 800ed7a:	9304      	str	r3, [sp, #16]
 800ed7c:	9203      	str	r2, [sp, #12]
 800ed7e:	eba3 030a 	sub.w	r3, r3, sl
 800ed82:	1a52      	subs	r2, r2, r1
 800ed84:	005b      	lsls	r3, r3, #1
 800ed86:	0092      	lsls	r2, r2, #2
 800ed88:	eb03 0902 	add.w	r9, r3, r2
 800ed8c:	1d5f      	adds	r7, r3, #5
 800ed8e:	f109 39ff 	add.w	r9, r9, #4294967295
 800ed92:	4417      	add	r7, r2
 800ed94:	44b1      	add	r9, r6
 800ed96:	4437      	add	r7, r6
			else          for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 800ed98:	4629      	mov	r1, r5
 800ed9a:	a80c      	add	r0, sp, #48	; 0x30
 800ed9c:	f7f9 fd3e 	bl	800881c <xmp3fixpt_GetBits>
 800eda0:	f809 0f01 	strb.w	r0, [r9, #1]!
 800eda4:	45b9      	cmp	r9, r7
 800eda6:	d1f7      	bne.n	800ed98 <xmp3fixpt_UnpackScaleFactors+0x6b4>
 800eda8:	e514      	b.n	800e7d4 <xmp3fixpt_UnpackScaleFactors+0xf0>
 800edaa:	9b04      	ldr	r3, [sp, #16]
 800edac:	9a03      	ldr	r2, [sp, #12]
 800edae:	9922      	ldr	r1, [sp, #136]	; 0x88
 800edb0:	eba3 030a 	sub.w	r3, r3, sl
 800edb4:	1a52      	subs	r2, r2, r1
 800edb6:	005b      	lsls	r3, r3, #1
 800edb8:	0092      	lsls	r2, r2, #2
 800edba:	eb03 0902 	add.w	r9, r3, r2
 800edbe:	f103 070a 	add.w	r7, r3, #10
 800edc2:	f109 0905 	add.w	r9, r9, #5
 800edc6:	4417      	add	r7, r2
 800edc8:	44b1      	add	r9, r6
 800edca:	4437      	add	r7, r6
			else          for(  ; sfb <11 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 800edcc:	4629      	mov	r1, r5
 800edce:	a80c      	add	r0, sp, #48	; 0x30
 800edd0:	f7f9 fd24 	bl	800881c <xmp3fixpt_GetBits>
 800edd4:	f809 0f01 	strb.w	r0, [r9, #1]!
 800edd8:	45b9      	cmp	r9, r7
 800edda:	d1f7      	bne.n	800edcc <xmp3fixpt_UnpackScaleFactors+0x6e8>
 800eddc:	e525      	b.n	800e82a <xmp3fixpt_UnpackScaleFactors+0x146>
 800edde:	9b04      	ldr	r3, [sp, #16]
 800ede0:	9a03      	ldr	r2, [sp, #12]
 800ede2:	9922      	ldr	r1, [sp, #136]	; 0x88
 800ede4:	eba3 030a 	sub.w	r3, r3, sl
 800ede8:	1a52      	subs	r2, r2, r1
 800edea:	005b      	lsls	r3, r3, #1
 800edec:	0092      	lsls	r2, r2, #2
 800edee:	189f      	adds	r7, r3, r2
 800edf0:	f103 050f 	add.w	r5, r3, #15
 800edf4:	370a      	adds	r7, #10
 800edf6:	4415      	add	r5, r2
 800edf8:	4437      	add	r7, r6
 800edfa:	4435      	add	r5, r6
			else          for(  ; sfb <16 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 800edfc:	4621      	mov	r1, r4
 800edfe:	a80c      	add	r0, sp, #48	; 0x30
 800ee00:	f7f9 fd0c 	bl	800881c <xmp3fixpt_GetBits>
 800ee04:	f807 0f01 	strb.w	r0, [r7, #1]!
 800ee08:	42af      	cmp	r7, r5
 800ee0a:	d1f7      	bne.n	800edfc <xmp3fixpt_UnpackScaleFactors+0x718>
 800ee0c:	e53a      	b.n	800e884 <xmp3fixpt_UnpackScaleFactors+0x1a0>
 800ee0e:	9b04      	ldr	r3, [sp, #16]
 800ee10:	9a03      	ldr	r2, [sp, #12]
 800ee12:	9922      	ldr	r1, [sp, #136]	; 0x88
 800ee14:	eba3 030a 	sub.w	r3, r3, sl
 800ee18:	1a52      	subs	r2, r2, r1
 800ee1a:	005b      	lsls	r3, r3, #1
 800ee1c:	0092      	lsls	r2, r2, #2
 800ee1e:	189f      	adds	r7, r3, r2
 800ee20:	f103 0514 	add.w	r5, r3, #20
 800ee24:	370f      	adds	r7, #15
 800ee26:	4415      	add	r5, r2
 800ee28:	4437      	add	r7, r6
 800ee2a:	4435      	add	r5, r6
			else          for(  ; sfb <21 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 800ee2c:	4621      	mov	r1, r4
 800ee2e:	a80c      	add	r0, sp, #48	; 0x30
 800ee30:	f7f9 fcf4 	bl	800881c <xmp3fixpt_GetBits>
 800ee34:	f807 0f01 	strb.w	r0, [r7, #1]!
 800ee38:	42af      	cmp	r7, r5
 800ee3a:	d1f7      	bne.n	800ee2c <xmp3fixpt_UnpackScaleFactors+0x748>
 800ee3c:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ee3e:	e54d      	b.n	800e8dc <xmp3fixpt_UnpackScaleFactors+0x1f8>
 800ee40:	ea4f 124a 	mov.w	r2, sl, lsl #5
 800ee44:	9204      	str	r2, [sp, #16]
 800ee46:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ee48:	0152      	lsls	r2, r2, #5
			sfb = 0;
 800ee4a:	4643      	mov	r3, r8
 800ee4c:	9203      	str	r2, [sp, #12]
 800ee4e:	e6e7      	b.n	800ec20 <xmp3fixpt_UnpackScaleFactors+0x53c>
 800ee50:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800ee52:	9922      	ldr	r1, [sp, #136]	; 0x88
 800ee54:	0152      	lsls	r2, r2, #5
 800ee56:	9203      	str	r2, [sp, #12]
 800ee58:	eba3 030a 	sub.w	r3, r3, sl
 800ee5c:	1a52      	subs	r2, r2, r1
 800ee5e:	005b      	lsls	r3, r3, #1
 800ee60:	0092      	lsls	r2, r2, #2
 800ee62:	eb02 0803 	add.w	r8, r2, r3
 800ee66:	1ddf      	adds	r7, r3, #7
 800ee68:	f108 38ff 	add.w	r8, r8, #4294967295
 800ee6c:	4417      	add	r7, r2
 800ee6e:	44b0      	add	r8, r6
 800ee70:	4437      	add	r7, r6
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
 800ee72:	4629      	mov	r1, r5
 800ee74:	a80c      	add	r0, sp, #48	; 0x30
 800ee76:	f7f9 fcd1 	bl	800881c <xmp3fixpt_GetBits>
 800ee7a:	f808 0f01 	strb.w	r0, [r8, #1]!
			for (sfb = 0; sfb < 8; sfb++)
 800ee7e:	45b8      	cmp	r8, r7
 800ee80:	d1f7      	bne.n	800ee72 <xmp3fixpt_UnpackScaleFactors+0x78e>
			sfb = 3;
 800ee82:	f04f 0b03 	mov.w	fp, #3
 800ee86:	e731      	b.n	800ecec <xmp3fixpt_UnpackScaleFactors+0x608>
			preFlag = 1;
 800ee88:	f04f 0c01 	mov.w	ip, #1
			sfcIdx = 2;
 800ee8c:	2202      	movs	r2, #2
 800ee8e:	e566      	b.n	800e95e <xmp3fixpt_UnpackScaleFactors+0x27a>
			slen[0] = (sfCompress / 36);
 800ee90:	4c32      	ldr	r4, [pc, #200]	; (800ef5c <xmp3fixpt_UnpackScaleFactors+0x878>)
			slen[1] = (sfCompress % 36) / 6;
 800ee92:	4833      	ldr	r0, [pc, #204]	; (800ef60 <xmp3fixpt_UnpackScaleFactors+0x87c>)
			slen[0] = (sfCompress / 36);
 800ee94:	17db      	asrs	r3, r3, #31
 800ee96:	fb84 5402 	smull	r5, r4, r4, r2
 800ee9a:	ebc3 04e4 	rsb	r4, r3, r4, asr #3
			slen[1] = (sfCompress % 36) / 6;
 800ee9e:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 800eea2:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
 800eea6:	fb80 0203 	smull	r0, r2, r0, r3
 800eeaa:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
			slen[2] = (sfCompress % 36) % 6;
 800eeae:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 800eeb2:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
			slen[3] = 0;
 800eeb6:	2000      	movs	r0, #0
			slen[1] = (sfCompress % 36) / 6;
 800eeb8:	9211      	str	r2, [sp, #68]	; 0x44
			slen[0] = (sfCompress / 36);
 800eeba:	9410      	str	r4, [sp, #64]	; 0x40
			slen[2] = (sfCompress % 36) % 6;
 800eebc:	9312      	str	r3, [sp, #72]	; 0x48
			slen[3] = 0;
 800eebe:	9013      	str	r0, [sp, #76]	; 0x4c
	preFlag = 0;
 800eec0:	4684      	mov	ip, r0
			sfcIdx = 3;
 800eec2:	2203      	movs	r2, #3
 800eec4:	e54b      	b.n	800e95e <xmp3fixpt_UnpackScaleFactors+0x27a>
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800eec6:	5c73      	ldrb	r3, [r6, r1]
 800eec8:	54b3      	strb	r3, [r6, r2]
 800eeca:	4431      	add	r1, r6
 800eecc:	4432      	add	r2, r6
 800eece:	784b      	ldrb	r3, [r1, #1]
 800eed0:	7053      	strb	r3, [r2, #1]
 800eed2:	788b      	ldrb	r3, [r1, #2]
 800eed4:	7093      	strb	r3, [r2, #2]
 800eed6:	78cb      	ldrb	r3, [r1, #3]
 800eed8:	70d3      	strb	r3, [r2, #3]
 800eeda:	790b      	ldrb	r3, [r1, #4]
 800eedc:	7113      	strb	r3, [r2, #4]
 800eede:	794b      	ldrb	r3, [r1, #5]
 800eee0:	7153      	strb	r3, [r2, #5]
 800eee2:	e477      	b.n	800e7d4 <xmp3fixpt_UnpackScaleFactors+0xf0>
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800eee4:	4433      	add	r3, r6
 800eee6:	4432      	add	r2, r6
 800eee8:	7c19      	ldrb	r1, [r3, #16]
 800eeea:	7411      	strb	r1, [r2, #16]
 800eeec:	7c59      	ldrb	r1, [r3, #17]
 800eeee:	7451      	strb	r1, [r2, #17]
 800eef0:	7c99      	ldrb	r1, [r3, #18]
 800eef2:	7491      	strb	r1, [r2, #18]
 800eef4:	7cd9      	ldrb	r1, [r3, #19]
 800eef6:	74d1      	strb	r1, [r2, #19]
 800eef8:	7d1b      	ldrb	r3, [r3, #20]
 800eefa:	7513      	strb	r3, [r2, #20]
 800eefc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800eefe:	e4ed      	b.n	800e8dc <xmp3fixpt_UnpackScaleFactors+0x1f8>
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800ef00:	4433      	add	r3, r6
 800ef02:	4432      	add	r2, r6
 800ef04:	7ad9      	ldrb	r1, [r3, #11]
 800ef06:	72d1      	strb	r1, [r2, #11]
 800ef08:	7b19      	ldrb	r1, [r3, #12]
 800ef0a:	7311      	strb	r1, [r2, #12]
 800ef0c:	7b59      	ldrb	r1, [r3, #13]
 800ef0e:	7351      	strb	r1, [r2, #13]
 800ef10:	7b99      	ldrb	r1, [r3, #14]
 800ef12:	7391      	strb	r1, [r2, #14]
 800ef14:	7bdb      	ldrb	r3, [r3, #15]
 800ef16:	73d3      	strb	r3, [r2, #15]
 800ef18:	e4b4      	b.n	800e884 <xmp3fixpt_UnpackScaleFactors+0x1a0>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 800ef1a:	4432      	add	r2, r6
 800ef1c:	798b      	ldrb	r3, [r1, #6]
 800ef1e:	7193      	strb	r3, [r2, #6]
 800ef20:	79cb      	ldrb	r3, [r1, #7]
 800ef22:	71d3      	strb	r3, [r2, #7]
 800ef24:	7a0b      	ldrb	r3, [r1, #8]
 800ef26:	7213      	strb	r3, [r2, #8]
 800ef28:	7a4b      	ldrb	r3, [r1, #9]
 800ef2a:	7253      	strb	r3, [r2, #9]
 800ef2c:	7a8b      	ldrb	r3, [r1, #10]
 800ef2e:	7293      	strb	r3, [r2, #10]
 800ef30:	e47b      	b.n	800e82a <xmp3fixpt_UnpackScaleFactors+0x146>
		return -1;
 800ef32:	f04f 30ff 	mov.w	r0, #4294967295
 800ef36:	e5b0      	b.n	800ea9a <xmp3fixpt_UnpackScaleFactors+0x3b6>
			slen[0] = (sfCompress / 3);
 800ef38:	4c0a      	ldr	r4, [pc, #40]	; (800ef64 <xmp3fixpt_UnpackScaleFactors+0x880>)
			sfCompress -= 244;
 800ef3a:	f1a2 03f4 	sub.w	r3, r2, #244	; 0xf4
			slen[0] = (sfCompress / 3);
 800ef3e:	fb84 2403 	smull	r2, r4, r4, r3
 800ef42:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
			slen[1] = (sfCompress % 3);
 800ef46:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 800ef4a:	1a9b      	subs	r3, r3, r2
			slen[2] = slen[3] = 0;
 800ef4c:	2200      	movs	r2, #0
 800ef4e:	9213      	str	r2, [sp, #76]	; 0x4c
 800ef50:	9212      	str	r2, [sp, #72]	; 0x48
	preFlag = 0;
 800ef52:	4694      	mov	ip, r2
			slen[0] = (sfCompress / 3);
 800ef54:	9410      	str	r4, [sp, #64]	; 0x40
			slen[1] = (sfCompress % 3);
 800ef56:	9311      	str	r3, [sp, #68]	; 0x44
			sfcIdx = 5;
 800ef58:	2205      	movs	r2, #5
 800ef5a:	e500      	b.n	800e95e <xmp3fixpt_UnpackScaleFactors+0x27a>
 800ef5c:	38e38e39 	.word	0x38e38e39
 800ef60:	2aaaaaab 	.word	0x2aaaaaab
 800ef64:	55555556 	.word	0x55555556

0800ef68 <xmp3fixpt_MidSideProc>:
 * Return:      none
 *
 * Notes:       assume at least 1 GB in input
 **************************************************************************************/
void MidSideProc(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, int mOut[2])  
{
 800ef68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	/* L = (M+S)/sqrt(2), R = (M-S)/sqrt(2) 
	 * NOTE: 1/sqrt(2) done in DequantChannel() - see comments there
	 */
	mOutL = mOutR = 0;
	for(i = 0; i < nSamps; i++) {
 800ef6c:	2900      	cmp	r1, #0
 800ef6e:	f04f 0800 	mov.w	r8, #0
 800ef72:	46c1      	mov	r9, r8
 800ef74:	dd1f      	ble.n	800efb6 <xmp3fixpt_MidSideProc+0x4e>
 800ef76:	46c6      	mov	lr, r8
 800ef78:	1f07      	subs	r7, r0, #4
 800ef7a:	f600 06fc 	addw	r6, r0, #2300	; 0x8fc
		xl = x[0][i];
 800ef7e:	6878      	ldr	r0, [r7, #4]
		xr = x[1][i];
 800ef80:	6873      	ldr	r3, [r6, #4]
		x[0][i] = xl + xr;
 800ef82:	18c5      	adds	r5, r0, r3
		x[1][i] = xl - xr;
 800ef84:	1ac3      	subs	r3, r0, r3
	sign = x >> (sizeof(int) * 8 - 1);
 800ef86:	ea4f 7ae5 	mov.w	sl, r5, asr #31
 800ef8a:	ea4f 7ce3 	mov.w	ip, r3, asr #31
	x ^= sign;
 800ef8e:	ea85 040a 	eor.w	r4, r5, sl
 800ef92:	ea83 000c 	eor.w	r0, r3, ip
	for(i = 0; i < nSamps; i++) {
 800ef96:	f10e 0e01 	add.w	lr, lr, #1
	x -= sign;
 800ef9a:	eba4 040a 	sub.w	r4, r4, sl
 800ef9e:	eba0 000c 	sub.w	r0, r0, ip
 800efa2:	4571      	cmp	r1, lr
		x[0][i] = xl + xr;
 800efa4:	f847 5f04 	str.w	r5, [r7, #4]!
		mOutL |= FASTABS(x[0][i]);
 800efa8:	ea49 0904 	orr.w	r9, r9, r4
		x[1][i] = xl - xr;
 800efac:	f846 3f04 	str.w	r3, [r6, #4]!
		mOutR |= FASTABS(x[1][i]);
 800efb0:	ea48 0800 	orr.w	r8, r8, r0
	for(i = 0; i < nSamps; i++) {
 800efb4:	d1e3      	bne.n	800ef7e <xmp3fixpt_MidSideProc+0x16>
	}
	mOut[0] |= mOutL;
	mOut[1] |= mOutR;
 800efb6:	e892 000a 	ldmia.w	r2, {r1, r3}
	mOut[0] |= mOutL;
 800efba:	ea41 0109 	orr.w	r1, r1, r9
	mOut[1] |= mOutR;
 800efbe:	ea43 0308 	orr.w	r3, r3, r8
 800efc2:	e882 000a 	stmia.w	r2, {r1, r3}
 800efc6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800efca:	bf00      	nop

0800efcc <xmp3fixpt_IntensityProcMPEG1>:
 * TODO:        combine MPEG1/2 into one function (maybe)
 *              make sure all the mixed-block and IIP logic is right
 **************************************************************************************/
void IntensityProcMPEG1(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, int midSideFlag, int mixFlag, int mOut[2])
{
 800efcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800efd0:	b091      	sub	sp, #68	; 0x44
 800efd2:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 800efd4:	900d      	str	r0, [sp, #52]	; 0x34
	 *  short block section (i.e. on or after sample 36 = sfBand->l[8] = 3*sfBand->s[3]
	 * is this a safe assumption?
	 * TODO - intensity + mixed not quite right (diff = 11 on he_mode)
	 *  figure out correct implementation (spec ambiguous about when to do short block reorder)
	 */
	if (cbi[1].cbType == 0) {
 800efd6:	f8d4 8018 	ldr.w	r8, [r4, #24]
 800efda:	f1b8 0f00 	cmp.w	r8, #0
 800efde:	d171      	bne.n	800f0c4 <xmp3fixpt_IntensityProcMPEG1+0xf8>
		/* long block */
		cbStartL = cbi[1].cbEndL + 1;
 800efe0:	f8d4 c02c 	ldr.w	ip, [r4, #44]	; 0x2c
		cbEndL =   cbi[0].cbEndL + 1;
		cbStartS = cbEndS = 0;
		i = fh->sfBand->l[cbStartL];
 800efe4:	6b57      	ldr	r7, [r2, #52]	; 0x34
		cbStartL = cbEndL = 0;
		i = 3 * fh->sfBand->s[cbStartS];
	}

	sampsLeft = nSamps - i;		/* process to length of left */
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800efe6:	981b      	ldr	r0, [sp, #108]	; 0x6c
 800efe8:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
		cbEndL =   cbi[0].cbEndL + 1;
 800efea:	6966      	ldr	r6, [r4, #20]
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800efec:	f8df a32c 	ldr.w	sl, [pc, #812]	; 800f31c <xmp3fixpt_IntensityProcMPEG1+0x350>
		cbStartL = cbi[1].cbEndL + 1;
 800eff0:	f10c 0201 	add.w	r2, ip, #1
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800eff4:	00c0      	lsls	r0, r0, #3
		i = fh->sfBand->l[cbStartL];
 800eff6:	f937 4012 	ldrsh.w	r4, [r7, r2, lsl #1]
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800effa:	eba0 0e05 	sub.w	lr, r0, r5
	mOutL = mOutR = 0;

	/* long blocks */
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 800effe:	42b2      	cmp	r2, r6
	sampsLeft = nSamps - i;		/* process to length of left */
 800f000:	eba1 0504 	sub.w	r5, r1, r4
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800f004:	eb0a 018e 	add.w	r1, sl, lr, lsl #2
 800f008:	9100      	str	r1, [sp, #0]
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 800f00a:	f300 817e 	bgt.w	800f30a <xmp3fixpt_IntensityProcMPEG1+0x33e>
 800f00e:	2d00      	cmp	r5, #0
 800f010:	f340 817b 	ble.w	800f30a <xmp3fixpt_IntensityProcMPEG1+0x33e>
 800f014:	eb03 0b0c 	add.w	fp, r3, ip
 800f018:	4433      	add	r3, r6
 800f01a:	9301      	str	r3, [sp, #4]
		isf = sfis->l[cb];
		if (isf == 7) {
			fl = ISFIIP[midSideFlag][0];
			fr = ISFIIP[midSideFlag][1];
 800f01c:	4bbe      	ldr	r3, [pc, #760]	; (800f318 <xmp3fixpt_IntensityProcMPEG1+0x34c>)
 800f01e:	4403      	add	r3, r0
 800f020:	eb07 0c42 	add.w	ip, r7, r2, lsl #1
 800f024:	9302      	str	r3, [sp, #8]
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 800f026:	46c2      	mov	sl, r8
		isf = sfis->l[cb];
 800f028:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
		if (isf == 7) {
 800f02c:	2b07      	cmp	r3, #7
 800f02e:	d042      	beq.n	800f0b6 <xmp3fixpt_IntensityProcMPEG1+0xea>
		} else {
			fl = isfTab[isf];	
 800f030:	9900      	ldr	r1, [sp, #0]
 800f032:	f851 e023 	ldr.w	lr, [r1, r3, lsl #2]
			fr = isfTab[6] - isfTab[isf];
 800f036:	698f      	ldr	r7, [r1, #24]
 800f038:	eba7 070e 	sub.w	r7, r7, lr
 800f03c:	4663      	mov	r3, ip
		}

		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f03e:	f9bc 9002 	ldrsh.w	r9, [ip, #2]
 800f042:	f9b3 3000 	ldrsh.w	r3, [r3]
 800f046:	eba9 0903 	sub.w	r9, r9, r3
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 800f04a:	f1b9 0f00 	cmp.w	r9, #0
		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f04e:	f10c 0c02 	add.w	ip, ip, #2
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 800f052:	dd25      	ble.n	800f0a0 <xmp3fixpt_IntensityProcMPEG1+0xd4>
 800f054:	00a6      	lsls	r6, r4, #2
 800f056:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800f058:	1f30      	subs	r0, r6, #4
 800f05a:	f606 06fc 	addw	r6, r6, #2300	; 0x8fc
 800f05e:	44a1      	add	r9, r4
 800f060:	4410      	add	r0, r2
 800f062:	4416      	add	r6, r2
 800f064:	e000      	b.n	800f068 <xmp3fixpt_IntensityProcMPEG1+0x9c>
 800f066:	b305      	cbz	r5, 800f0aa <xmp3fixpt_IntensityProcMPEG1+0xde>
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f068:	6843      	ldr	r3, [r0, #4]
 800f06a:	fb87 2303 	smull	r2, r3, r7, r3
			xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr; mOutR |= FASTABS(xr);
 800f06e:	009b      	lsls	r3, r3, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800f070:	17d9      	asrs	r1, r3, #31
 800f072:	f846 3f04 	str.w	r3, [r6, #4]!
	x ^= sign;
 800f076:	404b      	eors	r3, r1
	x -= sign;
 800f078:	1a5b      	subs	r3, r3, r1
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f07a:	6842      	ldr	r2, [r0, #4]
 800f07c:	ea4a 0a03 	orr.w	sl, sl, r3
 800f080:	fb8e 3202 	smull	r3, r2, lr, r2
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 800f084:	0092      	lsls	r2, r2, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800f086:	17d1      	asrs	r1, r2, #31
	x ^= sign;
 800f088:	ea82 0301 	eor.w	r3, r2, r1
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 800f08c:	3401      	adds	r4, #1
	x -= sign;
 800f08e:	1a5b      	subs	r3, r3, r1
 800f090:	454c      	cmp	r4, r9
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 800f092:	f840 2f04 	str.w	r2, [r0, #4]!
			sampsLeft--;
 800f096:	f105 35ff 	add.w	r5, r5, #4294967295
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 800f09a:	ea48 0803 	orr.w	r8, r8, r3
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 800f09e:	d1e2      	bne.n	800f066 <xmp3fixpt_IntensityProcMPEG1+0x9a>
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 800f0a0:	9b01      	ldr	r3, [sp, #4]
 800f0a2:	459b      	cmp	fp, r3
 800f0a4:	d001      	beq.n	800f0aa <xmp3fixpt_IntensityProcMPEG1+0xde>
 800f0a6:	2d00      	cmp	r5, #0
 800f0a8:	d1be      	bne.n	800f028 <xmp3fixpt_IntensityProcMPEG1+0x5c>
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
			sampsLeft -= 3;
		}
	}
	mOut[0] = mOutL;
 800f0aa:	9b1d      	ldr	r3, [sp, #116]	; 0x74
	mOut[1] = mOutR;
 800f0ac:	e883 0500 	stmia.w	r3, {r8, sl}
	
	return;
}
 800f0b0:	b011      	add	sp, #68	; 0x44
 800f0b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fl = ISFIIP[midSideFlag][0];
 800f0b6:	4b98      	ldr	r3, [pc, #608]	; (800f318 <xmp3fixpt_IntensityProcMPEG1+0x34c>)
 800f0b8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800f0ba:	f853 e032 	ldr.w	lr, [r3, r2, lsl #3]
			fr = ISFIIP[midSideFlag][1];
 800f0be:	9b02      	ldr	r3, [sp, #8]
 800f0c0:	685f      	ldr	r7, [r3, #4]
 800f0c2:	e7bb      	b.n	800f03c <xmp3fixpt_IntensityProcMPEG1+0x70>
	} else if (cbi[1].cbType == 1 || cbi[1].cbType == 2) {
 800f0c4:	f108 30ff 	add.w	r0, r8, #4294967295
 800f0c8:	2801      	cmp	r0, #1
 800f0ca:	f240 8112 	bls.w	800f2f2 <xmp3fixpt_IntensityProcMPEG1+0x326>
	int cbStartL=0, cbStartS=0, cbEndL=0, cbEndS=0;
 800f0ce:	2500      	movs	r5, #0
 800f0d0:	462e      	mov	r6, r5
	int i=0, j=0, n=0, cb=0, w=0;
 800f0d2:	46a9      	mov	r9, r5
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800f0d4:	981b      	ldr	r0, [sp, #108]	; 0x6c
 800f0d6:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 800f0d8:	4c90      	ldr	r4, [pc, #576]	; (800f31c <xmp3fixpt_IntensityProcMPEG1+0x350>)
 800f0da:	00c0      	lsls	r0, r0, #3
	sampsLeft = nSamps - i;		/* process to length of left */
 800f0dc:	eba1 0109 	sub.w	r1, r1, r9
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800f0e0:	1bc7      	subs	r7, r0, r7
	sampsLeft = nSamps - i;		/* process to length of left */
 800f0e2:	468e      	mov	lr, r1
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 800f0e4:	42b5      	cmp	r5, r6
	isfTab = (int *)ISFMpeg1[midSideFlag];
 800f0e6:	eb04 0187 	add.w	r1, r4, r7, lsl #2
 800f0ea:	910b      	str	r1, [sp, #44]	; 0x2c
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 800f0ec:	f340 810f 	ble.w	800f30e <xmp3fixpt_IntensityProcMPEG1+0x342>
 800f0f0:	4677      	mov	r7, lr
 800f0f2:	2f02      	cmp	r7, #2
 800f0f4:	f340 810b 	ble.w	800f30e <xmp3fixpt_IntensityProcMPEG1+0x342>
 800f0f8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800f0fc:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800f0fe:	3d03      	subs	r5, #3
 800f100:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 800f104:	195d      	adds	r5, r3, r5
 800f106:	4413      	add	r3, r2
 800f108:	930a      	str	r3, [sp, #40]	; 0x28
				frs[w] = ISFIIP[midSideFlag][1];
 800f10a:	4b83      	ldr	r3, [pc, #524]	; (800f318 <xmp3fixpt_IntensityProcMPEG1+0x34c>)
 800f10c:	950f      	str	r5, [sp, #60]	; 0x3c
 800f10e:	4403      	add	r3, r0
 800f110:	f106 0417 	add.w	r4, r6, #23
	mOutL = mOutR = 0;
 800f114:	f04f 0a00 	mov.w	sl, #0
 800f118:	eb01 0144 	add.w	r1, r1, r4, lsl #1
				frs[w] = ISFIIP[midSideFlag][1];
 800f11c:	930e      	str	r3, [sp, #56]	; 0x38
 800f11e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f120:	f8cd a000 	str.w	sl, [sp]
 800f124:	f8cd a004 	str.w	sl, [sp, #4]
 800f128:	910c      	str	r1, [sp, #48]	; 0x30
 800f12a:	46f2      	mov	sl, lr
			isf = sfis->s[cb][w];
 800f12c:	7ddb      	ldrb	r3, [r3, #23]
			if (isf == 7) {
 800f12e:	2b07      	cmp	r3, #7
 800f130:	f000 80b5 	beq.w	800f29e <xmp3fixpt_IntensityProcMPEG1+0x2d2>
				fls[w] = isfTab[isf];
 800f134:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800f136:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f13a:	9304      	str	r3, [sp, #16]
 800f13c:	461a      	mov	r2, r3
				frs[w] = isfTab[6] - isfTab[isf];
 800f13e:	698b      	ldr	r3, [r1, #24]
 800f140:	1a9b      	subs	r3, r3, r2
 800f142:	9303      	str	r3, [sp, #12]
			isf = sfis->s[cb][w];
 800f144:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f146:	7e1b      	ldrb	r3, [r3, #24]
			if (isf == 7) {
 800f148:	2b07      	cmp	r3, #7
 800f14a:	f000 80b5 	beq.w	800f2b8 <xmp3fixpt_IntensityProcMPEG1+0x2ec>
				fls[w] = isfTab[isf];
 800f14e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800f150:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f154:	9305      	str	r3, [sp, #20]
 800f156:	461a      	mov	r2, r3
				frs[w] = isfTab[6] - isfTab[isf];
 800f158:	698b      	ldr	r3, [r1, #24]
 800f15a:	1a9b      	subs	r3, r3, r2
 800f15c:	9306      	str	r3, [sp, #24]
			isf = sfis->s[cb][w];
 800f15e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f160:	7e5b      	ldrb	r3, [r3, #25]
			if (isf == 7) {
 800f162:	2b07      	cmp	r3, #7
 800f164:	f000 80b5 	beq.w	800f2d2 <xmp3fixpt_IntensityProcMPEG1+0x306>
				fls[w] = isfTab[isf];
 800f168:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800f16a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800f16e:	9307      	str	r3, [sp, #28]
 800f170:	461a      	mov	r2, r3
				frs[w] = isfTab[6] - isfTab[isf];
 800f172:	698b      	ldr	r3, [r1, #24]
 800f174:	1a9b      	subs	r3, r3, r2
 800f176:	9308      	str	r3, [sp, #32]
 800f178:	990c      	ldr	r1, [sp, #48]	; 0x30
 800f17a:	460a      	mov	r2, r1
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f17c:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
 800f180:	f9b2 2000 	ldrsh.w	r2, [r2]
 800f184:	1a9b      	subs	r3, r3, r2
 800f186:	3102      	adds	r1, #2
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 800f188:	2b00      	cmp	r3, #0
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f18a:	910c      	str	r1, [sp, #48]	; 0x30
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 800f18c:	f340 80aa 	ble.w	800f2e4 <xmp3fixpt_IntensityProcMPEG1+0x318>
 800f190:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800f194:	444b      	add	r3, r9
 800f196:	9309      	str	r3, [sp, #36]	; 0x24
 800f198:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800f19a:	eb03 0889 	add.w	r8, r3, r9, lsl #2
 800f19e:	e002      	b.n	800f1a6 <xmp3fixpt_IntensityProcMPEG1+0x1da>
 800f1a0:	f1ba 0f02 	cmp.w	sl, #2
 800f1a4:	dd72      	ble.n	800f28c <xmp3fixpt_IntensityProcMPEG1+0x2c0>
			xr = MULSHIFT32(frs[0], x[0][i+0]) << 2;	x[1][i+0] = xr;	mOutR |= FASTABS(xr);
 800f1a6:	f8d8 1000 	ldr.w	r1, [r8]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f1aa:	9b03      	ldr	r3, [sp, #12]
 800f1ac:	4608      	mov	r0, r1
 800f1ae:	461a      	mov	r2, r3
 800f1b0:	fb82 3000 	smull	r3, r0, r2, r0
 800f1b4:	0080      	lsls	r0, r0, #2
 800f1b6:	9b04      	ldr	r3, [sp, #16]
 800f1b8:	f8c8 0900 	str.w	r0, [r8, #2304]	; 0x900
	sign = x >> (sizeof(int) * 8 - 1);
 800f1bc:	ea4f 7ee0 	mov.w	lr, r0, asr #31
	x ^= sign;
 800f1c0:	ea80 000e 	eor.w	r0, r0, lr
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f1c4:	461a      	mov	r2, r3
 800f1c6:	fb82 3101 	smull	r3, r1, r2, r1
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 800f1ca:	0089      	lsls	r1, r1, #2
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 800f1cc:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800f1d0:	9c06      	ldr	r4, [sp, #24]
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 800f1d2:	f8c8 1000 	str.w	r1, [r8]
	sign = x >> (sizeof(int) * 8 - 1);
 800f1d6:	17ce      	asrs	r6, r1, #31
	x ^= sign;
 800f1d8:	4071      	eors	r1, r6
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f1da:	461a      	mov	r2, r3
 800f1dc:	4625      	mov	r5, r4
 800f1de:	fb85 4202 	smull	r4, r2, r5, r2
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 800f1e2:	0092      	lsls	r2, r2, #2
 800f1e4:	9c05      	ldr	r4, [sp, #20]
 800f1e6:	f8c8 2904 	str.w	r2, [r8, #2308]	; 0x904
	sign = x >> (sizeof(int) * 8 - 1);
 800f1ea:	ea4f 7ce2 	mov.w	ip, r2, asr #31
	x ^= sign;
 800f1ee:	ea82 020c 	eor.w	r2, r2, ip
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f1f2:	4625      	mov	r5, r4
 800f1f4:	fb85 4303 	smull	r4, r3, r5, r3
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 800f1f8:	009b      	lsls	r3, r3, #2
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 800f1fa:	f8d8 4008 	ldr.w	r4, [r8, #8]
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 800f1fe:	f8c8 3004 	str.w	r3, [r8, #4]
	sign = x >> (sizeof(int) * 8 - 1);
 800f202:	17df      	asrs	r7, r3, #31
	x ^= sign;
 800f204:	407b      	eors	r3, r7
 800f206:	9302      	str	r3, [sp, #8]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f208:	4625      	mov	r5, r4
 800f20a:	9b08      	ldr	r3, [sp, #32]
 800f20c:	fb83 b505 	smull	fp, r5, r3, r5
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 800f210:	00ad      	lsls	r5, r5, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800f212:	ea4f 7be5 	mov.w	fp, r5, asr #31
	x -= sign;
 800f216:	eba0 000e 	sub.w	r0, r0, lr
 800f21a:	eba2 020c 	sub.w	r2, r2, ip
	x ^= sign;
 800f21e:	ea85 0e0b 	eor.w	lr, r5, fp
 800f222:	4302      	orrs	r2, r0
	x -= sign;
 800f224:	ebae 0b0b 	sub.w	fp, lr, fp
 800f228:	9800      	ldr	r0, [sp, #0]
 800f22a:	f8c8 5908 	str.w	r5, [r8, #2312]	; 0x908
 800f22e:	ea42 020b 	orr.w	r2, r2, fp
 800f232:	4310      	orrs	r0, r2
 800f234:	9000      	str	r0, [sp, #0]
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f236:	9b07      	ldr	r3, [sp, #28]
 800f238:	fb83 2404 	smull	r2, r4, r3, r4
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 800f23c:	00a4      	lsls	r4, r4, #2
	x -= sign;
 800f23e:	9b02      	ldr	r3, [sp, #8]
 800f240:	f8c8 4008 	str.w	r4, [r8, #8]
	sign = x >> (sizeof(int) * 8 - 1);
 800f244:	17e2      	asrs	r2, r4, #31
	x -= sign;
 800f246:	1bdb      	subs	r3, r3, r7
 800f248:	1b89      	subs	r1, r1, r6
	x ^= sign;
 800f24a:	ea84 0002 	eor.w	r0, r4, r2
	x -= sign;
 800f24e:	1a82      	subs	r2, r0, r2
 800f250:	430b      	orrs	r3, r1
 800f252:	4313      	orrs	r3, r2
 800f254:	9a01      	ldr	r2, [sp, #4]
 800f256:	431a      	orrs	r2, r3
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 800f258:	9b09      	ldr	r3, [sp, #36]	; 0x24
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 800f25a:	9201      	str	r2, [sp, #4]
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 800f25c:	f109 0903 	add.w	r9, r9, #3
 800f260:	454b      	cmp	r3, r9
			sampsLeft -= 3;
 800f262:	f1aa 0a03 	sub.w	sl, sl, #3
 800f266:	f108 080c 	add.w	r8, r8, #12
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 800f26a:	d199      	bne.n	800f1a0 <xmp3fixpt_IntensityProcMPEG1+0x1d4>
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 800f26c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800f26e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800f270:	428a      	cmp	r2, r1
 800f272:	4613      	mov	r3, r2
 800f274:	d005      	beq.n	800f282 <xmp3fixpt_IntensityProcMPEG1+0x2b6>
 800f276:	3303      	adds	r3, #3
 800f278:	f1ba 0f02 	cmp.w	sl, #2
 800f27c:	930a      	str	r3, [sp, #40]	; 0x28
 800f27e:	f73f af55 	bgt.w	800f12c <xmp3fixpt_IntensityProcMPEG1+0x160>
 800f282:	f8dd a000 	ldr.w	sl, [sp]
 800f286:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800f28a:	e70e      	b.n	800f0aa <xmp3fixpt_IntensityProcMPEG1+0xde>
 800f28c:	f8dd a000 	ldr.w	sl, [sp]
	mOut[0] = mOutL;
 800f290:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800f292:	4690      	mov	r8, r2
	mOut[1] = mOutR;
 800f294:	e883 0500 	stmia.w	r3, {r8, sl}
}
 800f298:	b011      	add	sp, #68	; 0x44
 800f29a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				fls[w] = ISFIIP[midSideFlag][0];
 800f29e:	4b1e      	ldr	r3, [pc, #120]	; (800f318 <xmp3fixpt_IntensityProcMPEG1+0x34c>)
 800f2a0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800f2a2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 800f2a6:	9304      	str	r3, [sp, #16]
				frs[w] = ISFIIP[midSideFlag][1];
 800f2a8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f2aa:	685b      	ldr	r3, [r3, #4]
 800f2ac:	9303      	str	r3, [sp, #12]
			isf = sfis->s[cb][w];
 800f2ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f2b0:	7e1b      	ldrb	r3, [r3, #24]
			if (isf == 7) {
 800f2b2:	2b07      	cmp	r3, #7
 800f2b4:	f47f af4b 	bne.w	800f14e <xmp3fixpt_IntensityProcMPEG1+0x182>
				fls[w] = ISFIIP[midSideFlag][0];
 800f2b8:	4b17      	ldr	r3, [pc, #92]	; (800f318 <xmp3fixpt_IntensityProcMPEG1+0x34c>)
 800f2ba:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800f2bc:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 800f2c0:	9305      	str	r3, [sp, #20]
				frs[w] = ISFIIP[midSideFlag][1];
 800f2c2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f2c4:	685b      	ldr	r3, [r3, #4]
 800f2c6:	9306      	str	r3, [sp, #24]
			isf = sfis->s[cb][w];
 800f2c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f2ca:	7e5b      	ldrb	r3, [r3, #25]
			if (isf == 7) {
 800f2cc:	2b07      	cmp	r3, #7
 800f2ce:	f47f af4b 	bne.w	800f168 <xmp3fixpt_IntensityProcMPEG1+0x19c>
				fls[w] = ISFIIP[midSideFlag][0];
 800f2d2:	4b11      	ldr	r3, [pc, #68]	; (800f318 <xmp3fixpt_IntensityProcMPEG1+0x34c>)
 800f2d4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800f2d6:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 800f2da:	9307      	str	r3, [sp, #28]
				frs[w] = ISFIIP[midSideFlag][1];
 800f2dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f2de:	685b      	ldr	r3, [r3, #4]
 800f2e0:	9308      	str	r3, [sp, #32]
 800f2e2:	e749      	b.n	800f178 <xmp3fixpt_IntensityProcMPEG1+0x1ac>
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 800f2e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f2e6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800f2e8:	4293      	cmp	r3, r2
 800f2ea:	d0ca      	beq.n	800f282 <xmp3fixpt_IntensityProcMPEG1+0x2b6>
 800f2ec:	3303      	adds	r3, #3
 800f2ee:	930a      	str	r3, [sp, #40]	; 0x28
 800f2f0:	e71c      	b.n	800f12c <xmp3fixpt_IntensityProcMPEG1+0x160>
		cbStartS = cbi[1].cbEndSMax + 1;
 800f2f2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
		i = 3 * fh->sfBand->s[cbStartS];
 800f2f4:	6b50      	ldr	r0, [r2, #52]	; 0x34
		cbEndS =   cbi[0].cbEndSMax + 1;
 800f2f6:	6925      	ldr	r5, [r4, #16]
		i = 3 * fh->sfBand->s[cbStartS];
 800f2f8:	eb00 0046 	add.w	r0, r0, r6, lsl #1
		cbEndS =   cbi[0].cbEndSMax + 1;
 800f2fc:	3501      	adds	r5, #1
		i = 3 * fh->sfBand->s[cbStartS];
 800f2fe:	f9b0 0030 	ldrsh.w	r0, [r0, #48]	; 0x30
		cbStartS = cbi[1].cbEndSMax + 1;
 800f302:	3601      	adds	r6, #1
		i = 3 * fh->sfBand->s[cbStartS];
 800f304:	eb00 0940 	add.w	r9, r0, r0, lsl #1
 800f308:	e6e4      	b.n	800f0d4 <xmp3fixpt_IntensityProcMPEG1+0x108>
	mOutL = mOutR = 0;
 800f30a:	46c2      	mov	sl, r8
 800f30c:	e6cd      	b.n	800f0aa <xmp3fixpt_IntensityProcMPEG1+0xde>
 800f30e:	f04f 0a00 	mov.w	sl, #0
 800f312:	46d0      	mov	r8, sl
 800f314:	e6c9      	b.n	800f0aa <xmp3fixpt_IntensityProcMPEG1+0xde>
 800f316:	bf00      	nop
 800f318:	08017710 	.word	0x08017710
 800f31c:	08017820 	.word	0x08017820

0800f320 <xmp3fixpt_IntensityProcMPEG2>:
 *              make sure all the mixed-block and IIP logic is right
 *                probably redo IIP logic to be simpler
 **************************************************************************************/
void IntensityProcMPEG2(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, ScaleFactorJS *sfjs, int midSideFlag, int mixFlag, int mOut[2])
{
 800f320:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f324:	b0a1      	sub	sp, #132	; 0x84
	int sampsLeft;
	int isf, sfIdx, tmp, il[23];
	int *isfTab;
	int cbStartL, cbStartS, cbEndL, cbEndS;
	
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 800f326:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 800f5e0 <xmp3fixpt_IntensityProcMPEG2+0x2c0>
{
 800f32a:	f8dd e0ac 	ldr.w	lr, [sp, #172]	; 0xac
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 800f32e:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
{
 800f330:	9306      	str	r3, [sp, #24]
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 800f332:	4675      	mov	r5, lr
{
 800f334:	9f2a      	ldr	r7, [sp, #168]	; 0xa8
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 800f336:	f855 4b04 	ldr.w	r4, [r5], #4
 800f33a:	eb06 0444 	add.w	r4, r6, r4, lsl #1
 800f33e:	eb08 1384 	add.w	r3, r8, r4, lsl #6
{
 800f342:	468a      	mov	sl, r1
 800f344:	4694      	mov	ip, r2
 800f346:	f10e 0e14 	add.w	lr, lr, #20
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 800f34a:	9301      	str	r3, [sp, #4]
	mOutL = mOutR = 0;

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
 800f34c:	2600      	movs	r6, #0
		tmp = (1 << sfjs->slen[r]) - 1;
 800f34e:	f04f 0901 	mov.w	r9, #1
 800f352:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
 800f356:	f855 1b04 	ldr.w	r1, [r5], #4
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 800f35a:	68ec      	ldr	r4, [r5, #12]
		tmp = (1 << sfjs->slen[r]) - 1;
 800f35c:	fa09 f101 	lsl.w	r1, r9, r1
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 800f360:	2c00      	cmp	r4, #0
		tmp = (1 << sfjs->slen[r]) - 1;
 800f362:	f101 31ff 	add.w	r1, r1, #4294967295
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 800f366:	dd0f      	ble.n	800f388 <xmp3fixpt_IntensityProcMPEG2+0x68>
 800f368:	eb06 0208 	add.w	r2, r6, r8
 800f36c:	ab09      	add	r3, sp, #36	; 0x24
 800f36e:	4422      	add	r2, r4
 800f370:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 800f374:	f10d 0b24 	add.w	fp, sp, #36	; 0x24
 800f378:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
 800f37c:	3b04      	subs	r3, #4
			il[k] = tmp;
 800f37e:	f843 1f04 	str.w	r1, [r3, #4]!
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 800f382:	4293      	cmp	r3, r2
 800f384:	d1fb      	bne.n	800f37e <xmp3fixpt_IntensityProcMPEG2+0x5e>
 800f386:	4426      	add	r6, r4
	for (k = r = 0; r < 4; r++) {
 800f388:	4575      	cmp	r5, lr
 800f38a:	d1e4      	bne.n	800f356 <xmp3fixpt_IntensityProcMPEG2+0x36>
	}

	if (cbi[1].cbType == 0) {
 800f38c:	69be      	ldr	r6, [r7, #24]
 800f38e:	2e00      	cmp	r6, #0
 800f390:	f040 808c 	bne.w	800f4ac <xmp3fixpt_IntensityProcMPEG2+0x18c>
		/* long blocks */
		il[21] = il[22] = 1;
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 800f394:	6afa      	ldr	r2, [r7, #44]	; 0x2c
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 800f396:	6979      	ldr	r1, [r7, #20]
		i = fh->sfBand->l[cbStartL];
 800f398:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 800f39c:	9105      	str	r1, [sp, #20]
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 800f39e:	f102 0c01 	add.w	ip, r2, #1
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 800f3a2:	460c      	mov	r4, r1
		i = fh->sfBand->l[cbStartL];
 800f3a4:	f933 801c 	ldrsh.w	r8, [r3, ip, lsl #1]
		il[21] = il[22] = 1;
 800f3a8:	2101      	movs	r1, #1
		sampsLeft = nSamps - i;

		for(cb = cbStartL; cb < cbEndL; cb++) {
 800f3aa:	45a4      	cmp	ip, r4
		il[21] = il[22] = 1;
 800f3ac:	911f      	str	r1, [sp, #124]	; 0x7c
		sampsLeft = nSamps - i;
 800f3ae:	ebaa 0a08 	sub.w	sl, sl, r8
		il[21] = il[22] = 1;
 800f3b2:	911e      	str	r1, [sp, #120]	; 0x78
		for(cb = cbStartL; cb < cbEndL; cb++) {
 800f3b4:	f300 810b 	bgt.w	800f5ce <xmp3fixpt_IntensityProcMPEG2+0x2ae>
 800f3b8:	9906      	ldr	r1, [sp, #24]
 800f3ba:	eb03 034c 	add.w	r3, r3, ip, lsl #1
 800f3be:	4411      	add	r1, r2
 800f3c0:	9304      	str	r3, [sp, #16]
			sfIdx = sfis->l[cb];
			if (sfIdx == il[cb]) {
				fl = ISFIIP[midSideFlag][0];
				fr = ISFIIP[midSideFlag][1];
 800f3c2:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800f3c4:	4b85      	ldr	r3, [pc, #532]	; (800f5dc <xmp3fixpt_IntensityProcMPEG2+0x2bc>)
 800f3c6:	9102      	str	r1, [sp, #8]
 800f3c8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800f3cc:	9306      	str	r3, [sp, #24]
 800f3ce:	ab20      	add	r3, sp, #128	; 0x80
 800f3d0:	eb03 038c 	add.w	r3, r3, ip, lsl #2
 800f3d4:	3b60      	subs	r3, #96	; 0x60
 800f3d6:	9303      	str	r3, [sp, #12]
		for(cb = cbStartL; cb < cbEndL; cb++) {
 800f3d8:	46b3      	mov	fp, r6
			sfIdx = sfis->l[cb];
 800f3da:	9b02      	ldr	r3, [sp, #8]
			if (sfIdx == il[cb]) {
 800f3dc:	9903      	ldr	r1, [sp, #12]
			sfIdx = sfis->l[cb];
 800f3de:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 800f3e2:	9302      	str	r3, [sp, #8]
			if (sfIdx == il[cb]) {
 800f3e4:	f851 3f04 	ldr.w	r3, [r1, #4]!
 800f3e8:	9103      	str	r1, [sp, #12]
 800f3ea:	429a      	cmp	r2, r3
 800f3ec:	d057      	beq.n	800f49e <xmp3fixpt_IntensityProcMPEG2+0x17e>
			} else {
				isf = (sfis->l[cb] + 1) >> 1;
 800f3ee:	1c53      	adds	r3, r2, #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f3f0:	07d1      	lsls	r1, r2, #31
				isf = (sfis->l[cb] + 1) >> 1;
 800f3f2:	ea4f 0363 	mov.w	r3, r3, asr #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f3f6:	d54e      	bpl.n	800f496 <xmp3fixpt_IntensityProcMPEG2+0x176>
 800f3f8:	9a01      	ldr	r2, [sp, #4]
 800f3fa:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 800f3fe:	2300      	movs	r3, #0
 800f400:	58d5      	ldr	r5, [r2, r3]
 800f402:	9904      	ldr	r1, [sp, #16]
			}
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);
 800f404:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
 800f408:	f9b1 2000 	ldrsh.w	r2, [r1]
 800f40c:	eba3 0e02 	sub.w	lr, r3, r2
 800f410:	45d6      	cmp	lr, sl
 800f412:	bfa8      	it	ge
 800f414:	46d6      	movge	lr, sl
 800f416:	460b      	mov	r3, r1
 800f418:	3302      	adds	r3, #2

			for(j = 0; j < n; j++, i++) {
 800f41a:	f1be 0f00 	cmp.w	lr, #0
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);
 800f41e:	f10c 0c01 	add.w	ip, ip, #1
 800f422:	9304      	str	r3, [sp, #16]
			for(j = 0; j < n; j++, i++) {
 800f424:	dd2b      	ble.n	800f47e <xmp3fixpt_IntensityProcMPEG2+0x15e>
 800f426:	f108 4780 	add.w	r7, r8, #1073741824	; 0x40000000
 800f42a:	ea4f 0188 	mov.w	r1, r8, lsl #2
 800f42e:	3f01      	subs	r7, #1
 800f430:	1f0a      	subs	r2, r1, #4
 800f432:	4477      	add	r7, lr
 800f434:	f601 01fc 	addw	r1, r1, #2300	; 0x8fc
 800f438:	4402      	add	r2, r0
 800f43a:	4401      	add	r1, r0
 800f43c:	eb00 0787 	add.w	r7, r0, r7, lsl #2
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f440:	6853      	ldr	r3, [r2, #4]
 800f442:	fb85 9303 	smull	r9, r3, r5, r3
				xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 800f446:	009b      	lsls	r3, r3, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800f448:	ea4f 79e3 	mov.w	r9, r3, asr #31
 800f44c:	f841 3f04 	str.w	r3, [r1, #4]!
	x ^= sign;
 800f450:	ea83 0309 	eor.w	r3, r3, r9
	x -= sign;
 800f454:	eba3 0309 	sub.w	r3, r3, r9
 800f458:	ea4b 0b03 	orr.w	fp, fp, r3
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f45c:	6853      	ldr	r3, [r2, #4]
 800f45e:	fb84 9303 	smull	r9, r3, r4, r3
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 800f462:	009b      	lsls	r3, r3, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800f464:	ea4f 79e3 	mov.w	r9, r3, asr #31
 800f468:	f842 3f04 	str.w	r3, [r2, #4]!
	x ^= sign;
 800f46c:	ea83 0309 	eor.w	r3, r3, r9
	x -= sign;
 800f470:	eba3 0309 	sub.w	r3, r3, r9
			for(j = 0; j < n; j++, i++) {
 800f474:	4297      	cmp	r7, r2
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 800f476:	ea46 0603 	orr.w	r6, r6, r3
			for(j = 0; j < n; j++, i++) {
 800f47a:	d1e1      	bne.n	800f440 <xmp3fixpt_IntensityProcMPEG2+0x120>
 800f47c:	44f0      	add	r8, lr
			}

			/* early exit once we've used all the non-zero samples */
			sampsLeft -= n;
			if (sampsLeft == 0)		
 800f47e:	ebba 0a0e 	subs.w	sl, sl, lr
 800f482:	d002      	beq.n	800f48a <xmp3fixpt_IntensityProcMPEG2+0x16a>
		for(cb = cbStartL; cb < cbEndL; cb++) {
 800f484:	9b05      	ldr	r3, [sp, #20]
 800f486:	4563      	cmp	r3, ip
 800f488:	daa7      	bge.n	800f3da <xmp3fixpt_IntensityProcMPEG2+0xba>
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
				}
			}
		}
	}
	mOut[0] = mOutL;
 800f48a:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
	mOut[1] = mOutR;
 800f48c:	e883 0840 	stmia.w	r3, {r6, fp}

	return;
}
 800f490:	b021      	add	sp, #132	; 0x84
 800f492:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f496:	9a01      	ldr	r2, [sp, #4]
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 800f498:	009b      	lsls	r3, r3, #2
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f49a:	6814      	ldr	r4, [r2, #0]
 800f49c:	e7b0      	b.n	800f400 <xmp3fixpt_IntensityProcMPEG2+0xe0>
				fl = ISFIIP[midSideFlag][0];
 800f49e:	4b4f      	ldr	r3, [pc, #316]	; (800f5dc <xmp3fixpt_IntensityProcMPEG2+0x2bc>)
 800f4a0:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800f4a2:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
				fr = ISFIIP[midSideFlag][1];
 800f4a6:	9b06      	ldr	r3, [sp, #24]
 800f4a8:	685d      	ldr	r5, [r3, #4]
 800f4aa:	e7aa      	b.n	800f402 <xmp3fixpt_IntensityProcMPEG2+0xe2>
 800f4ac:	1d3a      	adds	r2, r7, #4
 800f4ae:	9204      	str	r2, [sp, #16]
					fr = ISFIIP[midSideFlag][1];
 800f4b0:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800f4b2:	4a4a      	ldr	r2, [pc, #296]	; (800f5dc <xmp3fixpt_IntensityProcMPEG2+0x2bc>)
 800f4b4:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
 800f4b8:	9307      	str	r3, [sp, #28]
	mOutL = mOutR = 0;
 800f4ba:	f04f 0b00 	mov.w	fp, #0
		il[12] = 1;
 800f4be:	2301      	movs	r3, #1
					fr = ISFIIP[midSideFlag][1];
 800f4c0:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800f4c4:	9205      	str	r2, [sp, #20]
		il[12] = 1;
 800f4c6:	9315      	str	r3, [sp, #84]	; 0x54
		for(w = 0; w < 3; w++) {
 800f4c8:	f8cd b00c 	str.w	fp, [sp, #12]
 800f4cc:	46de      	mov	lr, fp
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 800f4ce:	9a04      	ldr	r2, [sp, #16]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 800f4d0:	9d07      	ldr	r5, [sp, #28]
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 800f4d2:	f8d2 9018 	ldr.w	r9, [r2, #24]
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 800f4d6:	f852 3b04 	ldr.w	r3, [r2], #4
 800f4da:	9204      	str	r2, [sp, #16]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 800f4dc:	eb05 0249 	add.w	r2, r5, r9, lsl #1
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 800f4e0:	f109 0a01 	add.w	sl, r9, #1
			i = 3 * fh->sfBand->s[cbStartS] + w;
 800f4e4:	8e14      	ldrh	r4, [r2, #48]	; 0x30
 800f4e6:	9903      	ldr	r1, [sp, #12]
 800f4e8:	2203      	movs	r2, #3
 800f4ea:	4616      	mov	r6, r2
			for(cb = cbStartS; cb < cbEndS; cb++) {
 800f4ec:	459a      	cmp	sl, r3
			i = 3 * fh->sfBand->s[cbStartS] + w;
 800f4ee:	fb14 1406 	smlabb	r4, r4, r6, r1
			for(cb = cbStartS; cb < cbEndS; cb++) {
 800f4f2:	dc55      	bgt.n	800f5a0 <xmp3fixpt_IntensityProcMPEG2+0x280>
 800f4f4:	aa09      	add	r2, sp, #36	; 0x24
 800f4f6:	eb02 0a8a 	add.w	sl, r2, sl, lsl #2
 800f4fa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800f4fe:	9a06      	ldr	r2, [sp, #24]
 800f500:	eb09 0849 	add.w	r8, r9, r9, lsl #1
 800f504:	440b      	add	r3, r1
 800f506:	4488      	add	r8, r1
 800f508:	f109 0918 	add.w	r9, r9, #24
 800f50c:	18d3      	adds	r3, r2, r3
 800f50e:	9302      	str	r3, [sp, #8]
 800f510:	f1aa 0a04 	sub.w	sl, sl, #4
 800f514:	4490      	add	r8, r2
 800f516:	eb05 0949 	add.w	r9, r5, r9, lsl #1
				sfIdx = sfis->s[cb][w];
 800f51a:	f898 201a 	ldrb.w	r2, [r8, #26]
				if (sfIdx == il[cb]) {
 800f51e:	f85a 3f04 	ldr.w	r3, [sl, #4]!
 800f522:	429a      	cmp	r2, r3
 800f524:	d04c      	beq.n	800f5c0 <xmp3fixpt_IntensityProcMPEG2+0x2a0>
					isf = (sfis->s[cb][w] + 1) >> 1;
 800f526:	1c53      	adds	r3, r2, #1
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f528:	07d2      	lsls	r2, r2, #31
					isf = (sfis->s[cb][w] + 1) >> 1;
 800f52a:	ea4f 0363 	mov.w	r3, r3, asr #1
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f52e:	d543      	bpl.n	800f5b8 <xmp3fixpt_IntensityProcMPEG2+0x298>
 800f530:	9a01      	ldr	r2, [sp, #4]
 800f532:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 800f536:	2300      	movs	r3, #0
 800f538:	58d6      	ldr	r6, [r2, r3]
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f53a:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
 800f53e:	464a      	mov	r2, r9
 800f540:	f109 0902 	add.w	r9, r9, #2
 800f544:	f9b2 2000 	ldrsh.w	r2, [r2]
 800f548:	1a9b      	subs	r3, r3, r2
				for(j = 0; j < n; j++, i+=3) {
 800f54a:	2b00      	cmp	r3, #0
 800f54c:	dd23      	ble.n	800f596 <xmp3fixpt_IntensityProcMPEG2+0x276>
 800f54e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800f552:	eb03 0c04 	add.w	ip, r3, r4
 800f556:	eb00 0584 	add.w	r5, r0, r4, lsl #2
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f55a:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
 800f55e:	fb86 2303 	smull	r2, r3, r6, r3
					xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 800f562:	009b      	lsls	r3, r3, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800f564:	17d9      	asrs	r1, r3, #31
 800f566:	f8c5 3900 	str.w	r3, [r5, #2304]	; 0x900
	x ^= sign;
 800f56a:	404b      	eors	r3, r1
	x -= sign;
 800f56c:	1a5b      	subs	r3, r3, r1
	__asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y) : "cc");
 800f56e:	f850 2024 	ldr.w	r2, [r0, r4, lsl #2]
 800f572:	ea4b 0b03 	orr.w	fp, fp, r3
 800f576:	fb87 3202 	smull	r3, r2, r7, r2
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 800f57a:	0092      	lsls	r2, r2, #2
	sign = x >> (sizeof(int) * 8 - 1);
 800f57c:	17d1      	asrs	r1, r2, #31
	x ^= sign;
 800f57e:	ea82 0301 	eor.w	r3, r2, r1
 800f582:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
				for(j = 0; j < n; j++, i+=3) {
 800f586:	3403      	adds	r4, #3
	x -= sign;
 800f588:	1a5b      	subs	r3, r3, r1
 800f58a:	4564      	cmp	r4, ip
 800f58c:	f105 050c 	add.w	r5, r5, #12
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 800f590:	ea4e 0e03 	orr.w	lr, lr, r3
				for(j = 0; j < n; j++, i+=3) {
 800f594:	d1e1      	bne.n	800f55a <xmp3fixpt_IntensityProcMPEG2+0x23a>
			for(cb = cbStartS; cb < cbEndS; cb++) {
 800f596:	9b02      	ldr	r3, [sp, #8]
 800f598:	f108 0803 	add.w	r8, r8, #3
 800f59c:	4598      	cmp	r8, r3
 800f59e:	d1bc      	bne.n	800f51a <xmp3fixpt_IntensityProcMPEG2+0x1fa>
		for(w = 0; w < 3; w++) {
 800f5a0:	9b03      	ldr	r3, [sp, #12]
 800f5a2:	3301      	adds	r3, #1
 800f5a4:	2b03      	cmp	r3, #3
 800f5a6:	9303      	str	r3, [sp, #12]
 800f5a8:	d191      	bne.n	800f4ce <xmp3fixpt_IntensityProcMPEG2+0x1ae>
	mOut[0] = mOutL;
 800f5aa:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 800f5ac:	4676      	mov	r6, lr
	mOut[1] = mOutR;
 800f5ae:	e883 0840 	stmia.w	r3, {r6, fp}
}
 800f5b2:	b021      	add	sp, #132	; 0x84
 800f5b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f5b8:	9a01      	ldr	r2, [sp, #4]
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 800f5ba:	009b      	lsls	r3, r3, #2
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 800f5bc:	6817      	ldr	r7, [r2, #0]
 800f5be:	e7bb      	b.n	800f538 <xmp3fixpt_IntensityProcMPEG2+0x218>
					fl = ISFIIP[midSideFlag][0];
 800f5c0:	4b06      	ldr	r3, [pc, #24]	; (800f5dc <xmp3fixpt_IntensityProcMPEG2+0x2bc>)
 800f5c2:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 800f5c4:	f853 7032 	ldr.w	r7, [r3, r2, lsl #3]
					fr = ISFIIP[midSideFlag][1];
 800f5c8:	9b05      	ldr	r3, [sp, #20]
 800f5ca:	685e      	ldr	r6, [r3, #4]
 800f5cc:	e7b5      	b.n	800f53a <xmp3fixpt_IntensityProcMPEG2+0x21a>
	mOut[0] = mOutL;
 800f5ce:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
	mOutL = mOutR = 0;
 800f5d0:	46b3      	mov	fp, r6
	mOut[1] = mOutR;
 800f5d2:	e883 0840 	stmia.w	r3, {r6, fp}
}
 800f5d6:	b021      	add	sp, #132	; 0x84
 800f5d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f5dc:	08017710 	.word	0x08017710
 800f5e0:	08017720 	.word	0x08017720

0800f5e4 <xmp3fixpt_Subband>:
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	SubbandInfo *sbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 800f5e4:	2800      	cmp	r0, #0
 800f5e6:	f000 8083 	beq.w	800f6f0 <xmp3fixpt_Subband+0x10c>
 800f5ea:	68c3      	ldr	r3, [r0, #12]
 800f5ec:	2b00      	cmp	r3, #0
 800f5ee:	d07f      	beq.n	800f6f0 <xmp3fixpt_Subband+0x10c>
{
 800f5f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 800f5f4:	6944      	ldr	r4, [r0, #20]
{
 800f5f6:	b085      	sub	sp, #20
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 800f5f8:	2c00      	cmp	r4, #0
 800f5fa:	d076      	beq.n	800f6ea <xmp3fixpt_Subband+0x106>
 800f5fc:	f8d0 8018 	ldr.w	r8, [r0, #24]
 800f600:	f1b8 0f00 	cmp.w	r8, #0
 800f604:	d071      	beq.n	800f6ea <xmp3fixpt_Subband+0x106>

	hi = (HuffmanInfo *)mp3DecInfo->HuffmanInfoPS;
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
	sbi = (SubbandInfo*)(mp3DecInfo->SubbandInfoPS);

	if (mp3DecInfo->nChans == 2) {
 800f606:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	; 0x7bc
 800f60a:	2b02      	cmp	r3, #2
 800f60c:	460f      	mov	r7, r1
 800f60e:	f508 5608 	add.w	r6, r8, #8704	; 0x2200
 800f612:	f504 59d8 	add.w	r9, r4, #6912	; 0x1b00
 800f616:	d02d      	beq.n	800f674 <xmp3fixpt_Subband+0x90>
 800f618:	6832      	ldr	r2, [r6, #0]
		}
	} else {
		/* mono */
		for (b = 0; b < BLOCK_SIZE; b++) {
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 800f61a:	f8df b0dc 	ldr.w	fp, [pc, #220]	; 800f6f8 <xmp3fixpt_Subband+0x114>
 800f61e:	f109 0918 	add.w	r9, r9, #24
	if (mp3DecInfo->nChans == 2) {
 800f622:	f04f 0a00 	mov.w	sl, #0
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 800f626:	f00a 0501 	and.w	r5, sl, #1
 800f62a:	f8d9 3000 	ldr.w	r3, [r9]
 800f62e:	9300      	str	r3, [sp, #0]
 800f630:	4620      	mov	r0, r4
 800f632:	462b      	mov	r3, r5
 800f634:	4641      	mov	r1, r8
 800f636:	f7fa fc7d 	bl	8009f34 <xmp3fixpt_FDCT32>
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 800f63a:	6831      	ldr	r1, [r6, #0]
 800f63c:	012b      	lsls	r3, r5, #4
 800f63e:	442b      	add	r3, r5
 800f640:	eb01 1183 	add.w	r1, r1, r3, lsl #6
 800f644:	465a      	mov	r2, fp
 800f646:	4638      	mov	r0, r7
 800f648:	eb08 0181 	add.w	r1, r8, r1, lsl #2
 800f64c:	f7fe fc32 	bl	800deb4 <xmp3fixpt_PolyphaseMono>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 800f650:	6832      	ldr	r2, [r6, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 800f652:	f10a 0a01 	add.w	sl, sl, #1
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 800f656:	1b52      	subs	r2, r2, r5
 800f658:	f002 0207 	and.w	r2, r2, #7
		for (b = 0; b < BLOCK_SIZE; b++) {
 800f65c:	f1ba 0f12 	cmp.w	sl, #18
 800f660:	f104 0480 	add.w	r4, r4, #128	; 0x80
			pcmBuf += NBANDS;
 800f664:	f107 0740 	add.w	r7, r7, #64	; 0x40
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 800f668:	6032      	str	r2, [r6, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 800f66a:	d1dc      	bne.n	800f626 <xmp3fixpt_Subband+0x42>
		}
	}

	return 0;
 800f66c:	2000      	movs	r0, #0
}
 800f66e:	b005      	add	sp, #20
 800f670:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f674:	f504 6310 	add.w	r3, r4, #2304	; 0x900
 800f678:	46cb      	mov	fp, r9
 800f67a:	9302      	str	r3, [sp, #8]
 800f67c:	6832      	ldr	r2, [r6, #0]
 800f67e:	f108 0380 	add.w	r3, r8, #128	; 0x80
 800f682:	f109 0918 	add.w	r9, r9, #24
 800f686:	f10b 0b1c 	add.w	fp, fp, #28
 800f68a:	9303      	str	r3, [sp, #12]
	if (mp3DecInfo->nChans == 2) {
 800f68c:	f04f 0a00 	mov.w	sl, #0
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 800f690:	f00a 0501 	and.w	r5, sl, #1
 800f694:	f8d9 3000 	ldr.w	r3, [r9]
 800f698:	9300      	str	r3, [sp, #0]
 800f69a:	4620      	mov	r0, r4
 800f69c:	462b      	mov	r3, r5
 800f69e:	4641      	mov	r1, r8
 800f6a0:	f7fa fc48 	bl	8009f34 <xmp3fixpt_FDCT32>
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 800f6a4:	f8db 3000 	ldr.w	r3, [fp]
 800f6a8:	6832      	ldr	r2, [r6, #0]
 800f6aa:	9903      	ldr	r1, [sp, #12]
 800f6ac:	9300      	str	r3, [sp, #0]
 800f6ae:	f504 6010 	add.w	r0, r4, #2304	; 0x900
 800f6b2:	462b      	mov	r3, r5
 800f6b4:	f7fa fc3e 	bl	8009f34 <xmp3fixpt_FDCT32>
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 800f6b8:	6831      	ldr	r1, [r6, #0]
 800f6ba:	4a0f      	ldr	r2, [pc, #60]	; (800f6f8 <xmp3fixpt_Subband+0x114>)
 800f6bc:	012b      	lsls	r3, r5, #4
 800f6be:	442b      	add	r3, r5
 800f6c0:	eb01 1183 	add.w	r1, r1, r3, lsl #6
 800f6c4:	4638      	mov	r0, r7
 800f6c6:	eb08 0181 	add.w	r1, r8, r1, lsl #2
 800f6ca:	f7fe fd63 	bl	800e194 <xmp3fixpt_PolyphaseStereo>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 800f6ce:	6832      	ldr	r2, [r6, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 800f6d0:	9b02      	ldr	r3, [sp, #8]
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 800f6d2:	1b52      	subs	r2, r2, r5
 800f6d4:	3480      	adds	r4, #128	; 0x80
 800f6d6:	f002 0207 	and.w	r2, r2, #7
		for (b = 0; b < BLOCK_SIZE; b++) {
 800f6da:	42a3      	cmp	r3, r4
 800f6dc:	f10a 0a01 	add.w	sl, sl, #1
			pcmBuf += (2 * NBANDS);
 800f6e0:	f107 0780 	add.w	r7, r7, #128	; 0x80
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 800f6e4:	6032      	str	r2, [r6, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 800f6e6:	d1d3      	bne.n	800f690 <xmp3fixpt_Subband+0xac>
 800f6e8:	e7c0      	b.n	800f66c <xmp3fixpt_Subband+0x88>
		return -1;
 800f6ea:	f04f 30ff 	mov.w	r0, #4294967295
 800f6ee:	e7be      	b.n	800f66e <xmp3fixpt_Subband+0x8a>
 800f6f0:	f04f 30ff 	mov.w	r0, #4294967295
 800f6f4:	4770      	bx	lr
 800f6f6:	bf00      	nop
 800f6f8:	0801722c 	.word	0x0801722c

0800f6fc <UB_Button_Init>:

//--------------------------------------------------------------
// Init aller Buttons
//--------------------------------------------------------------
void UB_Button_Init(void)
{
 800f6fc:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStructure;  
  BUTTON_NAME_t btn_name;
  
  for(btn_name=0;btn_name<BUTTON_ANZ;btn_name++) {
    // Clock Enable
    RCC_AHB1PeriphClockCmd(BUTTON[btn_name].BUTTON_CLK, ENABLE);
 800f6fe:	4c0a      	ldr	r4, [pc, #40]	; (800f728 <UB_Button_Init+0x2c>)
{
 800f700:	b082      	sub	sp, #8
    RCC_AHB1PeriphClockCmd(BUTTON[btn_name].BUTTON_CLK, ENABLE);
 800f702:	68e0      	ldr	r0, [r4, #12]
 800f704:	2101      	movs	r1, #1
 800f706:	f7f1 fcd7 	bl	80010b8 <RCC_AHB1PeriphClockCmd>
  
    // Config als Digital-Eingang
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_PuPd = BUTTON[btn_name].BUTTON_R;
    GPIO_InitStructure.GPIO_Pin = BUTTON[btn_name].BUTTON_PIN;
 800f70a:	a902      	add	r1, sp, #8
 800f70c:	8923      	ldrh	r3, [r4, #8]
 800f70e:	f841 3d08 	str.w	r3, [r1, #-8]!
    GPIO_InitStructure.GPIO_PuPd = BUTTON[btn_name].BUTTON_R;
 800f712:	7c23      	ldrb	r3, [r4, #16]
 800f714:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_Init(BUTTON[btn_name].BUTTON_PORT, &GPIO_InitStructure);
 800f718:	6860      	ldr	r0, [r4, #4]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800f71a:	2300      	movs	r3, #0
 800f71c:	f88d 3004 	strb.w	r3, [sp, #4]
    GPIO_Init(BUTTON[btn_name].BUTTON_PORT, &GPIO_InitStructure);
 800f720:	f7f1 f8b0 	bl	8000884 <GPIO_Init>
  }
}
 800f724:	b002      	add	sp, #8
 800f726:	bd10      	pop	{r4, pc}
 800f728:	20000088 	.word	0x20000088

0800f72c <UB_Button_Read>:
// Return Wert :
//  -> wenn Button losgelassen = BTN_RELEASED
//  -> wenn Button gedrueckt   = BTN_PRESSED
//--------------------------------------------------------------
BUTTON_STATUS_t UB_Button_Read(BUTTON_NAME_t btn_name)
{
 800f72c:	b508      	push	{r3, lr}
  uint32_t wert;

  wert=GPIO_ReadInputDataBit(BUTTON[btn_name].BUTTON_PORT, BUTTON[btn_name].BUTTON_PIN);
 800f72e:	4b06      	ldr	r3, [pc, #24]	; (800f748 <UB_Button_Read+0x1c>)
 800f730:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800f734:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800f738:	8901      	ldrh	r1, [r0, #8]
 800f73a:	6840      	ldr	r0, [r0, #4]
 800f73c:	f7f1 f90e 	bl	800095c <GPIO_ReadInputDataBit>
	  return(BTN_RELEASED);
  }
  else {
	  return(BTN_PRESSED);
  }
} 
 800f740:	3000      	adds	r0, #0
 800f742:	bf18      	it	ne
 800f744:	2001      	movne	r0, #1
 800f746:	bd08      	pop	{r3, pc}
 800f748:	20000088 	.word	0x20000088

0800f74c <MP3CallbackFkt>:

//--------------------------------------------------------------
// interne Funktion
//--------------------------------------------------------------
static void MP3CallbackFkt(void *context, int buffer_nr)
{
 800f74c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  int offset;
  int error;
  int ok;

  // nchste sync finden
  offset = MP3FindSyncWord((unsigned char*)my_mp3.read_ptr, my_mp3.bytes_left);
 800f750:	4c72      	ldr	r4, [pc, #456]	; (800f91c <MP3CallbackFkt+0x1d0>)
{
 800f752:	b082      	sub	sp, #8
 800f754:	4607      	mov	r7, r0
 800f756:	460e      	mov	r6, r1
  offset = MP3FindSyncWord((unsigned char*)my_mp3.read_ptr, my_mp3.bytes_left);
 800f758:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800f75a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800f75c:	f7f8 fdac 	bl	80082b8 <MP3FindSyncWord>
  if(offset<0) {
 800f760:	1e05      	subs	r5, r0, #0
 800f762:	db59      	blt.n	800f818 <MP3CallbackFkt+0xcc>
    // kein sync gefunden
    my_mp3.last_err=MP3_SYNC_ERR;
    my_mp3.ende_flag=1;
  }
  else if(offset>0){
 800f764:	d078      	beq.n	800f858 <MP3CallbackFkt+0x10c>
    // sync ok aber keine Daten
    // frameinfo auslesen
    error=MP3GetNextFrameInfo(my_mp3.mp3_data, &my_mp3.mp3_info,(unsigned char*)my_mp3.read_ptr);
 800f766:	4621      	mov	r1, r4
 800f768:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800f76a:	f851 0b04 	ldr.w	r0, [r1], #4
 800f76e:	f7f8 fde5 	bl	800833c <MP3GetNextFrameInfo>
    if(error==ERR_MP3_NONE) {
 800f772:	bb18      	cbnz	r0, 800f7bc <MP3CallbackFkt+0x70>
      // kein Fehler
      if(my_mp3.mp3_info.samprate!=44100) {
 800f774:	68e2      	ldr	r2, [r4, #12]
 800f776:	f64a 4344 	movw	r3, #44100	; 0xac44
 800f77a:	429a      	cmp	r2, r3
 800f77c:	d044      	beq.n	800f808 <MP3CallbackFkt+0xbc>
        // falsche sampelrate
        my_mp3.last_err=MP3_FRQ_ERR;
 800f77e:	f244 0141 	movw	r1, #16449	; 0x4041
        my_mp3.ende_flag=1;
 800f782:	f244 0335 	movw	r3, #16437	; 0x4035
        my_mp3.last_err=MP3_FRQ_ERR;
 800f786:	2005      	movs	r0, #5
        my_mp3.ende_flag=1;
 800f788:	2201      	movs	r2, #1
        my_mp3.last_err=MP3_FRQ_ERR;
 800f78a:	5460      	strb	r0, [r4, r1]
        my_mp3.ende_flag=1;
 800f78c:	54e2      	strb	r2, [r4, r3]
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f78e:	4a64      	ldr	r2, [pc, #400]	; (800f920 <MP3CallbackFkt+0x1d4>)
 800f790:	7a13      	ldrb	r3, [r2, #8]
 800f792:	3b02      	subs	r3, #2
 800f794:	2b01      	cmp	r3, #1
 800f796:	d83c      	bhi.n	800f812 <MP3CallbackFkt+0xc6>
    cs43l22_status=CS43L22_STOP;
 800f798:	2304      	movs	r3, #4
    EVAL_AUDIO_Stop(CODEC_PDWN_HW);  // CODEC_PDWN_SW => rauschen
 800f79a:	2001      	movs	r0, #1
    cs43l22_status=CS43L22_STOP;
 800f79c:	7213      	strb	r3, [r2, #8]
    EVAL_AUDIO_Stop(CODEC_PDWN_HW);  // CODEC_PDWN_SW => rauschen
 800f79e:	f7f2 feef 	bl	8002580 <EVAL_AUDIO_Stop>
    my_mp3.dma_enable = 0;
 800f7a2:	f244 0136 	movw	r1, #16438	; 0x4036
    my_mp3.next_buffer_ptr = 0;
 800f7a6:	f244 0238 	movw	r2, #16440	; 0x4038
    UB_Fatfs_CloseFile(&myMP3File);
 800f7aa:	485e      	ldr	r0, [pc, #376]	; (800f924 <MP3CallbackFkt+0x1d8>)
    my_mp3.dma_enable = 0;
 800f7ac:	2300      	movs	r3, #0
 800f7ae:	5463      	strb	r3, [r4, r1]
    my_mp3.next_buffer_ptr = 0;
 800f7b0:	50a3      	str	r3, [r4, r2]
  // test ob ende erreicht
  // (kommt bei der MP3 Version normalerweise nicht vor)
  if(my_mp3.ende_flag==1) {
    UB_CS43L22_StopMP3();
  }
}
 800f7b2:	b002      	add	sp, #8
 800f7b4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    UB_Fatfs_CloseFile(&myMP3File);
 800f7b8:	f000 bc0a 	b.w	800ffd0 <UB_Fatfs_CloseFile>
    else if(error==ERR_MP3_INVALID_FRAMEHEADER) {
 800f7bc:	3006      	adds	r0, #6
 800f7be:	d039      	beq.n	800f834 <MP3CallbackFkt+0xe8>
      my_mp3.ende_flag=1;
 800f7c0:	f244 0335 	movw	r3, #16437	; 0x4035
 800f7c4:	2201      	movs	r2, #1
 800f7c6:	54e2      	strb	r2, [r4, r3]
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f7c8:	4a55      	ldr	r2, [pc, #340]	; (800f920 <MP3CallbackFkt+0x1d4>)
 800f7ca:	7a13      	ldrb	r3, [r2, #8]
      my_mp3.last_err=MP3_FRAME_ERR;
 800f7cc:	f244 0141 	movw	r1, #16449	; 0x4041
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f7d0:	3b02      	subs	r3, #2
      my_mp3.last_err=MP3_FRAME_ERR;
 800f7d2:	2006      	movs	r0, #6
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f7d4:	2b01      	cmp	r3, #1
      my_mp3.last_err=MP3_FRAME_ERR;
 800f7d6:	5460      	strb	r0, [r4, r1]
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f7d8:	d81b      	bhi.n	800f812 <MP3CallbackFkt+0xc6>
 800f7da:	e7dd      	b.n	800f798 <MP3CallbackFkt+0x4c>
  EVAL_IRQ_DISABLE();

  my_mp3.next_buffer_ptr = data_ptr;
  my_mp3.next_buffer_len = sampl_cnt;

  if (my_mp3.dma_enable==0) {
 800f7dc:	f244 0836 	movw	r8, #16438	; 0x4036
        SetMP3Buffer(my_mp3.data_ptr, my_mp3.mp3_info.outputSamps);
 800f7e0:	f8d4 a030 	ldr.w	sl, [r4, #48]	; 0x30
  EVAL_IRQ_DISABLE();
 800f7e4:	f7f2 ff70 	bl	80026c8 <EVAL_IRQ_DISABLE>
  my_mp3.next_buffer_len = sampl_cnt;
 800f7e8:	f244 033c 	movw	r3, #16444	; 0x403c
  if (my_mp3.dma_enable==0) {
 800f7ec:	f814 9008 	ldrb.w	r9, [r4, r8]
  my_mp3.next_buffer_ptr = data_ptr;
 800f7f0:	f844 a007 	str.w	sl, [r4, r7]
  my_mp3.next_buffer_len = sampl_cnt;
 800f7f4:	50e5      	str	r5, [r4, r3]
  if (my_mp3.dma_enable==0) {
 800f7f6:	f1b9 0f00 	cmp.w	r9, #0
 800f7fa:	d077      	beq.n	800f8ec <MP3CallbackFkt+0x1a0>
    StartMP3Buffer();
  }

  EVAL_IRQ_ENABLE();
 800f7fc:	f7f2 ff5c 	bl	80026b8 <EVAL_IRQ_ENABLE>
        if (buffer_nr==0) {
 800f800:	2e00      	cmp	r6, #0
 800f802:	d170      	bne.n	800f8e6 <MP3CallbackFkt+0x19a>
          my_mp3.data_ptr = my_mp3.buffer0;
 800f804:	4b48      	ldr	r3, [pc, #288]	; (800f928 <MP3CallbackFkt+0x1dc>)
 800f806:	6323      	str	r3, [r4, #48]	; 0x30
  if(my_mp3.ende_flag==1) {
 800f808:	f244 0335 	movw	r3, #16437	; 0x4035
 800f80c:	5ce3      	ldrb	r3, [r4, r3]
 800f80e:	2b01      	cmp	r3, #1
 800f810:	d0bd      	beq.n	800f78e <MP3CallbackFkt+0x42>
}
 800f812:	b002      	add	sp, #8
 800f814:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    my_mp3.ende_flag=1;
 800f818:	f244 0335 	movw	r3, #16437	; 0x4035
 800f81c:	2201      	movs	r2, #1
 800f81e:	54e2      	strb	r2, [r4, r3]
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f820:	4a3f      	ldr	r2, [pc, #252]	; (800f920 <MP3CallbackFkt+0x1d4>)
 800f822:	7a13      	ldrb	r3, [r2, #8]
    my_mp3.last_err=MP3_SYNC_ERR;
 800f824:	f244 0141 	movw	r1, #16449	; 0x4041
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f828:	3b02      	subs	r3, #2
    my_mp3.last_err=MP3_SYNC_ERR;
 800f82a:	2004      	movs	r0, #4
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f82c:	2b01      	cmp	r3, #1
    my_mp3.last_err=MP3_SYNC_ERR;
 800f82e:	5460      	strb	r0, [r4, r1]
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800f830:	d8ef      	bhi.n	800f812 <MP3CallbackFkt+0xc6>
 800f832:	e7b1      	b.n	800f798 <MP3CallbackFkt+0x4c>
      my_mp3.bytes_left -= offset;
 800f834:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      my_mp3.read_ptr += offset;
 800f836:	6a62      	ldr	r2, [r4, #36]	; 0x24
      my_mp3.bytes_left -= offset;
 800f838:	1b5b      	subs	r3, r3, r5
      if(my_mp3.bytes_left<MP3_MIN_BYTES_REMAINING) {
 800f83a:	2b63      	cmp	r3, #99	; 0x63
      my_mp3.read_ptr += offset;
 800f83c:	4415      	add	r5, r2
      my_mp3.bytes_left -= offset;
 800f83e:	62e3      	str	r3, [r4, #44]	; 0x2c
      my_mp3.read_ptr += offset;
 800f840:	6265      	str	r5, [r4, #36]	; 0x24
      if(my_mp3.bytes_left<MP3_MIN_BYTES_REMAINING) {
 800f842:	dc03      	bgt.n	800f84c <MP3CallbackFkt+0x100>
        my_mp3.ende_flag=1;
 800f844:	f244 0335 	movw	r3, #16437	; 0x4035
 800f848:	2201      	movs	r2, #1
 800f84a:	54e2      	strb	r2, [r4, r3]
      MP3CallbackFunctionPtr(context, buffer_nr);
 800f84c:	4b34      	ldr	r3, [pc, #208]	; (800f920 <MP3CallbackFkt+0x1d4>)
 800f84e:	4631      	mov	r1, r6
 800f850:	4638      	mov	r0, r7
 800f852:	681b      	ldr	r3, [r3, #0]
 800f854:	4798      	blx	r3
 800f856:	e7d7      	b.n	800f808 <MP3CallbackFkt+0xbc>
    error = MP3Decode(my_mp3.mp3_data, (unsigned char**)&my_mp3.read_ptr, &my_mp3.bytes_left, my_mp3.data_ptr, 0);
 800f858:	4622      	mov	r2, r4
 800f85a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800f85c:	f852 0b2c 	ldr.w	r0, [r2], #44
 800f860:	9500      	str	r5, [sp, #0]
 800f862:	f104 0124 	add.w	r1, r4, #36	; 0x24
 800f866:	f7f8 fd99 	bl	800839c <MP3Decode>
    switch(error) {
 800f86a:	1c43      	adds	r3, r0, #1
 800f86c:	d032      	beq.n	800f8d4 <MP3CallbackFkt+0x188>
 800f86e:	b168      	cbz	r0, 800f88c <MP3CallbackFkt+0x140>
 800f870:	3002      	adds	r0, #2
 800f872:	d025      	beq.n	800f8c0 <MP3CallbackFkt+0x174>
        if(my_mp3.bytes_left>(2*MP3_BYTES_SKIP)) {
 800f874:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    	my_mp3.last_err=MP3_DECODE_ERR;
 800f876:	f244 0241 	movw	r2, #16449	; 0x4041
 800f87a:	2109      	movs	r1, #9
        if(my_mp3.bytes_left>(2*MP3_BYTES_SKIP)) {
 800f87c:	2b64      	cmp	r3, #100	; 0x64
    	my_mp3.last_err=MP3_DECODE_ERR;
 800f87e:	54a1      	strb	r1, [r4, r2]
        if(my_mp3.bytes_left>(2*MP3_BYTES_SKIP)) {
 800f880:	dc13      	bgt.n	800f8aa <MP3CallbackFkt+0x15e>
          my_mp3.ende_flag=1;
 800f882:	f244 0335 	movw	r3, #16437	; 0x4035
 800f886:	2201      	movs	r2, #1
 800f888:	54e2      	strb	r2, [r4, r3]
 800f88a:	e780      	b.n	800f78e <MP3CallbackFkt+0x42>
      MP3GetLastFrameInfo(my_mp3.mp3_data, &my_mp3.mp3_info);
 800f88c:	4621      	mov	r1, r4
 800f88e:	f851 0b04 	ldr.w	r0, [r1], #4
 800f892:	f7f8 fd27 	bl	80082e4 <MP3GetLastFrameInfo>
      if(my_mp3.mp3_info.outputSamps>0) {
 800f896:	6965      	ldr	r5, [r4, #20]
 800f898:	2d00      	cmp	r5, #0
 800f89a:	ddb5      	ble.n	800f808 <MP3CallbackFkt+0xbc>
  if (my_mp3.next_buffer_ptr) {
 800f89c:	f244 0738 	movw	r7, #16440	; 0x4038
 800f8a0:	59e3      	ldr	r3, [r4, r7]
 800f8a2:	2b00      	cmp	r3, #0
 800f8a4:	d09a      	beq.n	800f7dc <MP3CallbackFkt+0x90>
    __asm__ volatile ("wfi");
 800f8a6:	bf30      	wfi
 800f8a8:	e7fd      	b.n	800f8a6 <MP3CallbackFkt+0x15a>
          my_mp3.read_ptr += MP3_BYTES_SKIP;
 800f8aa:	6a62      	ldr	r2, [r4, #36]	; 0x24
          MP3CallbackFunctionPtr(context, buffer_nr);
 800f8ac:	4d1c      	ldr	r5, [pc, #112]	; (800f920 <MP3CallbackFkt+0x1d4>)
          my_mp3.bytes_left -= MP3_BYTES_SKIP;
 800f8ae:	3b32      	subs	r3, #50	; 0x32
          my_mp3.read_ptr += MP3_BYTES_SKIP;
 800f8b0:	3232      	adds	r2, #50	; 0x32
          my_mp3.bytes_left -= MP3_BYTES_SKIP;
 800f8b2:	62e3      	str	r3, [r4, #44]	; 0x2c
          MP3CallbackFunctionPtr(context, buffer_nr);
 800f8b4:	4631      	mov	r1, r6
 800f8b6:	4638      	mov	r0, r7
          my_mp3.read_ptr += MP3_BYTES_SKIP;
 800f8b8:	6262      	str	r2, [r4, #36]	; 0x24
          MP3CallbackFunctionPtr(context, buffer_nr);
 800f8ba:	682b      	ldr	r3, [r5, #0]
 800f8bc:	4798      	blx	r3
 800f8be:	e7a3      	b.n	800f808 <MP3CallbackFkt+0xbc>
        MP3CallbackFunctionPtr(context, buffer_nr);
 800f8c0:	4b17      	ldr	r3, [pc, #92]	; (800f920 <MP3CallbackFkt+0x1d4>)
 800f8c2:	4631      	mov	r1, r6
 800f8c4:	681b      	ldr	r3, [r3, #0]
 800f8c6:	4638      	mov	r0, r7
 800f8c8:	4798      	blx	r3
        my_mp3.last_err=MP3_MDATA_ERR;
 800f8ca:	f244 0341 	movw	r3, #16449	; 0x4041
 800f8ce:	2208      	movs	r2, #8
 800f8d0:	54e2      	strb	r2, [r4, r3]
      break;
 800f8d2:	e799      	b.n	800f808 <MP3CallbackFkt+0xbc>
    	my_mp3.last_err=MP3_IDATA_ERR;
 800f8d4:	f244 0141 	movw	r1, #16449	; 0x4041
        my_mp3.ende_flag=1;
 800f8d8:	f244 0335 	movw	r3, #16437	; 0x4035
    	my_mp3.last_err=MP3_IDATA_ERR;
 800f8dc:	2007      	movs	r0, #7
        my_mp3.ende_flag=1;
 800f8de:	2201      	movs	r2, #1
    	my_mp3.last_err=MP3_IDATA_ERR;
 800f8e0:	5460      	strb	r0, [r4, r1]
        my_mp3.ende_flag=1;
 800f8e2:	54e2      	strb	r2, [r4, r3]
      break;
 800f8e4:	e753      	b.n	800f78e <MP3CallbackFkt+0x42>
          my_mp3.data_ptr = my_mp3.buffer1;
 800f8e6:	4b11      	ldr	r3, [pc, #68]	; (800f92c <MP3CallbackFkt+0x1e0>)
 800f8e8:	6323      	str	r3, [r4, #48]	; 0x30
 800f8ea:	e78d      	b.n	800f808 <MP3CallbackFkt+0xbc>
//--------------------------------------------------------------
// interne Funktion
//--------------------------------------------------------------
void StartMP3Buffer(void)
{
  EVAL_SET_DMA(my_mp3.next_buffer_len, my_mp3.next_buffer_ptr);
 800f8ec:	4628      	mov	r0, r5
 800f8ee:	4651      	mov	r1, sl
 800f8f0:	f7f2 fef2 	bl	80026d8 <EVAL_SET_DMA>

  my_mp3.next_buffer_ptr = 0;
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800f8f4:	f244 0334 	movw	r3, #16436	; 0x4034
  my_mp3.dma_enable = 1;

  if (MP3CallbackFunctionPtr) {
 800f8f8:	4809      	ldr	r0, [pc, #36]	; (800f920 <MP3CallbackFkt+0x1d4>)
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800f8fa:	5ce1      	ldrb	r1, [r4, r3]
  if (MP3CallbackFunctionPtr) {
 800f8fc:	6802      	ldr	r2, [r0, #0]
  my_mp3.next_buffer_ptr = 0;
 800f8fe:	f844 9007 	str.w	r9, [r4, r7]
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800f902:	f1c1 0101 	rsb	r1, r1, #1
 800f906:	b2c9      	uxtb	r1, r1
  my_mp3.dma_enable = 1;
 800f908:	2501      	movs	r5, #1
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800f90a:	54e1      	strb	r1, [r4, r3]
  my_mp3.dma_enable = 1;
 800f90c:	f804 5008 	strb.w	r5, [r4, r8]
  if (MP3CallbackFunctionPtr) {
 800f910:	2a00      	cmp	r2, #0
 800f912:	f43f af73 	beq.w	800f7fc <MP3CallbackFkt+0xb0>
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800f916:	6840      	ldr	r0, [r0, #4]
 800f918:	4790      	blx	r2
 800f91a:	e76f      	b.n	800f7fc <MP3CallbackFkt+0xb0>
 800f91c:	200080d8 	.word	0x200080d8
 800f920:	20007e38 	.word	0x20007e38
 800f924:	2000c11c 	.word	0x2000c11c
 800f928:	2000810c 	.word	0x2000810c
 800f92c:	2000a10c 	.word	0x2000a10c

0800f930 <UB_CS43L22_InitMP3>:
{
 800f930:	b570      	push	{r4, r5, r6, lr}
  if(cs43l22_status==CS43L22_NO_INIT) {
 800f932:	4d11      	ldr	r5, [pc, #68]	; (800f978 <UB_CS43L22_InitMP3+0x48>)
 800f934:	7a2c      	ldrb	r4, [r5, #8]
 800f936:	b10c      	cbz	r4, 800f93c <UB_CS43L22_InitMP3+0xc>
  ErrorStatus ret_wert=ERROR;
 800f938:	2000      	movs	r0, #0
}
 800f93a:	bd70      	pop	{r4, r5, r6, pc}
    my_mp3.mp3_data = MP3InitDecoder();
 800f93c:	f7f8 fcb6 	bl	80082ac <MP3InitDecoder>
 800f940:	4e0e      	ldr	r6, [pc, #56]	; (800f97c <UB_CS43L22_InitMP3+0x4c>)
 800f942:	6030      	str	r0, [r6, #0]
    if(my_mp3.mp3_data==0) {
 800f944:	b190      	cbz	r0, 800f96c <UB_CS43L22_InitMP3+0x3c>
    UB_AUDIO_SetI2SClock();
 800f946:	f7f2 fc63 	bl	8002210 <UB_AUDIO_SetI2SClock>
    check=EVAL_AUDIO_Init(70, I2S_AudioFreq_44k);
 800f94a:	f64a 4144 	movw	r1, #44100	; 0xac44
 800f94e:	2046      	movs	r0, #70	; 0x46
 800f950:	f7f2 fc72 	bl	8002238 <EVAL_AUDIO_Init>
      my_mp3.last_err=MP3_OK;
 800f954:	f244 0341 	movw	r3, #16449	; 0x4041
    if(check==0) {
 800f958:	b118      	cbz	r0, 800f962 <UB_CS43L22_InitMP3+0x32>
      my_mp3.last_err=MP3_INIT_ERR;
 800f95a:	2201      	movs	r2, #1
      ret_wert=ERROR;
 800f95c:	4620      	mov	r0, r4
      my_mp3.last_err=MP3_INIT_ERR;
 800f95e:	54f2      	strb	r2, [r6, r3]
 800f960:	bd70      	pop	{r4, r5, r6, pc}
      cs43l22_status=CS43L22_INIT_OK;
 800f962:	2401      	movs	r4, #1
      my_mp3.last_err=MP3_OK;
 800f964:	54f0      	strb	r0, [r6, r3]
      cs43l22_status=CS43L22_INIT_OK;
 800f966:	722c      	strb	r4, [r5, #8]
      ret_wert=SUCCESS;
 800f968:	4620      	mov	r0, r4
 800f96a:	bd70      	pop	{r4, r5, r6, pc}
      my_mp3.last_err=MP3_MALLOC_ERR;
 800f96c:	f244 0341 	movw	r3, #16449	; 0x4041
 800f970:	2202      	movs	r2, #2
 800f972:	54f2      	strb	r2, [r6, r3]
      return(ERROR);
 800f974:	bd70      	pop	{r4, r5, r6, pc}
 800f976:	bf00      	nop
 800f978:	20007e38 	.word	0x20007e38
 800f97c:	200080d8 	.word	0x200080d8

0800f980 <UB_CS43L22_PlayMP3Single>:
{
 800f980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if((cs43l22_status==CS43L22_INIT_OK) || (cs43l22_status==CS43L22_STOP)) {
 800f984:	4d36      	ldr	r5, [pc, #216]	; (800fa60 <UB_CS43L22_PlayMP3Single+0xe0>)
 800f986:	7a2b      	ldrb	r3, [r5, #8]
 800f988:	2b01      	cmp	r3, #1
{
 800f98a:	b082      	sub	sp, #8
  if((cs43l22_status==CS43L22_INIT_OK) || (cs43l22_status==CS43L22_STOP)) {
 800f98c:	d005      	beq.n	800f99a <UB_CS43L22_PlayMP3Single+0x1a>
 800f98e:	2b04      	cmp	r3, #4
 800f990:	d003      	beq.n	800f99a <UB_CS43L22_PlayMP3Single+0x1a>
  MP3_ERR_t ret_wert=MP3_INIT_ERR;
 800f992:	2001      	movs	r0, #1
}
 800f994:	b002      	add	sp, #8
 800f996:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f99a:	460e      	mov	r6, r1
    check_fat=UB_Fatfs_OpenFile(&myMP3File,name,F_RD);
 800f99c:	2200      	movs	r2, #0
 800f99e:	4601      	mov	r1, r0
 800f9a0:	4830      	ldr	r0, [pc, #192]	; (800fa64 <UB_CS43L22_PlayMP3Single+0xe4>)
 800f9a2:	f000 fae9 	bl	800ff78 <UB_Fatfs_OpenFile>
    if(check_fat!=FATFS_OK) {
 800f9a6:	b118      	cbz	r0, 800f9b0 <UB_CS43L22_PlayMP3Single+0x30>
      return(MP3_FILE_ERR);
 800f9a8:	2003      	movs	r0, #3
}
 800f9aa:	b002      	add	sp, #8
 800f9ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    check_read=f_read(&myMP3File, mp3_buf, MP3_READ_BUF_SIZE, &bytes_read);
 800f9b0:	4f2d      	ldr	r7, [pc, #180]	; (800fa68 <UB_CS43L22_PlayMP3Single+0xe8>)
 800f9b2:	482c      	ldr	r0, [pc, #176]	; (800fa64 <UB_CS43L22_PlayMP3Single+0xe4>)
 800f9b4:	4639      	mov	r1, r7
 800f9b6:	ab01      	add	r3, sp, #4
 800f9b8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800f9bc:	f7f5 fb86 	bl	80050cc <f_read>
    if((check_read!=FR_OK) || (bytes_read!=MP3_READ_BUF_SIZE)) {
 800f9c0:	4604      	mov	r4, r0
 800f9c2:	2800      	cmp	r0, #0
 800f9c4:	d147      	bne.n	800fa56 <UB_CS43L22_PlayMP3Single+0xd6>
 800f9c6:	9b01      	ldr	r3, [sp, #4]
 800f9c8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800f9cc:	d143      	bne.n	800fa56 <UB_CS43L22_PlayMP3Single+0xd6>
    my_mp3.start_ptr=&mp3_buf[0];
 800f9ce:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 800fa70 <UB_CS43L22_PlayMP3Single+0xf0>
  MP3CallbackFunctionPtr = 0;
 800f9d2:	6028      	str	r0, [r5, #0]
    my_mp3.loop_flag=0;
 800f9d4:	f244 0240 	movw	r2, #16448	; 0x4040
  my_mp3.next_buffer_ptr = 0;
 800f9d8:	f244 0138 	movw	r1, #16440	; 0x4038
    my_mp3.loop_flag=0;
 800f9dc:	f808 4002 	strb.w	r4, [r8, r2]
    my_mp3.bytes_left_start=MP3_READ_BUF_SIZE;
 800f9e0:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    my_mp3.bytes_left=my_mp3.bytes_left_start;
 800f9e4:	f8c8 302c 	str.w	r3, [r8, #44]	; 0x2c
  my_mp3.data_ptr = my_mp3.buffer0;
 800f9e8:	f108 0234 	add.w	r2, r8, #52	; 0x34
  my_mp3.next_buffer_len = 0;
 800f9ec:	f244 033c 	movw	r3, #16444	; 0x403c
  my_mp3.ende_flag=0;
 800f9f0:	f244 0e35 	movw	lr, #16437	; 0x4035
    EVAL_AUDIO_Init(Volume, I2S_AudioFreq_44k);
 800f9f4:	4630      	mov	r0, r6
    my_mp3.start_ptr=&mp3_buf[0];
 800f9f6:	f8c8 7020 	str.w	r7, [r8, #32]
    my_mp3.read_ptr=my_mp3.start_ptr;
 800f9fa:	f8c8 7024 	str.w	r7, [r8, #36]	; 0x24
  my_mp3.data_ptr = my_mp3.buffer0;
 800f9fe:	f8c8 2030 	str.w	r2, [r8, #48]	; 0x30
  my_mp3.akt_buf_nr = 0;
 800fa02:	f244 0634 	movw	r6, #16436	; 0x4034
  my_mp3.last_err=MP3_OK;
 800fa06:	f244 0241 	movw	r2, #16449	; 0x4041
  my_mp3.dma_enable=0;
 800fa0a:	f244 0736 	movw	r7, #16438	; 0x4036
  my_mp3.next_buffer_ptr = 0;
 800fa0e:	f848 4001 	str.w	r4, [r8, r1]
  my_mp3.next_buffer_len = 0;
 800fa12:	f848 4003 	str.w	r4, [r8, r3]
    EVAL_AUDIO_Init(Volume, I2S_AudioFreq_44k);
 800fa16:	f64a 4144 	movw	r1, #44100	; 0xac44
    cs43l22_status=CS43L22_PLAY;
 800fa1a:	2302      	movs	r3, #2
  my_mp3.ende_flag=0;
 800fa1c:	f808 400e 	strb.w	r4, [r8, lr]
  my_mp3.last_err=MP3_OK;
 800fa20:	f808 4002 	strb.w	r4, [r8, r2]
    cs43l22_status=CS43L22_PLAY;
 800fa24:	722b      	strb	r3, [r5, #8]
  CallbackContextPtr = 0;
 800fa26:	606c      	str	r4, [r5, #4]
  my_mp3.akt_buf_nr = 0;
 800fa28:	f808 4006 	strb.w	r4, [r8, r6]
  my_mp3.dma_enable=0;
 800fa2c:	f808 4007 	strb.w	r4, [r8, r7]
    EVAL_AUDIO_Init(Volume, I2S_AudioFreq_44k);
 800fa30:	f7f2 fc02 	bl	8002238 <EVAL_AUDIO_Init>
  EVAL_AUDIO_StopDMA();
 800fa34:	f7f2 fddc 	bl	80025f0 <EVAL_AUDIO_StopDMA>
  my_mp3.dma_enable = 0;
 800fa38:	f808 4007 	strb.w	r4, [r8, r7]
  EVAL_AUDIO_Play();
 800fa3c:	f7f2 fd1c 	bl	8002478 <EVAL_AUDIO_Play>
  MP3CallbackFunctionPtr = callback_ptr;
 800fa40:	4b0a      	ldr	r3, [pc, #40]	; (800fa6c <UB_CS43L22_PlayMP3Single+0xec>)
  my_mp3.akt_buf_nr = 0;
 800fa42:	f808 4006 	strb.w	r4, [r8, r6]
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fa46:	4620      	mov	r0, r4
 800fa48:	4621      	mov	r1, r4
  MP3CallbackFunctionPtr = callback_ptr;
 800fa4a:	e885 0018 	stmia.w	r5, {r3, r4}
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fa4e:	f7ff fe7d 	bl	800f74c <MP3CallbackFkt>
    ret_wert=MP3_OK;
 800fa52:	4620      	mov	r0, r4
 800fa54:	e79e      	b.n	800f994 <UB_CS43L22_PlayMP3Single+0x14>
      UB_Fatfs_CloseFile(&myMP3File);
 800fa56:	4803      	ldr	r0, [pc, #12]	; (800fa64 <UB_CS43L22_PlayMP3Single+0xe4>)
 800fa58:	f000 faba 	bl	800ffd0 <UB_Fatfs_CloseFile>
      return(MP3_FILE_ERR);
 800fa5c:	2003      	movs	r0, #3
 800fa5e:	e799      	b.n	800f994 <UB_CS43L22_PlayMP3Single+0x14>
 800fa60:	20007e38 	.word	0x20007e38
 800fa64:	2000c11c 	.word	0x2000c11c
 800fa68:	2000c340 	.word	0x2000c340
 800fa6c:	0800f74d 	.word	0x0800f74d
 800fa70:	200080d8 	.word	0x200080d8

0800fa74 <UB_CS43L22_PlayMP3Loop>:
{
 800fa74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if((cs43l22_status==CS43L22_INIT_OK) || (cs43l22_status==CS43L22_STOP)) {
 800fa78:	4d37      	ldr	r5, [pc, #220]	; (800fb58 <UB_CS43L22_PlayMP3Loop+0xe4>)
 800fa7a:	7a2b      	ldrb	r3, [r5, #8]
 800fa7c:	2b01      	cmp	r3, #1
{
 800fa7e:	b082      	sub	sp, #8
  if((cs43l22_status==CS43L22_INIT_OK) || (cs43l22_status==CS43L22_STOP)) {
 800fa80:	d005      	beq.n	800fa8e <UB_CS43L22_PlayMP3Loop+0x1a>
 800fa82:	2b04      	cmp	r3, #4
 800fa84:	d003      	beq.n	800fa8e <UB_CS43L22_PlayMP3Loop+0x1a>
  MP3_ERR_t ret_wert=MP3_INIT_ERR;
 800fa86:	2001      	movs	r0, #1
}
 800fa88:	b002      	add	sp, #8
 800fa8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fa8e:	460e      	mov	r6, r1
    check_fat=UB_Fatfs_OpenFile(&myMP3File,name,F_RD);
 800fa90:	2200      	movs	r2, #0
 800fa92:	4601      	mov	r1, r0
 800fa94:	4831      	ldr	r0, [pc, #196]	; (800fb5c <UB_CS43L22_PlayMP3Loop+0xe8>)
 800fa96:	f000 fa6f 	bl	800ff78 <UB_Fatfs_OpenFile>
    if(check_fat!=FATFS_OK) {
 800fa9a:	b118      	cbz	r0, 800faa4 <UB_CS43L22_PlayMP3Loop+0x30>
      return(MP3_FILE_ERR);
 800fa9c:	2003      	movs	r0, #3
}
 800fa9e:	b002      	add	sp, #8
 800faa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    check_read=f_read(&myMP3File, mp3_buf, MP3_READ_BUF_SIZE, &bytes_read);
 800faa4:	4f2e      	ldr	r7, [pc, #184]	; (800fb60 <UB_CS43L22_PlayMP3Loop+0xec>)
 800faa6:	482d      	ldr	r0, [pc, #180]	; (800fb5c <UB_CS43L22_PlayMP3Loop+0xe8>)
 800faa8:	4639      	mov	r1, r7
 800faaa:	ab01      	add	r3, sp, #4
 800faac:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800fab0:	f7f5 fb0c 	bl	80050cc <f_read>
    if((check_read!=FR_OK) || (bytes_read!=MP3_READ_BUF_SIZE)) {
 800fab4:	4604      	mov	r4, r0
 800fab6:	2800      	cmp	r0, #0
 800fab8:	d148      	bne.n	800fb4c <UB_CS43L22_PlayMP3Loop+0xd8>
 800faba:	9b01      	ldr	r3, [sp, #4]
 800fabc:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800fac0:	d144      	bne.n	800fb4c <UB_CS43L22_PlayMP3Loop+0xd8>
    my_mp3.start_ptr=&mp3_buf[0];
 800fac2:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 800fb68 <UB_CS43L22_PlayMP3Loop+0xf4>
  MP3CallbackFunctionPtr = 0;
 800fac6:	6028      	str	r0, [r5, #0]
    my_mp3.loop_flag=1; // Loop
 800fac8:	f244 0240 	movw	r2, #16448	; 0x4040
    my_mp3.bytes_left_start=MP3_READ_BUF_SIZE;
 800facc:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
    my_mp3.bytes_left=my_mp3.bytes_left_start;
 800fad0:	f8c8 302c 	str.w	r3, [r8, #44]	; 0x2c
    my_mp3.loop_flag=1; // Loop
 800fad4:	2301      	movs	r3, #1
 800fad6:	f808 3002 	strb.w	r3, [r8, r2]
  my_mp3.next_buffer_ptr = 0;
 800fada:	f244 0138 	movw	r1, #16440	; 0x4038
  my_mp3.next_buffer_len = 0;
 800fade:	f244 033c 	movw	r3, #16444	; 0x403c
  my_mp3.data_ptr = my_mp3.buffer0;
 800fae2:	f108 0234 	add.w	r2, r8, #52	; 0x34
  my_mp3.ende_flag=0;
 800fae6:	f244 0e35 	movw	lr, #16437	; 0x4035
    EVAL_AUDIO_Init(Volume, I2S_AudioFreq_44k);
 800faea:	4630      	mov	r0, r6
    my_mp3.start_ptr=&mp3_buf[0];
 800faec:	f8c8 7020 	str.w	r7, [r8, #32]
    my_mp3.read_ptr=my_mp3.start_ptr;
 800faf0:	f8c8 7024 	str.w	r7, [r8, #36]	; 0x24
  my_mp3.data_ptr = my_mp3.buffer0;
 800faf4:	f8c8 2030 	str.w	r2, [r8, #48]	; 0x30
  my_mp3.akt_buf_nr = 0;
 800faf8:	f244 0634 	movw	r6, #16436	; 0x4034
  my_mp3.last_err=MP3_OK;
 800fafc:	f244 0241 	movw	r2, #16449	; 0x4041
  my_mp3.dma_enable=0;
 800fb00:	f244 0736 	movw	r7, #16438	; 0x4036
  my_mp3.next_buffer_ptr = 0;
 800fb04:	f848 4001 	str.w	r4, [r8, r1]
  my_mp3.next_buffer_len = 0;
 800fb08:	f848 4003 	str.w	r4, [r8, r3]
    EVAL_AUDIO_Init(Volume, I2S_AudioFreq_44k);
 800fb0c:	f64a 4144 	movw	r1, #44100	; 0xac44
    cs43l22_status=CS43L22_PLAY;
 800fb10:	2302      	movs	r3, #2
  my_mp3.ende_flag=0;
 800fb12:	f808 400e 	strb.w	r4, [r8, lr]
  my_mp3.last_err=MP3_OK;
 800fb16:	f808 4002 	strb.w	r4, [r8, r2]
    cs43l22_status=CS43L22_PLAY;
 800fb1a:	722b      	strb	r3, [r5, #8]
  CallbackContextPtr = 0;
 800fb1c:	606c      	str	r4, [r5, #4]
  my_mp3.akt_buf_nr = 0;
 800fb1e:	f808 4006 	strb.w	r4, [r8, r6]
  my_mp3.dma_enable=0;
 800fb22:	f808 4007 	strb.w	r4, [r8, r7]
    EVAL_AUDIO_Init(Volume, I2S_AudioFreq_44k);
 800fb26:	f7f2 fb87 	bl	8002238 <EVAL_AUDIO_Init>
  EVAL_AUDIO_StopDMA();
 800fb2a:	f7f2 fd61 	bl	80025f0 <EVAL_AUDIO_StopDMA>
  my_mp3.dma_enable = 0;
 800fb2e:	f808 4007 	strb.w	r4, [r8, r7]
  EVAL_AUDIO_Play();
 800fb32:	f7f2 fca1 	bl	8002478 <EVAL_AUDIO_Play>
  MP3CallbackFunctionPtr = callback_ptr;
 800fb36:	4b0b      	ldr	r3, [pc, #44]	; (800fb64 <UB_CS43L22_PlayMP3Loop+0xf0>)
  my_mp3.akt_buf_nr = 0;
 800fb38:	f808 4006 	strb.w	r4, [r8, r6]
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fb3c:	4620      	mov	r0, r4
 800fb3e:	4621      	mov	r1, r4
  MP3CallbackFunctionPtr = callback_ptr;
 800fb40:	e885 0018 	stmia.w	r5, {r3, r4}
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fb44:	f7ff fe02 	bl	800f74c <MP3CallbackFkt>
    ret_wert=MP3_OK;
 800fb48:	4620      	mov	r0, r4
 800fb4a:	e79d      	b.n	800fa88 <UB_CS43L22_PlayMP3Loop+0x14>
      UB_Fatfs_CloseFile(&myMP3File);
 800fb4c:	4803      	ldr	r0, [pc, #12]	; (800fb5c <UB_CS43L22_PlayMP3Loop+0xe8>)
 800fb4e:	f000 fa3f 	bl	800ffd0 <UB_Fatfs_CloseFile>
      return(MP3_FILE_ERR);
 800fb52:	2003      	movs	r0, #3
 800fb54:	e798      	b.n	800fa88 <UB_CS43L22_PlayMP3Loop+0x14>
 800fb56:	bf00      	nop
 800fb58:	20007e38 	.word	0x20007e38
 800fb5c:	2000c11c 	.word	0x2000c11c
 800fb60:	2000c340 	.word	0x2000c340
 800fb64:	0800f74d 	.word	0x0800f74d
 800fb68:	200080d8 	.word	0x200080d8

0800fb6c <UB_CS43L22_PlayMP3Do>:
{
 800fb6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(cs43l22_status==CS43L22_PLAY) {
 800fb70:	4c2c      	ldr	r4, [pc, #176]	; (800fc24 <UB_CS43L22_PlayMP3Do+0xb8>)
 800fb72:	7a20      	ldrb	r0, [r4, #8]
 800fb74:	2802      	cmp	r0, #2
{
 800fb76:	b082      	sub	sp, #8
  if(cs43l22_status==CS43L22_PLAY) {
 800fb78:	d002      	beq.n	800fb80 <UB_CS43L22_PlayMP3Do+0x14>
}
 800fb7a:	b002      	add	sp, #8
 800fb7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(my_mp3.bytes_left<MP3_READ_BUF_HALF) {      
 800fb80:	4d29      	ldr	r5, [pc, #164]	; (800fc28 <UB_CS43L22_PlayMP3Do+0xbc>)
 800fb82:	6aee      	ldr	r6, [r5, #44]	; 0x2c
 800fb84:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
 800fb88:	daf7      	bge.n	800fb7a <UB_CS43L22_PlayMP3Do+0xe>
      memcpy(mp3_buf, my_mp3.read_ptr, my_mp3.bytes_left);
 800fb8a:	4f28      	ldr	r7, [pc, #160]	; (800fc2c <UB_CS43L22_PlayMP3Do+0xc0>)
 800fb8c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800fb8e:	4632      	mov	r2, r6
 800fb90:	4638      	mov	r0, r7
      bytes_rest = MP3_READ_BUF_SIZE - my_mp3.bytes_left;
 800fb92:	f5c6 4880 	rsb	r8, r6, #16384	; 0x4000
      memcpy(mp3_buf, my_mp3.read_ptr, my_mp3.bytes_left);
 800fb96:	f004 fd0d 	bl	80145b4 <memcpy>
      check_read=f_read(&myMP3File, mp3_buf+my_mp3.bytes_left, bytes_rest, &bytes_read);
 800fb9a:	19b9      	adds	r1, r7, r6
 800fb9c:	4642      	mov	r2, r8
 800fb9e:	ab01      	add	r3, sp, #4
 800fba0:	4823      	ldr	r0, [pc, #140]	; (800fc30 <UB_CS43L22_PlayMP3Do+0xc4>)
      my_mp3.read_ptr = mp3_buf;
 800fba2:	626f      	str	r7, [r5, #36]	; 0x24
      check_read=f_read(&myMP3File, mp3_buf+my_mp3.bytes_left, bytes_rest, &bytes_read);
 800fba4:	f7f5 fa92 	bl	80050cc <f_read>
      if((check_read!=FR_OK) || (bytes_read!=bytes_rest)) {
 800fba8:	b910      	cbnz	r0, 800fbb0 <UB_CS43L22_PlayMP3Do+0x44>
 800fbaa:	9b01      	ldr	r3, [sp, #4]
 800fbac:	4598      	cmp	r8, r3
 800fbae:	d019      	beq.n	800fbe4 <UB_CS43L22_PlayMP3Do+0x78>
        if(my_mp3.loop_flag==1) {
 800fbb0:	f244 0340 	movw	r3, #16448	; 0x4040
 800fbb4:	5ceb      	ldrb	r3, [r5, r3]
 800fbb6:	2b01      	cmp	r3, #1
 800fbb8:	d019      	beq.n	800fbee <UB_CS43L22_PlayMP3Do+0x82>
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800fbba:	7a20      	ldrb	r0, [r4, #8]
 800fbbc:	1e83      	subs	r3, r0, #2
 800fbbe:	2b01      	cmp	r3, #1
 800fbc0:	d8db      	bhi.n	800fb7a <UB_CS43L22_PlayMP3Do+0xe>
    cs43l22_status=CS43L22_STOP;
 800fbc2:	2304      	movs	r3, #4
    EVAL_AUDIO_Stop(CODEC_PDWN_HW);  // CODEC_PDWN_SW => rauschen
 800fbc4:	2001      	movs	r0, #1
    cs43l22_status=CS43L22_STOP;
 800fbc6:	7223      	strb	r3, [r4, #8]
    EVAL_AUDIO_Stop(CODEC_PDWN_HW);  // CODEC_PDWN_SW => rauschen
 800fbc8:	f7f2 fcda 	bl	8002580 <EVAL_AUDIO_Stop>
    my_mp3.dma_enable = 0;
 800fbcc:	f244 0136 	movw	r1, #16438	; 0x4036
    my_mp3.next_buffer_ptr = 0;
 800fbd0:	f244 0238 	movw	r2, #16440	; 0x4038
    my_mp3.dma_enable = 0;
 800fbd4:	2300      	movs	r3, #0
    UB_Fatfs_CloseFile(&myMP3File);
 800fbd6:	4816      	ldr	r0, [pc, #88]	; (800fc30 <UB_CS43L22_PlayMP3Do+0xc4>)
    my_mp3.dma_enable = 0;
 800fbd8:	546b      	strb	r3, [r5, r1]
    my_mp3.next_buffer_ptr = 0;
 800fbda:	50ab      	str	r3, [r5, r2]
    UB_Fatfs_CloseFile(&myMP3File);
 800fbdc:	f000 f9f8 	bl	800ffd0 <UB_Fatfs_CloseFile>
 800fbe0:	7a20      	ldrb	r0, [r4, #8]
 800fbe2:	e7ca      	b.n	800fb7a <UB_CS43L22_PlayMP3Do+0xe>
        my_mp3.bytes_left=MP3_READ_BUF_SIZE;
 800fbe4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800fbe8:	7a20      	ldrb	r0, [r4, #8]
 800fbea:	62eb      	str	r3, [r5, #44]	; 0x2c
 800fbec:	e7c5      	b.n	800fb7a <UB_CS43L22_PlayMP3Do+0xe>
          f_lseek(&myMP3File, 0);
 800fbee:	2100      	movs	r1, #0
 800fbf0:	480f      	ldr	r0, [pc, #60]	; (800fc30 <UB_CS43L22_PlayMP3Do+0xc4>)
 800fbf2:	f7f5 fbff 	bl	80053f4 <f_lseek>
          f_read(&myMP3File, mp3_buf, MP3_READ_BUF_SIZE, &bytes_read);
 800fbf6:	ab01      	add	r3, sp, #4
 800fbf8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800fbfc:	490b      	ldr	r1, [pc, #44]	; (800fc2c <UB_CS43L22_PlayMP3Do+0xc0>)
 800fbfe:	480c      	ldr	r0, [pc, #48]	; (800fc30 <UB_CS43L22_PlayMP3Do+0xc4>)
 800fc00:	f7f5 fa64 	bl	80050cc <f_read>
          my_mp3.akt_buf_nr = 0;
 800fc04:	f244 0734 	movw	r7, #16436	; 0x4034
          my_mp3.ende_flag=0;
 800fc08:	f244 0e35 	movw	lr, #16437	; 0x4035
 800fc0c:	2300      	movs	r3, #0
          my_mp3.read_ptr=my_mp3.start_ptr;
 800fc0e:	6a2e      	ldr	r6, [r5, #32]
          my_mp3.bytes_left=my_mp3.bytes_left_start;
 800fc10:	6aa9      	ldr	r1, [r5, #40]	; 0x28
          my_mp3.data_ptr = my_mp3.buffer0;
 800fc12:	4a08      	ldr	r2, [pc, #32]	; (800fc34 <UB_CS43L22_PlayMP3Do+0xc8>)
 800fc14:	7a20      	ldrb	r0, [r4, #8]
          my_mp3.ende_flag=0;
 800fc16:	f805 300e 	strb.w	r3, [r5, lr]
          my_mp3.akt_buf_nr = 0;
 800fc1a:	55eb      	strb	r3, [r5, r7]
          my_mp3.read_ptr=my_mp3.start_ptr;
 800fc1c:	626e      	str	r6, [r5, #36]	; 0x24
          my_mp3.bytes_left=my_mp3.bytes_left_start;
 800fc1e:	62e9      	str	r1, [r5, #44]	; 0x2c
          my_mp3.data_ptr = my_mp3.buffer0;
 800fc20:	632a      	str	r2, [r5, #48]	; 0x30
 800fc22:	e7aa      	b.n	800fb7a <UB_CS43L22_PlayMP3Do+0xe>
 800fc24:	20007e38 	.word	0x20007e38
 800fc28:	200080d8 	.word	0x200080d8
 800fc2c:	2000c340 	.word	0x2000c340
 800fc30:	2000c11c 	.word	0x2000c11c
 800fc34:	2000810c 	.word	0x2000810c

0800fc38 <UB_CS43L22_PauseMP3>:
  if(cs43l22_status==CS43L22_PLAY) {
 800fc38:	4b04      	ldr	r3, [pc, #16]	; (800fc4c <UB_CS43L22_PauseMP3+0x14>)
 800fc3a:	7a1a      	ldrb	r2, [r3, #8]
 800fc3c:	2a02      	cmp	r2, #2
 800fc3e:	d000      	beq.n	800fc42 <UB_CS43L22_PauseMP3+0xa>
 800fc40:	4770      	bx	lr
    cs43l22_status=CS43L22_PAUSE;
 800fc42:	2203      	movs	r2, #3
    EVAL_AUDIO_PauseResume(AUDIO_PAUSE);
 800fc44:	2000      	movs	r0, #0
    cs43l22_status=CS43L22_PAUSE;
 800fc46:	721a      	strb	r2, [r3, #8]
    EVAL_AUDIO_PauseResume(AUDIO_PAUSE);
 800fc48:	f7f2 bc32 	b.w	80024b0 <EVAL_AUDIO_PauseResume>
 800fc4c:	20007e38 	.word	0x20007e38

0800fc50 <UB_CS43L22_ResumeMP3>:
  if(cs43l22_status==CS43L22_PAUSE) {
 800fc50:	4b04      	ldr	r3, [pc, #16]	; (800fc64 <UB_CS43L22_ResumeMP3+0x14>)
 800fc52:	7a1a      	ldrb	r2, [r3, #8]
 800fc54:	2a03      	cmp	r2, #3
 800fc56:	d000      	beq.n	800fc5a <UB_CS43L22_ResumeMP3+0xa>
 800fc58:	4770      	bx	lr
    cs43l22_status=CS43L22_PLAY;
 800fc5a:	2202      	movs	r2, #2
    EVAL_AUDIO_PauseResume(AUDIO_RESUME);
 800fc5c:	2001      	movs	r0, #1
    cs43l22_status=CS43L22_PLAY;
 800fc5e:	721a      	strb	r2, [r3, #8]
    EVAL_AUDIO_PauseResume(AUDIO_RESUME);
 800fc60:	f7f2 bc26 	b.w	80024b0 <EVAL_AUDIO_PauseResume>
 800fc64:	20007e38 	.word	0x20007e38

0800fc68 <UB_CS43L22_StopMP3>:
  if((cs43l22_status==CS43L22_PLAY) || (cs43l22_status==CS43L22_PAUSE)) {
 800fc68:	4a0c      	ldr	r2, [pc, #48]	; (800fc9c <UB_CS43L22_StopMP3+0x34>)
 800fc6a:	7a13      	ldrb	r3, [r2, #8]
 800fc6c:	3b02      	subs	r3, #2
 800fc6e:	2b01      	cmp	r3, #1
 800fc70:	d900      	bls.n	800fc74 <UB_CS43L22_StopMP3+0xc>
 800fc72:	4770      	bx	lr
{
 800fc74:	b510      	push	{r4, lr}
    cs43l22_status=CS43L22_STOP;
 800fc76:	2304      	movs	r3, #4
    EVAL_AUDIO_Stop(CODEC_PDWN_HW);  // CODEC_PDWN_SW => rauschen
 800fc78:	2001      	movs	r0, #1
    cs43l22_status=CS43L22_STOP;
 800fc7a:	7213      	strb	r3, [r2, #8]
    my_mp3.dma_enable = 0;
 800fc7c:	f244 0436 	movw	r4, #16438	; 0x4036
    EVAL_AUDIO_Stop(CODEC_PDWN_HW);  // CODEC_PDWN_SW => rauschen
 800fc80:	f7f2 fc7e 	bl	8002580 <EVAL_AUDIO_Stop>
    my_mp3.dma_enable = 0;
 800fc84:	4b06      	ldr	r3, [pc, #24]	; (800fca0 <UB_CS43L22_StopMP3+0x38>)
    UB_Fatfs_CloseFile(&myMP3File);
 800fc86:	4807      	ldr	r0, [pc, #28]	; (800fca4 <UB_CS43L22_StopMP3+0x3c>)
    my_mp3.dma_enable = 0;
 800fc88:	2200      	movs	r2, #0
 800fc8a:	551a      	strb	r2, [r3, r4]
    my_mp3.next_buffer_ptr = 0;
 800fc8c:	f244 0138 	movw	r1, #16440	; 0x4038
}
 800fc90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    my_mp3.next_buffer_ptr = 0;
 800fc94:	505a      	str	r2, [r3, r1]
    UB_Fatfs_CloseFile(&myMP3File);
 800fc96:	f000 b99b 	b.w	800ffd0 <UB_Fatfs_CloseFile>
 800fc9a:	bf00      	nop
 800fc9c:	20007e38 	.word	0x20007e38
 800fca0:	200080d8 	.word	0x200080d8
 800fca4:	2000c11c 	.word	0x2000c11c

0800fca8 <UB_CS43L22_SetVolumeMP3>:
  EVAL_AUDIO_VolumeCtl(Volume);
 800fca8:	f7f2 bcb0 	b.w	800260c <EVAL_AUDIO_VolumeCtl>

0800fcac <UB_CS43L22_GetMP3Err>:
  ret_wert=my_mp3.last_err;
 800fcac:	4a03      	ldr	r2, [pc, #12]	; (800fcbc <UB_CS43L22_GetMP3Err+0x10>)
 800fcae:	f244 0341 	movw	r3, #16449	; 0x4041
  my_mp3.last_err=MP3_OK;
 800fcb2:	2100      	movs	r1, #0
  ret_wert=my_mp3.last_err;
 800fcb4:	5cd0      	ldrb	r0, [r2, r3]
  my_mp3.last_err=MP3_OK;
 800fcb6:	54d1      	strb	r1, [r2, r3]
}
 800fcb8:	4770      	bx	lr
 800fcba:	bf00      	nop
 800fcbc:	200080d8 	.word	0x200080d8

0800fcc0 <P_CS43L22_InitMP3>:
{
 800fcc0:	b4f0      	push	{r4, r5, r6, r7}
  my_mp3.akt_buf_nr = 0;
 800fcc2:	4a0e      	ldr	r2, [pc, #56]	; (800fcfc <P_CS43L22_InitMP3+0x3c>)
  MP3CallbackFunctionPtr = 0;
 800fcc4:	490e      	ldr	r1, [pc, #56]	; (800fd00 <P_CS43L22_InitMP3+0x40>)
  my_mp3.akt_buf_nr = 0;
 800fcc6:	f244 0034 	movw	r0, #16436	; 0x4034
 800fcca:	2300      	movs	r3, #0
  my_mp3.ende_flag=0;
 800fccc:	f244 0735 	movw	r7, #16437	; 0x4035
  my_mp3.dma_enable=0;
 800fcd0:	f244 0636 	movw	r6, #16438	; 0x4036
  my_mp3.akt_buf_nr = 0;
 800fcd4:	5413      	strb	r3, [r2, r0]
  my_mp3.last_err=MP3_OK;
 800fcd6:	f244 0041 	movw	r0, #16449	; 0x4041
  my_mp3.next_buffer_ptr = 0;
 800fcda:	f244 0538 	movw	r5, #16440	; 0x4038
  my_mp3.next_buffer_len = 0;
 800fcde:	f244 043c 	movw	r4, #16444	; 0x403c
  my_mp3.ende_flag=0;
 800fce2:	55d3      	strb	r3, [r2, r7]
  my_mp3.dma_enable=0;
 800fce4:	5593      	strb	r3, [r2, r6]
  my_mp3.last_err=MP3_OK;
 800fce6:	5413      	strb	r3, [r2, r0]
  my_mp3.data_ptr = my_mp3.buffer0;
 800fce8:	f102 0034 	add.w	r0, r2, #52	; 0x34
  my_mp3.next_buffer_ptr = 0;
 800fcec:	5153      	str	r3, [r2, r5]
  my_mp3.next_buffer_len = 0;
 800fcee:	5113      	str	r3, [r2, r4]
  my_mp3.data_ptr = my_mp3.buffer0;
 800fcf0:	6310      	str	r0, [r2, #48]	; 0x30
  MP3CallbackFunctionPtr = 0;
 800fcf2:	600b      	str	r3, [r1, #0]
  CallbackContextPtr = 0;
 800fcf4:	604b      	str	r3, [r1, #4]
}
 800fcf6:	bcf0      	pop	{r4, r5, r6, r7}
 800fcf8:	4770      	bx	lr
 800fcfa:	bf00      	nop
 800fcfc:	200080d8 	.word	0x200080d8
 800fd00:	20007e38 	.word	0x20007e38

0800fd04 <PlayMP3WithCallback>:
{
 800fd04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800fd08:	4604      	mov	r4, r0
 800fd0a:	460f      	mov	r7, r1
  my_mp3.dma_enable = 0;
 800fd0c:	4e0b      	ldr	r6, [pc, #44]	; (800fd3c <PlayMP3WithCallback+0x38>)
  EVAL_AUDIO_StopDMA();
 800fd0e:	f7f2 fc6f 	bl	80025f0 <EVAL_AUDIO_StopDMA>
  my_mp3.dma_enable = 0;
 800fd12:	f244 0336 	movw	r3, #16438	; 0x4036
 800fd16:	2500      	movs	r5, #0
 800fd18:	54f5      	strb	r5, [r6, r3]
  EVAL_AUDIO_Play();
 800fd1a:	f7f2 fbad 	bl	8002478 <EVAL_AUDIO_Play>
  my_mp3.akt_buf_nr = 0;
 800fd1e:	f244 0234 	movw	r2, #16436	; 0x4034
  MP3CallbackFunctionPtr = callback_ptr;
 800fd22:	4b07      	ldr	r3, [pc, #28]	; (800fd40 <PlayMP3WithCallback+0x3c>)
  my_mp3.akt_buf_nr = 0;
 800fd24:	54b5      	strb	r5, [r6, r2]
  CallbackContextPtr = context;
 800fd26:	e883 0090 	stmia.w	r3, {r4, r7}
  if (MP3CallbackFunctionPtr) {
 800fd2a:	b12c      	cbz	r4, 800fd38 <PlayMP3WithCallback+0x34>
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fd2c:	4629      	mov	r1, r5
 800fd2e:	4638      	mov	r0, r7
 800fd30:	4623      	mov	r3, r4
}
 800fd32:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fd36:	4718      	bx	r3
 800fd38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fd3c:	200080d8 	.word	0x200080d8
 800fd40:	20007e38 	.word	0x20007e38

0800fd44 <SetMP3Buffer>:
{
 800fd44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (my_mp3.next_buffer_ptr) {
 800fd48:	4c19      	ldr	r4, [pc, #100]	; (800fdb0 <SetMP3Buffer+0x6c>)
 800fd4a:	f244 0738 	movw	r7, #16440	; 0x4038
 800fd4e:	59e3      	ldr	r3, [r4, r7]
 800fd50:	b10b      	cbz	r3, 800fd56 <SetMP3Buffer+0x12>
    __asm__ volatile ("wfi");
 800fd52:	bf30      	wfi
 800fd54:	e7fd      	b.n	800fd52 <SetMP3Buffer+0xe>
  if (my_mp3.dma_enable==0) {
 800fd56:	f244 0836 	movw	r8, #16438	; 0x4036
 800fd5a:	460d      	mov	r5, r1
 800fd5c:	4606      	mov	r6, r0
  EVAL_IRQ_DISABLE();
 800fd5e:	f7f2 fcb3 	bl	80026c8 <EVAL_IRQ_DISABLE>
  my_mp3.next_buffer_len = sampl_cnt;
 800fd62:	f244 033c 	movw	r3, #16444	; 0x403c
  if (my_mp3.dma_enable==0) {
 800fd66:	f814 9008 	ldrb.w	r9, [r4, r8]
  my_mp3.next_buffer_ptr = data_ptr;
 800fd6a:	51e6      	str	r6, [r4, r7]
  my_mp3.next_buffer_len = sampl_cnt;
 800fd6c:	50e5      	str	r5, [r4, r3]
  if (my_mp3.dma_enable==0) {
 800fd6e:	f1b9 0f00 	cmp.w	r9, #0
 800fd72:	d003      	beq.n	800fd7c <SetMP3Buffer+0x38>
}
 800fd74:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  EVAL_IRQ_ENABLE();
 800fd78:	f7f2 bc9e 	b.w	80026b8 <EVAL_IRQ_ENABLE>
  EVAL_SET_DMA(my_mp3.next_buffer_len, my_mp3.next_buffer_ptr);
 800fd7c:	4628      	mov	r0, r5
 800fd7e:	4631      	mov	r1, r6
 800fd80:	f7f2 fcaa 	bl	80026d8 <EVAL_SET_DMA>
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fd84:	f244 0334 	movw	r3, #16436	; 0x4034
  if (MP3CallbackFunctionPtr) {
 800fd88:	480a      	ldr	r0, [pc, #40]	; (800fdb4 <SetMP3Buffer+0x70>)
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fd8a:	5ce1      	ldrb	r1, [r4, r3]
  if (MP3CallbackFunctionPtr) {
 800fd8c:	6802      	ldr	r2, [r0, #0]
  my_mp3.next_buffer_ptr = 0;
 800fd8e:	f844 9007 	str.w	r9, [r4, r7]
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fd92:	f1c1 0101 	rsb	r1, r1, #1
 800fd96:	b2c9      	uxtb	r1, r1
  my_mp3.dma_enable = 1;
 800fd98:	2501      	movs	r5, #1
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fd9a:	54e1      	strb	r1, [r4, r3]
  my_mp3.dma_enable = 1;
 800fd9c:	f804 5008 	strb.w	r5, [r4, r8]
  if (MP3CallbackFunctionPtr) {
 800fda0:	2a00      	cmp	r2, #0
 800fda2:	d0e7      	beq.n	800fd74 <SetMP3Buffer+0x30>
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fda4:	6840      	ldr	r0, [r0, #4]
 800fda6:	4790      	blx	r2
}
 800fda8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  EVAL_IRQ_ENABLE();
 800fdac:	f7f2 bc84 	b.w	80026b8 <EVAL_IRQ_ENABLE>
 800fdb0:	200080d8 	.word	0x200080d8
 800fdb4:	20007e38 	.word	0x20007e38

0800fdb8 <TryMP3Buffer>:
{
 800fdb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (my_mp3.next_buffer_ptr) {
 800fdbc:	4c19      	ldr	r4, [pc, #100]	; (800fe24 <TryMP3Buffer+0x6c>)
 800fdbe:	f244 0538 	movw	r5, #16440	; 0x4038
 800fdc2:	5963      	ldr	r3, [r4, r5]
 800fdc4:	b113      	cbz	r3, 800fdcc <TryMP3Buffer+0x14>
    return 0;
 800fdc6:	2000      	movs	r0, #0
}
 800fdc8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (my_mp3.dma_enable==0) {
 800fdcc:	f244 0836 	movw	r8, #16438	; 0x4036
 800fdd0:	460e      	mov	r6, r1
 800fdd2:	4607      	mov	r7, r0
  EVAL_IRQ_DISABLE();
 800fdd4:	f7f2 fc78 	bl	80026c8 <EVAL_IRQ_DISABLE>
  my_mp3.next_buffer_len = sampl_cnt;
 800fdd8:	f244 033c 	movw	r3, #16444	; 0x403c
  if (my_mp3.dma_enable==0) {
 800fddc:	f814 9008 	ldrb.w	r9, [r4, r8]
  my_mp3.next_buffer_ptr = data_ptr;
 800fde0:	5167      	str	r7, [r4, r5]
  my_mp3.next_buffer_len = sampl_cnt;
 800fde2:	50e6      	str	r6, [r4, r3]
  if (my_mp3.dma_enable==0) {
 800fde4:	f1b9 0f00 	cmp.w	r9, #0
 800fde8:	d004      	beq.n	800fdf4 <TryMP3Buffer+0x3c>
  EVAL_IRQ_ENABLE();
 800fdea:	f7f2 fc65 	bl	80026b8 <EVAL_IRQ_ENABLE>
 800fdee:	2001      	movs	r0, #1
 800fdf0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  EVAL_SET_DMA(my_mp3.next_buffer_len, my_mp3.next_buffer_ptr);
 800fdf4:	4639      	mov	r1, r7
 800fdf6:	4630      	mov	r0, r6
 800fdf8:	f7f2 fc6e 	bl	80026d8 <EVAL_SET_DMA>
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fdfc:	f244 0334 	movw	r3, #16436	; 0x4034
  if (MP3CallbackFunctionPtr) {
 800fe00:	4809      	ldr	r0, [pc, #36]	; (800fe28 <TryMP3Buffer+0x70>)
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe02:	5ce1      	ldrb	r1, [r4, r3]
  if (MP3CallbackFunctionPtr) {
 800fe04:	6802      	ldr	r2, [r0, #0]
  my_mp3.next_buffer_ptr = 0;
 800fe06:	f844 9005 	str.w	r9, [r4, r5]
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe0a:	f1c1 0101 	rsb	r1, r1, #1
 800fe0e:	b2c9      	uxtb	r1, r1
  my_mp3.dma_enable = 1;
 800fe10:	2501      	movs	r5, #1
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe12:	54e1      	strb	r1, [r4, r3]
  my_mp3.dma_enable = 1;
 800fe14:	f804 5008 	strb.w	r5, [r4, r8]
  if (MP3CallbackFunctionPtr) {
 800fe18:	2a00      	cmp	r2, #0
 800fe1a:	d0e6      	beq.n	800fdea <TryMP3Buffer+0x32>
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fe1c:	6840      	ldr	r0, [r0, #4]
 800fe1e:	4790      	blx	r2
 800fe20:	e7e3      	b.n	800fdea <TryMP3Buffer+0x32>
 800fe22:	bf00      	nop
 800fe24:	200080d8 	.word	0x200080d8
 800fe28:	20007e38 	.word	0x20007e38

0800fe2c <StartMP3Buffer>:
{
 800fe2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  EVAL_SET_DMA(my_mp3.next_buffer_len, my_mp3.next_buffer_ptr);
 800fe30:	f244 033c 	movw	r3, #16444	; 0x403c
 800fe34:	4c0e      	ldr	r4, [pc, #56]	; (800fe70 <StartMP3Buffer+0x44>)
 800fe36:	f244 0538 	movw	r5, #16440	; 0x4038
 800fe3a:	58e0      	ldr	r0, [r4, r3]
 800fe3c:	5961      	ldr	r1, [r4, r5]
 800fe3e:	f7f2 fc4b 	bl	80026d8 <EVAL_SET_DMA>
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe42:	f244 0334 	movw	r3, #16436	; 0x4034
  if (MP3CallbackFunctionPtr) {
 800fe46:	480b      	ldr	r0, [pc, #44]	; (800fe74 <StartMP3Buffer+0x48>)
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe48:	5ce1      	ldrb	r1, [r4, r3]
  if (MP3CallbackFunctionPtr) {
 800fe4a:	6802      	ldr	r2, [r0, #0]
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe4c:	f1c1 0101 	rsb	r1, r1, #1
  my_mp3.dma_enable = 1;
 800fe50:	f244 0636 	movw	r6, #16438	; 0x4036
  my_mp3.next_buffer_ptr = 0;
 800fe54:	2700      	movs	r7, #0
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe56:	b2c9      	uxtb	r1, r1
  my_mp3.next_buffer_ptr = 0;
 800fe58:	5167      	str	r7, [r4, r5]
  my_mp3.dma_enable = 1;
 800fe5a:	2501      	movs	r5, #1
 800fe5c:	55a5      	strb	r5, [r4, r6]
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fe5e:	54e1      	strb	r1, [r4, r3]
  if (MP3CallbackFunctionPtr) {
 800fe60:	b11a      	cbz	r2, 800fe6a <StartMP3Buffer+0x3e>
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fe62:	6840      	ldr	r0, [r0, #4]
  }
}
 800fe64:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fe68:	4710      	bx	r2
 800fe6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fe6e:	bf00      	nop
 800fe70:	200080d8 	.word	0x200080d8
 800fe74:	20007e38 	.word	0x20007e38

0800fe78 <EVAL_AUDIO_TransferComplete_CallBack>:

//--------------------------------------------------------------
// wird aufgerufen, wenn MP3-Buffer komplett abgespielt wurde
//--------------------------------------------------------------
void EVAL_AUDIO_TransferComplete_CallBack(void)
{
 800fe78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (DMA_GetFlagStatus(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_TC) != RESET)
 800fe7c:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
 800fe80:	4817      	ldr	r0, [pc, #92]	; (800fee0 <EVAL_AUDIO_TransferComplete_CallBack+0x68>)
 800fe82:	f7f0 fbd7 	bl	8000634 <DMA_GetFlagStatus>
 800fe86:	b908      	cbnz	r0, 800fe8c <EVAL_AUDIO_TransferComplete_CallBack+0x14>
 800fe88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    DMA_ClearFlag(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_TC);

    if (my_mp3.next_buffer_ptr) {
 800fe8c:	4c15      	ldr	r4, [pc, #84]	; (800fee4 <EVAL_AUDIO_TransferComplete_CallBack+0x6c>)
    DMA_ClearFlag(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_TC);
 800fe8e:	4814      	ldr	r0, [pc, #80]	; (800fee0 <EVAL_AUDIO_TransferComplete_CallBack+0x68>)
    if (my_mp3.next_buffer_ptr) {
 800fe90:	f244 0538 	movw	r5, #16440	; 0x4038
    DMA_ClearFlag(AUDIO_I2S_DMA_STREAM, AUDIO_I2S_DMA_FLAG_TC);
 800fe94:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
 800fe98:	f7f0 fbea 	bl	8000670 <DMA_ClearFlag>
    if (my_mp3.next_buffer_ptr) {
 800fe9c:	5961      	ldr	r1, [r4, r5]
 800fe9e:	b1c9      	cbz	r1, 800fed4 <EVAL_AUDIO_TransferComplete_CallBack+0x5c>
  EVAL_SET_DMA(my_mp3.next_buffer_len, my_mp3.next_buffer_ptr);
 800fea0:	f244 033c 	movw	r3, #16444	; 0x403c
  my_mp3.dma_enable = 1;
 800fea4:	f244 0636 	movw	r6, #16438	; 0x4036
  EVAL_SET_DMA(my_mp3.next_buffer_len, my_mp3.next_buffer_ptr);
 800fea8:	58e0      	ldr	r0, [r4, r3]
 800feaa:	f7f2 fc15 	bl	80026d8 <EVAL_SET_DMA>
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800feae:	f244 0334 	movw	r3, #16436	; 0x4034
  if (MP3CallbackFunctionPtr) {
 800feb2:	480d      	ldr	r0, [pc, #52]	; (800fee8 <EVAL_AUDIO_TransferComplete_CallBack+0x70>)
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800feb4:	5ce1      	ldrb	r1, [r4, r3]
  if (MP3CallbackFunctionPtr) {
 800feb6:	6802      	ldr	r2, [r0, #0]
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800feb8:	f1c1 0101 	rsb	r1, r1, #1
 800febc:	b2c9      	uxtb	r1, r1
  my_mp3.dma_enable = 1;
 800febe:	2701      	movs	r7, #1
  my_mp3.akt_buf_nr = 1 - my_mp3.akt_buf_nr;
 800fec0:	54e1      	strb	r1, [r4, r3]
  my_mp3.next_buffer_ptr = 0;
 800fec2:	2300      	movs	r3, #0
  my_mp3.dma_enable = 1;
 800fec4:	55a7      	strb	r7, [r4, r6]
  my_mp3.next_buffer_ptr = 0;
 800fec6:	5163      	str	r3, [r4, r5]
  if (MP3CallbackFunctionPtr) {
 800fec8:	2a00      	cmp	r2, #0
 800feca:	d0dd      	beq.n	800fe88 <EVAL_AUDIO_TransferComplete_CallBack+0x10>
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fecc:	6840      	ldr	r0, [r0, #4]
      StartMP3Buffer();
    } else {
      my_mp3.dma_enable = 0;
    }
  }
}
 800fece:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MP3CallbackFunctionPtr(CallbackContextPtr, my_mp3.akt_buf_nr);
 800fed2:	4710      	bx	r2
      my_mp3.dma_enable = 0;
 800fed4:	f244 0336 	movw	r3, #16438	; 0x4036
 800fed8:	54e1      	strb	r1, [r4, r3]
 800feda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fede:	bf00      	nop
 800fee0:	400260b8 	.word	0x400260b8
 800fee4:	200080d8 	.word	0x200080d8
 800fee8:	20007e38 	.word	0x20007e38

0800feec <UB_Fatfs_Init>:
//--------------------------------------------------------------
// Init-Funktion
// (init aller Systeme)
//--------------------------------------------------------------
void UB_Fatfs_Init(void)
{
 800feec:	b508      	push	{r3, lr}
  // init der Hardware fr die SDCard-Funktionen
  UB_SDCard_Init();
 800feee:	f7f8 f8fb 	bl	80080e8 <UB_SDCard_Init>
  // init der Hardware fr die USB-Funktionen
  UB_USBDisk_Init();
 800fef2:	f7f8 f911 	bl	8008118 <UB_USBDisk_Init>
  // init der Hardware fr die ATA-Funktionen
  UB_ATADrive_Init();
}
 800fef6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UB_ATADrive_Init();
 800fefa:	f7f8 b8dd 	b.w	80080b8 <UB_ATADrive_Init>
 800fefe:	bf00      	nop

0800ff00 <UB_Fatfs_CheckMedia>:
{
  FATFS_t ret_wert=FATFS_NO_MEDIA;
  uint8_t check=USB_NOT_PRESENT;

  // check ob Medium eingelegt
  if(dev==USB_0) check=UB_USBDrive_CheckMedia();
 800ff00:	b108      	cbz	r0, 800ff06 <UB_Fatfs_CheckMedia+0x6>
  if(check==USB_PRESENT) {
    ret_wert=FATFS_OK;
  }
  else {
    ret_wert=FATFS_NO_MEDIA;
 800ff02:	2001      	movs	r0, #1
 800ff04:	4770      	bx	lr
{
 800ff06:	b508      	push	{r3, lr}
  if(dev==USB_0) check=UB_USBDrive_CheckMedia();
 800ff08:	f7f8 f908 	bl	800811c <UB_USBDrive_CheckMedia>
    ret_wert=FATFS_OK;
 800ff0c:	f110 30ff 	adds.w	r0, r0, #4294967295
 800ff10:	bf18      	it	ne
 800ff12:	2001      	movne	r0, #1
 800ff14:	bd08      	pop	{r3, pc}
 800ff16:	bf00      	nop

0800ff18 <UB_Fatfs_Mount>:
  FATFS_t ret_wert=FATFS_MOUNT_ERR;
  FRESULT check=FR_INVALID_PARAMETER;
  DWORD fre_clust;
  FATFS	*fs;

  if(dev==USB_0) check=f_mount(0, &FileSystemObject);
 800ff18:	b108      	cbz	r0, 800ff1e <UB_Fatfs_Mount+0x6>
    else {
      ret_wert=FATFS_GETFREE_ERR;
    }
  }
  else {
    ret_wert=FATFS_MOUNT_ERR;
 800ff1a:	2002      	movs	r0, #2
  }

  return(ret_wert);
}
 800ff1c:	4770      	bx	lr
{
 800ff1e:	b500      	push	{lr}
  if(dev==USB_0) check=f_mount(0, &FileSystemObject);
 800ff20:	490a      	ldr	r1, [pc, #40]	; (800ff4c <UB_Fatfs_Mount+0x34>)
{
 800ff22:	b083      	sub	sp, #12
  if(dev==USB_0) check=f_mount(0, &FileSystemObject);
 800ff24:	f7f4 fe5c 	bl	8004be0 <f_mount>
  if(check == FR_OK) {
 800ff28:	b958      	cbnz	r0, 800ff42 <UB_Fatfs_Mount+0x2a>
    if(dev==USB_0) check=f_getfree("0:", &fre_clust, &fs);
 800ff2a:	aa01      	add	r2, sp, #4
 800ff2c:	4669      	mov	r1, sp
 800ff2e:	4808      	ldr	r0, [pc, #32]	; (800ff50 <UB_Fatfs_Mount+0x38>)
 800ff30:	f7f5 ff6e 	bl	8005e10 <f_getfree>
    if(check == FR_OK) {
 800ff34:	2800      	cmp	r0, #0
      ret_wert=FATFS_GETFREE_ERR;
 800ff36:	bf0c      	ite	eq
 800ff38:	2000      	moveq	r0, #0
 800ff3a:	2003      	movne	r0, #3
}
 800ff3c:	b003      	add	sp, #12
 800ff3e:	f85d fb04 	ldr.w	pc, [sp], #4
    ret_wert=FATFS_MOUNT_ERR;
 800ff42:	2002      	movs	r0, #2
}
 800ff44:	b003      	add	sp, #12
 800ff46:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff4a:	bf00      	nop
 800ff4c:	20007e44 	.word	0x20007e44
 800ff50:	08017aa8 	.word	0x08017aa8

0800ff54 <UB_Fatfs_UnMount>:
FATFS_t UB_Fatfs_UnMount(MEDIA_t dev)
{
  FATFS_t ret_wert=FATFS_MOUNT_ERR;
  FRESULT check=FR_INVALID_PARAMETER;

  if(dev==USB_0) check=f_mount(0, NULL);
 800ff54:	b108      	cbz	r0, 800ff5a <UB_Fatfs_UnMount+0x6>
  if(check == FR_OK) {
    ret_wert=FATFS_OK;
  }
  else {
    ret_wert=FATFS_MOUNT_ERR;
 800ff56:	2002      	movs	r0, #2
 800ff58:	4770      	bx	lr
{
 800ff5a:	b508      	push	{r3, lr}
 800ff5c:	4601      	mov	r1, r0
  if(dev==USB_0) check=f_mount(0, NULL);
 800ff5e:	f7f4 fe3f 	bl	8004be0 <f_mount>
  if(check == FR_OK) {
 800ff62:	b100      	cbz	r0, 800ff66 <UB_Fatfs_UnMount+0x12>
    ret_wert=FATFS_MOUNT_ERR;
 800ff64:	2002      	movs	r0, #2
  }

  return(ret_wert);
}
 800ff66:	bd08      	pop	{r3, pc}

0800ff68 <UB_Fatfs_DelFile>:
// Return Wert :
//     FATFS_OK      => kein Fehler
//  FATFS_UNLINK_ERR => Fehler
//--------------------------------------------------------------
FATFS_t UB_Fatfs_DelFile(const char* name)
{
 800ff68:	b508      	push	{r3, lr}
  FATFS_t ret_wert=FATFS_UNLINK_ERR;
  FRESULT check=FR_INVALID_PARAMETER;

  check=f_unlink(name);
 800ff6a:	f7f6 f86b 	bl	8006044 <f_unlink>
  if(check==FR_OK) {
 800ff6e:	2800      	cmp	r0, #0
  else {
    ret_wert=FATFS_UNLINK_ERR;
  }

  return(ret_wert);
}
 800ff70:	bf14      	ite	ne
 800ff72:	2004      	movne	r0, #4
 800ff74:	2000      	moveq	r0, #0
 800ff76:	bd08      	pop	{r3, pc}

0800ff78 <UB_Fatfs_OpenFile>:
//     FATFS_OK    => kein Fehler
//  FATFS_OPEN_ERR => Fehler
//  FATFS_SEEK_ERR => Fehler bei WR und WR_NEW
//--------------------------------------------------------------
FATFS_t UB_Fatfs_OpenFile(FIL* fp, const char* name, FMODE_t mode)
{
 800ff78:	b510      	push	{r4, lr}
  FATFS_t ret_wert=FATFS_OPEN_ERR;
  FRESULT check=FR_INVALID_PARAMETER;

  if(mode==F_RD) check = f_open(fp, name, FA_OPEN_EXISTING | FA_READ); 
 800ff7a:	b142      	cbz	r2, 800ff8e <UB_Fatfs_OpenFile+0x16>
  if(mode==F_WR) check = f_open(fp, name, FA_OPEN_EXISTING | FA_WRITE);
 800ff7c:	2a01      	cmp	r2, #1
 800ff7e:	4604      	mov	r4, r0
 800ff80:	d01f      	beq.n	800ffc2 <UB_Fatfs_OpenFile+0x4a>
  if(mode==F_WR_NEW) check = f_open(fp, name, FA_OPEN_ALWAYS | FA_WRITE);
 800ff82:	2a02      	cmp	r2, #2
 800ff84:	d00a      	beq.n	800ff9c <UB_Fatfs_OpenFile+0x24>
  if(mode==F_WR_CLEAR) check = f_open(fp, name, FA_CREATE_ALWAYS | FA_WRITE);
 800ff86:	2a03      	cmp	r2, #3
 800ff88:	d015      	beq.n	800ffb6 <UB_Fatfs_OpenFile+0x3e>
        ret_wert=FATFS_SEEK_ERR;
      }
    }
  }
  else {
    ret_wert=FATFS_OPEN_ERR;
 800ff8a:	2005      	movs	r0, #5
 800ff8c:	bd10      	pop	{r4, pc}
  if(mode==F_RD) check = f_open(fp, name, FA_OPEN_EXISTING | FA_READ); 
 800ff8e:	2201      	movs	r2, #1
 800ff90:	f7f4 fe36 	bl	8004c00 <f_open>
  if(check==FR_OK) {
 800ff94:	2800      	cmp	r0, #0
 800ff96:	d1f8      	bne.n	800ff8a <UB_Fatfs_OpenFile+0x12>
    ret_wert=FATFS_OK;
 800ff98:	2000      	movs	r0, #0
 800ff9a:	bd10      	pop	{r4, pc}
  if(mode==F_WR_NEW) check = f_open(fp, name, FA_OPEN_ALWAYS | FA_WRITE);
 800ff9c:	2212      	movs	r2, #18
 800ff9e:	f7f4 fe2f 	bl	8004c00 <f_open>
  if(check==FR_OK) {
 800ffa2:	2800      	cmp	r0, #0
 800ffa4:	d1f1      	bne.n	800ff8a <UB_Fatfs_OpenFile+0x12>
      check = f_lseek(fp, f_size(fp));
 800ffa6:	68e1      	ldr	r1, [r4, #12]
 800ffa8:	4620      	mov	r0, r4
 800ffaa:	f7f5 fa23 	bl	80053f4 <f_lseek>
      if(check!=FR_OK) {
 800ffae:	2800      	cmp	r0, #0
 800ffb0:	d0f2      	beq.n	800ff98 <UB_Fatfs_OpenFile+0x20>
        ret_wert=FATFS_SEEK_ERR;
 800ffb2:	2008      	movs	r0, #8
  }   

  return(ret_wert);
 800ffb4:	bd10      	pop	{r4, pc}
  if(mode==F_WR_CLEAR) check = f_open(fp, name, FA_CREATE_ALWAYS | FA_WRITE);
 800ffb6:	220a      	movs	r2, #10
 800ffb8:	f7f4 fe22 	bl	8004c00 <f_open>
  if(check==FR_OK) {
 800ffbc:	2800      	cmp	r0, #0
 800ffbe:	d0eb      	beq.n	800ff98 <UB_Fatfs_OpenFile+0x20>
 800ffc0:	e7e3      	b.n	800ff8a <UB_Fatfs_OpenFile+0x12>
  if(mode==F_WR) check = f_open(fp, name, FA_OPEN_EXISTING | FA_WRITE);
 800ffc2:	2202      	movs	r2, #2
 800ffc4:	f7f4 fe1c 	bl	8004c00 <f_open>
  if(check==FR_OK) {
 800ffc8:	2800      	cmp	r0, #0
 800ffca:	d0ec      	beq.n	800ffa6 <UB_Fatfs_OpenFile+0x2e>
    ret_wert=FATFS_OPEN_ERR;
 800ffcc:	2005      	movs	r0, #5
 800ffce:	bd10      	pop	{r4, pc}

0800ffd0 <UB_Fatfs_CloseFile>:
// Return Wert :
//     FATFS_OK     => kein Fehler
//  FATFS_CLOSE_ERR => Fehler
//--------------------------------------------------------------
FATFS_t UB_Fatfs_CloseFile(FIL* fp)
{
 800ffd0:	b508      	push	{r3, lr}
  FATFS_t ret_wert=FATFS_CLOSE_ERR;
  FRESULT check=FR_INVALID_PARAMETER;

  check=f_close(fp);
 800ffd2:	f7f5 f973 	bl	80052bc <f_close>

  if(check==FR_OK) {
 800ffd6:	2800      	cmp	r0, #0
  else {
    ret_wert=FATFS_CLOSE_ERR;
  }   

  return(ret_wert);
}
 800ffd8:	bf14      	ite	ne
 800ffda:	2006      	movne	r0, #6
 800ffdc:	2000      	moveq	r0, #0
 800ffde:	bd08      	pop	{r3, pc}

0800ffe0 <UB_Fatfs_WriteString>:
// Return Wert :
//     FATFS_OK    => kein Fehler
//  FATFS_PUTS_ERR => Fehler
//--------------------------------------------------------------
FATFS_t UB_Fatfs_WriteString(FIL* fp, const char* text)
{
 800ffe0:	b510      	push	{r4, lr}
 800ffe2:	4604      	mov	r4, r0
  FATFS_t ret_wert=FATFS_PUTS_ERR;
  int check=0;

  check=f_puts(text, fp);
 800ffe4:	4608      	mov	r0, r1
 800ffe6:	4621      	mov	r1, r4
 800ffe8:	f7f7 faee 	bl	80075c8 <f_puts>

  if(check>=0) {
 800ffec:	2800      	cmp	r0, #0
 800ffee:	da01      	bge.n	800fff4 <UB_Fatfs_WriteString+0x14>
    ret_wert=FATFS_OK;
    // Zeilenendekennung hinzufgen
    f_putc('\n', fp);
  }
  else {
    ret_wert=FATFS_PUTS_ERR;
 800fff0:	2007      	movs	r0, #7
  }   

  return(ret_wert);
}
 800fff2:	bd10      	pop	{r4, pc}
    f_putc('\n', fp);
 800fff4:	4621      	mov	r1, r4
 800fff6:	200a      	movs	r0, #10
 800fff8:	f7f7 fa98 	bl	800752c <f_putc>
    ret_wert=FATFS_OK;
 800fffc:	2000      	movs	r0, #0
 800fffe:	bd10      	pop	{r4, pc}

08010000 <UB_Fatfs_ReadString>:
//     FATFS_OK        => kein Fehler
//    FATFS_EOF        => Fileende erreicht
// FATFS_RD_STRING_ERR => Fehler
//--------------------------------------------------------------
FATFS_t UB_Fatfs_ReadString(FIL* fp, char* text, uint32_t len)
{
 8010000:	b510      	push	{r4, lr}
 8010002:	4604      	mov	r4, r0
  FATFS_t ret_wert=FATFS_RD_STRING_ERR;
  int check;

  f_gets(text, len, fp);
 8010004:	4608      	mov	r0, r1
 8010006:	4611      	mov	r1, r2
 8010008:	4622      	mov	r2, r4
 801000a:	f7f7 fa4f 	bl	80074ac <f_gets>
  check=f_eof(fp);
  if(check!=0) return(FATFS_EOF);
 801000e:	68a2      	ldr	r2, [r4, #8]
 8010010:	68e3      	ldr	r3, [r4, #12]
 8010012:	429a      	cmp	r2, r3
 8010014:	d006      	beq.n	8010024 <UB_Fatfs_ReadString+0x24>
  check=f_error(fp);
  if(check!=0) return(FATFS_RD_STRING_ERR);
 8010016:	f994 3006 	ldrsb.w	r3, [r4, #6]
 801001a:	2b00      	cmp	r3, #0
  ret_wert=FATFS_OK;

  return(ret_wert);
 801001c:	bfb4      	ite	lt
 801001e:	2009      	movlt	r0, #9
 8010020:	2000      	movge	r0, #0
 8010022:	bd10      	pop	{r4, pc}
  if(check!=0) return(FATFS_EOF);
 8010024:	200c      	movs	r0, #12
}
 8010026:	bd10      	pop	{r4, pc}

08010028 <UB_Fatfs_FileSize>:
uint32_t UB_Fatfs_FileSize(FIL* fp)
{
  uint32_t ret_wert=0;
  int filesize;

  filesize=f_size(fp);
 8010028:	68c0      	ldr	r0, [r0, #12]
  if(filesize>=0) ret_wert=(uint32_t)(filesize);

  return(ret_wert);
}
 801002a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 801002e:	4770      	bx	lr

08010030 <UB_Fatfs_ReadBlock>:
//     FATFS_OK        => kein Fehler
//    FATFS_EOF        => Fileende erreicht
//  FATFS_RD_BLOCK_ERR => Fehler
//--------------------------------------------------------------
FATFS_t UB_Fatfs_ReadBlock(FIL* fp, unsigned char* buf, uint32_t len, uint32_t* read)
{
 8010030:	b530      	push	{r4, r5, lr}
  FATFS_t ret_wert=FATFS_RD_BLOCK_ERR;
  FRESULT check=FR_INVALID_PARAMETER;
  UINT ulen,uread;

  ulen=(UINT)(len);
  if(ulen>_MAX_SS) {
 8010032:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
{
 8010036:	b083      	sub	sp, #12
 8010038:	461d      	mov	r5, r3
  if(ulen>_MAX_SS) {
 801003a:	d904      	bls.n	8010046 <UB_Fatfs_ReadBlock+0x16>
    ret_wert=FATFS_RD_BLOCK_ERR;
    *read=0;
 801003c:	2300      	movs	r3, #0
 801003e:	602b      	str	r3, [r5, #0]
    ret_wert=FATFS_RD_BLOCK_ERR;
 8010040:	200a      	movs	r0, #10
      *read=0;
    }
  }

  return(ret_wert);
}
 8010042:	b003      	add	sp, #12
 8010044:	bd30      	pop	{r4, r5, pc}
    check=f_read(fp, buf, ulen, &uread);
 8010046:	ab01      	add	r3, sp, #4
 8010048:	4614      	mov	r4, r2
 801004a:	f7f5 f83f 	bl	80050cc <f_read>
    if(check==FR_OK) {
 801004e:	2800      	cmp	r0, #0
 8010050:	d1f4      	bne.n	801003c <UB_Fatfs_ReadBlock+0xc>
      *read=(uint32_t)(uread);
 8010052:	9801      	ldr	r0, [sp, #4]
 8010054:	6028      	str	r0, [r5, #0]
        ret_wert=FATFS_EOF;
 8010056:	4284      	cmp	r4, r0
 8010058:	bf14      	ite	ne
 801005a:	200c      	movne	r0, #12
 801005c:	2000      	moveq	r0, #0
 801005e:	e7f0      	b.n	8010042 <UB_Fatfs_ReadBlock+0x12>

08010060 <UB_Fatfs_WriteBlock>:
//     FATFS_OK        => kein Fehler
//    FATFS_DISK_FULL  => kein Speicherplatz mehr
//  FATFS_WR_BLOCK_ERR => Fehler
//--------------------------------------------------------------
FATFS_t UB_Fatfs_WriteBlock(FIL* fp, unsigned char* buf, uint32_t len, uint32_t* write)
{
 8010060:	b530      	push	{r4, r5, lr}
  FATFS_t ret_wert=FATFS_WR_BLOCK_ERR;
  FRESULT check=FR_INVALID_PARAMETER;
  UINT ulen,uwrite;

  ulen=(UINT)(len);
  if(ulen>_MAX_SS) {
 8010062:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
{
 8010066:	b083      	sub	sp, #12
 8010068:	461d      	mov	r5, r3
  if(ulen>_MAX_SS) {
 801006a:	d904      	bls.n	8010076 <UB_Fatfs_WriteBlock+0x16>
    ret_wert=FATFS_WR_BLOCK_ERR;
    *write=0;
 801006c:	2300      	movs	r3, #0
 801006e:	602b      	str	r3, [r5, #0]
    ret_wert=FATFS_WR_BLOCK_ERR;
 8010070:	200b      	movs	r0, #11
      *write=0;
    }
  }

  return(ret_wert);
}
 8010072:	b003      	add	sp, #12
 8010074:	bd30      	pop	{r4, r5, pc}
    check=f_write(fp, buf, ulen, &uwrite);
 8010076:	ab01      	add	r3, sp, #4
 8010078:	4614      	mov	r4, r2
 801007a:	f7f5 f857 	bl	800512c <f_write>
    if(check==FR_OK) {
 801007e:	2800      	cmp	r0, #0
 8010080:	d1f4      	bne.n	801006c <UB_Fatfs_WriteBlock+0xc>
      *write=(uint32_t)(uwrite);
 8010082:	9801      	ldr	r0, [sp, #4]
 8010084:	6028      	str	r0, [r5, #0]
        ret_wert=FATFS_DISK_FULL;
 8010086:	4284      	cmp	r4, r0
 8010088:	bf14      	ite	ne
 801008a:	200d      	movne	r0, #13
 801008c:	2000      	moveq	r0, #0
 801008e:	e7f0      	b.n	8010072 <UB_Fatfs_WriteBlock+0x12>

08010090 <UB_I2C1_Init>:

//--------------------------------------------------------------
// Init von I2C1
//-------------------------------------------------------------- 
void UB_I2C1_Init(void)
{
 8010090:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  static uint8_t init_ok=0;
  GPIO_InitTypeDef  GPIO_InitStructure;

  // initialisierung darf nur einmal gemacht werden
  if(init_ok!=0) {
 8010094:	4e2d      	ldr	r6, [pc, #180]	; (801014c <UB_I2C1_Init+0xbc>)
 8010096:	7834      	ldrb	r4, [r6, #0]
{
 8010098:	b086      	sub	sp, #24
  if(init_ok!=0) {
 801009a:	b114      	cbz	r4, 80100a2 <UB_I2C1_Init+0x12>
  // I2C init
  P_I2C1_InitI2C();

  // init Mode speichern
  init_ok=1;
}
 801009c:	b006      	add	sp, #24
 801009e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  RCC_AHB1PeriphClockCmd(I2C1DEV.SCL.CLK, ENABLE); 
 80100a2:	4d2b      	ldr	r5, [pc, #172]	; (8010150 <UB_I2C1_Init+0xc0>)
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
 80100a4:	2101      	movs	r1, #1
 80100a6:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80100aa:	f7f1 f829 	bl	8001100 <RCC_APB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(I2C1DEV.SCL.CLK, ENABLE); 
 80100ae:	68a8      	ldr	r0, [r5, #8]
 80100b0:	2101      	movs	r1, #1
 80100b2:	f7f1 f801 	bl	80010b8 <RCC_AHB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(I2C1DEV.SDA.CLK, ENABLE);
 80100b6:	69a8      	ldr	r0, [r5, #24]
 80100b8:	2101      	movs	r1, #1
 80100ba:	f7f0 fffd 	bl	80010b8 <RCC_AHB1PeriphClockCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 80100be:	2101      	movs	r1, #1
 80100c0:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80100c4:	f7f1 f858 	bl	8001178 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
 80100c8:	4621      	mov	r1, r4
 80100ca:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80100ce:	f7f1 f853 	bl	8001178 <RCC_APB1PeriphResetCmd>
  GPIO_PinAFConfig(I2C1DEV.SCL.PORT, I2C1DEV.SCL.SOURCE, GPIO_AF_I2C1); 
 80100d2:	7b29      	ldrb	r1, [r5, #12]
 80100d4:	6828      	ldr	r0, [r5, #0]
 80100d6:	2204      	movs	r2, #4
 80100d8:	f7f0 fc64 	bl	80009a4 <GPIO_PinAFConfig>
  GPIO_InitStructure.GPIO_Pin = I2C1DEV.SCL.PIN;
 80100dc:	af06      	add	r7, sp, #24
  GPIO_PinAFConfig(I2C1DEV.SDA.PORT, I2C1DEV.SDA.SOURCE, GPIO_AF_I2C1);
 80100de:	2204      	movs	r2, #4
 80100e0:	7f29      	ldrb	r1, [r5, #28]
 80100e2:	6928      	ldr	r0, [r5, #16]
 80100e4:	f7f0 fc5e 	bl	80009a4 <GPIO_PinAFConfig>
  GPIO_InitStructure.GPIO_Pin = I2C1DEV.SCL.PIN;
 80100e8:	88ab      	ldrh	r3, [r5, #4]
 80100ea:	f847 3d18 	str.w	r3, [r7, #-24]!
  GPIO_Init(I2C1DEV.SCL.PORT, &GPIO_InitStructure);
 80100ee:	6828      	ldr	r0, [r5, #0]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80100f0:	4b18      	ldr	r3, [pc, #96]	; (8010154 <UB_I2C1_Init+0xc4>)
 80100f2:	9301      	str	r3, [sp, #4]
  GPIO_Init(I2C1DEV.SCL.PORT, &GPIO_InitStructure);
 80100f4:	4639      	mov	r1, r7
 80100f6:	f7f0 fbc5 	bl	8000884 <GPIO_Init>
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80100fa:	f10d 0818 	add.w	r8, sp, #24
  GPIO_InitStructure.GPIO_Pin = I2C1DEV.SDA.PIN;
 80100fe:	8aab      	ldrh	r3, [r5, #20]
  GPIO_Init(I2C1DEV.SDA.PORT, &GPIO_InitStructure);
 8010100:	6928      	ldr	r0, [r5, #16]
  GPIO_InitStructure.GPIO_Pin = I2C1DEV.SDA.PIN;
 8010102:	9300      	str	r3, [sp, #0]
  GPIO_Init(I2C1DEV.SDA.PORT, &GPIO_InitStructure);
 8010104:	4639      	mov	r1, r7
 8010106:	f7f0 fbbd 	bl	8000884 <GPIO_Init>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 801010a:	4b13      	ldr	r3, [pc, #76]	; (8010158 <UB_I2C1_Init+0xc8>)
 801010c:	f848 3d10 	str.w	r3, [r8, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010110:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010114:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010118:	f64b 75ff 	movw	r5, #49151	; 0xbfff

  // I2C enable
  I2C_Cmd(I2C1, ENABLE);
 801011c:	2101      	movs	r1, #1
 801011e:	480f      	ldr	r0, [pc, #60]	; (801015c <UB_I2C1_Init+0xcc>)
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010120:	f8ad 3014 	strh.w	r3, [sp, #20]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010124:	f8ad 2012 	strh.w	r2, [sp, #18]
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8010128:	f8ad 400c 	strh.w	r4, [sp, #12]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 801012c:	f8ad 4010 	strh.w	r4, [sp, #16]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010130:	f8ad 500e 	strh.w	r5, [sp, #14]
  I2C_Cmd(I2C1, ENABLE);
 8010134:	f7f0 fd06 	bl	8000b44 <I2C_Cmd>

  // Init Struktur
  I2C_Init(I2C1, &I2C_InitStructure);
 8010138:	4641      	mov	r1, r8
 801013a:	4808      	ldr	r0, [pc, #32]	; (801015c <UB_I2C1_Init+0xcc>)
 801013c:	f7f0 fc7e 	bl	8000a3c <I2C_Init>
  init_ok=1;
 8010140:	2301      	movs	r3, #1
 8010142:	7033      	strb	r3, [r6, #0]
}
 8010144:	b006      	add	sp, #24
 8010146:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801014a:	bf00      	nop
 801014c:	20008078 	.word	0x20008078
 8010150:	2000009c 	.word	0x2000009c
 8010154:	00010202 	.word	0x00010202
 8010158:	000186a0 	.word	0x000186a0
 801015c:	40005400 	.word	0x40005400

08010160 <UB_I2C1_ReadByte>:
{
 8010160:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010164:	4607      	mov	r7, r0
  I2C_GenerateSTART(I2C1, ENABLE);
 8010166:	48c4      	ldr	r0, [pc, #784]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010168:	4ec4      	ldr	r6, [pc, #784]	; (801047c <UB_I2C1_ReadByte+0x31c>)
{
 801016a:	b084      	sub	sp, #16
 801016c:	4688      	mov	r8, r1
  I2C_GenerateSTART(I2C1, ENABLE);
 801016e:	2101      	movs	r1, #1
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010170:	4605      	mov	r5, r0
 8010172:	f243 0401 	movw	r4, #12289	; 0x3001
  I2C_GenerateSTART(I2C1, ENABLE);
 8010176:	f7f0 fcf3 	bl	8000b60 <I2C_GenerateSTART>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 801017a:	e002      	b.n	8010182 <UB_I2C1_ReadByte+0x22>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-1));
 801017c:	3c01      	subs	r4, #1
 801017e:	f000 80ba 	beq.w	80102f6 <UB_I2C1_ReadByte+0x196>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010182:	4631      	mov	r1, r6
 8010184:	4628      	mov	r0, r5
 8010186:	f7f0 fe1f 	bl	8000dc8 <I2C_GetFlagStatus>
 801018a:	2800      	cmp	r0, #0
 801018c:	d0f6      	beq.n	801017c <UB_I2C1_ReadByte+0x1c>
  I2C_AcknowledgeConfig(I2C1, DISABLE);
 801018e:	48ba      	ldr	r0, [pc, #744]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8010190:	4dbb      	ldr	r5, [pc, #748]	; (8010480 <UB_I2C1_ReadByte+0x320>)
  I2C_AcknowledgeConfig(I2C1, DISABLE);
 8010192:	2100      	movs	r1, #0
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8010194:	4606      	mov	r6, r0
  I2C_AcknowledgeConfig(I2C1, DISABLE);
 8010196:	f7f0 fd0b 	bl	8000bb0 <I2C_AcknowledgeConfig>
  I2C_Send7bitAddress(I2C1, slave_adr, I2C_Direction_Transmitter); 
 801019a:	2200      	movs	r2, #0
 801019c:	4639      	mov	r1, r7
 801019e:	4630      	mov	r0, r6
 80101a0:	f7f0 fcfa 	bl	8000b98 <I2C_Send7bitAddress>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 80101a4:	f243 0401 	movw	r4, #12289	; 0x3001
 80101a8:	e002      	b.n	80101b0 <UB_I2C1_ReadByte+0x50>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-2));
 80101aa:	3c01      	subs	r4, #1
 80101ac:	f000 80d4 	beq.w	8010358 <UB_I2C1_ReadByte+0x1f8>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 80101b0:	4629      	mov	r1, r5
 80101b2:	48b1      	ldr	r0, [pc, #708]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80101b4:	f7f0 fe08 	bl	8000dc8 <I2C_GetFlagStatus>
 80101b8:	2800      	cmp	r0, #0
 80101ba:	d0f6      	beq.n	80101aa <UB_I2C1_ReadByte+0x4a>
  I2C1->SR2;
 80101bc:	8b33      	ldrh	r3, [r6, #24]
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80101be:	4dae      	ldr	r5, [pc, #696]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80101c0:	4eb0      	ldr	r6, [pc, #704]	; (8010484 <UB_I2C1_ReadByte+0x324>)
 80101c2:	f243 0401 	movw	r4, #12289	; 0x3001
 80101c6:	e002      	b.n	80101ce <UB_I2C1_ReadByte+0x6e>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-3));
 80101c8:	3c01      	subs	r4, #1
 80101ca:	f000 80f6 	beq.w	80103ba <UB_I2C1_ReadByte+0x25a>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80101ce:	4631      	mov	r1, r6
 80101d0:	4628      	mov	r0, r5
 80101d2:	f7f0 fdf9 	bl	8000dc8 <I2C_GetFlagStatus>
 80101d6:	2800      	cmp	r0, #0
 80101d8:	d0f6      	beq.n	80101c8 <UB_I2C1_ReadByte+0x68>
  I2C_SendData(I2C1, adr);
 80101da:	48a7      	ldr	r0, [pc, #668]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 80101dc:	4ea9      	ldr	r6, [pc, #676]	; (8010484 <UB_I2C1_ReadByte+0x324>)
  I2C_SendData(I2C1, adr);
 80101de:	4641      	mov	r1, r8
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 80101e0:	4605      	mov	r5, r0
 80101e2:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 8010490 <UB_I2C1_ReadByte+0x330>
  I2C_SendData(I2C1, adr);
 80101e6:	f7f0 fd71 	bl	8000ccc <I2C_SendData>
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 80101ea:	f243 0401 	movw	r4, #12289	; 0x3001
 80101ee:	e001      	b.n	80101f4 <UB_I2C1_ReadByte+0x94>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-4));
 80101f0:	3c01      	subs	r4, #1
 80101f2:	d04f      	beq.n	8010294 <UB_I2C1_ReadByte+0x134>
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 80101f4:	4631      	mov	r1, r6
 80101f6:	4628      	mov	r0, r5
 80101f8:	f7f0 fde6 	bl	8000dc8 <I2C_GetFlagStatus>
 80101fc:	2800      	cmp	r0, #0
 80101fe:	d0f7      	beq.n	80101f0 <UB_I2C1_ReadByte+0x90>
 8010200:	4641      	mov	r1, r8
 8010202:	4628      	mov	r0, r5
 8010204:	f7f0 fde0 	bl	8000dc8 <I2C_GetFlagStatus>
 8010208:	2800      	cmp	r0, #0
 801020a:	d0f1      	beq.n	80101f0 <UB_I2C1_ReadByte+0x90>
  I2C_GenerateSTART(I2C1, ENABLE);
 801020c:	489a      	ldr	r0, [pc, #616]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 801020e:	4e9b      	ldr	r6, [pc, #620]	; (801047c <UB_I2C1_ReadByte+0x31c>)
  I2C_GenerateSTART(I2C1, ENABLE);
 8010210:	2101      	movs	r1, #1
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010212:	4605      	mov	r5, r0
 8010214:	f243 0401 	movw	r4, #12289	; 0x3001
  I2C_GenerateSTART(I2C1, ENABLE);
 8010218:	f7f0 fca2 	bl	8000b60 <I2C_GenerateSTART>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 801021c:	e002      	b.n	8010224 <UB_I2C1_ReadByte+0xc4>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-5));
 801021e:	3c01      	subs	r4, #1
 8010220:	f000 80fc 	beq.w	801041c <UB_I2C1_ReadByte+0x2bc>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010224:	4631      	mov	r1, r6
 8010226:	4628      	mov	r0, r5
 8010228:	f7f0 fdce 	bl	8000dc8 <I2C_GetFlagStatus>
 801022c:	2800      	cmp	r0, #0
 801022e:	d0f6      	beq.n	801021e <UB_I2C1_ReadByte+0xbe>
  I2C_Send7bitAddress(I2C1, slave_adr, I2C_Direction_Receiver);
 8010230:	4891      	ldr	r0, [pc, #580]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8010232:	4d93      	ldr	r5, [pc, #588]	; (8010480 <UB_I2C1_ReadByte+0x320>)
  I2C_Send7bitAddress(I2C1, slave_adr, I2C_Direction_Receiver);
 8010234:	4639      	mov	r1, r7
 8010236:	2201      	movs	r2, #1
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8010238:	4606      	mov	r6, r0
 801023a:	f243 0401 	movw	r4, #12289	; 0x3001
  I2C_Send7bitAddress(I2C1, slave_adr, I2C_Direction_Receiver);
 801023e:	f7f0 fcab 	bl	8000b98 <I2C_Send7bitAddress>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8010242:	e002      	b.n	801024a <UB_I2C1_ReadByte+0xea>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-6));
 8010244:	3c01      	subs	r4, #1
 8010246:	f000 8125 	beq.w	8010494 <UB_I2C1_ReadByte+0x334>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 801024a:	4629      	mov	r1, r5
 801024c:	488a      	ldr	r0, [pc, #552]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801024e:	f7f0 fdbb 	bl	8000dc8 <I2C_GetFlagStatus>
 8010252:	2800      	cmp	r0, #0
 8010254:	d0f6      	beq.n	8010244 <UB_I2C1_ReadByte+0xe4>
  I2C1->SR2;
 8010256:	8b33      	ldrh	r3, [r6, #24]
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_RXNE)) {
 8010258:	4d87      	ldr	r5, [pc, #540]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801025a:	4e8b      	ldr	r6, [pc, #556]	; (8010488 <UB_I2C1_ReadByte+0x328>)
 801025c:	f243 0401 	movw	r4, #12289	; 0x3001
 8010260:	e002      	b.n	8010268 <UB_I2C1_ReadByte+0x108>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-7));
 8010262:	3c01      	subs	r4, #1
 8010264:	f000 8144 	beq.w	80104f0 <UB_I2C1_ReadByte+0x390>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_RXNE)) {
 8010268:	4631      	mov	r1, r6
 801026a:	4628      	mov	r0, r5
 801026c:	f7f0 fdac 	bl	8000dc8 <I2C_GetFlagStatus>
 8010270:	2800      	cmp	r0, #0
 8010272:	d0f6      	beq.n	8010262 <UB_I2C1_ReadByte+0x102>
  I2C_GenerateSTOP(I2C1, ENABLE);
 8010274:	2101      	movs	r1, #1
 8010276:	4880      	ldr	r0, [pc, #512]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010278:	f7f0 fc80 	bl	8000b7c <I2C_GenerateSTOP>
  ret_wert=(int16_t)(I2C_ReceiveData(I2C1));
 801027c:	487e      	ldr	r0, [pc, #504]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801027e:	f7f0 fd27 	bl	8000cd0 <I2C_ReceiveData>
  I2C_AcknowledgeConfig(I2C1, ENABLE);
 8010282:	2101      	movs	r1, #1
  ret_wert=(int16_t)(I2C_ReceiveData(I2C1));
 8010284:	b204      	sxth	r4, r0
  I2C_AcknowledgeConfig(I2C1, ENABLE);
 8010286:	487c      	ldr	r0, [pc, #496]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010288:	f7f0 fc92 	bl	8000bb0 <I2C_AcknowledgeConfig>
}
 801028c:	4620      	mov	r0, r4
 801028e:	b004      	add	sp, #16
 8010290:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
int16_t P_I2C1_timeout(int16_t wert)
{
  int16_t ret_wert=wert;

  // Stop und Reset
  I2C_GenerateSTOP(I2C1, ENABLE);
 8010294:	2101      	movs	r1, #1
 8010296:	4878      	ldr	r0, [pc, #480]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010298:	f7f0 fc70 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 801029c:	2101      	movs	r1, #1
 801029e:	4876      	ldr	r0, [pc, #472]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80102a0:	f7f0 fcba 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 80102a4:	4621      	mov	r1, r4
 80102a6:	4874      	ldr	r0, [pc, #464]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80102a8:	f7f0 fcb6 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80102ac:	ad04      	add	r5, sp, #16

  // I2C deinit
  I2C_DeInit(I2C1);
 80102ae:	4872      	ldr	r0, [pc, #456]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80102b0:	f7f0 fb8e 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80102b4:	4b75      	ldr	r3, [pc, #468]	; (801048c <UB_I2C1_ReadByte+0x32c>)
 80102b6:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80102ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80102be:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_Cmd(I2C1, ENABLE);
 80102c2:	2101      	movs	r1, #1
 80102c4:	486c      	ldr	r0, [pc, #432]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80102c6:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80102ca:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 80102ce:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80102d2:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80102d6:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80102da:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 80102de:	f7f0 fc31 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 80102e2:	4629      	mov	r1, r5
 80102e4:	4864      	ldr	r0, [pc, #400]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80102e6:	f7f0 fba9 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-4));
 80102ea:	f06f 0403 	mvn.w	r4, #3
}
 80102ee:	4620      	mov	r0, r4
 80102f0:	b004      	add	sp, #16
 80102f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 80102f6:	2101      	movs	r1, #1
 80102f8:	485f      	ldr	r0, [pc, #380]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80102fa:	f7f0 fc3f 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 80102fe:	2101      	movs	r1, #1
 8010300:	485d      	ldr	r0, [pc, #372]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010302:	f7f0 fc89 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 8010306:	4621      	mov	r1, r4
 8010308:	485b      	ldr	r0, [pc, #364]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801030a:	f7f0 fc85 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 801030e:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 8010310:	4859      	ldr	r0, [pc, #356]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010312:	f7f0 fb5d 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010316:	4b5d      	ldr	r3, [pc, #372]	; (801048c <UB_I2C1_ReadByte+0x32c>)
 8010318:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 801031c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010320:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010324:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 8010328:	2101      	movs	r1, #1
 801032a:	4853      	ldr	r0, [pc, #332]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 801032c:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 8010330:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010334:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010338:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 801033c:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 8010340:	f7f0 fc00 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 8010344:	4629      	mov	r1, r5
 8010346:	484c      	ldr	r0, [pc, #304]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010348:	f7f0 fb78 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-1));
 801034c:	f04f 34ff 	mov.w	r4, #4294967295
}
 8010350:	4620      	mov	r0, r4
 8010352:	b004      	add	sp, #16
 8010354:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 8010358:	2101      	movs	r1, #1
 801035a:	4847      	ldr	r0, [pc, #284]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801035c:	f7f0 fc0e 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 8010360:	2101      	movs	r1, #1
 8010362:	4845      	ldr	r0, [pc, #276]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010364:	f7f0 fc58 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 8010368:	4621      	mov	r1, r4
 801036a:	4843      	ldr	r0, [pc, #268]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801036c:	f7f0 fc54 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010370:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 8010372:	4841      	ldr	r0, [pc, #260]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010374:	f7f0 fb2c 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010378:	4b44      	ldr	r3, [pc, #272]	; (801048c <UB_I2C1_ReadByte+0x32c>)
 801037a:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 801037e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010382:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010386:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 801038a:	2101      	movs	r1, #1
 801038c:	483a      	ldr	r0, [pc, #232]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 801038e:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 8010392:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010396:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 801039a:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 801039e:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 80103a2:	f7f0 fbcf 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 80103a6:	4629      	mov	r1, r5
 80103a8:	4833      	ldr	r0, [pc, #204]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80103aa:	f7f0 fb47 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-2));
 80103ae:	f06f 0401 	mvn.w	r4, #1
}
 80103b2:	4620      	mov	r0, r4
 80103b4:	b004      	add	sp, #16
 80103b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 80103ba:	2101      	movs	r1, #1
 80103bc:	482e      	ldr	r0, [pc, #184]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80103be:	f7f0 fbdd 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 80103c2:	2101      	movs	r1, #1
 80103c4:	482c      	ldr	r0, [pc, #176]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80103c6:	f7f0 fc27 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 80103ca:	4621      	mov	r1, r4
 80103cc:	482a      	ldr	r0, [pc, #168]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80103ce:	f7f0 fc23 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80103d2:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 80103d4:	4828      	ldr	r0, [pc, #160]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 80103d6:	f7f0 fafb 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80103da:	4b2c      	ldr	r3, [pc, #176]	; (801048c <UB_I2C1_ReadByte+0x32c>)
 80103dc:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80103e0:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80103e4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80103e8:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 80103ec:	2101      	movs	r1, #1
 80103ee:	4822      	ldr	r0, [pc, #136]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80103f0:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 80103f4:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80103f8:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80103fc:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010400:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 8010404:	f7f0 fb9e 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 8010408:	4629      	mov	r1, r5
 801040a:	481b      	ldr	r0, [pc, #108]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801040c:	f7f0 fb16 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-3));
 8010410:	f06f 0402 	mvn.w	r4, #2
}
 8010414:	4620      	mov	r0, r4
 8010416:	b004      	add	sp, #16
 8010418:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 801041c:	2101      	movs	r1, #1
 801041e:	4816      	ldr	r0, [pc, #88]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010420:	f7f0 fbac 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 8010424:	2101      	movs	r1, #1
 8010426:	4814      	ldr	r0, [pc, #80]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010428:	f7f0 fbf6 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 801042c:	4621      	mov	r1, r4
 801042e:	4812      	ldr	r0, [pc, #72]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010430:	f7f0 fbf2 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010434:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 8010436:	4810      	ldr	r0, [pc, #64]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 8010438:	f7f0 faca 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 801043c:	4b13      	ldr	r3, [pc, #76]	; (801048c <UB_I2C1_ReadByte+0x32c>)
 801043e:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010442:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010446:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_Cmd(I2C1, ENABLE);
 801044a:	2101      	movs	r1, #1
 801044c:	480a      	ldr	r0, [pc, #40]	; (8010478 <UB_I2C1_ReadByte+0x318>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 801044e:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010452:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 8010456:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 801045a:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 801045e:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010462:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 8010466:	f7f0 fb6d 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 801046a:	4629      	mov	r1, r5
 801046c:	4802      	ldr	r0, [pc, #8]	; (8010478 <UB_I2C1_ReadByte+0x318>)
 801046e:	f7f0 fae5 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-5));
 8010472:	f06f 0404 	mvn.w	r4, #4
 8010476:	e73a      	b.n	80102ee <UB_I2C1_ReadByte+0x18e>
 8010478:	40005400 	.word	0x40005400
 801047c:	10000001 	.word	0x10000001
 8010480:	10000002 	.word	0x10000002
 8010484:	10000080 	.word	0x10000080
 8010488:	10000040 	.word	0x10000040
 801048c:	000186a0 	.word	0x000186a0
 8010490:	10000004 	.word	0x10000004
  I2C_GenerateSTOP(I2C1, ENABLE);
 8010494:	2101      	movs	r1, #1
 8010496:	482d      	ldr	r0, [pc, #180]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 8010498:	f7f0 fb70 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 801049c:	2101      	movs	r1, #1
 801049e:	482b      	ldr	r0, [pc, #172]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 80104a0:	f7f0 fbba 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 80104a4:	4621      	mov	r1, r4
 80104a6:	4829      	ldr	r0, [pc, #164]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 80104a8:	f7f0 fbb6 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80104ac:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 80104ae:	4827      	ldr	r0, [pc, #156]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 80104b0:	f7f0 fa8e 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80104b4:	4b26      	ldr	r3, [pc, #152]	; (8010550 <UB_I2C1_ReadByte+0x3f0>)
 80104b6:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80104ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80104be:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_Cmd(I2C1, ENABLE);
 80104c2:	2101      	movs	r1, #1
 80104c4:	4821      	ldr	r0, [pc, #132]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80104c6:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80104ca:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 80104ce:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80104d2:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80104d6:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80104da:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 80104de:	f7f0 fb31 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 80104e2:	4629      	mov	r1, r5
 80104e4:	4819      	ldr	r0, [pc, #100]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 80104e6:	f7f0 faa9 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-6));
 80104ea:	f06f 0405 	mvn.w	r4, #5
 80104ee:	e6fe      	b.n	80102ee <UB_I2C1_ReadByte+0x18e>
  I2C_GenerateSTOP(I2C1, ENABLE);
 80104f0:	2101      	movs	r1, #1
 80104f2:	4816      	ldr	r0, [pc, #88]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 80104f4:	f7f0 fb42 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 80104f8:	2101      	movs	r1, #1
 80104fa:	4814      	ldr	r0, [pc, #80]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 80104fc:	f7f0 fb8c 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 8010500:	4621      	mov	r1, r4
 8010502:	4812      	ldr	r0, [pc, #72]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 8010504:	f7f0 fb88 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010508:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 801050a:	4810      	ldr	r0, [pc, #64]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 801050c:	f7f0 fa60 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010510:	4b0f      	ldr	r3, [pc, #60]	; (8010550 <UB_I2C1_ReadByte+0x3f0>)
 8010512:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010516:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 801051a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_Cmd(I2C1, ENABLE);
 801051e:	2101      	movs	r1, #1
 8010520:	480a      	ldr	r0, [pc, #40]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8010522:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010526:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 801052a:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 801052e:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010532:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010536:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 801053a:	f7f0 fb03 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 801053e:	4629      	mov	r1, r5
 8010540:	4802      	ldr	r0, [pc, #8]	; (801054c <UB_I2C1_ReadByte+0x3ec>)
 8010542:	f7f0 fa7b 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-7));
 8010546:	f06f 0406 	mvn.w	r4, #6
 801054a:	e6d0      	b.n	80102ee <UB_I2C1_ReadByte+0x18e>
 801054c:	40005400 	.word	0x40005400
 8010550:	000186a0 	.word	0x000186a0

08010554 <UB_I2C1_WriteByte>:
{
 8010554:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010558:	4681      	mov	r9, r0
  I2C_GenerateSTART(I2C1, ENABLE); 
 801055a:	48ac      	ldr	r0, [pc, #688]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 801055c:	4eac      	ldr	r6, [pc, #688]	; (8010810 <UB_I2C1_WriteByte+0x2bc>)
{
 801055e:	b085      	sub	sp, #20
 8010560:	4688      	mov	r8, r1
  I2C_GenerateSTART(I2C1, ENABLE); 
 8010562:	2101      	movs	r1, #1
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010564:	4605      	mov	r5, r0
{
 8010566:	4617      	mov	r7, r2
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010568:	f243 0401 	movw	r4, #12289	; 0x3001
  I2C_GenerateSTART(I2C1, ENABLE); 
 801056c:	f7f0 faf8 	bl	8000b60 <I2C_GenerateSTART>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010570:	e002      	b.n	8010578 <UB_I2C1_WriteByte+0x24>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-1));
 8010572:	3c01      	subs	r4, #1
 8010574:	f000 808a 	beq.w	801068c <UB_I2C1_WriteByte+0x138>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB)) {
 8010578:	4631      	mov	r1, r6
 801057a:	4628      	mov	r0, r5
 801057c:	f7f0 fc24 	bl	8000dc8 <I2C_GetFlagStatus>
 8010580:	2800      	cmp	r0, #0
 8010582:	d0f6      	beq.n	8010572 <UB_I2C1_WriteByte+0x1e>
  I2C_Send7bitAddress(I2C1, slave_adr, I2C_Direction_Transmitter);
 8010584:	48a1      	ldr	r0, [pc, #644]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8010586:	4da3      	ldr	r5, [pc, #652]	; (8010814 <UB_I2C1_WriteByte+0x2c0>)
  I2C_Send7bitAddress(I2C1, slave_adr, I2C_Direction_Transmitter);
 8010588:	4649      	mov	r1, r9
 801058a:	2200      	movs	r2, #0
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 801058c:	4606      	mov	r6, r0
 801058e:	f243 0401 	movw	r4, #12289	; 0x3001
  I2C_Send7bitAddress(I2C1, slave_adr, I2C_Direction_Transmitter);
 8010592:	f7f0 fb01 	bl	8000b98 <I2C_Send7bitAddress>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8010596:	e002      	b.n	801059e <UB_I2C1_WriteByte+0x4a>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-2));
 8010598:	3c01      	subs	r4, #1
 801059a:	f000 80a7 	beq.w	80106ec <UB_I2C1_WriteByte+0x198>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 801059e:	4629      	mov	r1, r5
 80105a0:	489a      	ldr	r0, [pc, #616]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80105a2:	f7f0 fc11 	bl	8000dc8 <I2C_GetFlagStatus>
 80105a6:	2800      	cmp	r0, #0
 80105a8:	d0f6      	beq.n	8010598 <UB_I2C1_WriteByte+0x44>
  I2C1->SR2;
 80105aa:	8b33      	ldrh	r3, [r6, #24]
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80105ac:	4d97      	ldr	r5, [pc, #604]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80105ae:	4e9a      	ldr	r6, [pc, #616]	; (8010818 <UB_I2C1_WriteByte+0x2c4>)
 80105b0:	f243 0401 	movw	r4, #12289	; 0x3001
 80105b4:	e002      	b.n	80105bc <UB_I2C1_WriteByte+0x68>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-3));
 80105b6:	3c01      	subs	r4, #1
 80105b8:	f000 80c8 	beq.w	801074c <UB_I2C1_WriteByte+0x1f8>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80105bc:	4631      	mov	r1, r6
 80105be:	4628      	mov	r0, r5
 80105c0:	f7f0 fc02 	bl	8000dc8 <I2C_GetFlagStatus>
 80105c4:	2800      	cmp	r0, #0
 80105c6:	d0f6      	beq.n	80105b6 <UB_I2C1_WriteByte+0x62>
  I2C_SendData(I2C1, adr);
 80105c8:	4890      	ldr	r0, [pc, #576]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80105ca:	4e93      	ldr	r6, [pc, #588]	; (8010818 <UB_I2C1_WriteByte+0x2c4>)
  I2C_SendData(I2C1, adr);
 80105cc:	4641      	mov	r1, r8
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80105ce:	4605      	mov	r5, r0
 80105d0:	f243 0401 	movw	r4, #12289	; 0x3001
  I2C_SendData(I2C1, adr);
 80105d4:	f7f0 fb7a 	bl	8000ccc <I2C_SendData>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80105d8:	e002      	b.n	80105e0 <UB_I2C1_WriteByte+0x8c>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-4));
 80105da:	3c01      	subs	r4, #1
 80105dc:	f000 80e6 	beq.w	80107ac <UB_I2C1_WriteByte+0x258>
  while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) {
 80105e0:	4631      	mov	r1, r6
 80105e2:	4628      	mov	r0, r5
 80105e4:	f7f0 fbf0 	bl	8000dc8 <I2C_GetFlagStatus>
 80105e8:	2800      	cmp	r0, #0
 80105ea:	d0f6      	beq.n	80105da <UB_I2C1_WriteByte+0x86>
  I2C_SendData(I2C1, wert);
 80105ec:	4887      	ldr	r0, [pc, #540]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 80105ee:	4e8a      	ldr	r6, [pc, #552]	; (8010818 <UB_I2C1_WriteByte+0x2c4>)
  I2C_SendData(I2C1, wert);
 80105f0:	4639      	mov	r1, r7
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 80105f2:	4605      	mov	r5, r0
 80105f4:	4f89      	ldr	r7, [pc, #548]	; (801081c <UB_I2C1_WriteByte+0x2c8>)
  I2C_SendData(I2C1, wert);
 80105f6:	f7f0 fb69 	bl	8000ccc <I2C_SendData>
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 80105fa:	f243 0401 	movw	r4, #12289	; 0x3001
 80105fe:	e001      	b.n	8010604 <UB_I2C1_WriteByte+0xb0>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-5));
 8010600:	3c01      	subs	r4, #1
 8010602:	d013      	beq.n	801062c <UB_I2C1_WriteByte+0xd8>
  while ((!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE)) || (!I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF))) {
 8010604:	4631      	mov	r1, r6
 8010606:	4628      	mov	r0, r5
 8010608:	f7f0 fbde 	bl	8000dc8 <I2C_GetFlagStatus>
 801060c:	2800      	cmp	r0, #0
 801060e:	d0f7      	beq.n	8010600 <UB_I2C1_WriteByte+0xac>
 8010610:	4639      	mov	r1, r7
 8010612:	4628      	mov	r0, r5
 8010614:	f7f0 fbd8 	bl	8000dc8 <I2C_GetFlagStatus>
 8010618:	2800      	cmp	r0, #0
 801061a:	d0f1      	beq.n	8010600 <UB_I2C1_WriteByte+0xac>
  I2C_GenerateSTOP(I2C1, ENABLE);
 801061c:	2101      	movs	r1, #1
 801061e:	487b      	ldr	r0, [pc, #492]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010620:	f7f0 faac 	bl	8000b7c <I2C_GenerateSTOP>
  return(ret_wert);
 8010624:	2000      	movs	r0, #0
}
 8010626:	b005      	add	sp, #20
 8010628:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 801062c:	2101      	movs	r1, #1
 801062e:	4877      	ldr	r0, [pc, #476]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010630:	f7f0 faa4 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 8010634:	2101      	movs	r1, #1
 8010636:	4875      	ldr	r0, [pc, #468]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010638:	f7f0 faee 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 801063c:	4621      	mov	r1, r4
 801063e:	4873      	ldr	r0, [pc, #460]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010640:	f7f0 faea 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010644:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 8010646:	4871      	ldr	r0, [pc, #452]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010648:	f7f0 f9c2 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 801064c:	4b74      	ldr	r3, [pc, #464]	; (8010820 <UB_I2C1_WriteByte+0x2cc>)
 801064e:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010652:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010656:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 801065a:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 801065e:	2101      	movs	r1, #1
 8010660:	486a      	ldr	r0, [pc, #424]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010662:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010666:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 801066a:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 801066e:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010672:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 8010676:	f7f0 fa65 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 801067a:	4629      	mov	r1, r5
 801067c:	4863      	ldr	r0, [pc, #396]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 801067e:	f7f0 f9dd 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-5));
 8010682:	f06f 0004 	mvn.w	r0, #4
}
 8010686:	b005      	add	sp, #20
 8010688:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 801068c:	2101      	movs	r1, #1
 801068e:	485f      	ldr	r0, [pc, #380]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010690:	f7f0 fa74 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 8010694:	2101      	movs	r1, #1
 8010696:	485d      	ldr	r0, [pc, #372]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010698:	f7f0 fabe 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 801069c:	4621      	mov	r1, r4
 801069e:	485b      	ldr	r0, [pc, #364]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80106a0:	f7f0 faba 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80106a4:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 80106a6:	4859      	ldr	r0, [pc, #356]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80106a8:	f7f0 f992 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80106ac:	4b5c      	ldr	r3, [pc, #368]	; (8010820 <UB_I2C1_WriteByte+0x2cc>)
 80106ae:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80106b2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80106b6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80106ba:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 80106be:	2101      	movs	r1, #1
 80106c0:	4852      	ldr	r0, [pc, #328]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80106c2:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80106c6:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80106ca:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 80106ce:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80106d2:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 80106d6:	f7f0 fa35 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 80106da:	4629      	mov	r1, r5
 80106dc:	484b      	ldr	r0, [pc, #300]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80106de:	f7f0 f9ad 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-1));
 80106e2:	f04f 30ff 	mov.w	r0, #4294967295
}
 80106e6:	b005      	add	sp, #20
 80106e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 80106ec:	2101      	movs	r1, #1
 80106ee:	4847      	ldr	r0, [pc, #284]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80106f0:	f7f0 fa44 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 80106f4:	2101      	movs	r1, #1
 80106f6:	4845      	ldr	r0, [pc, #276]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80106f8:	f7f0 fa8e 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 80106fc:	4621      	mov	r1, r4
 80106fe:	4843      	ldr	r0, [pc, #268]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010700:	f7f0 fa8a 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010704:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 8010706:	4841      	ldr	r0, [pc, #260]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010708:	f7f0 f962 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 801070c:	4b44      	ldr	r3, [pc, #272]	; (8010820 <UB_I2C1_WriteByte+0x2cc>)
 801070e:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010712:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010716:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 801071a:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 801071e:	2101      	movs	r1, #1
 8010720:	483a      	ldr	r0, [pc, #232]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010722:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010726:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 801072a:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 801072e:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010732:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 8010736:	f7f0 fa05 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 801073a:	4629      	mov	r1, r5
 801073c:	4833      	ldr	r0, [pc, #204]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 801073e:	f7f0 f97d 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-2));
 8010742:	f06f 0001 	mvn.w	r0, #1
}
 8010746:	b005      	add	sp, #20
 8010748:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 801074c:	2101      	movs	r1, #1
 801074e:	482f      	ldr	r0, [pc, #188]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010750:	f7f0 fa14 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 8010754:	2101      	movs	r1, #1
 8010756:	482d      	ldr	r0, [pc, #180]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010758:	f7f0 fa5e 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 801075c:	4621      	mov	r1, r4
 801075e:	482b      	ldr	r0, [pc, #172]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010760:	f7f0 fa5a 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010764:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 8010766:	4829      	ldr	r0, [pc, #164]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 8010768:	f7f0 f932 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 801076c:	4b2c      	ldr	r3, [pc, #176]	; (8010820 <UB_I2C1_WriteByte+0x2cc>)
 801076e:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010772:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010776:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 801077a:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 801077e:	2101      	movs	r1, #1
 8010780:	4822      	ldr	r0, [pc, #136]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010782:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010786:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 801078a:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 801078e:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010792:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 8010796:	f7f0 f9d5 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 801079a:	4629      	mov	r1, r5
 801079c:	481b      	ldr	r0, [pc, #108]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 801079e:	f7f0 f94d 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-3));
 80107a2:	f06f 0002 	mvn.w	r0, #2
}
 80107a6:	b005      	add	sp, #20
 80107a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  I2C_GenerateSTOP(I2C1, ENABLE);
 80107ac:	2101      	movs	r1, #1
 80107ae:	4817      	ldr	r0, [pc, #92]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80107b0:	f7f0 f9e4 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 80107b4:	2101      	movs	r1, #1
 80107b6:	4815      	ldr	r0, [pc, #84]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80107b8:	f7f0 fa2e 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 80107bc:	4621      	mov	r1, r4
 80107be:	4813      	ldr	r0, [pc, #76]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80107c0:	f7f0 fa2a 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80107c4:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 80107c6:	4811      	ldr	r0, [pc, #68]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80107c8:	f7f0 f902 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80107cc:	4b14      	ldr	r3, [pc, #80]	; (8010820 <UB_I2C1_WriteByte+0x2cc>)
 80107ce:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80107d2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80107d6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80107da:	f64b 76ff 	movw	r6, #49151	; 0xbfff
  I2C_Cmd(I2C1, ENABLE);
 80107de:	2101      	movs	r1, #1
 80107e0:	480a      	ldr	r0, [pc, #40]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80107e2:	f8ad 200a 	strh.w	r2, [sp, #10]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80107e6:	f8ad 300c 	strh.w	r3, [sp, #12]
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80107ea:	f8ad 4004 	strh.w	r4, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 80107ee:	f8ad 4008 	strh.w	r4, [sp, #8]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80107f2:	f8ad 6006 	strh.w	r6, [sp, #6]
  I2C_Cmd(I2C1, ENABLE);
 80107f6:	f7f0 f9a5 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 80107fa:	4629      	mov	r1, r5
 80107fc:	4803      	ldr	r0, [pc, #12]	; (801080c <UB_I2C1_WriteByte+0x2b8>)
 80107fe:	f7f0 f91d 	bl	8000a3c <I2C_Init>
    if(timeout!=0) timeout--; else return(P_I2C1_timeout(-4));
 8010802:	f06f 0003 	mvn.w	r0, #3
}
 8010806:	b005      	add	sp, #20
 8010808:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801080c:	40005400 	.word	0x40005400
 8010810:	10000001 	.word	0x10000001
 8010814:	10000002 	.word	0x10000002
 8010818:	10000080 	.word	0x10000080
 801081c:	10000004 	.word	0x10000004
 8010820:	000186a0 	.word	0x000186a0

08010824 <UB_I2C1_Delay>:
{
 8010824:	b082      	sub	sp, #8
 8010826:	9001      	str	r0, [sp, #4]
  while(nCount--)
 8010828:	9b01      	ldr	r3, [sp, #4]
 801082a:	1e5a      	subs	r2, r3, #1
 801082c:	9201      	str	r2, [sp, #4]
 801082e:	2b00      	cmp	r3, #0
 8010830:	d1fa      	bne.n	8010828 <UB_I2C1_Delay+0x4>
}
 8010832:	b002      	add	sp, #8
 8010834:	4770      	bx	lr
 8010836:	bf00      	nop

08010838 <P_I2C1_InitI2C>:
{
 8010838:	b5f0      	push	{r4, r5, r6, r7, lr}
 801083a:	b085      	sub	sp, #20
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 801083c:	ac04      	add	r4, sp, #16
  I2C_Cmd(I2C1, ENABLE);
 801083e:	4d0f      	ldr	r5, [pc, #60]	; (801087c <P_I2C1_InitI2C+0x44>)
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 8010840:	4b0f      	ldr	r3, [pc, #60]	; (8010880 <P_I2C1_InitI2C+0x48>)
 8010842:	f844 3d10 	str.w	r3, [r4, #-16]!
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010846:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 801084a:	2300      	movs	r3, #0
  I2C_Cmd(I2C1, ENABLE);
 801084c:	4628      	mov	r0, r5
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 801084e:	f64b 77ff 	movw	r7, #49151	; 0xbfff
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010852:	f44f 6680 	mov.w	r6, #1024	; 0x400
  I2C_Cmd(I2C1, ENABLE);
 8010856:	2101      	movs	r1, #1
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8010858:	f8ad 3004 	strh.w	r3, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 801085c:	f8ad 3008 	strh.w	r3, [sp, #8]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8010860:	f8ad 200c 	strh.w	r2, [sp, #12]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8010864:	f8ad 7006 	strh.w	r7, [sp, #6]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8010868:	f8ad 600a 	strh.w	r6, [sp, #10]
  I2C_Cmd(I2C1, ENABLE);
 801086c:	f7f0 f96a 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 8010870:	4621      	mov	r1, r4
 8010872:	4628      	mov	r0, r5
 8010874:	f7f0 f8e2 	bl	8000a3c <I2C_Init>
}
 8010878:	b005      	add	sp, #20
 801087a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801087c:	40005400 	.word	0x40005400
 8010880:	000186a0 	.word	0x000186a0

08010884 <P_I2C1_timeout>:
{
 8010884:	b5f0      	push	{r4, r5, r6, r7, lr}
  I2C_GenerateSTOP(I2C1, ENABLE);
 8010886:	4c19      	ldr	r4, [pc, #100]	; (80108ec <P_I2C1_timeout+0x68>)
{
 8010888:	b085      	sub	sp, #20
 801088a:	4606      	mov	r6, r0
  I2C_GenerateSTOP(I2C1, ENABLE);
 801088c:	2101      	movs	r1, #1
 801088e:	4620      	mov	r0, r4
 8010890:	f7f0 f974 	bl	8000b7c <I2C_GenerateSTOP>
  I2C_SoftwareResetCmd(I2C1, ENABLE);
 8010894:	4620      	mov	r0, r4
 8010896:	2101      	movs	r1, #1
 8010898:	f7f0 f9be 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_SoftwareResetCmd(I2C1, DISABLE);
 801089c:	4620      	mov	r0, r4
 801089e:	2100      	movs	r1, #0
 80108a0:	f7f0 f9ba 	bl	8000c18 <I2C_SoftwareResetCmd>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80108a4:	ad04      	add	r5, sp, #16
  I2C_DeInit(I2C1);
 80108a6:	4620      	mov	r0, r4
 80108a8:	f7f0 f892 	bl	80009d0 <I2C_DeInit>
  I2C_InitStructure.I2C_ClockSpeed = I2C1_CLOCK_FRQ;
 80108ac:	4b10      	ldr	r3, [pc, #64]	; (80108f0 <P_I2C1_timeout+0x6c>)
 80108ae:	f845 3d10 	str.w	r3, [r5, #-16]!
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80108b2:	f64b 7eff 	movw	lr, #49151	; 0xbfff
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80108b6:	2300      	movs	r3, #0
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80108b8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  I2C_Cmd(I2C1, ENABLE);
 80108bc:	4620      	mov	r0, r4
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80108be:	f44f 6780 	mov.w	r7, #1024	; 0x400
  I2C_Cmd(I2C1, ENABLE);
 80108c2:	2101      	movs	r1, #1
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80108c4:	f8ad 3004 	strh.w	r3, [sp, #4]
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 80108c8:	f8ad 3008 	strh.w	r3, [sp, #8]
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 80108cc:	f8ad e006 	strh.w	lr, [sp, #6]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80108d0:	f8ad 200c 	strh.w	r2, [sp, #12]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80108d4:	f8ad 700a 	strh.w	r7, [sp, #10]
  I2C_Cmd(I2C1, ENABLE);
 80108d8:	f7f0 f934 	bl	8000b44 <I2C_Cmd>
  I2C_Init(I2C1, &I2C_InitStructure);
 80108dc:	4620      	mov	r0, r4
 80108de:	4629      	mov	r1, r5
 80108e0:	f7f0 f8ac 	bl	8000a3c <I2C_Init>
  // I2C init
  P_I2C1_InitI2C();
    
  return(ret_wert);
}
 80108e4:	4630      	mov	r0, r6
 80108e6:	b005      	add	sp, #20
 80108e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80108ea:	bf00      	nop
 80108ec:	40005400 	.word	0x40005400
 80108f0:	000186a0 	.word	0x000186a0

080108f4 <UB_MP3Player_Init>:

//--------------------------------------------------------------
// Init vom MP3-Player
//--------------------------------------------------------------
void UB_MP3Player_Init(void)
{
 80108f4:	b508      	push	{r3, lr}
  // Init vom CS43L22
  UB_CS43L22_InitMP3();
 80108f6:	f7ff f81b 	bl	800f930 <UB_CS43L22_InitMP3>

  // Init vom Button
  UB_Button_Init();
 80108fa:	f7fe feff 	bl	800f6fc <UB_Button_Init>

  // aktuelle MP Nummer = 0
  akt_mp3_nr=0;
 80108fe:	4b02      	ldr	r3, [pc, #8]	; (8010908 <UB_MP3Player_Init+0x14>)
 8010900:	2200      	movs	r2, #0
 8010902:	601a      	str	r2, [r3, #0]
 8010904:	bd08      	pop	{r3, pc}
 8010906:	bf00      	nop
 8010908:	20010340 	.word	0x20010340

0801090c <UB_MP3Player_Stop>:
//--------------------------------------------------------------
// stopt das abspielen vom MP3
//--------------------------------------------------------------
void UB_MP3Player_Stop(void)
{
  UB_Fatfs_UnMount(USB_0);
 801090c:	2000      	movs	r0, #0
 801090e:	f7ff bb21 	b.w	800ff54 <UB_Fatfs_UnMount>
 8010912:	bf00      	nop

08010914 <P_PlayMP3Nr>:
// ret_wert :
//   0 = mp3 gefunden und Widergabe gestartet
//   1 = mp3 nicht gefunden bzw. Ende vom Verzeichniss erreicht
//--------------------------------------------------------------
uint32_t P_PlayMP3Nr(const char* akt_pfad, uint32_t nr)
{
 8010914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010918:	4606      	mov	r6, r0
 801091a:	b097      	sub	sp, #92	; 0x5c
 801091c:	4689      	mov	r9, r1
  uint32_t mp3_ok=0;
  char buffer[32]; // Puffer fr Pfad+Filename
  uint32_t akt_nr=0;

  // Verzeichniss ffnen
  fatfs_error=f_opendir(&mydir, akt_pfad);
 801091e:	a807      	add	r0, sp, #28
 8010920:	4631      	mov	r1, r6
 8010922:	f7f4 fe33 	bl	800558c <f_opendir>
  if(fatfs_error==FR_OK) {
 8010926:	2800      	cmp	r0, #0
 8010928:	d154      	bne.n	80109d4 <P_PlayMP3Nr+0xc0>

  pch=strrchr(filename,'.');
  if(pch==0) return(0);
  if(pch==filename) return(0);

  if (strcmp(".MP3", pch) == 0) {
 801092a:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 80109f0 <P_PlayMP3Nr+0xdc>
        sprintf(buffer, "%s/%s", akt_pfad, myfileinfo.fname);
 801092e:	4f2e      	ldr	r7, [pc, #184]	; (80109e8 <P_PlayMP3Nr+0xd4>)
 8010930:	4605      	mov	r5, r0
      fatfs_error=f_readdir(&mydir, &myfileinfo);
 8010932:	a901      	add	r1, sp, #4
 8010934:	a807      	add	r0, sp, #28
 8010936:	f7f4 ffc9 	bl	80058cc <f_readdir>
      if(fatfs_error!=FR_OK) mp3_ok=1;
 801093a:	bb38      	cbnz	r0, 801098c <P_PlayMP3Nr+0x78>
      if(myfileinfo.fname[0] == 0) mp3_ok=1;
 801093c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8010940:	b323      	cbz	r3, 801098c <P_PlayMP3Nr+0x78>
      if((myfileinfo.fattrib & AM_DIR) == 0) {
 8010942:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8010946:	f013 0410 	ands.w	r4, r3, #16
 801094a:	d1f2      	bne.n	8010932 <P_PlayMP3Nr+0x1e>
        sprintf(buffer, "%s/%s", akt_pfad, myfileinfo.fname);
 801094c:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
 8010950:	f10d 030d 	add.w	r3, sp, #13
 8010954:	4632      	mov	r2, r6
 8010956:	4639      	mov	r1, r7
 8010958:	4658      	mov	r0, fp
 801095a:	f7f1 fbe5 	bl	8002128 <sprintf>
  pch=strrchr(filename,'.');
 801095e:	4658      	mov	r0, fp
 8010960:	212e      	movs	r1, #46	; 0x2e
 8010962:	f003 fe54 	bl	801460e <strrchr>
  if(pch==0) return(0);
 8010966:	4682      	mov	sl, r0
 8010968:	2800      	cmp	r0, #0
 801096a:	d0e2      	beq.n	8010932 <P_PlayMP3Nr+0x1e>
  if(pch==filename) return(0);
 801096c:	4558      	cmp	r0, fp
 801096e:	d0e0      	beq.n	8010932 <P_PlayMP3Nr+0x1e>
  if (strcmp(".MP3", pch) == 0) {
 8010970:	4651      	mov	r1, sl
 8010972:	4640      	mov	r0, r8
 8010974:	f003 fdf2 	bl	801455c <strcmp>
 8010978:	bb28      	cbnz	r0, 80109c6 <P_PlayMP3Nr+0xb2>
          if(akt_nr==nr) {
 801097a:	454d      	cmp	r5, r9
 801097c:	d02e      	beq.n	80109dc <P_PlayMP3Nr+0xc8>
            akt_nr++;
 801097e:	3501      	adds	r5, #1
    while(mp3_ok==0);
 8010980:	2c00      	cmp	r4, #0
 8010982:	d0d6      	beq.n	8010932 <P_PlayMP3Nr+0x1e>
  if(pch==filename) return(0);
 8010984:	2001      	movs	r0, #1
}
 8010986:	b017      	add	sp, #92	; 0x5c
 8010988:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if((myfileinfo.fattrib & AM_DIR) == 0) {
 801098c:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8010990:	06db      	lsls	r3, r3, #27
 8010992:	d4f7      	bmi.n	8010984 <P_PlayMP3Nr+0x70>
        sprintf(buffer, "%s/%s", akt_pfad, myfileinfo.fname);
 8010994:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
 8010998:	f10d 030d 	add.w	r3, sp, #13
 801099c:	4632      	mov	r2, r6
 801099e:	4639      	mov	r1, r7
 80109a0:	4658      	mov	r0, fp
 80109a2:	f7f1 fbc1 	bl	8002128 <sprintf>
  pch=strrchr(filename,'.');
 80109a6:	4658      	mov	r0, fp
 80109a8:	212e      	movs	r1, #46	; 0x2e
 80109aa:	f003 fe30 	bl	801460e <strrchr>
  if(pch==0) return(0);
 80109ae:	4682      	mov	sl, r0
 80109b0:	2800      	cmp	r0, #0
 80109b2:	d0e7      	beq.n	8010984 <P_PlayMP3Nr+0x70>
  if(pch==filename) return(0);
 80109b4:	4558      	cmp	r0, fp
 80109b6:	d0e5      	beq.n	8010984 <P_PlayMP3Nr+0x70>
  if (strcmp(".MP3", pch) == 0) {
 80109b8:	4651      	mov	r1, sl
 80109ba:	4640      	mov	r0, r8
  if(pch==filename) return(0);
 80109bc:	2401      	movs	r4, #1
  if (strcmp(".MP3", pch) == 0) {
 80109be:	f003 fdcd 	bl	801455c <strcmp>
 80109c2:	2800      	cmp	r0, #0
 80109c4:	d0d9      	beq.n	801097a <P_PlayMP3Nr+0x66>
    ret_wert=1;
  }
  if (strcmp(".mp3", pch) == 0) {
 80109c6:	4651      	mov	r1, sl
 80109c8:	4808      	ldr	r0, [pc, #32]	; (80109ec <P_PlayMP3Nr+0xd8>)
 80109ca:	f003 fdc7 	bl	801455c <strcmp>
 80109ce:	2800      	cmp	r0, #0
 80109d0:	d0d3      	beq.n	801097a <P_PlayMP3Nr+0x66>
 80109d2:	e7d5      	b.n	8010980 <P_PlayMP3Nr+0x6c>
  uint32_t ret_wert=0;
 80109d4:	2000      	movs	r0, #0
}
 80109d6:	b017      	add	sp, #92	; 0x5c
 80109d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            UB_CS43L22_PlayMP3Single(buffer,60);
 80109dc:	4658      	mov	r0, fp
 80109de:	213c      	movs	r1, #60	; 0x3c
 80109e0:	f7fe ffce 	bl	800f980 <UB_CS43L22_PlayMP3Single>
 80109e4:	2000      	movs	r0, #0
 80109e6:	e7ce      	b.n	8010986 <P_PlayMP3Nr+0x72>
 80109e8:	08017abc 	.word	0x08017abc
 80109ec:	08017ab4 	.word	0x08017ab4
 80109f0:	08017aac 	.word	0x08017aac

080109f4 <UB_MP3Player_Start>:
{
 80109f4:	b510      	push	{r4, lr}
  if(UB_Fatfs_Mount(USB_0)==FATFS_OK) {
 80109f6:	2000      	movs	r0, #0
 80109f8:	f7ff fa8e 	bl	800ff18 <UB_Fatfs_Mount>
 80109fc:	b930      	cbnz	r0, 8010a0c <UB_MP3Player_Start+0x18>
 80109fe:	4604      	mov	r4, r0
    P_PlayMP3Nr(MP3_DIR_NAME,0);
 8010a00:	4601      	mov	r1, r0
 8010a02:	4803      	ldr	r0, [pc, #12]	; (8010a10 <UB_MP3Player_Start+0x1c>)
 8010a04:	f7ff ff86 	bl	8010914 <P_PlayMP3Nr>
    akt_mp3_nr=0;
 8010a08:	4b02      	ldr	r3, [pc, #8]	; (8010a14 <UB_MP3Player_Start+0x20>)
 8010a0a:	601c      	str	r4, [r3, #0]
 8010a0c:	bd10      	pop	{r4, pc}
 8010a0e:	bf00      	nop
 8010a10:	08017ab0 	.word	0x08017ab0
 8010a14:	20010340 	.word	0x20010340

08010a18 <UB_MP3Player_Do>:
{
 8010a18:	b570      	push	{r4, r5, r6, lr}
  mp3_status=UB_CS43L22_PlayMP3Do();
 8010a1a:	f7ff f8a7 	bl	800fb6c <UB_CS43L22_PlayMP3Do>
  if(mp3_status==CS43L22_STOP) {
 8010a1e:	2804      	cmp	r0, #4
 8010a20:	d011      	beq.n	8010a46 <UB_MP3Player_Do+0x2e>
  delay++;
 8010a22:	4c1c      	ldr	r4, [pc, #112]	; (8010a94 <UB_MP3Player_Do+0x7c>)
 8010a24:	6823      	ldr	r3, [r4, #0]
  if(delay>10000) {
 8010a26:	f242 7210 	movw	r2, #10000	; 0x2710
  delay++;
 8010a2a:	3301      	adds	r3, #1
  if(delay>10000) {
 8010a2c:	4293      	cmp	r3, r2
 8010a2e:	d801      	bhi.n	8010a34 <UB_MP3Player_Do+0x1c>
  delay++;
 8010a30:	6023      	str	r3, [r4, #0]
 8010a32:	bd70      	pop	{r4, r5, r6, pc}
    delay=0;
 8010a34:	2500      	movs	r5, #0
    if(UB_Button_Read(BTN_USER)==BTN_PRESSED) {
 8010a36:	4628      	mov	r0, r5
    delay=0;
 8010a38:	6025      	str	r5, [r4, #0]
    if(UB_Button_Read(BTN_USER)==BTN_PRESSED) {
 8010a3a:	f7fe fe77 	bl	800f72c <UB_Button_Read>
 8010a3e:	2801      	cmp	r0, #1
 8010a40:	d012      	beq.n	8010a68 <UB_MP3Player_Do+0x50>
      next_song=0;
 8010a42:	6065      	str	r5, [r4, #4]
 8010a44:	bd70      	pop	{r4, r5, r6, pc}
    akt_mp3_nr++;
 8010a46:	4c14      	ldr	r4, [pc, #80]	; (8010a98 <UB_MP3Player_Do+0x80>)
    check=P_PlayMP3Nr(MP3_DIR_NAME, akt_mp3_nr);
 8010a48:	4814      	ldr	r0, [pc, #80]	; (8010a9c <UB_MP3Player_Do+0x84>)
    akt_mp3_nr++;
 8010a4a:	6823      	ldr	r3, [r4, #0]
 8010a4c:	3301      	adds	r3, #1
    check=P_PlayMP3Nr(MP3_DIR_NAME, akt_mp3_nr);
 8010a4e:	4619      	mov	r1, r3
    akt_mp3_nr++;
 8010a50:	6023      	str	r3, [r4, #0]
    check=P_PlayMP3Nr(MP3_DIR_NAME, akt_mp3_nr);
 8010a52:	f7ff ff5f 	bl	8010914 <P_PlayMP3Nr>
    if(check!=0) {
 8010a56:	2800      	cmp	r0, #0
 8010a58:	d0e3      	beq.n	8010a22 <UB_MP3Player_Do+0xa>
      P_PlayMP3Nr(MP3_DIR_NAME, 0);
 8010a5a:	2100      	movs	r1, #0
 8010a5c:	480f      	ldr	r0, [pc, #60]	; (8010a9c <UB_MP3Player_Do+0x84>)
 8010a5e:	f7ff ff59 	bl	8010914 <P_PlayMP3Nr>
      akt_mp3_nr=0;
 8010a62:	2300      	movs	r3, #0
 8010a64:	6023      	str	r3, [r4, #0]
 8010a66:	e7dc      	b.n	8010a22 <UB_MP3Player_Do+0xa>
      if(next_song==0) {
 8010a68:	6865      	ldr	r5, [r4, #4]
 8010a6a:	2d00      	cmp	r5, #0
 8010a6c:	d1ea      	bne.n	8010a44 <UB_MP3Player_Do+0x2c>
        akt_mp3_nr++;
 8010a6e:	4e0a      	ldr	r6, [pc, #40]	; (8010a98 <UB_MP3Player_Do+0x80>)
        next_song=1;
 8010a70:	6060      	str	r0, [r4, #4]
        UB_CS43L22_StopMP3();
 8010a72:	f7ff f8f9 	bl	800fc68 <UB_CS43L22_StopMP3>
        akt_mp3_nr++;
 8010a76:	6833      	ldr	r3, [r6, #0]
        check=P_PlayMP3Nr(MP3_DIR_NAME, akt_mp3_nr);
 8010a78:	4808      	ldr	r0, [pc, #32]	; (8010a9c <UB_MP3Player_Do+0x84>)
        akt_mp3_nr++;
 8010a7a:	3301      	adds	r3, #1
        check=P_PlayMP3Nr(MP3_DIR_NAME, akt_mp3_nr);
 8010a7c:	4619      	mov	r1, r3
        akt_mp3_nr++;
 8010a7e:	6033      	str	r3, [r6, #0]
        check=P_PlayMP3Nr(MP3_DIR_NAME, akt_mp3_nr);
 8010a80:	f7ff ff48 	bl	8010914 <P_PlayMP3Nr>
        if(check!=0) {
 8010a84:	2800      	cmp	r0, #0
 8010a86:	d0dd      	beq.n	8010a44 <UB_MP3Player_Do+0x2c>
          P_PlayMP3Nr(MP3_DIR_NAME, 0);
 8010a88:	4629      	mov	r1, r5
 8010a8a:	4804      	ldr	r0, [pc, #16]	; (8010a9c <UB_MP3Player_Do+0x84>)
 8010a8c:	f7ff ff42 	bl	8010914 <P_PlayMP3Nr>
          akt_mp3_nr=0;
 8010a90:	6035      	str	r5, [r6, #0]
 8010a92:	bd70      	pop	{r4, r5, r6, pc}
 8010a94:	2000807c 	.word	0x2000807c
 8010a98:	20010340 	.word	0x20010340
 8010a9c:	08017ab0 	.word	0x08017ab0

08010aa0 <P_Check_File_Extension>:
{
 8010aa0:	b538      	push	{r3, r4, r5, lr}
  pch=strrchr(filename,'.');
 8010aa2:	212e      	movs	r1, #46	; 0x2e
{
 8010aa4:	4605      	mov	r5, r0
  pch=strrchr(filename,'.');
 8010aa6:	f003 fdb2 	bl	801460e <strrchr>
  if(pch==0) return(0);
 8010aaa:	4604      	mov	r4, r0
 8010aac:	b188      	cbz	r0, 8010ad2 <P_Check_File_Extension+0x32>
  if(pch==filename) return(0);
 8010aae:	4285      	cmp	r5, r0
 8010ab0:	d00f      	beq.n	8010ad2 <P_Check_File_Extension+0x32>
  if (strcmp(".MP3", pch) == 0) {
 8010ab2:	4601      	mov	r1, r0
 8010ab4:	4808      	ldr	r0, [pc, #32]	; (8010ad8 <P_Check_File_Extension+0x38>)
 8010ab6:	f003 fd51 	bl	801455c <strcmp>
  if (strcmp(".mp3", pch) == 0) {
 8010aba:	4621      	mov	r1, r4
  if (strcmp(".MP3", pch) == 0) {
 8010abc:	4605      	mov	r5, r0
  if (strcmp(".mp3", pch) == 0) {
 8010abe:	4807      	ldr	r0, [pc, #28]	; (8010adc <P_Check_File_Extension+0x3c>)
 8010ac0:	f003 fd4c 	bl	801455c <strcmp>
 8010ac4:	b908      	cbnz	r0, 8010aca <P_Check_File_Extension+0x2a>
    ret_wert=1;
 8010ac6:	2001      	movs	r0, #1
  }

  return(ret_wert);
}
 8010ac8:	bd38      	pop	{r3, r4, r5, pc}
  if (strcmp(".MP3", pch) == 0) {
 8010aca:	fab5 f085 	clz	r0, r5
 8010ace:	0940      	lsrs	r0, r0, #5
 8010ad0:	bd38      	pop	{r3, r4, r5, pc}
  if(pch==0) return(0);
 8010ad2:	2000      	movs	r0, #0
 8010ad4:	bd38      	pop	{r3, r4, r5, pc}
 8010ad6:	bf00      	nop
 8010ad8:	08017aac 	.word	0x08017aac
 8010adc:	08017ab4 	.word	0x08017ab4

08010ae0 <UB_USB_MSC_HOST_Init>:
//--------------------------------------------------------------
// Init vom USB-OTG-Port als MSC-HOST
// (Host fr Wechseldatentrger z.B. USB-Stick)
//--------------------------------------------------------------
void UB_USB_MSC_HOST_Init(void)
{
 8010ae0:	b530      	push	{r4, r5, lr}
 8010ae2:	b083      	sub	sp, #12
  USB_MSC_HOST_STATUS=USB_MSC_DEV_DETACHED;
 8010ae4:	2401      	movs	r4, #1
 8010ae6:	4d06      	ldr	r5, [pc, #24]	; (8010b00 <UB_USB_MSC_HOST_Init+0x20>)
  USBH_Init(&USB_OTG_Core, USB_OTG_FS_CORE_ID, &USB_Host, &USBH_MSC_cb, &USR_Callbacks);
 8010ae8:	4b06      	ldr	r3, [pc, #24]	; (8010b04 <UB_USB_MSC_HOST_Init+0x24>)
 8010aea:	9300      	str	r3, [sp, #0]
 8010aec:	4621      	mov	r1, r4
 8010aee:	4b06      	ldr	r3, [pc, #24]	; (8010b08 <UB_USB_MSC_HOST_Init+0x28>)
 8010af0:	4a06      	ldr	r2, [pc, #24]	; (8010b0c <UB_USB_MSC_HOST_Init+0x2c>)
 8010af2:	4807      	ldr	r0, [pc, #28]	; (8010b10 <UB_USB_MSC_HOST_Init+0x30>)
  USB_MSC_HOST_STATUS=USB_MSC_DEV_DETACHED;
 8010af4:	702c      	strb	r4, [r5, #0]
  USBH_Init(&USB_OTG_Core, USB_OTG_FS_CORE_ID, &USB_Host, &USBH_MSC_cb, &USR_Callbacks);
 8010af6:	f002 f9c5 	bl	8012e84 <USBH_Init>
}
 8010afa:	b003      	add	sp, #12
 8010afc:	bd30      	pop	{r4, r5, pc}
 8010afe:	bf00      	nop
 8010b00:	20008098 	.word	0x20008098
 8010b04:	200000dc 	.word	0x200000dc
 8010b08:	200000c8 	.word	0x200000c8
 8010b0c:	200107f4 	.word	0x200107f4
 8010b10:	20010344 	.word	0x20010344

08010b14 <UB_USB_MSC_HOST_Do>:
// Hinweis : falls "USB_MSC_DEV_NOT_SUPPORTED" muss die
//           Init Procedure wiederholt werden
//           (bzw ein anderer USB-Stick benutzt werden)
//--------------------------------------------------------------
USB_MSC_HOST_STATUS_t UB_USB_MSC_HOST_Do(void)
{
 8010b14:	b510      	push	{r4, lr}

  if(USB_MSC_HOST_STATUS!=USB_MSC_DEV_NOT_SUPPORTED) {
 8010b16:	4c05      	ldr	r4, [pc, #20]	; (8010b2c <UB_USB_MSC_HOST_Do+0x18>)
 8010b18:	7820      	ldrb	r0, [r4, #0]
 8010b1a:	2803      	cmp	r0, #3
 8010b1c:	d004      	beq.n	8010b28 <UB_USB_MSC_HOST_Do+0x14>
    // wenn der USB-Stick nicht untersttzt wird,
    // wird die Funktion nicht mehr aufgerufen
    // damit die Software nicht hngenbleibt
    USBH_Process(&USB_OTG_Core, &USB_Host);
 8010b1e:	4804      	ldr	r0, [pc, #16]	; (8010b30 <UB_USB_MSC_HOST_Do+0x1c>)
 8010b20:	4904      	ldr	r1, [pc, #16]	; (8010b34 <UB_USB_MSC_HOST_Do+0x20>)
 8010b22:	f002 fafb 	bl	801311c <USBH_Process>
 8010b26:	7820      	ldrb	r0, [r4, #0]
  }

  return(USB_MSC_HOST_STATUS);
}
 8010b28:	bd10      	pop	{r4, pc}
 8010b2a:	bf00      	nop
 8010b2c:	20008098 	.word	0x20008098
 8010b30:	20010344 	.word	0x20010344
 8010b34:	200107f4 	.word	0x200107f4

08010b38 <USB_OTG_BSP_Init>:



//--------------------------------------------------------------
void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 8010b38:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStructure;

  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
 8010b3a:	2101      	movs	r1, #1
  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 8010b3c:	4c1b      	ldr	r4, [pc, #108]	; (8010bac <USB_OTG_BSP_Init+0x74>)
{
 8010b3e:	b083      	sub	sp, #12
  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
 8010b40:	4608      	mov	r0, r1
 8010b42:	f7f0 fab9 	bl	80010b8 <RCC_AHB1PeriphClockCmd>
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8010b46:	f240 3302 	movw	r3, #770	; 0x302
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 8010b4a:	4620      	mov	r0, r4
 8010b4c:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8010b4e:	f44f 52d0 	mov.w	r2, #6656	; 0x1a00
 8010b52:	e88d 000c 	stmia.w	sp, {r2, r3}
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 8010b56:	f7ef fe95 	bl	8000884 <GPIO_Init>
  
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ; 
 8010b5a:	4620      	mov	r0, r4
 8010b5c:	220a      	movs	r2, #10
 8010b5e:	2109      	movs	r1, #9
 8010b60:	f7ef ff20 	bl	80009a4 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ; 
 8010b64:	4620      	mov	r0, r4
 8010b66:	220a      	movs	r2, #10
 8010b68:	210b      	movs	r1, #11
 8010b6a:	f7ef ff1b 	bl	80009a4 <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 8010b6e:	4620      	mov	r0, r4
 8010b70:	220a      	movs	r2, #10
 8010b72:	210c      	movs	r1, #12
 8010b74:	f7ef ff16 	bl	80009a4 <GPIO_PinAFConfig>
  
  /* this for ID line debug */
  
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8010b78:	2501      	movs	r5, #1
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8010b7a:	2303      	movs	r3, #3
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 8010b7c:	4669      	mov	r1, sp
 8010b7e:	4620      	mov	r0, r4
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 8010b80:	f44f 6280 	mov.w	r2, #1024	; 0x400
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8010b84:	f88d 3005 	strb.w	r3, [sp, #5]
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 8010b88:	9200      	str	r2, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8010b8a:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
 8010b8e:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_Init(GPIOA, &GPIO_InitStructure);  
 8010b92:	f7ef fe77 	bl	8000884 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;   
 8010b96:	220a      	movs	r2, #10
 8010b98:	4611      	mov	r1, r2
 8010b9a:	4620      	mov	r0, r4
 8010b9c:	f7ef ff02 	bl	80009a4 <GPIO_PinAFConfig>


  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ; 
 8010ba0:	4629      	mov	r1, r5
 8010ba2:	2080      	movs	r0, #128	; 0x80
 8010ba4:	f7f0 fa94 	bl	80010d0 <RCC_AHB2PeriphClockCmd>
}
 8010ba8:	b003      	add	sp, #12
 8010baa:	bd30      	pop	{r4, r5, pc}
 8010bac:	40020000 	.word	0x40020000

08010bb0 <USB_OTG_BSP_EnableInterrupt>:

//--------------------------------------------------------------
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 8010bb0:	b500      	push	{lr}

  NVIC_InitTypeDef NVIC_InitStructure;
  /* Enable USB Interrupt */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8010bb2:	f44f 60c0 	mov.w	r0, #1536	; 0x600
{
 8010bb6:	b083      	sub	sp, #12
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8010bb8:	f7ef fbb8 	bl	800032c <NVIC_PriorityGroupConfig>

  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
 8010bbc:	a802      	add	r0, sp, #8
 8010bbe:	4b04      	ldr	r3, [pc, #16]	; (8010bd0 <USB_OTG_BSP_EnableInterrupt+0x20>)
 8010bc0:	f840 3d04 	str.w	r3, [r0, #-4]!
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 8010bc4:	f7ef fbbc 	bl	8000340 <NVIC_Init>
}
 8010bc8:	b003      	add	sp, #12
 8010bca:	f85d fb04 	ldr.w	pc, [sp], #4
 8010bce:	bf00      	nop
 8010bd0:	01010143 	.word	0x01010143

08010bd4 <USB_OTG_BSP_DriveVBUS>:

//--------------------------------------------------------------
void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev, uint8_t state)
{

  if (0 == state)
 8010bd4:	b119      	cbz	r1, 8010bde <USB_OTG_BSP_DriveVBUS+0xa>
    GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
  }
  else
  {
    /*ENABLE the Power Switch by driving the Enable LOW */
    GPIO_ResetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 8010bd6:	2101      	movs	r1, #1
 8010bd8:	4803      	ldr	r0, [pc, #12]	; (8010be8 <USB_OTG_BSP_DriveVBUS+0x14>)
 8010bda:	f7ef bed5 	b.w	8000988 <GPIO_ResetBits>
    GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 8010bde:	2101      	movs	r1, #1
 8010be0:	4801      	ldr	r0, [pc, #4]	; (8010be8 <USB_OTG_BSP_DriveVBUS+0x14>)
 8010be2:	f7ef becf 	b.w	8000984 <GPIO_SetBits>
 8010be6:	bf00      	nop
 8010be8:	40020800 	.word	0x40020800

08010bec <USB_OTG_BSP_ConfigVBUS>:
  }
}

//--------------------------------------------------------------
void  USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev)
{
 8010bec:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStructure; 
 
  RCC_AHB1PeriphClockCmd(HOST_POWERSW_PORT_RCC , ENABLE);  
 8010bee:	2101      	movs	r1, #1
{
 8010bf0:	b084      	sub	sp, #16
  RCC_AHB1PeriphClockCmd(HOST_POWERSW_PORT_RCC , ENABLE);  
 8010bf2:	2004      	movs	r0, #4
 8010bf4:	f7f0 fa60 	bl	80010b8 <RCC_AHB1PeriphClockCmd>
  
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
 8010bf8:	2401      	movs	r4, #1
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8010bfa:	f240 3301 	movw	r3, #769	; 0x301
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(HOST_POWERSW_PORT,&GPIO_InitStructure);
 8010bfe:	a902      	add	r1, sp, #8
 8010c00:	4809      	ldr	r0, [pc, #36]	; (8010c28 <USB_OTG_BSP_ConfigVBUS+0x3c>)
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8010c02:	9303      	str	r3, [sp, #12]
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
 8010c04:	9402      	str	r4, [sp, #8]
  GPIO_Init(HOST_POWERSW_PORT,&GPIO_InitStructure);
 8010c06:	f7ef fe3d 	bl	8000884 <GPIO_Init>

  /* By Default, DISABLE is needed on output of the Power Switch */
  GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 8010c0a:	4621      	mov	r1, r4
 8010c0c:	4806      	ldr	r0, [pc, #24]	; (8010c28 <USB_OTG_BSP_ConfigVBUS+0x3c>)
 8010c0e:	f7ef feb9 	bl	8000984 <GPIO_SetBits>


//--------------------------------------------------------------
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
  __IO uint32_t count = 0;
 8010c12:	2300      	movs	r3, #0
  const uint32_t utime = (120 * usec / 7);
  do
  {
    if ( ++count > utime )
 8010c14:	4a05      	ldr	r2, [pc, #20]	; (8010c2c <USB_OTG_BSP_ConfigVBUS+0x40>)
  __IO uint32_t count = 0;
 8010c16:	9301      	str	r3, [sp, #4]
    if ( ++count > utime )
 8010c18:	9b01      	ldr	r3, [sp, #4]
 8010c1a:	3301      	adds	r3, #1
 8010c1c:	4293      	cmp	r3, r2
 8010c1e:	9301      	str	r3, [sp, #4]
 8010c20:	d9fa      	bls.n	8010c18 <USB_OTG_BSP_ConfigVBUS+0x2c>
}
 8010c22:	b004      	add	sp, #16
 8010c24:	bd10      	pop	{r4, pc}
 8010c26:	bf00      	nop
 8010c28:	40020800 	.word	0x40020800
 8010c2c:	003450db 	.word	0x003450db

08010c30 <USB_OTG_BSP_uDelay>:
  const uint32_t utime = (120 * usec / 7);
 8010c30:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8010c34:	4a08      	ldr	r2, [pc, #32]	; (8010c58 <USB_OTG_BSP_uDelay+0x28>)
 8010c36:	00c0      	lsls	r0, r0, #3
 8010c38:	fba2 3200 	umull	r3, r2, r2, r0
{
 8010c3c:	b082      	sub	sp, #8
  const uint32_t utime = (120 * usec / 7);
 8010c3e:	1a80      	subs	r0, r0, r2
 8010c40:	eb02 0250 	add.w	r2, r2, r0, lsr #1
  __IO uint32_t count = 0;
 8010c44:	2300      	movs	r3, #0
  const uint32_t utime = (120 * usec / 7);
 8010c46:	0892      	lsrs	r2, r2, #2
  __IO uint32_t count = 0;
 8010c48:	9301      	str	r3, [sp, #4]
    if ( ++count > utime )
 8010c4a:	9b01      	ldr	r3, [sp, #4]
 8010c4c:	3301      	adds	r3, #1
 8010c4e:	429a      	cmp	r2, r3
 8010c50:	9301      	str	r3, [sp, #4]
 8010c52:	d2fa      	bcs.n	8010c4a <USB_OTG_BSP_uDelay+0x1a>
      return ;
    }
  }
  while (1);

}
 8010c54:	b002      	add	sp, #8
 8010c56:	4770      	bx	lr
 8010c58:	24924925 	.word	0x24924925

08010c5c <USB_OTG_BSP_mDelay>:
  const uint32_t utime = (120 * usec / 7);
 8010c5c:	4b09      	ldr	r3, [pc, #36]	; (8010c84 <USB_OTG_BSP_mDelay+0x28>)
 8010c5e:	4a0a      	ldr	r2, [pc, #40]	; (8010c88 <USB_OTG_BSP_mDelay+0x2c>)
 8010c60:	fb03 f000 	mul.w	r0, r3, r0
 8010c64:	fba2 3200 	umull	r3, r2, r2, r0

//--------------------------------------------------------------
void USB_OTG_BSP_mDelay (const uint32_t msec)
{
 8010c68:	b082      	sub	sp, #8
  const uint32_t utime = (120 * usec / 7);
 8010c6a:	1a80      	subs	r0, r0, r2
 8010c6c:	eb02 0250 	add.w	r2, r2, r0, lsr #1
  __IO uint32_t count = 0;
 8010c70:	2300      	movs	r3, #0
  const uint32_t utime = (120 * usec / 7);
 8010c72:	0892      	lsrs	r2, r2, #2
  __IO uint32_t count = 0;
 8010c74:	9301      	str	r3, [sp, #4]
    if ( ++count > utime )
 8010c76:	9b01      	ldr	r3, [sp, #4]
 8010c78:	3301      	adds	r3, #1
 8010c7a:	429a      	cmp	r2, r3
 8010c7c:	9301      	str	r3, [sp, #4]
 8010c7e:	d2fa      	bcs.n	8010c76 <USB_OTG_BSP_mDelay+0x1a>
  USB_OTG_BSP_uDelay(msec * 1000);
}
 8010c80:	b002      	add	sp, #8
 8010c82:	4770      	bx	lr
 8010c84:	0001d4c0 	.word	0x0001d4c0
 8010c88:	24924925 	.word	0x24924925

08010c8c <OTG_FS_IRQHandler>:


//--------------------------------------------------------------
void OTG_FS_IRQHandler(void)
{
  USBH_OTG_ISR_Handler(&USB_OTG_Core);
 8010c8c:	4801      	ldr	r0, [pc, #4]	; (8010c94 <OTG_FS_IRQHandler+0x8>)
 8010c8e:	f000 bf73 	b.w	8011b78 <USBH_OTG_ISR_Handler>
 8010c92:	bf00      	nop
 8010c94:	20010344 	.word	0x20010344

08010c98 <USB_OTG_WritePacket>:
//--------------------------------------------------------------
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 8010c98:	b430      	push	{r4, r5}
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8010c9a:	78c4      	ldrb	r4, [r0, #3]
 8010c9c:	b96c      	cbnz	r4, 8010cba <USB_OTG_WritePacket+0x22>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8010c9e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    count32b =  (len + 3) / 4;
 8010ca2:	1cd8      	adds	r0, r3, #3
    for (i = 0; i < count32b; i++, src+=4)
 8010ca4:	1080      	asrs	r0, r0, #2
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8010ca6:	f8d2 50d0 	ldr.w	r5, [r2, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 8010caa:	d006      	beq.n	8010cba <USB_OTG_WritePacket+0x22>
 8010cac:	4623      	mov	r3, r4
 8010cae:	3301      	adds	r3, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8010cb0:	f851 2b04 	ldr.w	r2, [r1], #4
 8010cb4:	602a      	str	r2, [r5, #0]
    for (i = 0; i < count32b; i++, src+=4)
 8010cb6:	4298      	cmp	r0, r3
 8010cb8:	d1f9      	bne.n	8010cae <USB_OTG_WritePacket+0x16>
    }
  }
  return status;
}
 8010cba:	2000      	movs	r0, #0
 8010cbc:	bc30      	pop	{r4, r5}
 8010cbe:	4770      	bx	lr

08010cc0 <USB_OTG_ReadPacket>:
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8010cc0:	3203      	adds	r2, #3
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8010cc2:	1092      	asrs	r2, r2, #2
{
 8010cc4:	b430      	push	{r4, r5}
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8010cc6:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
  for ( i = 0; i < count32b; i++, dest += 4 )
 8010cca:	d009      	beq.n	8010ce0 <USB_OTG_ReadPacket+0x20>
 8010ccc:	4608      	mov	r0, r1
 8010cce:	2300      	movs	r3, #0
 8010cd0:	3301      	adds	r3, #1
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8010cd2:	682c      	ldr	r4, [r5, #0]
 8010cd4:	f840 4b04 	str.w	r4, [r0], #4
  for ( i = 0; i < count32b; i++, dest += 4 )
 8010cd8:	429a      	cmp	r2, r3
 8010cda:	d1f9      	bne.n	8010cd0 <USB_OTG_ReadPacket+0x10>
 8010cdc:	eb01 0182 	add.w	r1, r1, r2, lsl #2
    
  }
  return ((void *)dest);
}
 8010ce0:	4608      	mov	r0, r1
 8010ce2:	bc30      	pop	{r4, r5}
 8010ce4:	4770      	bx	lr
 8010ce6:	bf00      	nop

08010ce8 <USB_OTG_SelectCore>:

//--------------------------------------------------------------
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 8010ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8010cea:	2401      	movs	r4, #1
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8010cec:	2240      	movs	r2, #64	; 0x40
  pdev->cfg.dma_enable       = 0;
 8010cee:	2300      	movs	r3, #0
    
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8010cf0:	42a1      	cmp	r1, r4
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8010cf2:	7084      	strb	r4, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8010cf4:	8082      	strh	r2, [r0, #4]
  pdev->cfg.dma_enable       = 0;
 8010cf6:	70c3      	strb	r3, [r0, #3]
  if (coreID == USB_OTG_FS_CORE_ID)
 8010cf8:	f000 8165 	beq.w	8010fc6 <USB_OTG_SelectCore+0x2de>
    


    
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 8010cfc:	2900      	cmp	r1, #0
 8010cfe:	f000 814f 	beq.w	8010fa0 <USB_OTG_SelectCore+0x2b8>
 8010d02:	7842      	ldrb	r2, [r0, #1]
    pdev->cfg.dev_endpoints    = 6 ;
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8010d04:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8010d06:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8010d0a:	6101      	str	r1, [r0, #16]
 8010d0c:	7806      	ldrb	r6, [r0, #0]
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d0e:	2a00      	cmp	r2, #0
 8010d10:	f000 816c 	beq.w	8010fec <USB_OTG_SelectCore+0x304>
 8010d14:	f44f 6760 	mov.w	r7, #3584	; 0xe00
 8010d18:	f44f 6488 	mov.w	r4, #1088	; 0x440
 8010d1c:	f44f 6180 	mov.w	r1, #1024	; 0x400
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d20:	f503 6e10 	add.w	lr, r3, #2304	; 0x900
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010d24:	f503 6530 	add.w	r5, r3, #2816	; 0xb00
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d28:	2a01      	cmp	r2, #1
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010d2a:	f8c0 e018 	str.w	lr, [r0, #24]
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010d2e:	6545      	str	r5, [r0, #84]	; 0x54
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d30:	d07e      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d32:	f503 6e12 	add.w	lr, r3, #2336	; 0x920
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010d36:	f503 6532 	add.w	r5, r3, #2848	; 0xb20
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d3a:	2a02      	cmp	r2, #2
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010d3c:	f8c0 e01c 	str.w	lr, [r0, #28]
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010d40:	6585      	str	r5, [r0, #88]	; 0x58
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d42:	d075      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d44:	f503 6e14 	add.w	lr, r3, #2368	; 0x940
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010d48:	f503 6534 	add.w	r5, r3, #2880	; 0xb40
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d4c:	2a03      	cmp	r2, #3
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010d4e:	f8c0 e020 	str.w	lr, [r0, #32]
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010d52:	65c5      	str	r5, [r0, #92]	; 0x5c
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d54:	d06c      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d56:	f503 6e16 	add.w	lr, r3, #2400	; 0x960
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010d5a:	f503 6536 	add.w	r5, r3, #2912	; 0xb60
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d5e:	2a04      	cmp	r2, #4
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010d60:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010d64:	6605      	str	r5, [r0, #96]	; 0x60
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d66:	d063      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d68:	f503 6e18 	add.w	lr, r3, #2432	; 0x980
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010d6c:	f503 6538 	add.w	r5, r3, #2944	; 0xb80
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d70:	2a05      	cmp	r2, #5
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010d72:	f8c0 e028 	str.w	lr, [r0, #40]	; 0x28
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010d76:	6645      	str	r5, [r0, #100]	; 0x64
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d78:	d05a      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d7a:	f503 6e1a 	add.w	lr, r3, #2464	; 0x9a0
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010d7e:	f503 653a 	add.w	r5, r3, #2976	; 0xba0
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d82:	2a06      	cmp	r2, #6
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010d84:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010d88:	6685      	str	r5, [r0, #104]	; 0x68
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d8a:	d051      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d8c:	f503 6e1c 	add.w	lr, r3, #2496	; 0x9c0
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010d90:	f503 653c 	add.w	r5, r3, #3008	; 0xbc0
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d94:	2a07      	cmp	r2, #7
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010d96:	f8c0 e030 	str.w	lr, [r0, #48]	; 0x30
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010d9a:	66c5      	str	r5, [r0, #108]	; 0x6c
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010d9c:	d048      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010d9e:	f503 6e1e 	add.w	lr, r3, #2528	; 0x9e0
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010da2:	f503 653e 	add.w	r5, r3, #3040	; 0xbe0
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010da6:	2a08      	cmp	r2, #8
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010da8:	f8c0 e034 	str.w	lr, [r0, #52]	; 0x34
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010dac:	6705      	str	r5, [r0, #112]	; 0x70
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010dae:	d03f      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010db0:	f503 6e20 	add.w	lr, r3, #2560	; 0xa00
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010db4:	f503 6540 	add.w	r5, r3, #3072	; 0xc00
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010db8:	2a09      	cmp	r2, #9
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010dba:	f8c0 e038 	str.w	lr, [r0, #56]	; 0x38
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010dbe:	6745      	str	r5, [r0, #116]	; 0x74
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010dc0:	d036      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010dc2:	f503 6e22 	add.w	lr, r3, #2592	; 0xa20
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010dc6:	f503 6542 	add.w	r5, r3, #3104	; 0xc20
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010dca:	2a0a      	cmp	r2, #10
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010dcc:	f8c0 e03c 	str.w	lr, [r0, #60]	; 0x3c
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010dd0:	6785      	str	r5, [r0, #120]	; 0x78
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010dd2:	d02d      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010dd4:	f503 6e24 	add.w	lr, r3, #2624	; 0xa40
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010dd8:	f503 6544 	add.w	r5, r3, #3136	; 0xc40
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010ddc:	2a0b      	cmp	r2, #11
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010dde:	f8c0 e040 	str.w	lr, [r0, #64]	; 0x40
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010de2:	67c5      	str	r5, [r0, #124]	; 0x7c
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010de4:	d024      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010de6:	f503 6e26 	add.w	lr, r3, #2656	; 0xa60
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010dea:	f503 6546 	add.w	r5, r3, #3168	; 0xc60
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010dee:	2a0c      	cmp	r2, #12
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010df0:	f8c0 e044 	str.w	lr, [r0, #68]	; 0x44
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010df4:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010df8:	d01a      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010dfa:	f503 6e28 	add.w	lr, r3, #2688	; 0xa80
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010dfe:	f503 6548 	add.w	r5, r3, #3200	; 0xc80
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010e02:	2a0d      	cmp	r2, #13
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010e04:	f8c0 e048 	str.w	lr, [r0, #72]	; 0x48
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010e08:	f8c0 5084 	str.w	r5, [r0, #132]	; 0x84
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010e0c:	d010      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010e0e:	f503 6e2a 	add.w	lr, r3, #2720	; 0xaa0
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010e12:	f503 654a 	add.w	r5, r3, #3232	; 0xca0
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010e16:	2a0e      	cmp	r2, #14
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010e18:	f8c0 e04c 	str.w	lr, [r0, #76]	; 0x4c
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010e1c:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010e20:	d006      	beq.n	8010e30 <USB_OTG_SelectCore+0x148>
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
 8010e22:	f503 652c 	add.w	r5, r3, #2752	; 0xac0
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
 8010e26:	f503 624c 	add.w	r2, r3, #3264	; 0xcc0
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8010e2a:	6505      	str	r5, [r0, #80]	; 0x50
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8010e2c:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 8010e30:	6141      	str	r1, [r0, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 8010e32:	f8c0 40cc 	str.w	r4, [r0, #204]	; 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e36:	2e00      	cmp	r6, #0
 8010e38:	f000 80ae 	beq.w	8010f98 <USB_OTG_SelectCore+0x2b0>
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e3c:	f503 62a0 	add.w	r2, r3, #1280	; 0x500
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e40:	2e01      	cmp	r6, #1
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e42:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e46:	f000 80e2 	beq.w	801100e <USB_OTG_SelectCore+0x326>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010e4a:	f503 62a4 	add.w	r2, r3, #1312	; 0x520
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e4e:	2e02      	cmp	r6, #2
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e50:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e54:	f000 80d2 	beq.w	8010ffc <USB_OTG_SelectCore+0x314>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010e58:	f503 62a8 	add.w	r2, r3, #1344	; 0x540
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e5c:	2e03      	cmp	r6, #3
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e5e:	f8c0 2098 	str.w	r2, [r0, #152]	; 0x98
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e62:	d045      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010e64:	f503 62ac 	add.w	r2, r3, #1376	; 0x560
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e68:	2e04      	cmp	r6, #4
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e6a:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e6e:	d03f      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010e70:	f503 62b0 	add.w	r2, r3, #1408	; 0x580
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e74:	2e05      	cmp	r6, #5
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e76:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e7a:	d039      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010e7c:	f503 62b4 	add.w	r2, r3, #1440	; 0x5a0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e80:	2e06      	cmp	r6, #6
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e82:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e86:	d033      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010e88:	f503 62b8 	add.w	r2, r3, #1472	; 0x5c0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e8c:	2e07      	cmp	r6, #7
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e8e:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e92:	d02d      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010e94:	f503 62bc 	add.w	r2, r3, #1504	; 0x5e0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e98:	2e08      	cmp	r6, #8
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010e9a:	f8c0 20ac 	str.w	r2, [r0, #172]	; 0xac
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010e9e:	d027      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010ea0:	f503 62c0 	add.w	r2, r3, #1536	; 0x600
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ea4:	2e09      	cmp	r6, #9
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010ea6:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010eaa:	d021      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010eac:	f503 62c4 	add.w	r2, r3, #1568	; 0x620
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010eb0:	2e0a      	cmp	r6, #10
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010eb2:	f8c0 20b4 	str.w	r2, [r0, #180]	; 0xb4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010eb6:	d01b      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010eb8:	f503 62c8 	add.w	r2, r3, #1600	; 0x640
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ebc:	2e0b      	cmp	r6, #11
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010ebe:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ec2:	d015      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010ec4:	f503 62cc 	add.w	r2, r3, #1632	; 0x660
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ec8:	2e0c      	cmp	r6, #12
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010eca:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ece:	d00f      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010ed0:	f503 62d0 	add.w	r2, r3, #1664	; 0x680
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ed4:	2e0d      	cmp	r6, #13
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010ed6:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010eda:	d009      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010edc:	f503 62d4 	add.w	r2, r3, #1696	; 0x6a0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ee0:	2e0e      	cmp	r6, #14
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010ee2:	f8c0 20c4 	str.w	r2, [r0, #196]	; 0xc4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010ee6:	d003      	beq.n	8010ef0 <USB_OTG_SelectCore+0x208>
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
 8010ee8:	f503 62d8 	add.w	r2, r3, #1728	; 0x6c0
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8010eec:	f8c0 20c8 	str.w	r2, [r0, #200]	; 0xc8
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010ef0:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
 8010ef4:	f503 5100 	add.w	r1, r3, #8192	; 0x2000
 8010ef8:	f503 5240 	add.w	r2, r3, #12288	; 0x3000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010efc:	2e03      	cmp	r6, #3
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010efe:	f8c0 40d0 	str.w	r4, [r0, #208]	; 0xd0
 8010f02:	f8c0 10d4 	str.w	r1, [r0, #212]	; 0xd4
 8010f06:	f8c0 20d8 	str.w	r2, [r0, #216]	; 0xd8
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f0a:	d045      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f0c:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f10:	2e04      	cmp	r6, #4
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f12:	f8c0 20dc 	str.w	r2, [r0, #220]	; 0xdc
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f16:	d03f      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f18:	f503 42a0 	add.w	r2, r3, #20480	; 0x5000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f1c:	2e05      	cmp	r6, #5
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f1e:	f8c0 20e0 	str.w	r2, [r0, #224]	; 0xe0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f22:	d039      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f24:	f503 42c0 	add.w	r2, r3, #24576	; 0x6000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f28:	2e06      	cmp	r6, #6
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f2a:	f8c0 20e4 	str.w	r2, [r0, #228]	; 0xe4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f2e:	d033      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f30:	f503 42e0 	add.w	r2, r3, #28672	; 0x7000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f34:	2e07      	cmp	r6, #7
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f36:	f8c0 20e8 	str.w	r2, [r0, #232]	; 0xe8
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f3a:	d02d      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f3c:	f503 4200 	add.w	r2, r3, #32768	; 0x8000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f40:	2e08      	cmp	r6, #8
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f42:	f8c0 20ec 	str.w	r2, [r0, #236]	; 0xec
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f46:	d027      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f48:	f503 4210 	add.w	r2, r3, #36864	; 0x9000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f4c:	2e09      	cmp	r6, #9
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f4e:	f8c0 20f0 	str.w	r2, [r0, #240]	; 0xf0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f52:	d021      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f54:	f503 4220 	add.w	r2, r3, #40960	; 0xa000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f58:	2e0a      	cmp	r6, #10
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f5a:	f8c0 20f4 	str.w	r2, [r0, #244]	; 0xf4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f5e:	d01b      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f60:	f503 4230 	add.w	r2, r3, #45056	; 0xb000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f64:	2e0b      	cmp	r6, #11
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f66:	f8c0 20f8 	str.w	r2, [r0, #248]	; 0xf8
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f6a:	d015      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f6c:	f503 4240 	add.w	r2, r3, #49152	; 0xc000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f70:	2e0c      	cmp	r6, #12
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f72:	f8c0 20fc 	str.w	r2, [r0, #252]	; 0xfc
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f76:	d00f      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f78:	f503 4250 	add.w	r2, r3, #53248	; 0xd000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f7c:	2e0d      	cmp	r6, #13
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f7e:	f8c0 2100 	str.w	r2, [r0, #256]	; 0x100
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f82:	d009      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f84:	f503 4260 	add.w	r2, r3, #57344	; 0xe000
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f88:	2e0e      	cmp	r6, #14
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f8a:	f8c0 2104 	str.w	r2, [r0, #260]	; 0x104
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8010f8e:	d003      	beq.n	8010f98 <USB_OTG_SelectCore+0x2b0>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010f90:	f503 4370 	add.w	r3, r3, #61440	; 0xf000
 8010f94:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 8010f98:	f8c0 710c 	str.w	r7, [r0, #268]	; 0x10c
  
  return status;
}
 8010f9c:	2000      	movs	r0, #0
 8010f9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8010fa0:	4d1d      	ldr	r5, [pc, #116]	; (8011018 <USB_OTG_SelectCore+0x330>)
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 8010fa2:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8010fa4:	f44f 61a0 	mov.w	r1, #1280	; 0x500
    pdev->cfg.host_channels    = 12 ;
 8010fa8:	260c      	movs	r6, #12
    pdev->cfg.dev_endpoints    = 6 ;
 8010faa:	2206      	movs	r2, #6
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8010fac:	80c1      	strh	r1, [r0, #6]
 8010fae:	4f1b      	ldr	r7, [pc, #108]	; (801101c <USB_OTG_SelectCore+0x334>)
 8010fb0:	4c1b      	ldr	r4, [pc, #108]	; (8011020 <USB_OTG_SelectCore+0x338>)
 8010fb2:	491c      	ldr	r1, [pc, #112]	; (8011024 <USB_OTG_SelectCore+0x33c>)
 8010fb4:	f8df e07c 	ldr.w	lr, [pc, #124]	; 8011034 <USB_OTG_SelectCore+0x34c>
    pdev->cfg.host_channels    = 12 ;
 8010fb8:	7006      	strb	r6, [r0, #0]
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8010fba:	462b      	mov	r3, r5
    pdev->cfg.dev_endpoints    = 6 ;
 8010fbc:	7042      	strb	r2, [r0, #1]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8010fbe:	60c5      	str	r5, [r0, #12]
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8010fc0:	f8c0 e010 	str.w	lr, [r0, #16]
 8010fc4:	e6ac      	b.n	8010d20 <USB_OTG_SelectCore+0x38>
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8010fc6:	f44f 74a0 	mov.w	r4, #320	; 0x140
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8010fca:	2302      	movs	r3, #2
    pdev->cfg.host_channels    = 8 ;
 8010fcc:	2608      	movs	r6, #8
    pdev->cfg.dev_endpoints    = 4 ;
 8010fce:	2204      	movs	r2, #4
 8010fd0:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 8010fd4:	72c1      	strb	r1, [r0, #11]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8010fd6:	80c4      	strh	r4, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8010fd8:	7203      	strb	r3, [r0, #8]
    pdev->cfg.host_channels    = 8 ;
 8010fda:	7006      	strb	r6, [r0, #0]
    pdev->cfg.dev_endpoints    = 4 ;
 8010fdc:	7042      	strb	r2, [r0, #1]
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 8010fde:	462b      	mov	r3, r5
 8010fe0:	4f11      	ldr	r7, [pc, #68]	; (8011028 <USB_OTG_SelectCore+0x340>)
 8010fe2:	4c12      	ldr	r4, [pc, #72]	; (801102c <USB_OTG_SelectCore+0x344>)
 8010fe4:	4912      	ldr	r1, [pc, #72]	; (8011030 <USB_OTG_SelectCore+0x348>)
 8010fe6:	f8df e050 	ldr.w	lr, [pc, #80]	; 8011038 <USB_OTG_SelectCore+0x350>
 8010fea:	e7e8      	b.n	8010fbe <USB_OTG_SelectCore+0x2d6>
  uint32_t i , baseAddress = 0;
 8010fec:	4613      	mov	r3, r2
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8010fee:	f44f 6760 	mov.w	r7, #3584	; 0xe00
 8010ff2:	f44f 6488 	mov.w	r4, #1088	; 0x440
 8010ff6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8010ffa:	e719      	b.n	8010e30 <USB_OTG_SelectCore+0x148>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8010ffc:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8011000:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8011004:	f8c0 20d0 	str.w	r2, [r0, #208]	; 0xd0
 8011008:	f8c0 30d4 	str.w	r3, [r0, #212]	; 0xd4
 801100c:	e7c4      	b.n	8010f98 <USB_OTG_SelectCore+0x2b0>
 801100e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8011012:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
 8011016:	e7bf      	b.n	8010f98 <USB_OTG_SelectCore+0x2b0>
 8011018:	40040000 	.word	0x40040000
 801101c:	40040e00 	.word	0x40040e00
 8011020:	40040440 	.word	0x40040440
 8011024:	40040400 	.word	0x40040400
 8011028:	50000e00 	.word	0x50000e00
 801102c:	50000440 	.word	0x50000440
 8011030:	50000400 	.word	0x50000400
 8011034:	40040800 	.word	0x40040800
 8011038:	50000800 	.word	0x50000800

0801103c <USB_OTG_CoreInit>:


//--------------------------------------------------------------
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 801103c:	b570      	push	{r4, r5, r6, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  

  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 801103e:	7a03      	ldrb	r3, [r0, #8]
 8011040:	2b01      	cmp	r3, #1
{
 8011042:	b082      	sub	sp, #8
 8011044:	4605      	mov	r5, r0
  gccfg.d32 = 0;
 8011046:	f04f 0200 	mov.w	r2, #0
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 801104a:	d049      	beq.n	80110e0 <USB_OTG_CoreInit+0xa4>
    }    
  }
  else /* FS interface (embedded Phy or I2C Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 801104c:	68c1      	ldr	r1, [r0, #12]
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801104e:	4c5e      	ldr	r4, [pc, #376]	; (80111c8 <USB_OTG_CoreInit+0x18c>)
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 8011050:	68cb      	ldr	r3, [r1, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 8011052:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8011056:	60cb      	str	r3, [r1, #12]
    USB_OTG_BSP_uDelay(3);
 8011058:	2003      	movs	r0, #3
  greset.d32 = 0;
 801105a:	9201      	str	r2, [sp, #4]
    USB_OTG_BSP_uDelay(3);
 801105c:	f7ff fde8 	bl	8010c30 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8011060:	68eb      	ldr	r3, [r5, #12]
 8011062:	691a      	ldr	r2, [r3, #16]
 8011064:	9201      	str	r2, [sp, #4]
 8011066:	e006      	b.n	8011076 <USB_OTG_CoreInit+0x3a>
    USB_OTG_BSP_uDelay(3);
 8011068:	f7ff fde2 	bl	8010c30 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801106c:	68eb      	ldr	r3, [r5, #12]
    if (++count > 200000)
 801106e:	3c01      	subs	r4, #1
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8011070:	691a      	ldr	r2, [r3, #16]
 8011072:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8011074:	d019      	beq.n	80110aa <USB_OTG_CoreInit+0x6e>
  while (greset.b.ahbidle == 0);
 8011076:	9a01      	ldr	r2, [sp, #4]
 8011078:	2a00      	cmp	r2, #0
    USB_OTG_BSP_uDelay(3);
 801107a:	f04f 0003 	mov.w	r0, #3
  while (greset.b.ahbidle == 0);
 801107e:	daf3      	bge.n	8011068 <USB_OTG_CoreInit+0x2c>
  greset.b.csftrst = 1;
 8011080:	9901      	ldr	r1, [sp, #4]
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8011082:	4a51      	ldr	r2, [pc, #324]	; (80111c8 <USB_OTG_CoreInit+0x18c>)
  greset.b.csftrst = 1;
 8011084:	f041 0101 	orr.w	r1, r1, #1
 8011088:	9101      	str	r1, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 801108a:	9901      	ldr	r1, [sp, #4]
 801108c:	6119      	str	r1, [r3, #16]
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801108e:	6919      	ldr	r1, [r3, #16]
 8011090:	9101      	str	r1, [sp, #4]
 8011092:	e003      	b.n	801109c <USB_OTG_CoreInit+0x60>
 8011094:	6919      	ldr	r1, [r3, #16]
 8011096:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8011098:	3a01      	subs	r2, #1
 801109a:	d002      	beq.n	80110a2 <USB_OTG_CoreInit+0x66>
  while (greset.b.csftrst == 1);
 801109c:	9901      	ldr	r1, [sp, #4]
 801109e:	07c9      	lsls	r1, r1, #31
 80110a0:	d4f8      	bmi.n	8011094 <USB_OTG_CoreInit+0x58>
  USB_OTG_BSP_uDelay(3);
 80110a2:	2003      	movs	r0, #3
 80110a4:	f7ff fdc4 	bl	8010c30 <USB_OTG_BSP_uDelay>
 80110a8:	68eb      	ldr	r3, [r5, #12]
    USB_OTG_CoreReset(pdev);
    /* Enable the I2C interface and deactivate the power down*/
    gccfg.d32 = 0;
    gccfg.b.pwdn = 1;
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 80110aa:	7a2a      	ldrb	r2, [r5, #8]
    gccfg.b.vbussensingB = 1 ;     

    gccfg.b.disablevbussensing = 1; 

    
    if(pdev->cfg.Sof_output)
 80110ac:	7a69      	ldrb	r1, [r5, #9]
      gccfg.b.i2cifen = 1;
 80110ae:	2a03      	cmp	r2, #3
    gccfg.b.disablevbussensing = 1; 
 80110b0:	bf14      	ite	ne
 80110b2:	f44f 1234 	movne.w	r2, #2949120	; 0x2d0000
 80110b6:	f44f 123c 	moveq.w	r2, #3080192	; 0x2f0000
    if(pdev->cfg.Sof_output)
 80110ba:	b109      	cbz	r1, 80110c0 <USB_OTG_CoreInit+0x84>
    {
      gccfg.b.sofouten = 1;  
 80110bc:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 80110c0:	639a      	str	r2, [r3, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 80110c2:	2014      	movs	r0, #20
 80110c4:	f7ff fdca 	bl	8010c5c <USB_OTG_BSP_mDelay>
    /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
    
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 80110c8:	7a29      	ldrb	r1, [r5, #8]
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80110ca:	68ea      	ldr	r2, [r5, #12]
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 80110cc:	2903      	cmp	r1, #3
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80110ce:	68d3      	ldr	r3, [r2, #12]
    if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
 80110d0:	d060      	beq.n	8011194 <USB_OTG_CoreInit+0x158>
    {
      usbcfg.b.otgutmifssel = 1;
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 80110d2:	60d3      	str	r3, [r2, #12]
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
      USB_OTG_BSP_mDelay(200);
    }
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 80110d4:	78eb      	ldrb	r3, [r5, #3]
 80110d6:	2b01      	cmp	r3, #1
 80110d8:	d051      	beq.n	801117e <USB_OTG_CoreInit+0x142>
    
  }
  /* initialize OTG features */

  return status;
}
 80110da:	2000      	movs	r0, #0
 80110dc:	b002      	add	sp, #8
 80110de:	bd70      	pop	{r4, r5, r6, pc}
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 80110e0:	68c1      	ldr	r1, [r0, #12]
    if (pdev->cfg.Sof_output)
 80110e2:	7a43      	ldrb	r3, [r0, #9]
 80110e4:	4616      	mov	r6, r2
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 80110e6:	6b8a      	ldr	r2, [r1, #56]	; 0x38
    gccfg.b.pwdn = 0;
 80110e8:	f366 4210 	bfi	r2, r6, #16, #1
    if (pdev->cfg.Sof_output)
 80110ec:	b10b      	cbz	r3, 80110f2 <USB_OTG_CoreInit+0xb6>
      gccfg.b.sofouten = 1;   
 80110ee:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 80110f2:	638a      	str	r2, [r1, #56]	; 0x38
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 80110f4:	68cb      	ldr	r3, [r1, #12]
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 80110f6:	4c34      	ldr	r4, [pc, #208]	; (80111c8 <USB_OTG_CoreInit+0x18c>)
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 80110f8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 80110fc:	f023 0350 	bic.w	r3, r3, #80	; 0x50
    usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
 8011100:	f043 0310 	orr.w	r3, r3, #16
    usbcfg.b.phyif             = 0; /* 8 bits */
 8011104:	f36f 03c3 	bfc	r3, #3, #1
    usbcfg.b.ddrsel            = 0; /* single data rate */
 8011108:	f36f 13c7 	bfc	r3, #7, #1
    usbcfg.b.ulpi_fsls = 0;
 801110c:	f36f 4351 	bfc	r3, #17, #1
    usbcfg.b.ulpi_clk_sus_m = 0;
 8011110:	f36f 43d3 	bfc	r3, #19, #1
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8011114:	60cb      	str	r3, [r1, #12]
    USB_OTG_BSP_uDelay(3);
 8011116:	2003      	movs	r0, #3
  greset.d32 = 0;
 8011118:	2300      	movs	r3, #0
 801111a:	9300      	str	r3, [sp, #0]
    USB_OTG_BSP_uDelay(3);
 801111c:	f7ff fd88 	bl	8010c30 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8011120:	68eb      	ldr	r3, [r5, #12]
 8011122:	691a      	ldr	r2, [r3, #16]
 8011124:	9200      	str	r2, [sp, #0]
 8011126:	e006      	b.n	8011136 <USB_OTG_CoreInit+0xfa>
    USB_OTG_BSP_uDelay(3);
 8011128:	f7ff fd82 	bl	8010c30 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801112c:	68eb      	ldr	r3, [r5, #12]
    if (++count > 200000)
 801112e:	3c01      	subs	r4, #1
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8011130:	691a      	ldr	r2, [r3, #16]
 8011132:	9200      	str	r2, [sp, #0]
    if (++count > 200000)
 8011134:	d018      	beq.n	8011168 <USB_OTG_CoreInit+0x12c>
  while (greset.b.ahbidle == 0);
 8011136:	9a00      	ldr	r2, [sp, #0]
 8011138:	2a00      	cmp	r2, #0
    USB_OTG_BSP_uDelay(3);
 801113a:	f04f 0003 	mov.w	r0, #3
  while (greset.b.ahbidle == 0);
 801113e:	daf3      	bge.n	8011128 <USB_OTG_CoreInit+0xec>
  greset.b.csftrst = 1;
 8011140:	9900      	ldr	r1, [sp, #0]
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8011142:	4a21      	ldr	r2, [pc, #132]	; (80111c8 <USB_OTG_CoreInit+0x18c>)
  greset.b.csftrst = 1;
 8011144:	f041 0101 	orr.w	r1, r1, #1
 8011148:	9100      	str	r1, [sp, #0]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 801114a:	9900      	ldr	r1, [sp, #0]
 801114c:	6119      	str	r1, [r3, #16]
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801114e:	6919      	ldr	r1, [r3, #16]
 8011150:	9100      	str	r1, [sp, #0]
 8011152:	e003      	b.n	801115c <USB_OTG_CoreInit+0x120>
 8011154:	6919      	ldr	r1, [r3, #16]
 8011156:	9100      	str	r1, [sp, #0]
    if (++count > 200000)
 8011158:	3a01      	subs	r2, #1
 801115a:	d002      	beq.n	8011162 <USB_OTG_CoreInit+0x126>
  while (greset.b.csftrst == 1);
 801115c:	9900      	ldr	r1, [sp, #0]
 801115e:	07c8      	lsls	r0, r1, #31
 8011160:	d4f8      	bmi.n	8011154 <USB_OTG_CoreInit+0x118>
  USB_OTG_BSP_uDelay(3);
 8011162:	2003      	movs	r0, #3
 8011164:	f7ff fd64 	bl	8010c30 <USB_OTG_BSP_uDelay>
    if(pdev->cfg.dma_enable == 1)
 8011168:	78eb      	ldrb	r3, [r5, #3]
 801116a:	2b01      	cmp	r3, #1
 801116c:	d1b5      	bne.n	80110da <USB_OTG_CoreInit+0x9e>
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 801116e:	2205      	movs	r2, #5
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8011170:	68eb      	ldr	r3, [r5, #12]
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8011172:	f362 0644 	bfi	r6, r2, #1, #4
      ahbcfg.b.dmaenable = 1;
 8011176:	f046 0620 	orr.w	r6, r6, #32
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 801117a:	609e      	str	r6, [r3, #8]
 801117c:	e000      	b.n	8011180 <USB_OTG_CoreInit+0x144>
 801117e:	68eb      	ldr	r3, [r5, #12]
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8011180:	689e      	ldr	r6, [r3, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8011182:	2205      	movs	r2, #5
 8011184:	f362 0644 	bfi	r6, r2, #1, #4
    ahbcfg.b.dmaenable = 1;
 8011188:	f046 0620 	orr.w	r6, r6, #32
}
 801118c:	2000      	movs	r0, #0
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 801118e:	609e      	str	r6, [r3, #8]
}
 8011190:	b002      	add	sp, #8
 8011192:	bd70      	pop	{r4, r5, r6, pc}
      usbcfg.b.otgutmifssel = 1;
 8011194:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8011198:	60d3      	str	r3, [r2, #12]
      i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
 801119a:	6b14      	ldr	r4, [r2, #48]	; 0x30
      i2cctl.b.i2cdevaddr = 1;
 801119c:	2301      	movs	r3, #1
 801119e:	f363 649b 	bfi	r4, r3, #26, #2
      i2cctl.b.i2cen = 0;
 80111a2:	f36f 54d7 	bfc	r4, #23, #1
      i2cctl.b.addr = 0x2D;
 80111a6:	232d      	movs	r3, #45	; 0x2d
      i2cctl.b.dat_se0 = 1;
 80111a8:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
      i2cctl.b.addr = 0x2D;
 80111ac:	f363 4416 	bfi	r4, r3, #16, #7
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 80111b0:	6314      	str	r4, [r2, #48]	; 0x30
      USB_OTG_BSP_mDelay(200);
 80111b2:	20c8      	movs	r0, #200	; 0xc8
 80111b4:	f7ff fd52 	bl	8010c5c <USB_OTG_BSP_mDelay>
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 80111b8:	68eb      	ldr	r3, [r5, #12]
      i2cctl.b.i2cen = 1;
 80111ba:	f444 0400 	orr.w	r4, r4, #8388608	; 0x800000
      USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
 80111be:	631c      	str	r4, [r3, #48]	; 0x30
      USB_OTG_BSP_mDelay(200);
 80111c0:	20c8      	movs	r0, #200	; 0xc8
 80111c2:	f7ff fd4b 	bl	8010c5c <USB_OTG_BSP_mDelay>
 80111c6:	e785      	b.n	80110d4 <USB_OTG_CoreInit+0x98>
 80111c8:	00030d40 	.word	0x00030d40

080111cc <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 80111cc:	68c2      	ldr	r2, [r0, #12]
 80111ce:	6893      	ldr	r3, [r2, #8]
 80111d0:	f043 0301 	orr.w	r3, r3, #1
 80111d4:	6093      	str	r3, [r2, #8]
  return status;
}
 80111d6:	2000      	movs	r0, #0
 80111d8:	4770      	bx	lr
 80111da:	bf00      	nop

080111dc <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 80111dc:	68c2      	ldr	r2, [r0, #12]
 80111de:	6893      	ldr	r3, [r2, #8]
 80111e0:	f023 0301 	bic.w	r3, r3, #1
 80111e4:	6093      	str	r3, [r2, #8]
  return status;
}
 80111e6:	2000      	movs	r0, #0
 80111e8:	4770      	bx	lr
 80111ea:	bf00      	nop

080111ec <USB_OTG_FlushTxFifo>:


//--------------------------------------------------------------
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 80111ec:	b500      	push	{lr}
 80111ee:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 80111f0:	2300      	movs	r3, #0
 80111f2:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 80111f4:	9a01      	ldr	r2, [sp, #4]
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80111f6:	4b0e      	ldr	r3, [pc, #56]	; (8011230 <USB_OTG_FlushTxFifo+0x44>)
  greset.b.txfflsh = 1;
 80111f8:	f042 0220 	orr.w	r2, r2, #32
 80111fc:	9201      	str	r2, [sp, #4]
  greset.b.txfnum  = num;
 80111fe:	9a01      	ldr	r2, [sp, #4]
 8011200:	f361 128a 	bfi	r2, r1, #6, #5
 8011204:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8011206:	68c1      	ldr	r1, [r0, #12]
 8011208:	9a01      	ldr	r2, [sp, #4]
 801120a:	610a      	str	r2, [r1, #16]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 801120c:	690a      	ldr	r2, [r1, #16]
 801120e:	9201      	str	r2, [sp, #4]
 8011210:	e003      	b.n	801121a <USB_OTG_FlushTxFifo+0x2e>
 8011212:	690a      	ldr	r2, [r1, #16]
 8011214:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8011216:	3b01      	subs	r3, #1
 8011218:	d002      	beq.n	8011220 <USB_OTG_FlushTxFifo+0x34>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 801121a:	9a01      	ldr	r2, [sp, #4]
 801121c:	0692      	lsls	r2, r2, #26
 801121e:	d4f8      	bmi.n	8011212 <USB_OTG_FlushTxFifo+0x26>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8011220:	2003      	movs	r0, #3
 8011222:	f7ff fd05 	bl	8010c30 <USB_OTG_BSP_uDelay>
  return status;
}
 8011226:	2000      	movs	r0, #0
 8011228:	b003      	add	sp, #12
 801122a:	f85d fb04 	ldr.w	pc, [sp], #4
 801122e:	bf00      	nop
 8011230:	00030d40 	.word	0x00030d40

08011234 <USB_OTG_FlushRxFifo>:


//--------------------------------------------------------------
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 8011234:	b500      	push	{lr}
 8011236:	b083      	sub	sp, #12
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8011238:	2300      	movs	r3, #0
 801123a:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 801123c:	9a01      	ldr	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 801123e:	4b0c      	ldr	r3, [pc, #48]	; (8011270 <USB_OTG_FlushRxFifo+0x3c>)
  greset.b.rxfflsh = 1;
 8011240:	f042 0210 	orr.w	r2, r2, #16
 8011244:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8011246:	68c1      	ldr	r1, [r0, #12]
 8011248:	9a01      	ldr	r2, [sp, #4]
 801124a:	610a      	str	r2, [r1, #16]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 801124c:	690a      	ldr	r2, [r1, #16]
 801124e:	9201      	str	r2, [sp, #4]
 8011250:	e003      	b.n	801125a <USB_OTG_FlushRxFifo+0x26>
 8011252:	690a      	ldr	r2, [r1, #16]
 8011254:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8011256:	3b01      	subs	r3, #1
 8011258:	d002      	beq.n	8011260 <USB_OTG_FlushRxFifo+0x2c>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 801125a:	9a01      	ldr	r2, [sp, #4]
 801125c:	06d2      	lsls	r2, r2, #27
 801125e:	d4f8      	bmi.n	8011252 <USB_OTG_FlushRxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8011260:	2003      	movs	r0, #3
 8011262:	f7ff fce5 	bl	8010c30 <USB_OTG_BSP_uDelay>
  return status;
}
 8011266:	2000      	movs	r0, #0
 8011268:	b003      	add	sp, #12
 801126a:	f85d fb04 	ldr.w	pc, [sp], #4
 801126e:	bf00      	nop
 8011270:	00030d40 	.word	0x00030d40

08011274 <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8011274:	68c2      	ldr	r2, [r0, #12]
{
 8011276:	b508      	push	{r3, lr}
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8011278:	68d3      	ldr	r3, [r2, #12]
  
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 801127a:	2901      	cmp	r1, #1
  usbcfg.b.force_host = 0;
 801127c:	f36f 735d 	bfc	r3, #29, #1
  usbcfg.b.force_dev = 0;
 8011280:	f36f 739e 	bfc	r3, #30, #1
  if ( mode == HOST_MODE)
 8011284:	d008      	beq.n	8011298 <USB_OTG_SetCurrentMode+0x24>
  {
    usbcfg.b.force_host = 1;
  }
  else if ( mode == DEVICE_MODE)
 8011286:	b909      	cbnz	r1, 801128c <USB_OTG_SetCurrentMode+0x18>
  {
    usbcfg.b.force_dev = 1;
 8011288:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 801128c:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 801128e:	2032      	movs	r0, #50	; 0x32
 8011290:	f7ff fce4 	bl	8010c5c <USB_OTG_BSP_mDelay>
  return status;
}
 8011294:	2000      	movs	r0, #0
 8011296:	bd08      	pop	{r3, pc}
    usbcfg.b.force_host = 1;
 8011298:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 801129c:	e7f6      	b.n	801128c <USB_OTG_SetCurrentMode+0x18>
 801129e:	bf00      	nop

080112a0 <USB_OTG_GetMode>:


//--------------------------------------------------------------
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 80112a0:	68c3      	ldr	r3, [r0, #12]
 80112a2:	6958      	ldr	r0, [r3, #20]
}
 80112a4:	f000 0001 	and.w	r0, r0, #1
 80112a8:	4770      	bx	lr
 80112aa:	bf00      	nop

080112ac <USB_OTG_IsDeviceMode>:
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 80112ac:	68c3      	ldr	r3, [r0, #12]
 80112ae:	6958      	ldr	r0, [r3, #20]


//--------------------------------------------------------------
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
 80112b0:	43c0      	mvns	r0, r0
}
 80112b2:	f000 0001 	and.w	r0, r0, #1
 80112b6:	4770      	bx	lr

080112b8 <USB_OTG_IsHostMode>:
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 80112b8:	68c3      	ldr	r3, [r0, #12]
 80112ba:	6958      	ldr	r0, [r3, #20]

//--------------------------------------------------------------
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
}
 80112bc:	f000 0001 	and.w	r0, r0, #1
 80112c0:	4770      	bx	lr
 80112c2:	bf00      	nop

080112c4 <USB_OTG_ReadCoreItr>:

//--------------------------------------------------------------
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 80112c4:	68c3      	ldr	r3, [r0, #12]
 80112c6:	6958      	ldr	r0, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 80112c8:	699b      	ldr	r3, [r3, #24]
  return v;
}
 80112ca:	4018      	ands	r0, r3
 80112cc:	4770      	bx	lr
 80112ce:	bf00      	nop

080112d0 <USB_OTG_ReadOtgItr>:


//--------------------------------------------------------------
uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
 80112d0:	68c3      	ldr	r3, [r0, #12]
 80112d2:	6858      	ldr	r0, [r3, #4]
}
 80112d4:	4770      	bx	lr
 80112d6:	bf00      	nop

080112d8 <USB_OTG_CoreInitHost>:


//--------------------------------------------------------------
USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
{
 80112d8:	b570      	push	{r4, r5, r6, lr}
 80112da:	4604      	mov	r4, r0
 80112dc:	b082      	sub	sp, #8

  hcfg.d32 = 0;
  
  
  /* configure charge pump IO */
  USB_OTG_BSP_ConfigVBUS(pdev);
 80112de:	f7ff fc85 	bl	8010bec <USB_OTG_BSP_ConfigVBUS>
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 80112e2:	f8d4 210c 	ldr.w	r2, [r4, #268]	; 0x10c
//--------------------------------------------------------------
void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
{
  USB_OTG_HCFG_TypeDef   hcfg;
  
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 80112e6:	6963      	ldr	r3, [r4, #20]
  nptxfifosize.d32 = 0;  
 80112e8:	2000      	movs	r0, #0
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 80112ea:	6010      	str	r0, [r2, #0]
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 80112ec:	681a      	ldr	r2, [r3, #0]
  hcfg.b.fslspclksel = freq;
 80112ee:	2101      	movs	r1, #1
 80112f0:	f361 0201 	bfi	r2, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 80112f4:	601a      	str	r2, [r3, #0]
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 80112f6:	681a      	ldr	r2, [r3, #0]
  hcfg.b.fslssupp = 0;
 80112f8:	f360 0282 	bfi	r2, r0, #2, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 80112fc:	601a      	str	r2, [r3, #0]
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
 80112fe:	7ae3      	ldrb	r3, [r4, #11]
 8011300:	428b      	cmp	r3, r1
 8011302:	f000 80c2 	beq.w	801148a <USB_OTG_CoreInitHost+0x1b2>
 8011306:	68e1      	ldr	r1, [r4, #12]
  greset.d32 = 0;
 8011308:	2300      	movs	r3, #0
 801130a:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 801130c:	9a01      	ldr	r2, [sp, #4]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 801130e:	4b68      	ldr	r3, [pc, #416]	; (80114b0 <USB_OTG_CoreInitHost+0x1d8>)
  greset.b.txfflsh = 1;
 8011310:	f042 0220 	orr.w	r2, r2, #32
 8011314:	9201      	str	r2, [sp, #4]
  greset.b.txfnum  = num;
 8011316:	9a01      	ldr	r2, [sp, #4]
 8011318:	2010      	movs	r0, #16
 801131a:	f360 128a 	bfi	r2, r0, #6, #5
 801131e:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8011320:	9a01      	ldr	r2, [sp, #4]
 8011322:	610a      	str	r2, [r1, #16]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8011324:	690a      	ldr	r2, [r1, #16]
 8011326:	9201      	str	r2, [sp, #4]
 8011328:	e003      	b.n	8011332 <USB_OTG_CoreInitHost+0x5a>
 801132a:	690a      	ldr	r2, [r1, #16]
 801132c:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 801132e:	3b01      	subs	r3, #1
 8011330:	d002      	beq.n	8011338 <USB_OTG_CoreInitHost+0x60>
  while (greset.b.txfflsh == 1);
 8011332:	9a01      	ldr	r2, [sp, #4]
 8011334:	0695      	lsls	r5, r2, #26
 8011336:	d4f8      	bmi.n	801132a <USB_OTG_CoreInitHost+0x52>
  USB_OTG_BSP_uDelay(3);
 8011338:	2003      	movs	r0, #3
 801133a:	f7ff fc79 	bl	8010c30 <USB_OTG_BSP_uDelay>
  greset.d32 = 0;
 801133e:	2300      	movs	r3, #0
 8011340:	9300      	str	r3, [sp, #0]
  greset.b.rxfflsh = 1;
 8011342:	9a00      	ldr	r2, [sp, #0]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8011344:	68e1      	ldr	r1, [r4, #12]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8011346:	4b5a      	ldr	r3, [pc, #360]	; (80114b0 <USB_OTG_CoreInitHost+0x1d8>)
  greset.b.rxfflsh = 1;
 8011348:	f042 0210 	orr.w	r2, r2, #16
 801134c:	9200      	str	r2, [sp, #0]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 801134e:	9a00      	ldr	r2, [sp, #0]
 8011350:	610a      	str	r2, [r1, #16]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8011352:	690a      	ldr	r2, [r1, #16]
 8011354:	9200      	str	r2, [sp, #0]
 8011356:	e003      	b.n	8011360 <USB_OTG_CoreInitHost+0x88>
 8011358:	690a      	ldr	r2, [r1, #16]
 801135a:	9200      	str	r2, [sp, #0]
    if (++count > 200000)
 801135c:	3b01      	subs	r3, #1
 801135e:	d002      	beq.n	8011366 <USB_OTG_CoreInitHost+0x8e>
  while (greset.b.rxfflsh == 1);
 8011360:	9a00      	ldr	r2, [sp, #0]
 8011362:	06d0      	lsls	r0, r2, #27
 8011364:	d4f8      	bmi.n	8011358 <USB_OTG_CoreInitHost+0x80>
  USB_OTG_BSP_uDelay(3);
 8011366:	2003      	movs	r0, #3
 8011368:	f7ff fc62 	bl	8010c30 <USB_OTG_BSP_uDelay>
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801136c:	7823      	ldrb	r3, [r4, #0]
 801136e:	2b00      	cmp	r3, #0
 8011370:	d05a      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011372:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 8011376:	f04f 31ff 	mov.w	r1, #4294967295
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 801137a:	2200      	movs	r2, #0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801137c:	2b01      	cmp	r3, #1
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801137e:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 8011380:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011382:	d051      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011384:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011388:	2b02      	cmp	r3, #2
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801138a:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 801138c:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801138e:	d04b      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011390:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011394:	2b03      	cmp	r3, #3
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011396:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 8011398:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801139a:	d045      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801139c:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113a0:	2b04      	cmp	r3, #4
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113a2:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113a4:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113a6:	d03f      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113a8:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113ac:	2b05      	cmp	r3, #5
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113ae:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113b0:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113b2:	d039      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113b4:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113b8:	2b06      	cmp	r3, #6
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113ba:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113bc:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113be:	d033      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113c0:	f8d4 00a8 	ldr.w	r0, [r4, #168]	; 0xa8
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113c4:	2b07      	cmp	r3, #7
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113c6:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113c8:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113ca:	d02d      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113cc:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113d0:	2b08      	cmp	r3, #8
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113d2:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113d4:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113d6:	d027      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113d8:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113dc:	2b09      	cmp	r3, #9
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113de:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113e0:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113e2:	d021      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113e4:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113e8:	2b0a      	cmp	r3, #10
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113ea:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113ec:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113ee:	d01b      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113f0:	f8d4 00b8 	ldr.w	r0, [r4, #184]	; 0xb8
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113f4:	2b0b      	cmp	r3, #11
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113f6:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 80113f8:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80113fa:	d015      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80113fc:	f8d4 00bc 	ldr.w	r0, [r4, #188]	; 0xbc
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011400:	2b0c      	cmp	r3, #12
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011402:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 8011404:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011406:	d00f      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011408:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801140c:	2b0d      	cmp	r3, #13
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801140e:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 8011410:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011412:	d009      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011414:	f8d4 00c4 	ldr.w	r0, [r4, #196]	; 0xc4
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011418:	2b0e      	cmp	r3, #14
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801141a:	6081      	str	r1, [r0, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 801141c:	60c2      	str	r2, [r0, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801141e:	d003      	beq.n	8011428 <USB_OTG_CoreInitHost+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 8011420:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8011424:	6099      	str	r1, [r3, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
 8011426:	60da      	str	r2, [r3, #12]
  USB_OTG_BSP_DriveVBUS(pdev, state);
 8011428:	2101      	movs	r1, #1
 801142a:	4620      	mov	r0, r4
 801142c:	f7ff fbd2 	bl	8010bd4 <USB_OTG_BSP_DriveVBUS>
//--------------------------------------------------------------
uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8011430:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
 8011434:	6813      	ldr	r3, [r2, #0]
  hprt0.b.prtena = 0;
 8011436:	f36f 0382 	bfc	r3, #2, #1
  hprt0.b.prtconndet = 0;
 801143a:	f36f 0341 	bfc	r3, #1, #1
  hprt0.b.prtenchng = 0;
 801143e:	f36f 03c3 	bfc	r3, #3, #1
  hprt0.b.prtovrcurrchng = 0;
 8011442:	f36f 1345 	bfc	r3, #5, #1
  if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
 8011446:	04d9      	lsls	r1, r3, #19
 8011448:	d402      	bmi.n	8011450 <USB_OTG_CoreInitHost+0x178>
    hprt0.b.prtpwr = 1;
 801144a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801144e:	6013      	str	r3, [r2, #0]
  USB_OTG_BSP_mDelay(200);
 8011450:	20c8      	movs	r0, #200	; 0xc8
 8011452:	f7ff fc03 	bl	8010c5c <USB_OTG_BSP_mDelay>
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 8011456:	68e2      	ldr	r2, [r4, #12]
  int_mask.b.usbsuspend = 1; 
 8011458:	4816      	ldr	r0, [pc, #88]	; (80114b4 <USB_OTG_CoreInitHost+0x1dc>)
  intmsk.d32 = 0;
 801145a:	2300      	movs	r3, #0
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 801145c:	f04f 31ff 	mov.w	r1, #4294967295
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 8011460:	6193      	str	r3, [r2, #24]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8011462:	6151      	str	r1, [r2, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 8011464:	6051      	str	r1, [r2, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8011466:	6151      	str	r1, [r2, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 8011468:	6190      	str	r0, [r2, #24]
  if (pdev->cfg.dma_enable == 0)
 801146a:	78e0      	ldrb	r0, [r4, #3]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 801146c:	6991      	ldr	r1, [r2, #24]
    intmsk.b.rxstsqlvl  = 1;
 801146e:	4298      	cmp	r0, r3
 8011470:	bf08      	it	eq
 8011472:	2310      	moveq	r3, #16
  intmsk.b.incomplisoout  = 1; 
 8011474:	f043 530c 	orr.w	r3, r3, #587202560	; 0x23000000
 8011478:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 801147c:	f043 0308 	orr.w	r3, r3, #8
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8011480:	430b      	orrs	r3, r1
}
 8011482:	2000      	movs	r0, #0
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8011484:	6193      	str	r3, [r2, #24]
}
 8011486:	b002      	add	sp, #8
 8011488:	bd70      	pop	{r4, r5, r6, pc}
 801148a:	4602      	mov	r2, r0
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 801148c:	2380      	movs	r3, #128	; 0x80
    ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
 801148e:	26e0      	movs	r6, #224	; 0xe0
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 8011490:	68e1      	ldr	r1, [r4, #12]
    nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
 8011492:	2560      	movs	r5, #96	; 0x60
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
 8011494:	f363 000f 	bfi	r0, r3, #0, #16
    ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
 8011498:	f366 020f 	bfi	r2, r6, #0, #16
    nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
 801149c:	f365 401f 	bfi	r0, r5, #16, #16
    ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
 80114a0:	f365 421f 	bfi	r2, r5, #16, #16
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 80114a4:	624b      	str	r3, [r1, #36]	; 0x24
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
 80114a6:	6288      	str	r0, [r1, #40]	; 0x28
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
 80114a8:	f8c1 2100 	str.w	r2, [r1, #256]	; 0x100
 80114ac:	e72c      	b.n	8011308 <USB_OTG_CoreInitHost+0x30>
 80114ae:	bf00      	nop
 80114b0:	00030d40 	.word	0x00030d40
 80114b4:	80000800 	.word	0x80000800

080114b8 <USB_OTG_IsEvenFrame>:
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 80114b8:	6943      	ldr	r3, [r0, #20]
 80114ba:	6898      	ldr	r0, [r3, #8]
 80114bc:	43c0      	mvns	r0, r0
}
 80114be:	f000 0001 	and.w	r0, r0, #1
 80114c2:	4770      	bx	lr

080114c4 <USB_OTG_DriveVbus>:
{
 80114c4:	b538      	push	{r3, r4, r5, lr}
 80114c6:	4605      	mov	r5, r0
 80114c8:	460c      	mov	r4, r1
  USB_OTG_BSP_DriveVBUS(pdev, state);
 80114ca:	f7ff fb83 	bl	8010bd4 <USB_OTG_BSP_DriveVBUS>
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 80114ce:	f8d5 20cc 	ldr.w	r2, [r5, #204]	; 0xcc
 80114d2:	6813      	ldr	r3, [r2, #0]
  hprt0.b.prtena = 0;
 80114d4:	f36f 0382 	bfc	r3, #2, #1
  hprt0.b.prtconndet = 0;
 80114d8:	f36f 0341 	bfc	r3, #1, #1
  hprt0.b.prtenchng = 0;
 80114dc:	f36f 03c3 	bfc	r3, #3, #1
  hprt0.b.prtovrcurrchng = 0;
 80114e0:	f36f 1345 	bfc	r3, #5, #1
  if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
 80114e4:	04d9      	lsls	r1, r3, #19
 80114e6:	d406      	bmi.n	80114f6 <USB_OTG_DriveVbus+0x32>
 80114e8:	2c01      	cmp	r4, #1
 80114ea:	d00f      	beq.n	801150c <USB_OTG_DriveVbus+0x48>
  USB_OTG_BSP_mDelay(200);
 80114ec:	20c8      	movs	r0, #200	; 0xc8
}
 80114ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  USB_OTG_BSP_mDelay(200);
 80114f2:	f7ff bbb3 	b.w	8010c5c <USB_OTG_BSP_mDelay>
  if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
 80114f6:	2c00      	cmp	r4, #0
 80114f8:	d1f8      	bne.n	80114ec <USB_OTG_DriveVbus+0x28>
 80114fa:	4619      	mov	r1, r3
    hprt0.b.prtpwr = 0;
 80114fc:	f364 310c 	bfi	r1, r4, #12, #1
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8011500:	6011      	str	r1, [r2, #0]
  USB_OTG_BSP_mDelay(200);
 8011502:	20c8      	movs	r0, #200	; 0xc8
}
 8011504:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  USB_OTG_BSP_mDelay(200);
 8011508:	f7ff bba8 	b.w	8010c5c <USB_OTG_BSP_mDelay>
    hprt0.b.prtpwr = 1;
 801150c:	f443 5180 	orr.w	r1, r3, #4096	; 0x1000
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8011510:	6011      	str	r1, [r2, #0]
  USB_OTG_BSP_mDelay(200);
 8011512:	20c8      	movs	r0, #200	; 0xc8
}
 8011514:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  USB_OTG_BSP_mDelay(200);
 8011518:	f7ff bba0 	b.w	8010c5c <USB_OTG_BSP_mDelay>

0801151c <USB_OTG_EnableHostInt>:
{
 801151c:	b410      	push	{r4}
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 801151e:	68c2      	ldr	r2, [r0, #12]
  int_mask.b.usbsuspend = 1; 
 8011520:	4c0c      	ldr	r4, [pc, #48]	; (8011554 <USB_OTG_EnableHostInt+0x38>)
  intmsk.d32 = 0;
 8011522:	2300      	movs	r3, #0
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8011524:	f04f 31ff 	mov.w	r1, #4294967295
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 8011528:	6193      	str	r3, [r2, #24]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 801152a:	6151      	str	r1, [r2, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 801152c:	6051      	str	r1, [r2, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 801152e:	6151      	str	r1, [r2, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 8011530:	6194      	str	r4, [r2, #24]
  if (pdev->cfg.dma_enable == 0)
 8011532:	78c0      	ldrb	r0, [r0, #3]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8011534:	6991      	ldr	r1, [r2, #24]
}
 8011536:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (pdev->cfg.dma_enable == 0)
 801153a:	4298      	cmp	r0, r3
    intmsk.b.rxstsqlvl  = 1;
 801153c:	bf08      	it	eq
 801153e:	2310      	moveq	r3, #16
  intmsk.b.incomplisoout  = 1; 
 8011540:	f043 530c 	orr.w	r3, r3, #587202560	; 0x23000000
 8011544:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8011548:	f043 0308 	orr.w	r3, r3, #8
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 801154c:	430b      	orrs	r3, r1
}
 801154e:	2000      	movs	r0, #0
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8011550:	6193      	str	r3, [r2, #24]
}
 8011552:	4770      	bx	lr
 8011554:	80000800 	.word	0x80000800

08011558 <USB_OTG_InitFSLSPClkSel>:
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 8011558:	6942      	ldr	r2, [r0, #20]
 801155a:	6813      	ldr	r3, [r2, #0]
  hcfg.b.fslspclksel = freq;
 801155c:	f361 0301 	bfi	r3, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 8011560:	6013      	str	r3, [r2, #0]
 8011562:	4770      	bx	lr

08011564 <USB_OTG_ReadHPRT0>:
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8011564:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
 8011568:	6818      	ldr	r0, [r3, #0]
  return hprt0.d32;
}
 801156a:	f020 002e 	bic.w	r0, r0, #46	; 0x2e
 801156e:	4770      	bx	lr

08011570 <USB_OTG_ReadHostAllChannels_intr>:


//--------------------------------------------------------------
uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
 8011570:	6943      	ldr	r3, [r0, #20]
 8011572:	6958      	ldr	r0, [r3, #20]
}
 8011574:	4770      	bx	lr
 8011576:	bf00      	nop

08011578 <USB_OTG_ResetPort>:


//--------------------------------------------------------------
uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 8011578:	b538      	push	{r3, r4, r5, lr}
 801157a:	4605      	mov	r5, r0
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
  hprt0.b.prtrst = 1;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
  USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
 801157c:	200a      	movs	r0, #10
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 801157e:	f8d5 20cc 	ldr.w	r2, [r5, #204]	; 0xcc
 8011582:	6813      	ldr	r3, [r2, #0]
  hprt0.b.prtena = 0;
 8011584:	f36f 0382 	bfc	r3, #2, #1
  hprt0.b.prtconndet = 0;
 8011588:	f36f 0341 	bfc	r3, #1, #1
  hprt0.b.prtenchng = 0;
 801158c:	f36f 03c3 	bfc	r3, #3, #1
  hprt0.b.prtovrcurrchng = 0;
 8011590:	f36f 1345 	bfc	r3, #5, #1
  hprt0.b.prtrst = 1;
 8011594:	f443 7480 	orr.w	r4, r3, #256	; 0x100
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8011598:	6014      	str	r4, [r2, #0]
  USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
 801159a:	f7ff fb5f 	bl	8010c5c <USB_OTG_BSP_mDelay>
  hprt0.b.prtrst = 0;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801159e:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
  hprt0.b.prtrst = 0;
 80115a2:	f36f 2408 	bfc	r4, #8, #1
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 80115a6:	601c      	str	r4, [r3, #0]
  USB_OTG_BSP_mDelay (20);   
 80115a8:	2014      	movs	r0, #20
 80115aa:	f7ff fb57 	bl	8010c5c <USB_OTG_BSP_mDelay>
  return 1;
}
 80115ae:	2001      	movs	r0, #1
 80115b0:	bd38      	pop	{r3, r4, r5, pc}
 80115b2:	bf00      	nop

080115b4 <USB_OTG_HC_Init>:


//--------------------------------------------------------------
USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 80115b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hcintmsk.d32 = 0;
  hcchar.d32 = 0;
  
  /* Clear old interrupt conditions for this host channel. */
  hcint.d32 = 0xFFFFFFFF;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
 80115b8:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 80115bc:	f04f 33ff 	mov.w	r3, #4294967295
 80115c0:	f8d2 5090 	ldr.w	r5, [r2, #144]	; 0x90
  if (pdev->cfg.dma_enable == 1)
  {
    hcintmsk.b.ahberr = 1;
  }
  
  switch (pdev->host.hc[hc_num].ep_type) 
 80115c4:	014e      	lsls	r6, r1, #5
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
 80115c6:	60ab      	str	r3, [r5, #8]
  switch (pdev->host.hc[hc_num].ep_type) 
 80115c8:	1982      	adds	r2, r0, r6
  if (pdev->cfg.dma_enable == 1)
 80115ca:	78c3      	ldrb	r3, [r0, #3]
  switch (pdev->host.hc[hc_num].ep_type) 
 80115cc:	f892 42b1 	ldrb.w	r4, [r2, #689]	; 0x2b1
    hcintmsk.b.ahberr = 1;
 80115d0:	2b01      	cmp	r3, #1
  hcintmsk.d32 = 0;
 80115d2:	f04f 0300 	mov.w	r3, #0
  hcchar.d32 = 0;
 80115d6:	461a      	mov	r2, r3
    hcintmsk.b.ahberr = 1;
 80115d8:	bf08      	it	eq
 80115da:	2304      	moveq	r3, #4
  switch (pdev->host.hc[hc_num].ep_type) 
 80115dc:	2c03      	cmp	r4, #3
 80115de:	d863      	bhi.n	80116a8 <USB_OTG_HC_Init+0xf4>
 80115e0:	e8df f004 	tbb	[pc, r4]
 80115e4:	024e424e 	.word	0x024e424e
    hcintmsk.b.stall = 1;
    hcintmsk.b.xacterr = 1;
    hcintmsk.b.datatglerr = 1;
    hcintmsk.b.frmovrun = 1;
    
    if (pdev->host.hc[hc_num].ep_is_in) 
 80115e8:	1987      	adds	r7, r0, r6
    hcintmsk.b.frmovrun = 1;
 80115ea:	f443 63d3 	orr.w	r3, r3, #1688	; 0x698
    if (pdev->host.hc[hc_num].ep_is_in) 
 80115ee:	f897 72ae 	ldrb.w	r7, [r7, #686]	; 0x2ae
    hcintmsk.b.frmovrun = 1;
 80115f2:	f043 0301 	orr.w	r3, r3, #1
    if (pdev->host.hc[hc_num].ep_is_in) 
 80115f6:	b10f      	cbz	r7, 80115fc <USB_OTG_HC_Init+0x48>
    {
      hcintmsk.b.bblerr = 1;
 80115f8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCGINTMSK, hcintmsk.d32);
  
  
  /* Enable the top level host channel interrupt. */
  intr_enable = (1 << hc_num);
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 80115fc:	f8d0 c014 	ldr.w	ip, [r0, #20]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCGINTMSK, hcintmsk.d32);
 8011600:	60eb      	str	r3, [r5, #12]
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 8011602:	f8dc 8018 	ldr.w	r8, [ip, #24]
  
  /* Make sure host channel interrupts are enabled. */
  gintmsk.b.hcintr = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 8011606:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  intr_enable = (1 << hc_num);
 801160a:	2301      	movs	r3, #1
 801160c:	fa03 f101 	lsl.w	r1, r3, r1
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 8011610:	ea41 0108 	orr.w	r1, r1, r8
 8011614:	f8cc 1018 	str.w	r1, [ip, #24]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 8011618:	f8de 3018 	ldr.w	r3, [lr, #24]
  
  /* Program the HCCHAR register */
  hcchar.d32 = 0;
  hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
 801161c:	4430      	add	r0, r6
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 801161e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8011622:	f8ce 3018 	str.w	r3, [lr, #24]
  hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
 8011626:	f890 e2ac 	ldrb.w	lr, [r0, #684]	; 0x2ac
  hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
  hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 801162a:	f890 32af 	ldrb.w	r3, [r0, #687]	; 0x2af
  hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
 801162e:	f890 62ad 	ldrb.w	r6, [r0, #685]	; 0x2ad
  hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 8011632:	f8b0 12b2 	ldrh.w	r1, [r0, #690]	; 0x2b2
  hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
 8011636:	f36e 529c 	bfi	r2, lr, #22, #7
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 801163a:	f1a3 0302 	sub.w	r3, r3, #2
  hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
 801163e:	f366 22ce 	bfi	r2, r6, #11, #4
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 8011642:	fab3 f383 	clz	r3, r3
  hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
 8011646:	f367 32cf 	bfi	r2, r7, #15, #1
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 801164a:	095b      	lsrs	r3, r3, #5
 801164c:	f363 4251 	bfi	r2, r3, #17, #1
  hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
 8011650:	f364 4293 	bfi	r2, r4, #18, #2
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 8011654:	f361 020a 	bfi	r2, r1, #0, #11
  if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
 8011658:	2c03      	cmp	r4, #3
  {
    hcchar.b.oddfrm  = 1;
 801165a:	bf08      	it	eq
 801165c:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8011660:	602a      	str	r2, [r5, #0]
  return status;
}
 8011662:	2000      	movs	r0, #0
 8011664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pdev->host.hc[hc_num].ep_is_in) 
 8011668:	1987      	adds	r7, r0, r6
    hcintmsk.b.ack = 1;
 801166a:	f443 7308 	orr.w	r3, r3, #544	; 0x220
    if (pdev->host.hc[hc_num].ep_is_in) 
 801166e:	f897 72ae 	ldrb.w	r7, [r7, #686]	; 0x2ae
    hcintmsk.b.ack = 1;
 8011672:	f043 0301 	orr.w	r3, r3, #1
    if (pdev->host.hc[hc_num].ep_is_in) 
 8011676:	2f00      	cmp	r7, #0
 8011678:	d0c0      	beq.n	80115fc <USB_OTG_HC_Init+0x48>
      hcintmsk.b.bblerr = 1;
 801167a:	f443 73c0 	orr.w	r3, r3, #384	; 0x180
 801167e:	e7bd      	b.n	80115fc <USB_OTG_HC_Init+0x48>
    if (pdev->host.hc[hc_num].ep_is_in) 
 8011680:	eb00 0e06 	add.w	lr, r0, r6
    hcintmsk.b.nak = 1;  
 8011684:	f443 6393 	orr.w	r3, r3, #1176	; 0x498
    if (pdev->host.hc[hc_num].ep_is_in) 
 8011688:	f89e 72ae 	ldrb.w	r7, [lr, #686]	; 0x2ae
    hcintmsk.b.nak = 1;  
 801168c:	f043 0301 	orr.w	r3, r3, #1
    if (pdev->host.hc[hc_num].ep_is_in) 
 8011690:	2f00      	cmp	r7, #0
 8011692:	d1b1      	bne.n	80115f8 <USB_OTG_HC_Init+0x44>
      if (pdev->host.hc[hc_num].do_ping) 
 8011694:	f89e e2b0 	ldrb.w	lr, [lr, #688]	; 0x2b0
      hcintmsk.b.nyet = 1;
 8011698:	f043 0340 	orr.w	r3, r3, #64	; 0x40
      if (pdev->host.hc[hc_num].do_ping) 
 801169c:	f1be 0f00 	cmp.w	lr, #0
 80116a0:	d0ac      	beq.n	80115fc <USB_OTG_HC_Init+0x48>
        hcintmsk.b.ack = 1;
 80116a2:	f043 0320 	orr.w	r3, r3, #32
 80116a6:	e7a9      	b.n	80115fc <USB_OTG_HC_Init+0x48>
 80116a8:	1987      	adds	r7, r0, r6
 80116aa:	f897 72ae 	ldrb.w	r7, [r7, #686]	; 0x2ae
 80116ae:	e7a5      	b.n	80115fc <USB_OTG_HC_Init+0x48>

080116b0 <USB_OTG_HC_StartXfer>:


//--------------------------------------------------------------
USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 80116b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  hctsiz.d32 = 0;
  hcchar.d32 = 0;
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
 80116b2:	014e      	lsls	r6, r1, #5
 80116b4:	1985      	adds	r5, r0, r6
  hctsiz.d32 = 0;
 80116b6:	2400      	movs	r4, #0
  if (pdev->host.hc[hc_num].xfer_len > 0)
 80116b8:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
 80116bc:	b183      	cbz	r3, 80116e0 <USB_OTG_HC_StartXfer+0x30>
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
 80116be:	f8b5 72b2 	ldrh.w	r7, [r5, #690]	; 0x2b2
 80116c2:	1e5a      	subs	r2, r3, #1
 80116c4:	443a      	add	r2, r7
 80116c6:	fbb2 f2f7 	udiv	r2, r2, r7
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
 80116ca:	b292      	uxth	r2, r2
    
    if (num_packets > max_hc_pkt_count)
 80116cc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80116d0:	d953      	bls.n	801177a <USB_OTG_HC_StartXfer+0xca>
    {
      num_packets = max_hc_pkt_count;
      pdev->host.hc[hc_num].xfer_len = num_packets * \
 80116d2:	023b      	lsls	r3, r7, #8
 80116d4:	f44f 7780 	mov.w	r7, #256	; 0x100
 80116d8:	f8c5 32bc 	str.w	r3, [r5, #700]	; 0x2bc
      num_packets = max_hc_pkt_count;
 80116dc:	463a      	mov	r2, r7
 80116de:	e001      	b.n	80116e4 <USB_OTG_HC_StartXfer+0x34>
 80116e0:	2701      	movs	r7, #1
        pdev->host.hc[hc_num].max_packet;
    }
  }
  else
  {
    num_packets = 1;
 80116e2:	463a      	mov	r2, r7
  }
  if (pdev->host.hc[hc_num].ep_is_in)
 80116e4:	1985      	adds	r5, r0, r6
 80116e6:	f895 e2ae 	ldrb.w	lr, [r5, #686]	; 0x2ae
 80116ea:	f1be 0f00 	cmp.w	lr, #0
 80116ee:	d005      	beq.n	80116fc <USB_OTG_HC_StartXfer+0x4c>
  {
    pdev->host.hc[hc_num].xfer_len = num_packets * \
      pdev->host.hc[hc_num].max_packet;
 80116f0:	f8b5 32b2 	ldrh.w	r3, [r5, #690]	; 0x2b2
    pdev->host.hc[hc_num].xfer_len = num_packets * \
 80116f4:	fb02 f303 	mul.w	r3, r2, r3
 80116f8:	f8c5 32bc 	str.w	r3, [r5, #700]	; 0x2bc
  }
  /* Initialize the HCTSIZn register */
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
  hctsiz.b.pktcnt = num_packets;
  hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
 80116fc:	f101 0e0d 	add.w	lr, r1, #13
 8011700:	eb00 124e 	add.w	r2, r0, lr, lsl #5
 8011704:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8011708:	f892 c114 	ldrb.w	ip, [r2, #276]	; 0x114
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 801170c:	f8d1 5090 	ldr.w	r5, [r1, #144]	; 0x90
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 8011710:	f363 0412 	bfi	r4, r3, #0, #19
  hctsiz.b.pktcnt = num_packets;
 8011714:	f367 44dc 	bfi	r4, r7, #19, #10
  hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
 8011718:	f36c 745e 	bfi	r4, ip, #29, #2
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 801171c:	612c      	str	r4, [r5, #16]
  
  if (pdev->cfg.dma_enable == 1)
 801171e:	78c7      	ldrb	r7, [r0, #3]
 8011720:	2f01      	cmp	r7, #1
 8011722:	d01a      	beq.n	801175a <USB_OTG_HC_StartXfer+0xaa>
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 8011724:	f8d0 c014 	ldr.w	ip, [r0, #20]
  {
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
  }
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 8011728:	682a      	ldr	r2, [r5, #0]
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 801172a:	f8dc 4008 	ldr.w	r4, [ip, #8]
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 801172e:	43e4      	mvns	r4, r4
 8011730:	f364 725d 	bfi	r2, r4, #29, #1
  
  /* Set host channel enable */
  hcchar.b.chen = 1;
 8011734:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  hcchar.b.chdis = 0;
 8011738:	f36f 729e 	bfc	r2, #30, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 801173c:	602a      	str	r2, [r5, #0]

  if (pdev->cfg.dma_enable == 0) /* Slave mode */
 801173e:	b9d7      	cbnz	r7, 8011776 <USB_OTG_HC_StartXfer+0xc6>
  {  
    if((pdev->host.hc[hc_num].ep_is_in == 0) && 
 8011740:	1982      	adds	r2, r0, r6
 8011742:	f892 42ae 	ldrb.w	r4, [r2, #686]	; 0x2ae
 8011746:	b9b4      	cbnz	r4, 8011776 <USB_OTG_HC_StartXfer+0xc6>
 8011748:	b1ab      	cbz	r3, 8011776 <USB_OTG_HC_StartXfer+0xc6>
        (pdev->host.hc[hc_num].xfer_len > 0))
    {
      switch(pdev->host.hc[hc_num].ep_type) 
 801174a:	f892 22b1 	ldrb.w	r2, [r2, #689]	; 0x2b1
 801174e:	2a03      	cmp	r2, #3
 8011750:	d823      	bhi.n	801179a <USB_OTG_HC_StartXfer+0xea>
 8011752:	e8df f002 	tbb	[pc, r2]
 8011756:	1535      	.short	0x1535
 8011758:	1535      	.short	0x1535
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
 801175a:	f8d2 2118 	ldr.w	r2, [r2, #280]	; 0x118
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 801175e:	6943      	ldr	r3, [r0, #20]
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
 8011760:	616a      	str	r2, [r5, #20]
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 8011762:	682a      	ldr	r2, [r5, #0]
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 8011764:	689b      	ldr	r3, [r3, #8]
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 8011766:	43db      	mvns	r3, r3
 8011768:	f363 725d 	bfi	r2, r3, #29, #1
  hcchar.b.chen = 1;
 801176c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  hcchar.b.chdis = 0;
 8011770:	f36f 729e 	bfc	r2, #30, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8011774:	602a      	str	r2, [r5, #0]
                          pdev->host.hc[hc_num].xfer_buff , 
                          hc_num, pdev->host.hc[hc_num].xfer_len);
    }
  }
  return status;
}
 8011776:	2000      	movs	r0, #0
 8011778:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801177a:	f3c2 0709 	ubfx	r7, r2, #0, #10
 801177e:	e7b1      	b.n	80116e4 <USB_OTG_HC_StartXfer+0x34>
        hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 8011780:	f8dc 4010 	ldr.w	r4, [ip, #16]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 8011784:	1cda      	adds	r2, r3, #3
        if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
 8011786:	b2a4      	uxth	r4, r4
 8011788:	f3c2 028f 	ubfx	r2, r2, #2, #16
 801178c:	42a2      	cmp	r2, r4
 801178e:	d904      	bls.n	801179a <USB_OTG_HC_StartXfer+0xea>
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 8011790:	68c4      	ldr	r4, [r0, #12]
 8011792:	69a2      	ldr	r2, [r4, #24]
 8011794:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8011798:	61a2      	str	r2, [r4, #24]
    count32b =  (len + 3) / 4;
 801179a:	b29b      	uxth	r3, r3
      USB_OTG_WritePacket(pdev, 
 801179c:	eb00 104e 	add.w	r0, r0, lr, lsl #5
    count32b =  (len + 3) / 4;
 80117a0:	3303      	adds	r3, #3
    for (i = 0; i < count32b; i++, src+=4)
 80117a2:	109b      	asrs	r3, r3, #2
      USB_OTG_WritePacket(pdev, 
 80117a4:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
    fifo = pdev->regs.DFIFO[ch_ep_num];
 80117a8:	f8d1 40d0 	ldr.w	r4, [r1, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 80117ac:	d0e3      	beq.n	8011776 <USB_OTG_HC_StartXfer+0xc6>
 80117ae:	2200      	movs	r2, #0
 80117b0:	3201      	adds	r2, #1
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 80117b2:	f850 1b04 	ldr.w	r1, [r0], #4
 80117b6:	6021      	str	r1, [r4, #0]
    for (i = 0; i < count32b; i++, src+=4)
 80117b8:	4293      	cmp	r3, r2
 80117ba:	d1f9      	bne.n	80117b0 <USB_OTG_HC_StartXfer+0x100>
}
 80117bc:	2000      	movs	r0, #0
 80117be:	bdf0      	pop	{r4, r5, r6, r7, pc}
        hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 80117c0:	68c5      	ldr	r5, [r0, #12]
 80117c2:	6aec      	ldr	r4, [r5, #44]	; 0x2c
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 80117c4:	1cda      	adds	r2, r3, #3
        if(len_words > hnptxsts.b.nptxfspcavail)
 80117c6:	b2a4      	uxth	r4, r4
 80117c8:	f3c2 028f 	ubfx	r2, r2, #2, #16
 80117cc:	42a2      	cmp	r2, r4
 80117ce:	d9e4      	bls.n	801179a <USB_OTG_HC_StartXfer+0xea>
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 80117d0:	69aa      	ldr	r2, [r5, #24]
 80117d2:	f042 0220 	orr.w	r2, r2, #32
 80117d6:	61aa      	str	r2, [r5, #24]
 80117d8:	e7df      	b.n	801179a <USB_OTG_HC_StartXfer+0xea>
 80117da:	bf00      	nop

080117dc <USB_OTG_HC_Halt>:
  USB_OTG_HPTXSTS_TypeDef             hptxsts;
  USB_OTG_HCCHAR_TypeDef              hcchar;
  
  nptxsts.d32 = 0;
  hptxsts.d32 = 0;
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 80117dc:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80117e0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80117e4:	6813      	ldr	r3, [r2, #0]
  hcchar.b.chen = 1;
  hcchar.b.chdis = 1;
 80117e6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  
  /* Check for space in the request queue to issue the halt. */
  if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
 80117ea:	0359      	lsls	r1, r3, #13
 80117ec:	d509      	bpl.n	8011802 <USB_OTG_HC_Halt+0x26>
      hcchar.b.chen = 0;
    }
  }
  else
  {
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 80117ee:	6941      	ldr	r1, [r0, #20]
 80117f0:	6909      	ldr	r1, [r1, #16]
    if (hptxsts.b.ptxqspcavail == 0)
 80117f2:	f3c1 4107 	ubfx	r1, r1, #16, #8
 80117f6:	b909      	cbnz	r1, 80117fc <USB_OTG_HC_Halt+0x20>
      hcchar.b.chen = 0;
 80117f8:	f36f 73df 	bfc	r3, #31, #1
    {
      hcchar.b.chen = 0;
    }
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 80117fc:	6013      	str	r3, [r2, #0]
  return status;
}
 80117fe:	2000      	movs	r0, #0
 8011800:	4770      	bx	lr
    nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 8011802:	68c1      	ldr	r1, [r0, #12]
 8011804:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    if (nptxsts.b.nptxqspcavail == 0)
 8011806:	f3c1 4107 	ubfx	r1, r1, #16, #8
 801180a:	2900      	cmp	r1, #0
 801180c:	d0f4      	beq.n	80117f8 <USB_OTG_HC_Halt+0x1c>
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 801180e:	6013      	str	r3, [r2, #0]
}
 8011810:	2000      	movs	r0, #0
 8011812:	4770      	bx	lr

08011814 <USB_OTG_HC_DoPing>:
  USB_OTG_HCTSIZn_TypeDef   hctsiz;  
 
  hctsiz.d32 = 0;
  hctsiz.b.dopng = 1;
  hctsiz.b.pktcnt = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 8011814:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  hctsiz.b.dopng = 1;
 8011818:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 801181c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
  hctsiz.b.pktcnt = 1;
 8011820:	2101      	movs	r1, #1
 8011822:	f361 43dc 	bfi	r3, r1, #19, #10
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 8011826:	6113      	str	r3, [r2, #16]
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 8011828:	6813      	ldr	r3, [r2, #0]
  hctsiz.b.dopng = 1;
 801182a:	2000      	movs	r0, #0
  hcchar.b.chen = 1;
 801182c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  hcchar.b.chdis = 0;
 8011830:	f360 739e 	bfi	r3, r0, #30, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8011834:	6013      	str	r3, [r2, #0]
  return status;  
}
 8011836:	4770      	bx	lr

08011838 <USB_OTG_StopHost>:

//--------------------------------------------------------------
void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
{
 8011838:	b510      	push	{r4, lr}
  USB_OTG_HCCHAR_TypeDef  hcchar;
  uint32_t                i;
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
 801183a:	6943      	ldr	r3, [r0, #20]
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
 801183c:	f04f 31ff 	mov.w	r1, #4294967295
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
 8011840:	2200      	movs	r2, #0
 8011842:	619a      	str	r2, [r3, #24]
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
 8011844:	6159      	str	r1, [r3, #20]
  /* Flush out any leftover queued requests. */
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011846:	7801      	ldrb	r1, [r0, #0]
{
 8011848:	b082      	sub	sp, #8
 801184a:	4604      	mov	r4, r0
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801184c:	2900      	cmp	r1, #0
 801184e:	f000 80b6 	beq.w	80119be <USB_OTG_StopHost+0x186>
  {
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8011852:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 8011856:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 8011858:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 801185c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011860:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011864:	2901      	cmp	r1, #1
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 8011866:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011868:	f000 80a9 	beq.w	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 801186c:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
 8011870:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 8011872:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 8011876:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 801187a:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801187e:	2902      	cmp	r1, #2
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 8011880:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011882:	f000 809c 	beq.w	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8011886:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
 801188a:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 801188c:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 8011890:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011894:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011898:	2903      	cmp	r1, #3
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 801189a:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801189c:	f000 808f 	beq.w	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 80118a0:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
 80118a4:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 80118a6:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 80118aa:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 80118ae:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80118b2:	2904      	cmp	r1, #4
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 80118b4:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80118b6:	f000 8082 	beq.w	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 80118ba:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
 80118be:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 80118c0:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 80118c4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 80118c8:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80118cc:	2905      	cmp	r1, #5
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 80118ce:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80118d0:	d075      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 80118d2:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 80118d6:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 80118d8:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 80118dc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 80118e0:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80118e4:	2906      	cmp	r1, #6
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 80118e6:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80118e8:	d069      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 80118ea:	f8d4 00a8 	ldr.w	r0, [r4, #168]	; 0xa8
 80118ee:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 80118f0:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 80118f4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 80118f8:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80118fc:	2907      	cmp	r1, #7
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 80118fe:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011900:	d05d      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8011902:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 8011906:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 8011908:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 801190c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011910:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011914:	2908      	cmp	r1, #8
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 8011916:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011918:	d051      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 801191a:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
 801191e:	6803      	ldr	r3, [r0, #0]
    hcchar.b.chen = 0;
 8011920:	f362 73df 	bfi	r3, r2, #31, #1
    hcchar.b.chdis = 1;
 8011924:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011928:	f362 33cf 	bfi	r3, r2, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801192c:	2909      	cmp	r1, #9
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 801192e:	6003      	str	r3, [r0, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011930:	d045      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8011932:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
 8011936:	6813      	ldr	r3, [r2, #0]
    hcchar.b.chen = 0;
 8011938:	f36f 73df 	bfc	r3, #31, #1
    hcchar.b.chdis = 1;
 801193c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011940:	f36f 33cf 	bfc	r3, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011944:	290a      	cmp	r1, #10
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 8011946:	6013      	str	r3, [r2, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011948:	d039      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 801194a:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
 801194e:	6813      	ldr	r3, [r2, #0]
    hcchar.b.chen = 0;
 8011950:	f36f 73df 	bfc	r3, #31, #1
    hcchar.b.chdis = 1;
 8011954:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011958:	f36f 33cf 	bfc	r3, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801195c:	290b      	cmp	r1, #11
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 801195e:	6013      	str	r3, [r2, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011960:	d02d      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8011962:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
 8011966:	6813      	ldr	r3, [r2, #0]
    hcchar.b.chen = 0;
 8011968:	f36f 73df 	bfc	r3, #31, #1
    hcchar.b.chdis = 1;
 801196c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011970:	f36f 33cf 	bfc	r3, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011974:	290c      	cmp	r1, #12
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 8011976:	6013      	str	r3, [r2, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011978:	d021      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 801197a:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 801197e:	6813      	ldr	r3, [r2, #0]
    hcchar.b.chen = 0;
 8011980:	f36f 73df 	bfc	r3, #31, #1
    hcchar.b.chdis = 1;
 8011984:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8011988:	f36f 33cf 	bfc	r3, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801198c:	290d      	cmp	r1, #13
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 801198e:	6013      	str	r3, [r2, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8011990:	d015      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8011992:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
 8011996:	6813      	ldr	r3, [r2, #0]
    hcchar.b.chen = 0;
 8011998:	f36f 73df 	bfc	r3, #31, #1
    hcchar.b.chdis = 1;
 801199c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 80119a0:	f36f 33cf 	bfc	r3, #15, #1
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80119a4:	290e      	cmp	r1, #14
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 80119a6:	6013      	str	r3, [r2, #0]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80119a8:	d009      	beq.n	80119be <USB_OTG_StopHost+0x186>
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 80119aa:	f8d4 20c8 	ldr.w	r2, [r4, #200]	; 0xc8
 80119ae:	6813      	ldr	r3, [r2, #0]
    hcchar.b.chen = 0;
 80119b0:	f36f 73df 	bfc	r3, #31, #1
    hcchar.b.chdis = 1;
 80119b4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 80119b8:	f36f 33cf 	bfc	r3, #15, #1
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 80119bc:	6013      	str	r3, [r2, #0]
  greset.d32 = 0;
 80119be:	2300      	movs	r3, #0
 80119c0:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 80119c2:	9a01      	ldr	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 80119c4:	68e1      	ldr	r1, [r4, #12]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80119c6:	4b18      	ldr	r3, [pc, #96]	; (8011a28 <USB_OTG_StopHost+0x1f0>)
  greset.b.rxfflsh = 1;
 80119c8:	f042 0210 	orr.w	r2, r2, #16
 80119cc:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 80119ce:	9a01      	ldr	r2, [sp, #4]
 80119d0:	610a      	str	r2, [r1, #16]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80119d2:	690a      	ldr	r2, [r1, #16]
 80119d4:	9201      	str	r2, [sp, #4]
 80119d6:	e003      	b.n	80119e0 <USB_OTG_StopHost+0x1a8>
 80119d8:	690a      	ldr	r2, [r1, #16]
 80119da:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 80119dc:	3b01      	subs	r3, #1
 80119de:	d002      	beq.n	80119e6 <USB_OTG_StopHost+0x1ae>
  while (greset.b.rxfflsh == 1);
 80119e0:	9a01      	ldr	r2, [sp, #4]
 80119e2:	06d0      	lsls	r0, r2, #27
 80119e4:	d4f8      	bmi.n	80119d8 <USB_OTG_StopHost+0x1a0>
  USB_OTG_BSP_uDelay(3);
 80119e6:	2003      	movs	r0, #3
 80119e8:	f7ff f922 	bl	8010c30 <USB_OTG_BSP_uDelay>
  greset.d32 = 0;
 80119ec:	2300      	movs	r3, #0
 80119ee:	9300      	str	r3, [sp, #0]
  greset.b.txfflsh = 1;
 80119f0:	9a00      	ldr	r2, [sp, #0]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 80119f2:	68e1      	ldr	r1, [r4, #12]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80119f4:	4b0c      	ldr	r3, [pc, #48]	; (8011a28 <USB_OTG_StopHost+0x1f0>)
  greset.b.txfflsh = 1;
 80119f6:	f042 0220 	orr.w	r2, r2, #32
 80119fa:	9200      	str	r2, [sp, #0]
  greset.b.txfnum  = num;
 80119fc:	9a00      	ldr	r2, [sp, #0]
 80119fe:	2010      	movs	r0, #16
 8011a00:	f360 128a 	bfi	r2, r0, #6, #5
 8011a04:	9200      	str	r2, [sp, #0]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8011a06:	9a00      	ldr	r2, [sp, #0]
 8011a08:	610a      	str	r2, [r1, #16]
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 8011a0a:	690a      	ldr	r2, [r1, #16]
 8011a0c:	9200      	str	r2, [sp, #0]
 8011a0e:	e003      	b.n	8011a18 <USB_OTG_StopHost+0x1e0>
 8011a10:	690a      	ldr	r2, [r1, #16]
 8011a12:	9200      	str	r2, [sp, #0]
    if (++count > 200000)
 8011a14:	3b01      	subs	r3, #1
 8011a16:	d002      	beq.n	8011a1e <USB_OTG_StopHost+0x1e6>
  while (greset.b.txfflsh == 1);
 8011a18:	9a00      	ldr	r2, [sp, #0]
 8011a1a:	0692      	lsls	r2, r2, #26
 8011a1c:	d4f8      	bmi.n	8011a10 <USB_OTG_StopHost+0x1d8>
  USB_OTG_BSP_uDelay(3);
 8011a1e:	2003      	movs	r0, #3
 8011a20:	f7ff f906 	bl	8010c30 <USB_OTG_BSP_uDelay>
  }
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
}
 8011a24:	b002      	add	sp, #8
 8011a26:	bd10      	pop	{r4, pc}
 8011a28:	00030d40 	.word	0x00030d40

08011a2c <HCD_Init>:


//--------------------------------------------------------------
uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
                  USB_OTG_CORE_ID_TypeDef coreID)
{
 8011a2c:	b538      	push	{r3, r4, r5, lr}
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
 8011a2e:	2500      	movs	r5, #0
  {
  pdev->host.ErrCnt[i]  = 0;
  pdev->host.XferCnt[i]   = 0;
  pdev->host.HC_Status[i]   = HC_IDLE;
  }
  pdev->host.hc[0].max_packet  = 8; 
 8011a30:	2308      	movs	r3, #8
  pdev->host.ConnSts = 0;
 8011a32:	f8c0 5210 	str.w	r5, [r0, #528]	; 0x210
{
 8011a36:	4604      	mov	r4, r0
  pdev->host.ErrCnt[i]  = 0;
 8011a38:	f8c0 5214 	str.w	r5, [r0, #532]	; 0x214
  pdev->host.XferCnt[i]   = 0;
 8011a3c:	f8c0 5250 	str.w	r5, [r0, #592]	; 0x250
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a40:	f880 528c 	strb.w	r5, [r0, #652]	; 0x28c
  pdev->host.ErrCnt[i]  = 0;
 8011a44:	f8c0 5218 	str.w	r5, [r0, #536]	; 0x218
  pdev->host.XferCnt[i]   = 0;
 8011a48:	f8c0 5254 	str.w	r5, [r0, #596]	; 0x254
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a4c:	f880 528d 	strb.w	r5, [r0, #653]	; 0x28d
  pdev->host.ErrCnt[i]  = 0;
 8011a50:	f8c0 521c 	str.w	r5, [r0, #540]	; 0x21c
  pdev->host.XferCnt[i]   = 0;
 8011a54:	f8c0 5258 	str.w	r5, [r0, #600]	; 0x258
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a58:	f880 528e 	strb.w	r5, [r0, #654]	; 0x28e
  pdev->host.ErrCnt[i]  = 0;
 8011a5c:	f8c0 5220 	str.w	r5, [r0, #544]	; 0x220
  pdev->host.XferCnt[i]   = 0;
 8011a60:	f8c0 525c 	str.w	r5, [r0, #604]	; 0x25c
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a64:	f880 528f 	strb.w	r5, [r0, #655]	; 0x28f
  pdev->host.ErrCnt[i]  = 0;
 8011a68:	f8c0 5224 	str.w	r5, [r0, #548]	; 0x224
  pdev->host.XferCnt[i]   = 0;
 8011a6c:	f8c0 5260 	str.w	r5, [r0, #608]	; 0x260
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a70:	f880 5290 	strb.w	r5, [r0, #656]	; 0x290
  pdev->host.ErrCnt[i]  = 0;
 8011a74:	f8c0 5228 	str.w	r5, [r0, #552]	; 0x228
  pdev->host.XferCnt[i]   = 0;
 8011a78:	f8c0 5264 	str.w	r5, [r0, #612]	; 0x264
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a7c:	f880 5291 	strb.w	r5, [r0, #657]	; 0x291
  pdev->host.ErrCnt[i]  = 0;
 8011a80:	f8c0 522c 	str.w	r5, [r0, #556]	; 0x22c
  pdev->host.XferCnt[i]   = 0;
 8011a84:	f8c0 5268 	str.w	r5, [r0, #616]	; 0x268
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a88:	f880 5292 	strb.w	r5, [r0, #658]	; 0x292
  pdev->host.ErrCnt[i]  = 0;
 8011a8c:	f8c0 5230 	str.w	r5, [r0, #560]	; 0x230
  pdev->host.XferCnt[i]   = 0;
 8011a90:	f8c0 526c 	str.w	r5, [r0, #620]	; 0x26c
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011a94:	f880 5293 	strb.w	r5, [r0, #659]	; 0x293
  pdev->host.ErrCnt[i]  = 0;
 8011a98:	f8c0 5234 	str.w	r5, [r0, #564]	; 0x234
  pdev->host.XferCnt[i]   = 0;
 8011a9c:	f8c0 5270 	str.w	r5, [r0, #624]	; 0x270
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011aa0:	f880 5294 	strb.w	r5, [r0, #660]	; 0x294
  pdev->host.ErrCnt[i]  = 0;
 8011aa4:	f8c0 5238 	str.w	r5, [r0, #568]	; 0x238
  pdev->host.XferCnt[i]   = 0;
 8011aa8:	f8c0 5274 	str.w	r5, [r0, #628]	; 0x274
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011aac:	f880 5295 	strb.w	r5, [r0, #661]	; 0x295
  pdev->host.ErrCnt[i]  = 0;
 8011ab0:	f8c0 523c 	str.w	r5, [r0, #572]	; 0x23c
  pdev->host.XferCnt[i]   = 0;
 8011ab4:	f8c0 5278 	str.w	r5, [r0, #632]	; 0x278
  pdev->host.hc[0].max_packet  = 8; 
 8011ab8:	f8a0 32b2 	strh.w	r3, [r0, #690]	; 0x2b2
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011abc:	f880 5296 	strb.w	r5, [r0, #662]	; 0x296
  pdev->host.ErrCnt[i]  = 0;
 8011ac0:	f8c0 5240 	str.w	r5, [r0, #576]	; 0x240
  pdev->host.XferCnt[i]   = 0;
 8011ac4:	f8c0 527c 	str.w	r5, [r0, #636]	; 0x27c
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011ac8:	f880 5297 	strb.w	r5, [r0, #663]	; 0x297
  pdev->host.ErrCnt[i]  = 0;
 8011acc:	f8c0 5244 	str.w	r5, [r0, #580]	; 0x244
  pdev->host.XferCnt[i]   = 0;
 8011ad0:	f8c0 5280 	str.w	r5, [r0, #640]	; 0x280
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011ad4:	f880 5298 	strb.w	r5, [r0, #664]	; 0x298
  pdev->host.ErrCnt[i]  = 0;
 8011ad8:	f8c0 5248 	str.w	r5, [r0, #584]	; 0x248
  pdev->host.XferCnt[i]   = 0;
 8011adc:	f8c0 5284 	str.w	r5, [r0, #644]	; 0x284
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011ae0:	f880 5299 	strb.w	r5, [r0, #665]	; 0x299
  pdev->host.ErrCnt[i]  = 0;
 8011ae4:	f8c0 524c 	str.w	r5, [r0, #588]	; 0x24c
  pdev->host.XferCnt[i]   = 0;
 8011ae8:	f8c0 5288 	str.w	r5, [r0, #648]	; 0x288
  pdev->host.HC_Status[i]   = HC_IDLE;
 8011aec:	f880 529a 	strb.w	r5, [r0, #666]	; 0x29a

  USB_OTG_SelectCore(pdev, coreID);
 8011af0:	f7ff f8fa 	bl	8010ce8 <USB_OTG_SelectCore>

  USB_OTG_DisableGlobalInt(pdev);
 8011af4:	4620      	mov	r0, r4
 8011af6:	f7ff fb71 	bl	80111dc <USB_OTG_DisableGlobalInt>
  USB_OTG_CoreInit(pdev);
 8011afa:	4620      	mov	r0, r4
 8011afc:	f7ff fa9e 	bl	801103c <USB_OTG_CoreInit>

  /* Force Host Mode*/
  USB_OTG_SetCurrentMode(pdev , HOST_MODE);
 8011b00:	2101      	movs	r1, #1
 8011b02:	4620      	mov	r0, r4
 8011b04:	f7ff fbb6 	bl	8011274 <USB_OTG_SetCurrentMode>
  USB_OTG_CoreInitHost(pdev);
 8011b08:	4620      	mov	r0, r4
 8011b0a:	f7ff fbe5 	bl	80112d8 <USB_OTG_CoreInitHost>
  USB_OTG_EnableGlobalInt(pdev);
 8011b0e:	4620      	mov	r0, r4
 8011b10:	f7ff fb5c 	bl	80111cc <USB_OTG_EnableGlobalInt>

   
  return 0;
}
 8011b14:	4628      	mov	r0, r5
 8011b16:	bd38      	pop	{r3, r4, r5, pc}

08011b18 <HCD_GetCurrentSpeed>:

//--------------------------------------------------------------
uint32_t HCD_GetCurrentSpeed (USB_OTG_CORE_HANDLE *pdev)
{    
    USB_OTG_HPRT0_TypeDef  HPRT0;
    HPRT0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8011b18:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
 8011b1c:	6818      	ldr	r0, [r3, #0]
    
    return HPRT0.b.prtspd;
}
 8011b1e:	f3c0 4041 	ubfx	r0, r0, #17, #2
 8011b22:	4770      	bx	lr

08011b24 <HCD_ResetPort>:

//--------------------------------------------------------------
uint32_t HCD_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 8011b24:	b508      	push	{r3, lr}
  interrupt triggered by the debounce done bit (DBCDNE bit in OTG_FS_GOTGINT), 
  which indicates that the bus is stable again after the electrical debounce 
  caused by the attachment of a pull-up resistor on DP (FS) or DM (LS).
  */
  
  USB_OTG_ResetPort(pdev); 
 8011b26:	f7ff fd27 	bl	8011578 <USB_OTG_ResetPort>
  return 0;
}
 8011b2a:	2000      	movs	r0, #0
 8011b2c:	bd08      	pop	{r3, pc}
 8011b2e:	bf00      	nop

08011b30 <HCD_IsDeviceConnected>:

//--------------------------------------------------------------
uint32_t HCD_IsDeviceConnected(USB_OTG_CORE_HANDLE *pdev)
{
  return (pdev->host.ConnSts);
 8011b30:	f8d0 0210 	ldr.w	r0, [r0, #528]	; 0x210
}
 8011b34:	4770      	bx	lr
 8011b36:	bf00      	nop

08011b38 <HCD_GetCurrentFrame>:

//--------------------------------------------------------------
uint32_t HCD_GetCurrentFrame (USB_OTG_CORE_HANDLE *pdev) 
{
 return (USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0xFFFF) ;
 8011b38:	6943      	ldr	r3, [r0, #20]
 8011b3a:	6898      	ldr	r0, [r3, #8]
}
 8011b3c:	b280      	uxth	r0, r0
 8011b3e:	4770      	bx	lr

08011b40 <HCD_GetURB_State>:

//--------------------------------------------------------------
URB_STATE HCD_GetURB_State (USB_OTG_CORE_HANDLE *pdev , uint8_t ch_num) 
{
  return pdev->host.URB_State[ch_num] ;
 8011b40:	4401      	add	r1, r0
 8011b42:	f891 029b 	ldrb.w	r0, [r1, #667]	; 0x29b
}
 8011b46:	4770      	bx	lr

08011b48 <HCD_GetXferCnt>:

//--------------------------------------------------------------
uint32_t HCD_GetXferCnt (USB_OTG_CORE_HANDLE *pdev, uint8_t ch_num) 
{
  return pdev->host.XferCnt[ch_num] ;
 8011b48:	3194      	adds	r1, #148	; 0x94
 8011b4a:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
}
 8011b4e:	4770      	bx	lr

08011b50 <HCD_GetHCState>:


//--------------------------------------------------------------
HC_STATUS HCD_GetHCState (USB_OTG_CORE_HANDLE *pdev ,  uint8_t ch_num) 
{
  return pdev->host.HC_Status[ch_num] ;
 8011b50:	4401      	add	r1, r0
 8011b52:	f891 028c 	ldrb.w	r0, [r1, #652]	; 0x28c
}
 8011b56:	4770      	bx	lr

08011b58 <HCD_HC_Init>:

//--------------------------------------------------------------
uint32_t HCD_HC_Init (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 8011b58:	b508      	push	{r3, lr}
  return USB_OTG_HC_Init(pdev, hc_num);  
 8011b5a:	f7ff fd2b 	bl	80115b4 <USB_OTG_HC_Init>
}
 8011b5e:	bd08      	pop	{r3, pc}

08011b60 <HCD_SubmitRequest>:

//--------------------------------------------------------------
uint32_t HCD_SubmitRequest (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 8011b60:	b510      	push	{r4, lr}
  
  pdev->host.URB_State[hc_num] =   URB_IDLE;  
  pdev->host.hc[hc_num].xfer_count = 0 ;
 8011b62:	eb00 1341 	add.w	r3, r0, r1, lsl #5
  pdev->host.URB_State[hc_num] =   URB_IDLE;  
 8011b66:	1844      	adds	r4, r0, r1
 8011b68:	2200      	movs	r2, #0
 8011b6a:	f884 229b 	strb.w	r2, [r4, #667]	; 0x29b
  pdev->host.hc[hc_num].xfer_count = 0 ;
 8011b6e:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
  return USB_OTG_HC_StartXfer(pdev, hc_num);
 8011b72:	f7ff fd9d 	bl	80116b0 <USB_OTG_HC_StartXfer>
}
 8011b76:	bd10      	pop	{r4, pc}

08011b78 <USBH_OTG_ISR_Handler>:
static uint32_t USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (USB_OTG_CORE_HANDLE *pdev);


//--------------------------------------------------------------
uint32_t USBH_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 8011b78:	b580      	push	{r7, lr}
 8011b7a:	b084      	sub	sp, #16
 8011b7c:	af00      	add	r7, sp, #0
 8011b7e:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t retval = 0;
 8011b80:	2300      	movs	r3, #0
 8011b82:	60fb      	str	r3, [r7, #12]
  
  gintsts.d32 = 0;
 8011b84:	2300      	movs	r3, #0
 8011b86:	60bb      	str	r3, [r7, #8]
  
  /* Check if HOST Mode */
  if (USB_OTG_IsHostMode(pdev))
 8011b88:	6878      	ldr	r0, [r7, #4]
 8011b8a:	f7ff fb95 	bl	80112b8 <USB_OTG_IsHostMode>
 8011b8e:	4603      	mov	r3, r0
 8011b90:	2b00      	cmp	r3, #0
 8011b92:	d071      	beq.n	8011c78 <USBH_OTG_ISR_Handler+0x100>
  {
    gintsts.d32 = USB_OTG_ReadCoreItr(pdev);
 8011b94:	6878      	ldr	r0, [r7, #4]
 8011b96:	f7ff fb95 	bl	80112c4 <USB_OTG_ReadCoreItr>
 8011b9a:	4603      	mov	r3, r0
 8011b9c:	60bb      	str	r3, [r7, #8]
    if (!gintsts.d32)
 8011b9e:	68bb      	ldr	r3, [r7, #8]
 8011ba0:	2b00      	cmp	r3, #0
 8011ba2:	d101      	bne.n	8011ba8 <USBH_OTG_ISR_Handler+0x30>
    {
      return 0;
 8011ba4:	2300      	movs	r3, #0
 8011ba6:	e068      	b.n	8011c7a <USBH_OTG_ISR_Handler+0x102>
    }
    
    if (gintsts.b.sofintr)
 8011ba8:	7a3b      	ldrb	r3, [r7, #8]
 8011baa:	f003 0308 	and.w	r3, r3, #8
 8011bae:	b2db      	uxtb	r3, r3
 8011bb0:	2b00      	cmp	r3, #0
 8011bb2:	d006      	beq.n	8011bc2 <USBH_OTG_ISR_Handler+0x4a>
    {
      retval |= USB_OTG_USBH_handle_sof_ISR (pdev);
 8011bb4:	6878      	ldr	r0, [r7, #4]
 8011bb6:	f000 f8aa 	bl	8011d0e <USB_OTG_USBH_handle_sof_ISR>
 8011bba:	4602      	mov	r2, r0
 8011bbc:	68fb      	ldr	r3, [r7, #12]
 8011bbe:	4313      	orrs	r3, r2
 8011bc0:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.rxstsqlvl)
 8011bc2:	7a3b      	ldrb	r3, [r7, #8]
 8011bc4:	f003 0310 	and.w	r3, r3, #16
 8011bc8:	b2db      	uxtb	r3, r3
 8011bca:	2b00      	cmp	r3, #0
 8011bcc:	d006      	beq.n	8011bdc <USBH_OTG_ISR_Handler+0x64>
    {
      retval |= USB_OTG_USBH_handle_rx_qlvl_ISR (pdev);
 8011bce:	6878      	ldr	r0, [r7, #4]
 8011bd0:	f001 f856 	bl	8012c80 <USB_OTG_USBH_handle_rx_qlvl_ISR>
 8011bd4:	4602      	mov	r2, r0
 8011bd6:	68fb      	ldr	r3, [r7, #12]
 8011bd8:	4313      	orrs	r3, r2
 8011bda:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.nptxfempty)
 8011bdc:	7a3b      	ldrb	r3, [r7, #8]
 8011bde:	f003 0320 	and.w	r3, r3, #32
 8011be2:	b2db      	uxtb	r3, r3
 8011be4:	2b00      	cmp	r3, #0
 8011be6:	d006      	beq.n	8011bf6 <USBH_OTG_ISR_Handler+0x7e>
    {
      retval |= USB_OTG_USBH_handle_nptxfempty_ISR (pdev);
 8011be8:	6878      	ldr	r0, [r7, #4]
 8011bea:	f000 f8c2 	bl	8011d72 <USB_OTG_USBH_handle_nptxfempty_ISR>
 8011bee:	4602      	mov	r2, r0
 8011bf0:	68fb      	ldr	r3, [r7, #12]
 8011bf2:	4313      	orrs	r3, r2
 8011bf4:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.ptxfempty)
 8011bf6:	7afb      	ldrb	r3, [r7, #11]
 8011bf8:	f003 0304 	and.w	r3, r3, #4
 8011bfc:	b2db      	uxtb	r3, r3
 8011bfe:	2b00      	cmp	r3, #0
 8011c00:	d006      	beq.n	8011c10 <USBH_OTG_ISR_Handler+0x98>
    {
      retval |= USB_OTG_USBH_handle_ptxfempty_ISR (pdev);
 8011c02:	6878      	ldr	r0, [r7, #4]
 8011c04:	f000 f978 	bl	8011ef8 <USB_OTG_USBH_handle_ptxfempty_ISR>
 8011c08:	4602      	mov	r2, r0
 8011c0a:	68fb      	ldr	r3, [r7, #12]
 8011c0c:	4313      	orrs	r3, r2
 8011c0e:	60fb      	str	r3, [r7, #12]
    }    
    
    if (gintsts.b.hcintr)
 8011c10:	7afb      	ldrb	r3, [r7, #11]
 8011c12:	f003 0302 	and.w	r3, r3, #2
 8011c16:	b2db      	uxtb	r3, r3
 8011c18:	2b00      	cmp	r3, #0
 8011c1a:	d006      	beq.n	8011c2a <USBH_OTG_ISR_Handler+0xb2>
    {
      retval |= USB_OTG_USBH_handle_hc_ISR (pdev);
 8011c1c:	6878      	ldr	r0, [r7, #4]
 8011c1e:	f000 f830 	bl	8011c82 <USB_OTG_USBH_handle_hc_ISR>
 8011c22:	4602      	mov	r2, r0
 8011c24:	68fb      	ldr	r3, [r7, #12]
 8011c26:	4313      	orrs	r3, r2
 8011c28:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.portintr)
 8011c2a:	7afb      	ldrb	r3, [r7, #11]
 8011c2c:	f003 0301 	and.w	r3, r3, #1
 8011c30:	b2db      	uxtb	r3, r3
 8011c32:	2b00      	cmp	r3, #0
 8011c34:	d006      	beq.n	8011c44 <USBH_OTG_ISR_Handler+0xcc>
    {
      retval |= USB_OTG_USBH_handle_port_ISR (pdev);
 8011c36:	6878      	ldr	r0, [r7, #4]
 8011c38:	f000 fa21 	bl	801207e <USB_OTG_USBH_handle_port_ISR>
 8011c3c:	4602      	mov	r2, r0
 8011c3e:	68fb      	ldr	r3, [r7, #12]
 8011c40:	4313      	orrs	r3, r2
 8011c42:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.disconnect)
 8011c44:	7afb      	ldrb	r3, [r7, #11]
 8011c46:	f003 0320 	and.w	r3, r3, #32
 8011c4a:	b2db      	uxtb	r3, r3
 8011c4c:	2b00      	cmp	r3, #0
 8011c4e:	d006      	beq.n	8011c5e <USBH_OTG_ISR_Handler+0xe6>
    {
      retval |= USB_OTG_USBH_handle_Disconnect_ISR (pdev);  
 8011c50:	6878      	ldr	r0, [r7, #4]
 8011c52:	f000 f871 	bl	8011d38 <USB_OTG_USBH_handle_Disconnect_ISR>
 8011c56:	4602      	mov	r2, r0
 8011c58:	68fb      	ldr	r3, [r7, #12]
 8011c5a:	4313      	orrs	r3, r2
 8011c5c:	60fb      	str	r3, [r7, #12]
      
    }
    
     if (gintsts.b.incomplisoout)
 8011c5e:	7abb      	ldrb	r3, [r7, #10]
 8011c60:	f003 0320 	and.w	r3, r3, #32
 8011c64:	b2db      	uxtb	r3, r3
 8011c66:	2b00      	cmp	r3, #0
 8011c68:	d006      	beq.n	8011c78 <USBH_OTG_ISR_Handler+0x100>
      {
         retval |= USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (pdev);
 8011c6a:	6878      	ldr	r0, [r7, #4]
 8011c6c:	f001 f8d3 	bl	8012e16 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>
 8011c70:	4602      	mov	r2, r0
 8011c72:	68fb      	ldr	r3, [r7, #12]
 8011c74:	4313      	orrs	r3, r2
 8011c76:	60fb      	str	r3, [r7, #12]
      }
      
    
  }
  return retval;
 8011c78:	68fb      	ldr	r3, [r7, #12]
}
 8011c7a:	4618      	mov	r0, r3
 8011c7c:	3710      	adds	r7, #16
 8011c7e:	46bd      	mov	sp, r7
 8011c80:	bd80      	pop	{r7, pc}

08011c82 <USB_OTG_USBH_handle_hc_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_hc_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8011c82:	b580      	push	{r7, lr}
 8011c84:	b086      	sub	sp, #24
 8011c86:	af00      	add	r7, sp, #0
 8011c88:	6078      	str	r0, [r7, #4]
  USB_OTG_HAINT_TypeDef        haint;
  USB_OTG_HCCHAR_TypeDef       hcchar;
  uint32_t i = 0;
 8011c8a:	2300      	movs	r3, #0
 8011c8c:	617b      	str	r3, [r7, #20]
  uint32_t retval = 0;
 8011c8e:	2300      	movs	r3, #0
 8011c90:	613b      	str	r3, [r7, #16]
  
  /* Clear appropriate bits in HCINTn to clear the interrupt bit in
  * GINTSTS */
  
  haint.d32 = USB_OTG_ReadHostAllChannels_intr(pdev);
 8011c92:	6878      	ldr	r0, [r7, #4]
 8011c94:	f7ff fc6c 	bl	8011570 <USB_OTG_ReadHostAllChannels_intr>
 8011c98:	4603      	mov	r3, r0
 8011c9a:	60fb      	str	r3, [r7, #12]
  
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 8011c9c:	2300      	movs	r3, #0
 8011c9e:	617b      	str	r3, [r7, #20]
 8011ca0:	e02a      	b.n	8011cf8 <USB_OTG_USBH_handle_hc_ISR+0x76>
  {
    if (haint.b.chint & (1 << i))
 8011ca2:	89bb      	ldrh	r3, [r7, #12]
 8011ca4:	461a      	mov	r2, r3
 8011ca6:	697b      	ldr	r3, [r7, #20]
 8011ca8:	fa42 f303 	asr.w	r3, r2, r3
 8011cac:	f003 0301 	and.w	r3, r3, #1
 8011cb0:	2b00      	cmp	r3, #0
 8011cb2:	d01e      	beq.n	8011cf2 <USB_OTG_USBH_handle_hc_ISR+0x70>
    {
      hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8011cb4:	687a      	ldr	r2, [r7, #4]
 8011cb6:	697b      	ldr	r3, [r7, #20]
 8011cb8:	3322      	adds	r3, #34	; 0x22
 8011cba:	009b      	lsls	r3, r3, #2
 8011cbc:	4413      	add	r3, r2
 8011cbe:	689b      	ldr	r3, [r3, #8]
 8011cc0:	681b      	ldr	r3, [r3, #0]
 8011cc2:	60bb      	str	r3, [r7, #8]
      
      if (hcchar.b.epdir)
 8011cc4:	7a7b      	ldrb	r3, [r7, #9]
 8011cc6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8011cca:	b2db      	uxtb	r3, r3
 8011ccc:	2b00      	cmp	r3, #0
 8011cce:	d008      	beq.n	8011ce2 <USB_OTG_USBH_handle_hc_ISR+0x60>
      {
        retval |= USB_OTG_USBH_handle_hc_n_In_ISR (pdev, i);
 8011cd0:	6979      	ldr	r1, [r7, #20]
 8011cd2:	6878      	ldr	r0, [r7, #4]
 8011cd4:	f000 fcfd 	bl	80126d2 <USB_OTG_USBH_handle_hc_n_In_ISR>
 8011cd8:	4602      	mov	r2, r0
 8011cda:	693b      	ldr	r3, [r7, #16]
 8011cdc:	4313      	orrs	r3, r2
 8011cde:	613b      	str	r3, [r7, #16]
 8011ce0:	e007      	b.n	8011cf2 <USB_OTG_USBH_handle_hc_ISR+0x70>
      }
      else
      {
        retval |=  USB_OTG_USBH_handle_hc_n_Out_ISR (pdev, i);
 8011ce2:	6979      	ldr	r1, [r7, #20]
 8011ce4:	6878      	ldr	r0, [r7, #4]
 8011ce6:	f000 fa7c 	bl	80121e2 <USB_OTG_USBH_handle_hc_n_Out_ISR>
 8011cea:	4602      	mov	r2, r0
 8011cec:	693b      	ldr	r3, [r7, #16]
 8011cee:	4313      	orrs	r3, r2
 8011cf0:	613b      	str	r3, [r7, #16]
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 8011cf2:	697b      	ldr	r3, [r7, #20]
 8011cf4:	3301      	adds	r3, #1
 8011cf6:	617b      	str	r3, [r7, #20]
 8011cf8:	687b      	ldr	r3, [r7, #4]
 8011cfa:	781b      	ldrb	r3, [r3, #0]
 8011cfc:	461a      	mov	r2, r3
 8011cfe:	697b      	ldr	r3, [r7, #20]
 8011d00:	429a      	cmp	r2, r3
 8011d02:	d8ce      	bhi.n	8011ca2 <USB_OTG_USBH_handle_hc_ISR+0x20>
      }
    }
  }
  
  return retval;
 8011d04:	693b      	ldr	r3, [r7, #16]
}
 8011d06:	4618      	mov	r0, r3
 8011d08:	3718      	adds	r7, #24
 8011d0a:	46bd      	mov	sp, r7
 8011d0c:	bd80      	pop	{r7, pc}

08011d0e <USB_OTG_USBH_handle_sof_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_sof_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8011d0e:	b480      	push	{r7}
 8011d10:	b085      	sub	sp, #20
 8011d12:	af00      	add	r7, sp, #0
 8011d14:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  
  
  gintsts.d32 = 0;
 8011d16:	2300      	movs	r3, #0
 8011d18:	60fb      	str	r3, [r7, #12]
  /* Clear interrupt */
  gintsts.b.sofintr = 1;
 8011d1a:	7b3b      	ldrb	r3, [r7, #12]
 8011d1c:	f043 0308 	orr.w	r3, r3, #8
 8011d20:	733b      	strb	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8011d22:	687b      	ldr	r3, [r7, #4]
 8011d24:	68db      	ldr	r3, [r3, #12]
 8011d26:	68fa      	ldr	r2, [r7, #12]
 8011d28:	615a      	str	r2, [r3, #20]
  
  return 1;
 8011d2a:	2301      	movs	r3, #1
}
 8011d2c:	4618      	mov	r0, r3
 8011d2e:	3714      	adds	r7, #20
 8011d30:	46bd      	mov	sp, r7
 8011d32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d36:	4770      	bx	lr

08011d38 <USB_OTG_USBH_handle_Disconnect_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_Disconnect_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8011d38:	b580      	push	{r7, lr}
 8011d3a:	b084      	sub	sp, #16
 8011d3c:	af00      	add	r7, sp, #0
 8011d3e:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  
  pdev->host.ConnSts = 0;
 8011d40:	687b      	ldr	r3, [r7, #4]
 8011d42:	2200      	movs	r2, #0
 8011d44:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  gintsts.d32 = 0;
 8011d48:	2300      	movs	r3, #0
 8011d4a:	60fb      	str	r3, [r7, #12]
  
  pdev->host.port_cb->Disconnect(pdev);
 8011d4c:	687b      	ldr	r3, [r7, #4]
 8011d4e:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8011d52:	681b      	ldr	r3, [r3, #0]
 8011d54:	6878      	ldr	r0, [r7, #4]
 8011d56:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.disconnect = 1;
 8011d58:	7bfb      	ldrb	r3, [r7, #15]
 8011d5a:	f043 0320 	orr.w	r3, r3, #32
 8011d5e:	73fb      	strb	r3, [r7, #15]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8011d60:	687b      	ldr	r3, [r7, #4]
 8011d62:	68db      	ldr	r3, [r3, #12]
 8011d64:	68fa      	ldr	r2, [r7, #12]
 8011d66:	615a      	str	r2, [r3, #20]
  
  return 1;
 8011d68:	2301      	movs	r3, #1
}
 8011d6a:	4618      	mov	r0, r3
 8011d6c:	3710      	adds	r7, #16
 8011d6e:	46bd      	mov	sp, r7
 8011d70:	bd80      	pop	{r7, pc}

08011d72 <USB_OTG_USBH_handle_nptxfempty_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_nptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8011d72:	b580      	push	{r7, lr}
 8011d74:	b086      	sub	sp, #24
 8011d76:	af00      	add	r7, sp, #0
 8011d78:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HNPTXSTS_TypeDef     hnptxsts; 
  uint16_t                     len_words , len; 
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 8011d7a:	687b      	ldr	r3, [r7, #4]
 8011d7c:	68db      	ldr	r3, [r3, #12]
 8011d7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011d80:	60fb      	str	r3, [r7, #12]
  
  len_words = (pdev->host.hc[hnptxsts.b.chnum].xfer_len + 3) / 4;
 8011d82:	7bfb      	ldrb	r3, [r7, #15]
 8011d84:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011d88:	b2db      	uxtb	r3, r3
 8011d8a:	687a      	ldr	r2, [r7, #4]
 8011d8c:	015b      	lsls	r3, r3, #5
 8011d8e:	4413      	add	r3, r2
 8011d90:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011d94:	681b      	ldr	r3, [r3, #0]
 8011d96:	3303      	adds	r3, #3
 8011d98:	089b      	lsrs	r3, r3, #2
 8011d9a:	82fb      	strh	r3, [r7, #22]
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 8011d9c:	e096      	b.n	8011ecc <USB_OTG_USBH_handle_nptxfempty_ISR+0x15a>
      (pdev->host.hc[hnptxsts.b.chnum].xfer_len != 0))
  {
    
    len = hnptxsts.b.nptxfspcavail * 4;
 8011d9e:	89bb      	ldrh	r3, [r7, #12]
 8011da0:	009b      	lsls	r3, r3, #2
 8011da2:	82bb      	strh	r3, [r7, #20]
    
    if (len > pdev->host.hc[hnptxsts.b.chnum].xfer_len)
 8011da4:	8aba      	ldrh	r2, [r7, #20]
 8011da6:	7bfb      	ldrb	r3, [r7, #15]
 8011da8:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011dac:	b2db      	uxtb	r3, r3
 8011dae:	6879      	ldr	r1, [r7, #4]
 8011db0:	015b      	lsls	r3, r3, #5
 8011db2:	440b      	add	r3, r1
 8011db4:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011db8:	681b      	ldr	r3, [r3, #0]
 8011dba:	429a      	cmp	r2, r3
 8011dbc:	d919      	bls.n	8011df2 <USB_OTG_USBH_handle_nptxfempty_ISR+0x80>
    {
      /* Last packet */
      len = pdev->host.hc[hnptxsts.b.chnum].xfer_len;
 8011dbe:	7bfb      	ldrb	r3, [r7, #15]
 8011dc0:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011dc4:	b2db      	uxtb	r3, r3
 8011dc6:	687a      	ldr	r2, [r7, #4]
 8011dc8:	015b      	lsls	r3, r3, #5
 8011dca:	4413      	add	r3, r2
 8011dcc:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011dd0:	681b      	ldr	r3, [r3, #0]
 8011dd2:	82bb      	strh	r3, [r7, #20]
      
      intmsk.d32 = 0;
 8011dd4:	2300      	movs	r3, #0
 8011dd6:	613b      	str	r3, [r7, #16]
      intmsk.b.nptxfempty = 1;
 8011dd8:	7c3b      	ldrb	r3, [r7, #16]
 8011dda:	f043 0320 	orr.w	r3, r3, #32
 8011dde:	743b      	strb	r3, [r7, #16]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);       
 8011de0:	687b      	ldr	r3, [r7, #4]
 8011de2:	68db      	ldr	r3, [r3, #12]
 8011de4:	687a      	ldr	r2, [r7, #4]
 8011de6:	68d2      	ldr	r2, [r2, #12]
 8011de8:	6991      	ldr	r1, [r2, #24]
 8011dea:	693a      	ldr	r2, [r7, #16]
 8011dec:	43d2      	mvns	r2, r2
 8011dee:	400a      	ands	r2, r1
 8011df0:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hnptxsts.b.chnum].xfer_len + 3) / 4;
 8011df2:	7bfb      	ldrb	r3, [r7, #15]
 8011df4:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011df8:	b2db      	uxtb	r3, r3
 8011dfa:	687a      	ldr	r2, [r7, #4]
 8011dfc:	015b      	lsls	r3, r3, #5
 8011dfe:	4413      	add	r3, r2
 8011e00:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011e04:	681b      	ldr	r3, [r3, #0]
 8011e06:	3303      	adds	r3, #3
 8011e08:	089b      	lsrs	r3, r3, #2
 8011e0a:	82fb      	strh	r3, [r7, #22]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hnptxsts.b.chnum].xfer_buff, hnptxsts.b.chnum, len);
 8011e0c:	7bfb      	ldrb	r3, [r7, #15]
 8011e0e:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011e12:	b2db      	uxtb	r3, r3
 8011e14:	687a      	ldr	r2, [r7, #4]
 8011e16:	330d      	adds	r3, #13
 8011e18:	015b      	lsls	r3, r3, #5
 8011e1a:	4413      	add	r3, r2
 8011e1c:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8011e20:	6819      	ldr	r1, [r3, #0]
 8011e22:	7bfb      	ldrb	r3, [r7, #15]
 8011e24:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011e28:	b2db      	uxtb	r3, r3
 8011e2a:	461a      	mov	r2, r3
 8011e2c:	8abb      	ldrh	r3, [r7, #20]
 8011e2e:	6878      	ldr	r0, [r7, #4]
 8011e30:	f7fe ff32 	bl	8010c98 <USB_OTG_WritePacket>
    
    pdev->host.hc[hnptxsts.b.chnum].xfer_buff  += len;
 8011e34:	7bfb      	ldrb	r3, [r7, #15]
 8011e36:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011e3a:	b2db      	uxtb	r3, r3
 8011e3c:	4618      	mov	r0, r3
 8011e3e:	7bfb      	ldrb	r3, [r7, #15]
 8011e40:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011e44:	b2db      	uxtb	r3, r3
 8011e46:	687a      	ldr	r2, [r7, #4]
 8011e48:	330d      	adds	r3, #13
 8011e4a:	015b      	lsls	r3, r3, #5
 8011e4c:	4413      	add	r3, r2
 8011e4e:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8011e52:	681a      	ldr	r2, [r3, #0]
 8011e54:	8abb      	ldrh	r3, [r7, #20]
 8011e56:	441a      	add	r2, r3
 8011e58:	6879      	ldr	r1, [r7, #4]
 8011e5a:	f100 030d 	add.w	r3, r0, #13
 8011e5e:	015b      	lsls	r3, r3, #5
 8011e60:	440b      	add	r3, r1
 8011e62:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8011e66:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hnptxsts.b.chnum].xfer_len   -= len;
 8011e68:	7bfb      	ldrb	r3, [r7, #15]
 8011e6a:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011e6e:	b2db      	uxtb	r3, r3
 8011e70:	4618      	mov	r0, r3
 8011e72:	7bfb      	ldrb	r3, [r7, #15]
 8011e74:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011e78:	b2db      	uxtb	r3, r3
 8011e7a:	687a      	ldr	r2, [r7, #4]
 8011e7c:	015b      	lsls	r3, r3, #5
 8011e7e:	4413      	add	r3, r2
 8011e80:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011e84:	681a      	ldr	r2, [r3, #0]
 8011e86:	8abb      	ldrh	r3, [r7, #20]
 8011e88:	1ad2      	subs	r2, r2, r3
 8011e8a:	6879      	ldr	r1, [r7, #4]
 8011e8c:	0143      	lsls	r3, r0, #5
 8011e8e:	440b      	add	r3, r1
 8011e90:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011e94:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hnptxsts.b.chnum].xfer_count  += len; 
 8011e96:	7bfb      	ldrb	r3, [r7, #15]
 8011e98:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011e9c:	b2db      	uxtb	r3, r3
 8011e9e:	4618      	mov	r0, r3
 8011ea0:	7bfb      	ldrb	r3, [r7, #15]
 8011ea2:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011ea6:	b2db      	uxtb	r3, r3
 8011ea8:	687a      	ldr	r2, [r7, #4]
 8011eaa:	015b      	lsls	r3, r3, #5
 8011eac:	4413      	add	r3, r2
 8011eae:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8011eb2:	681a      	ldr	r2, [r3, #0]
 8011eb4:	8abb      	ldrh	r3, [r7, #20]
 8011eb6:	441a      	add	r2, r3
 8011eb8:	6879      	ldr	r1, [r7, #4]
 8011eba:	0143      	lsls	r3, r0, #5
 8011ebc:	440b      	add	r3, r1
 8011ebe:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8011ec2:	601a      	str	r2, [r3, #0]
        
    hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 8011ec4:	687b      	ldr	r3, [r7, #4]
 8011ec6:	68db      	ldr	r3, [r3, #12]
 8011ec8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011eca:	60fb      	str	r3, [r7, #12]
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 8011ecc:	89bb      	ldrh	r3, [r7, #12]
 8011ece:	8afa      	ldrh	r2, [r7, #22]
 8011ed0:	429a      	cmp	r2, r3
 8011ed2:	d20c      	bcs.n	8011eee <USB_OTG_USBH_handle_nptxfempty_ISR+0x17c>
      (pdev->host.hc[hnptxsts.b.chnum].xfer_len != 0))
 8011ed4:	7bfb      	ldrb	r3, [r7, #15]
 8011ed6:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011eda:	b2db      	uxtb	r3, r3
 8011edc:	687a      	ldr	r2, [r7, #4]
 8011ede:	015b      	lsls	r3, r3, #5
 8011ee0:	4413      	add	r3, r2
 8011ee2:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011ee6:	681b      	ldr	r3, [r3, #0]
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 8011ee8:	2b00      	cmp	r3, #0
 8011eea:	f47f af58 	bne.w	8011d9e <USB_OTG_USBH_handle_nptxfempty_ISR+0x2c>
  }  

  return 1;
 8011eee:	2301      	movs	r3, #1
}
 8011ef0:	4618      	mov	r0, r3
 8011ef2:	3718      	adds	r7, #24
 8011ef4:	46bd      	mov	sp, r7
 8011ef6:	bd80      	pop	{r7, pc}

08011ef8 <USB_OTG_USBH_handle_ptxfempty_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_ptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8011ef8:	b580      	push	{r7, lr}
 8011efa:	b086      	sub	sp, #24
 8011efc:	af00      	add	r7, sp, #0
 8011efe:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HPTXSTS_TypeDef      hptxsts; 
  uint16_t                     len_words , len; 
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 8011f00:	687b      	ldr	r3, [r7, #4]
 8011f02:	695b      	ldr	r3, [r3, #20]
 8011f04:	691b      	ldr	r3, [r3, #16]
 8011f06:	60fb      	str	r3, [r7, #12]
  
  len_words = (pdev->host.hc[hptxsts.b.chnum].xfer_len + 3) / 4;
 8011f08:	7bfb      	ldrb	r3, [r7, #15]
 8011f0a:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011f0e:	b2db      	uxtb	r3, r3
 8011f10:	687a      	ldr	r2, [r7, #4]
 8011f12:	015b      	lsls	r3, r3, #5
 8011f14:	4413      	add	r3, r2
 8011f16:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011f1a:	681b      	ldr	r3, [r3, #0]
 8011f1c:	3303      	adds	r3, #3
 8011f1e:	089b      	lsrs	r3, r3, #2
 8011f20:	82fb      	strh	r3, [r7, #22]
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 8011f22:	e096      	b.n	8012052 <USB_OTG_USBH_handle_ptxfempty_ISR+0x15a>
      (pdev->host.hc[hptxsts.b.chnum].xfer_len != 0))    
  {
    
    len = hptxsts.b.ptxfspcavail * 4;
 8011f24:	89bb      	ldrh	r3, [r7, #12]
 8011f26:	009b      	lsls	r3, r3, #2
 8011f28:	82bb      	strh	r3, [r7, #20]
    
    if (len > pdev->host.hc[hptxsts.b.chnum].xfer_len)
 8011f2a:	8aba      	ldrh	r2, [r7, #20]
 8011f2c:	7bfb      	ldrb	r3, [r7, #15]
 8011f2e:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011f32:	b2db      	uxtb	r3, r3
 8011f34:	6879      	ldr	r1, [r7, #4]
 8011f36:	015b      	lsls	r3, r3, #5
 8011f38:	440b      	add	r3, r1
 8011f3a:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011f3e:	681b      	ldr	r3, [r3, #0]
 8011f40:	429a      	cmp	r2, r3
 8011f42:	d919      	bls.n	8011f78 <USB_OTG_USBH_handle_ptxfempty_ISR+0x80>
    {
      len = pdev->host.hc[hptxsts.b.chnum].xfer_len;
 8011f44:	7bfb      	ldrb	r3, [r7, #15]
 8011f46:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011f4a:	b2db      	uxtb	r3, r3
 8011f4c:	687a      	ldr	r2, [r7, #4]
 8011f4e:	015b      	lsls	r3, r3, #5
 8011f50:	4413      	add	r3, r2
 8011f52:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011f56:	681b      	ldr	r3, [r3, #0]
 8011f58:	82bb      	strh	r3, [r7, #20]
      /* Last packet */
      intmsk.d32 = 0;
 8011f5a:	2300      	movs	r3, #0
 8011f5c:	613b      	str	r3, [r7, #16]
      intmsk.b.ptxfempty = 1;
 8011f5e:	7cfb      	ldrb	r3, [r7, #19]
 8011f60:	f043 0304 	orr.w	r3, r3, #4
 8011f64:	74fb      	strb	r3, [r7, #19]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0); 
 8011f66:	687b      	ldr	r3, [r7, #4]
 8011f68:	68db      	ldr	r3, [r3, #12]
 8011f6a:	687a      	ldr	r2, [r7, #4]
 8011f6c:	68d2      	ldr	r2, [r2, #12]
 8011f6e:	6991      	ldr	r1, [r2, #24]
 8011f70:	693a      	ldr	r2, [r7, #16]
 8011f72:	43d2      	mvns	r2, r2
 8011f74:	400a      	ands	r2, r1
 8011f76:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hptxsts.b.chnum].xfer_len + 3) / 4;
 8011f78:	7bfb      	ldrb	r3, [r7, #15]
 8011f7a:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011f7e:	b2db      	uxtb	r3, r3
 8011f80:	687a      	ldr	r2, [r7, #4]
 8011f82:	015b      	lsls	r3, r3, #5
 8011f84:	4413      	add	r3, r2
 8011f86:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 8011f8a:	681b      	ldr	r3, [r3, #0]
 8011f8c:	3303      	adds	r3, #3
 8011f8e:	089b      	lsrs	r3, r3, #2
 8011f90:	82fb      	strh	r3, [r7, #22]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hptxsts.b.chnum].xfer_buff, hptxsts.b.chnum, len);
 8011f92:	7bfb      	ldrb	r3, [r7, #15]
 8011f94:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011f98:	b2db      	uxtb	r3, r3
 8011f9a:	687a      	ldr	r2, [r7, #4]
 8011f9c:	330d      	adds	r3, #13
 8011f9e:	015b      	lsls	r3, r3, #5
 8011fa0:	4413      	add	r3, r2
 8011fa2:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8011fa6:	6819      	ldr	r1, [r3, #0]
 8011fa8:	7bfb      	ldrb	r3, [r7, #15]
 8011faa:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011fae:	b2db      	uxtb	r3, r3
 8011fb0:	461a      	mov	r2, r3
 8011fb2:	8abb      	ldrh	r3, [r7, #20]
 8011fb4:	6878      	ldr	r0, [r7, #4]
 8011fb6:	f7fe fe6f 	bl	8010c98 <USB_OTG_WritePacket>
    
    pdev->host.hc[hptxsts.b.chnum].xfer_buff  += len;
 8011fba:	7bfb      	ldrb	r3, [r7, #15]
 8011fbc:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011fc0:	b2db      	uxtb	r3, r3
 8011fc2:	4618      	mov	r0, r3
 8011fc4:	7bfb      	ldrb	r3, [r7, #15]
 8011fc6:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011fca:	b2db      	uxtb	r3, r3
 8011fcc:	687a      	ldr	r2, [r7, #4]
 8011fce:	330d      	adds	r3, #13
 8011fd0:	015b      	lsls	r3, r3, #5
 8011fd2:	4413      	add	r3, r2
 8011fd4:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8011fd8:	681a      	ldr	r2, [r3, #0]
 8011fda:	8abb      	ldrh	r3, [r7, #20]
 8011fdc:	441a      	add	r2, r3
 8011fde:	6879      	ldr	r1, [r7, #4]
 8011fe0:	f100 030d 	add.w	r3, r0, #13
 8011fe4:	015b      	lsls	r3, r3, #5
 8011fe6:	440b      	add	r3, r1
 8011fe8:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8011fec:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hptxsts.b.chnum].xfer_len   -= len;
 8011fee:	7bfb      	ldrb	r3, [r7, #15]
 8011ff0:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011ff4:	b2db      	uxtb	r3, r3
 8011ff6:	4618      	mov	r0, r3
 8011ff8:	7bfb      	ldrb	r3, [r7, #15]
 8011ffa:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8011ffe:	b2db      	uxtb	r3, r3
 8012000:	687a      	ldr	r2, [r7, #4]
 8012002:	015b      	lsls	r3, r3, #5
 8012004:	4413      	add	r3, r2
 8012006:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 801200a:	681a      	ldr	r2, [r3, #0]
 801200c:	8abb      	ldrh	r3, [r7, #20]
 801200e:	1ad2      	subs	r2, r2, r3
 8012010:	6879      	ldr	r1, [r7, #4]
 8012012:	0143      	lsls	r3, r0, #5
 8012014:	440b      	add	r3, r1
 8012016:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 801201a:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hptxsts.b.chnum].xfer_count  += len; 
 801201c:	7bfb      	ldrb	r3, [r7, #15]
 801201e:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8012022:	b2db      	uxtb	r3, r3
 8012024:	4618      	mov	r0, r3
 8012026:	7bfb      	ldrb	r3, [r7, #15]
 8012028:	f3c3 1341 	ubfx	r3, r3, #5, #2
 801202c:	b2db      	uxtb	r3, r3
 801202e:	687a      	ldr	r2, [r7, #4]
 8012030:	015b      	lsls	r3, r3, #5
 8012032:	4413      	add	r3, r2
 8012034:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8012038:	681a      	ldr	r2, [r3, #0]
 801203a:	8abb      	ldrh	r3, [r7, #20]
 801203c:	441a      	add	r2, r3
 801203e:	6879      	ldr	r1, [r7, #4]
 8012040:	0143      	lsls	r3, r0, #5
 8012042:	440b      	add	r3, r1
 8012044:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8012048:	601a      	str	r2, [r3, #0]
     
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 801204a:	687b      	ldr	r3, [r7, #4]
 801204c:	695b      	ldr	r3, [r3, #20]
 801204e:	691b      	ldr	r3, [r3, #16]
 8012050:	60fb      	str	r3, [r7, #12]
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 8012052:	89bb      	ldrh	r3, [r7, #12]
 8012054:	8afa      	ldrh	r2, [r7, #22]
 8012056:	429a      	cmp	r2, r3
 8012058:	d20c      	bcs.n	8012074 <USB_OTG_USBH_handle_ptxfempty_ISR+0x17c>
      (pdev->host.hc[hptxsts.b.chnum].xfer_len != 0))    
 801205a:	7bfb      	ldrb	r3, [r7, #15]
 801205c:	f3c3 1341 	ubfx	r3, r3, #5, #2
 8012060:	b2db      	uxtb	r3, r3
 8012062:	687a      	ldr	r2, [r7, #4]
 8012064:	015b      	lsls	r3, r3, #5
 8012066:	4413      	add	r3, r2
 8012068:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 801206c:	681b      	ldr	r3, [r3, #0]
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 801206e:	2b00      	cmp	r3, #0
 8012070:	f47f af58 	bne.w	8011f24 <USB_OTG_USBH_handle_ptxfempty_ISR+0x2c>
  }  
  
  return 1;
 8012074:	2301      	movs	r3, #1
}
 8012076:	4618      	mov	r0, r3
 8012078:	3718      	adds	r7, #24
 801207a:	46bd      	mov	sp, r7
 801207c:	bd80      	pop	{r7, pc}

0801207e <USB_OTG_USBH_handle_port_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_port_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801207e:	b580      	push	{r7, lr}
 8012080:	b088      	sub	sp, #32
 8012082:	af00      	add	r7, sp, #0
 8012084:	6078      	str	r0, [r7, #4]
  USB_OTG_HPRT0_TypeDef  hprt0;
  USB_OTG_HPRT0_TypeDef  hprt0_dup;
  USB_OTG_HCFG_TypeDef   hcfg;    
  uint32_t do_reset = 0;
 8012086:	2300      	movs	r3, #0
 8012088:	61fb      	str	r3, [r7, #28]
  uint32_t retval = 0;
 801208a:	2300      	movs	r3, #0
 801208c:	61bb      	str	r3, [r7, #24]
  
  hcfg.d32 = 0;
 801208e:	2300      	movs	r3, #0
 8012090:	60fb      	str	r3, [r7, #12]
  hprt0.d32 = 0;
 8012092:	2300      	movs	r3, #0
 8012094:	617b      	str	r3, [r7, #20]
  hprt0_dup.d32 = 0;
 8012096:	2300      	movs	r3, #0
 8012098:	613b      	str	r3, [r7, #16]
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 801209a:	687b      	ldr	r3, [r7, #4]
 801209c:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80120a0:	681b      	ldr	r3, [r3, #0]
 80120a2:	617b      	str	r3, [r7, #20]
  hprt0_dup.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 80120a4:	687b      	ldr	r3, [r7, #4]
 80120a6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80120aa:	681b      	ldr	r3, [r3, #0]
 80120ac:	613b      	str	r3, [r7, #16]
  
  /* Clear the interrupt bits in GINTSTS */
  
  hprt0_dup.b.prtena = 0;
 80120ae:	7c3b      	ldrb	r3, [r7, #16]
 80120b0:	f36f 0382 	bfc	r3, #2, #1
 80120b4:	743b      	strb	r3, [r7, #16]
  hprt0_dup.b.prtconndet = 0;
 80120b6:	7c3b      	ldrb	r3, [r7, #16]
 80120b8:	f36f 0341 	bfc	r3, #1, #1
 80120bc:	743b      	strb	r3, [r7, #16]
  hprt0_dup.b.prtenchng = 0;
 80120be:	7c3b      	ldrb	r3, [r7, #16]
 80120c0:	f36f 03c3 	bfc	r3, #3, #1
 80120c4:	743b      	strb	r3, [r7, #16]
  hprt0_dup.b.prtovrcurrchng = 0;
 80120c6:	7c3b      	ldrb	r3, [r7, #16]
 80120c8:	f36f 1345 	bfc	r3, #5, #1
 80120cc:	743b      	strb	r3, [r7, #16]
  
  /* Port Connect Detected */
  if (hprt0.b.prtconndet)
 80120ce:	7d3b      	ldrb	r3, [r7, #20]
 80120d0:	f003 0302 	and.w	r3, r3, #2
 80120d4:	b2db      	uxtb	r3, r3
 80120d6:	2b00      	cmp	r3, #0
 80120d8:	d00f      	beq.n	80120fa <USB_OTG_USBH_handle_port_ISR+0x7c>
  {
    pdev->host.port_cb->Connect(pdev);
 80120da:	687b      	ldr	r3, [r7, #4]
 80120dc:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 80120e0:	685b      	ldr	r3, [r3, #4]
 80120e2:	6878      	ldr	r0, [r7, #4]
 80120e4:	4798      	blx	r3
    hprt0_dup.b.prtconndet = 1;
 80120e6:	7c3b      	ldrb	r3, [r7, #16]
 80120e8:	f043 0302 	orr.w	r3, r3, #2
 80120ec:	743b      	strb	r3, [r7, #16]
    do_reset = 1;
 80120ee:	2301      	movs	r3, #1
 80120f0:	61fb      	str	r3, [r7, #28]
    retval |= 1;
 80120f2:	69bb      	ldr	r3, [r7, #24]
 80120f4:	f043 0301 	orr.w	r3, r3, #1
 80120f8:	61bb      	str	r3, [r7, #24]
  }
  
  /* Port Enable Changed */
  if (hprt0.b.prtenchng)
 80120fa:	7d3b      	ldrb	r3, [r7, #20]
 80120fc:	f003 0308 	and.w	r3, r3, #8
 8012100:	b2db      	uxtb	r3, r3
 8012102:	2b00      	cmp	r3, #0
 8012104:	d04f      	beq.n	80121a6 <USB_OTG_USBH_handle_port_ISR+0x128>
  {
    hprt0_dup.b.prtenchng = 1;
 8012106:	7c3b      	ldrb	r3, [r7, #16]
 8012108:	f043 0308 	orr.w	r3, r3, #8
 801210c:	743b      	strb	r3, [r7, #16]
    if (hprt0.b.prtena == 1)
 801210e:	7d3b      	ldrb	r3, [r7, #20]
 8012110:	f003 0304 	and.w	r3, r3, #4
 8012114:	b2db      	uxtb	r3, r3
 8012116:	2b00      	cmp	r3, #0
 8012118:	d045      	beq.n	80121a6 <USB_OTG_USBH_handle_port_ISR+0x128>
    {
      pdev->host.ConnSts = 1;
 801211a:	687b      	ldr	r3, [r7, #4]
 801211c:	2201      	movs	r2, #1
 801211e:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
      
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 8012122:	7dbb      	ldrb	r3, [r7, #22]
 8012124:	f003 0306 	and.w	r3, r3, #6
 8012128:	b2db      	uxtb	r3, r3
 801212a:	2b04      	cmp	r3, #4
 801212c:	d005      	beq.n	801213a <USB_OTG_USBH_handle_port_ISR+0xbc>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
 801212e:	7dbb      	ldrb	r3, [r7, #22]
 8012130:	f003 0306 	and.w	r3, r3, #6
 8012134:	b2db      	uxtb	r3, r3
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 8012136:	2b02      	cmp	r3, #2
 8012138:	d131      	bne.n	801219e <USB_OTG_USBH_handle_port_ISR+0x120>
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 801213a:	687b      	ldr	r3, [r7, #4]
 801213c:	695b      	ldr	r3, [r3, #20]
 801213e:	681b      	ldr	r3, [r3, #0]
 8012140:	60fb      	str	r3, [r7, #12]
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8012142:	7dbb      	ldrb	r3, [r7, #22]
 8012144:	f003 0306 	and.w	r3, r3, #6
 8012148:	b2db      	uxtb	r3, r3
 801214a:	2b04      	cmp	r3, #4
 801214c:	d115      	bne.n	801217a <USB_OTG_USBH_handle_port_ISR+0xfc>
        {
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 6000 );
 801214e:	687b      	ldr	r3, [r7, #4]
 8012150:	695b      	ldr	r3, [r3, #20]
 8012152:	f241 7270 	movw	r2, #6000	; 0x1770
 8012156:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_6_MHZ)
 8012158:	7b3b      	ldrb	r3, [r7, #12]
 801215a:	f003 0303 	and.w	r3, r3, #3
 801215e:	b2db      	uxtb	r3, r3
 8012160:	2b02      	cmp	r3, #2
 8012162:	d01f      	beq.n	80121a4 <USB_OTG_USBH_handle_port_ISR+0x126>
          {
            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
 8012164:	687b      	ldr	r3, [r7, #4]
 8012166:	7adb      	ldrb	r3, [r3, #11]
 8012168:	2b01      	cmp	r3, #1
 801216a:	d103      	bne.n	8012174 <USB_OTG_USBH_handle_port_ISR+0xf6>
            {          
              USB_OTG_InitFSLSPClkSel(pdev ,HCFG_6_MHZ );
 801216c:	2102      	movs	r1, #2
 801216e:	6878      	ldr	r0, [r7, #4]
 8012170:	f7ff f9f2 	bl	8011558 <USB_OTG_InitFSLSPClkSel>
            }          
            do_reset = 1;
 8012174:	2301      	movs	r3, #1
 8012176:	61fb      	str	r3, [r7, #28]
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8012178:	e014      	b.n	80121a4 <USB_OTG_USBH_handle_port_ISR+0x126>
          }
        }
        else
        {
          
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 48000 );            
 801217a:	687b      	ldr	r3, [r7, #4]
 801217c:	695b      	ldr	r3, [r3, #20]
 801217e:	f64b 3280 	movw	r2, #48000	; 0xbb80
 8012182:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_48_MHZ)
 8012184:	7b3b      	ldrb	r3, [r7, #12]
 8012186:	f003 0303 	and.w	r3, r3, #3
 801218a:	b2db      	uxtb	r3, r3
 801218c:	2b01      	cmp	r3, #1
 801218e:	d009      	beq.n	80121a4 <USB_OTG_USBH_handle_port_ISR+0x126>
          {
            USB_OTG_InitFSLSPClkSel(pdev ,HCFG_48_MHZ );
 8012190:	2101      	movs	r1, #1
 8012192:	6878      	ldr	r0, [r7, #4]
 8012194:	f7ff f9e0 	bl	8011558 <USB_OTG_InitFSLSPClkSel>
            do_reset = 1;
 8012198:	2301      	movs	r3, #1
 801219a:	61fb      	str	r3, [r7, #28]
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 801219c:	e002      	b.n	80121a4 <USB_OTG_USBH_handle_port_ISR+0x126>
          }
        }
      }
      else
      {
        do_reset = 1;
 801219e:	2301      	movs	r3, #1
 80121a0:	61fb      	str	r3, [r7, #28]
 80121a2:	e000      	b.n	80121a6 <USB_OTG_USBH_handle_port_ISR+0x128>
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 80121a4:	bf00      	nop
      }
    }
  }
  /* Overcurrent Change Interrupt */
  if (hprt0.b.prtovrcurrchng)
 80121a6:	7d3b      	ldrb	r3, [r7, #20]
 80121a8:	f003 0320 	and.w	r3, r3, #32
 80121ac:	b2db      	uxtb	r3, r3
 80121ae:	2b00      	cmp	r3, #0
 80121b0:	d007      	beq.n	80121c2 <USB_OTG_USBH_handle_port_ISR+0x144>
  {
    hprt0_dup.b.prtovrcurrchng = 1;
 80121b2:	7c3b      	ldrb	r3, [r7, #16]
 80121b4:	f043 0320 	orr.w	r3, r3, #32
 80121b8:	743b      	strb	r3, [r7, #16]
    retval |= 1;
 80121ba:	69bb      	ldr	r3, [r7, #24]
 80121bc:	f043 0301 	orr.w	r3, r3, #1
 80121c0:	61bb      	str	r3, [r7, #24]
  }
  if (do_reset)
 80121c2:	69fb      	ldr	r3, [r7, #28]
 80121c4:	2b00      	cmp	r3, #0
 80121c6:	d002      	beq.n	80121ce <USB_OTG_USBH_handle_port_ISR+0x150>
  {
    USB_OTG_ResetPort(pdev);
 80121c8:	6878      	ldr	r0, [r7, #4]
 80121ca:	f7ff f9d5 	bl	8011578 <USB_OTG_ResetPort>
    
  }
  /* Clear Port Interrupts */
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0_dup.d32);
 80121ce:	687b      	ldr	r3, [r7, #4]
 80121d0:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80121d4:	693a      	ldr	r2, [r7, #16]
 80121d6:	601a      	str	r2, [r3, #0]
  
  return retval;
 80121d8:	69bb      	ldr	r3, [r7, #24]
}
 80121da:	4618      	mov	r0, r3
 80121dc:	3720      	adds	r7, #32
 80121de:	46bd      	mov	sp, r7
 80121e0:	bd80      	pop	{r7, pc}

080121e2 <USB_OTG_USBH_handle_hc_n_Out_ISR>:

//--------------------------------------------------------------
uint32_t USB_OTG_USBH_handle_hc_n_Out_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 80121e2:	b580      	push	{r7, lr}
 80121e4:	b098      	sub	sp, #96	; 0x60
 80121e6:	af00      	add	r7, sp, #0
 80121e8:	6078      	str	r0, [r7, #4]
 80121ea:	6039      	str	r1, [r7, #0]
  USB_OTG_HCINTn_TypeDef     hcint;
  USB_OTG_HCGINTMSK_TypeDef  hcintmsk;
  USB_OTG_HC_REGS *hcreg;
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  
  hcreg = pdev->regs.HC_REGS[num];
 80121ec:	687a      	ldr	r2, [r7, #4]
 80121ee:	683b      	ldr	r3, [r7, #0]
 80121f0:	3322      	adds	r3, #34	; 0x22
 80121f2:	009b      	lsls	r3, r3, #2
 80121f4:	4413      	add	r3, r2
 80121f6:	689b      	ldr	r3, [r3, #8]
 80121f8:	65fb      	str	r3, [r7, #92]	; 0x5c
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 80121fa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80121fc:	689b      	ldr	r3, [r3, #8]
 80121fe:	65bb      	str	r3, [r7, #88]	; 0x58
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCGINTMSK);
 8012200:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012202:	68db      	ldr	r3, [r3, #12]
 8012204:	657b      	str	r3, [r7, #84]	; 0x54
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 8012206:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8012208:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801220a:	4013      	ands	r3, r2
 801220c:	65bb      	str	r3, [r7, #88]	; 0x58
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 801220e:	687a      	ldr	r2, [r7, #4]
 8012210:	683b      	ldr	r3, [r7, #0]
 8012212:	3322      	adds	r3, #34	; 0x22
 8012214:	009b      	lsls	r3, r3, #2
 8012216:	4413      	add	r3, r2
 8012218:	689b      	ldr	r3, [r3, #8]
 801221a:	681b      	ldr	r3, [r3, #0]
 801221c:	653b      	str	r3, [r7, #80]	; 0x50
  
  if (hcint.b.ahberr)
 801221e:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8012222:	f003 0304 	and.w	r3, r3, #4
 8012226:	b2db      	uxtb	r3, r3
 8012228:	2b00      	cmp	r3, #0
 801222a:	d021      	beq.n	8012270 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x8e>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 801222c:	2300      	movs	r3, #0
 801222e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8012230:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 8012234:	f043 0304 	orr.w	r3, r3, #4
 8012238:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
 801223c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801223e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012240:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8012242:	687a      	ldr	r2, [r7, #4]
 8012244:	683b      	ldr	r3, [r7, #0]
 8012246:	3322      	adds	r3, #34	; 0x22
 8012248:	009b      	lsls	r3, r3, #2
 801224a:	4413      	add	r3, r2
 801224c:	689b      	ldr	r3, [r3, #8]
 801224e:	68db      	ldr	r3, [r3, #12]
 8012250:	64bb      	str	r3, [r7, #72]	; 0x48
 8012252:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8012256:	f043 0302 	orr.w	r3, r3, #2
 801225a:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
 801225e:	687a      	ldr	r2, [r7, #4]
 8012260:	683b      	ldr	r3, [r7, #0]
 8012262:	3322      	adds	r3, #34	; 0x22
 8012264:	009b      	lsls	r3, r3, #2
 8012266:	4413      	add	r3, r2
 8012268:	689b      	ldr	r3, [r3, #8]
 801226a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801226c:	60da      	str	r2, [r3, #12]
 801226e:	e22b      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  } 
  else if (hcint.b.ack)
 8012270:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8012274:	f003 0320 	and.w	r3, r3, #32
 8012278:	b2db      	uxtb	r3, r3
 801227a:	2b00      	cmp	r3, #0
 801227c:	d00b      	beq.n	8012296 <USB_OTG_USBH_handle_hc_n_Out_ISR+0xb4>
  {
    CLEAR_HC_INT(hcreg , ack);
 801227e:	2300      	movs	r3, #0
 8012280:	647b      	str	r3, [r7, #68]	; 0x44
 8012282:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8012286:	f043 0320 	orr.w	r3, r3, #32
 801228a:	f887 3044 	strb.w	r3, [r7, #68]	; 0x44
 801228e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8012290:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012292:	609a      	str	r2, [r3, #8]
 8012294:	e218      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  }
  
  else if (hcint.b.xfercompl)
 8012296:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 801229a:	f003 0301 	and.w	r3, r3, #1
 801229e:	b2db      	uxtb	r3, r3
 80122a0:	2b00      	cmp	r3, #0
 80122a2:	d035      	beq.n	8012310 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x12e>
  {
    pdev->host.ErrCnt[num] = 0;
 80122a4:	687a      	ldr	r2, [r7, #4]
 80122a6:	683b      	ldr	r3, [r7, #0]
 80122a8:	3384      	adds	r3, #132	; 0x84
 80122aa:	009b      	lsls	r3, r3, #2
 80122ac:	4413      	add	r3, r2
 80122ae:	2200      	movs	r2, #0
 80122b0:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 80122b2:	687a      	ldr	r2, [r7, #4]
 80122b4:	683b      	ldr	r3, [r7, #0]
 80122b6:	3322      	adds	r3, #34	; 0x22
 80122b8:	009b      	lsls	r3, r3, #2
 80122ba:	4413      	add	r3, r2
 80122bc:	689b      	ldr	r3, [r3, #8]
 80122be:	68db      	ldr	r3, [r3, #12]
 80122c0:	643b      	str	r3, [r7, #64]	; 0x40
 80122c2:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 80122c6:	f043 0302 	orr.w	r3, r3, #2
 80122ca:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
 80122ce:	687a      	ldr	r2, [r7, #4]
 80122d0:	683b      	ldr	r3, [r7, #0]
 80122d2:	3322      	adds	r3, #34	; 0x22
 80122d4:	009b      	lsls	r3, r3, #2
 80122d6:	4413      	add	r3, r2
 80122d8:	689b      	ldr	r3, [r3, #8]
 80122da:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80122dc:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80122de:	683b      	ldr	r3, [r7, #0]
 80122e0:	b2db      	uxtb	r3, r3
 80122e2:	4619      	mov	r1, r3
 80122e4:	6878      	ldr	r0, [r7, #4]
 80122e6:	f7ff fa79 	bl	80117dc <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xfercompl);
 80122ea:	2300      	movs	r3, #0
 80122ec:	63fb      	str	r3, [r7, #60]	; 0x3c
 80122ee:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 80122f2:	f043 0301 	orr.w	r3, r3, #1
 80122f6:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
 80122fa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80122fc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80122fe:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_XFRC;            
 8012300:	687a      	ldr	r2, [r7, #4]
 8012302:	683b      	ldr	r3, [r7, #0]
 8012304:	4413      	add	r3, r2
 8012306:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 801230a:	2201      	movs	r2, #1
 801230c:	701a      	strb	r2, [r3, #0]
 801230e:	e1db      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  }
  
  else if (hcint.b.stall)
 8012310:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8012314:	f003 0308 	and.w	r3, r3, #8
 8012318:	b2db      	uxtb	r3, r3
 801231a:	2b00      	cmp	r3, #0
 801231c:	d02e      	beq.n	801237c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x19a>
  {
    CLEAR_HC_INT(hcreg , stall);
 801231e:	2300      	movs	r3, #0
 8012320:	63bb      	str	r3, [r7, #56]	; 0x38
 8012322:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8012326:	f043 0308 	orr.w	r3, r3, #8
 801232a:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
 801232e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8012330:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012332:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8012334:	687a      	ldr	r2, [r7, #4]
 8012336:	683b      	ldr	r3, [r7, #0]
 8012338:	3322      	adds	r3, #34	; 0x22
 801233a:	009b      	lsls	r3, r3, #2
 801233c:	4413      	add	r3, r2
 801233e:	689b      	ldr	r3, [r3, #8]
 8012340:	68db      	ldr	r3, [r3, #12]
 8012342:	637b      	str	r3, [r7, #52]	; 0x34
 8012344:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8012348:	f043 0302 	orr.w	r3, r3, #2
 801234c:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
 8012350:	687a      	ldr	r2, [r7, #4]
 8012352:	683b      	ldr	r3, [r7, #0]
 8012354:	3322      	adds	r3, #34	; 0x22
 8012356:	009b      	lsls	r3, r3, #2
 8012358:	4413      	add	r3, r2
 801235a:	689b      	ldr	r3, [r3, #8]
 801235c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801235e:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8012360:	683b      	ldr	r3, [r7, #0]
 8012362:	b2db      	uxtb	r3, r3
 8012364:	4619      	mov	r1, r3
 8012366:	6878      	ldr	r0, [r7, #4]
 8012368:	f7ff fa38 	bl	80117dc <USB_OTG_HC_Halt>
    pdev->host.HC_Status[num] = HC_STALL;      
 801236c:	687a      	ldr	r2, [r7, #4]
 801236e:	683b      	ldr	r3, [r7, #0]
 8012370:	4413      	add	r3, r2
 8012372:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012376:	2205      	movs	r2, #5
 8012378:	701a      	strb	r2, [r3, #0]
 801237a:	e1a5      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  }
  
  else if (hcint.b.nak)
 801237c:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8012380:	f003 0310 	and.w	r3, r3, #16
 8012384:	b2db      	uxtb	r3, r3
 8012386:	2b00      	cmp	r3, #0
 8012388:	d035      	beq.n	80123f6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x214>
  {
    pdev->host.ErrCnt[num] = 0;
 801238a:	687a      	ldr	r2, [r7, #4]
 801238c:	683b      	ldr	r3, [r7, #0]
 801238e:	3384      	adds	r3, #132	; 0x84
 8012390:	009b      	lsls	r3, r3, #2
 8012392:	4413      	add	r3, r2
 8012394:	2200      	movs	r2, #0
 8012396:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 8012398:	687a      	ldr	r2, [r7, #4]
 801239a:	683b      	ldr	r3, [r7, #0]
 801239c:	3322      	adds	r3, #34	; 0x22
 801239e:	009b      	lsls	r3, r3, #2
 80123a0:	4413      	add	r3, r2
 80123a2:	689b      	ldr	r3, [r3, #8]
 80123a4:	68db      	ldr	r3, [r3, #12]
 80123a6:	633b      	str	r3, [r7, #48]	; 0x30
 80123a8:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 80123ac:	f043 0302 	orr.w	r3, r3, #2
 80123b0:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
 80123b4:	687a      	ldr	r2, [r7, #4]
 80123b6:	683b      	ldr	r3, [r7, #0]
 80123b8:	3322      	adds	r3, #34	; 0x22
 80123ba:	009b      	lsls	r3, r3, #2
 80123bc:	4413      	add	r3, r2
 80123be:	689b      	ldr	r3, [r3, #8]
 80123c0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80123c2:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80123c4:	683b      	ldr	r3, [r7, #0]
 80123c6:	b2db      	uxtb	r3, r3
 80123c8:	4619      	mov	r1, r3
 80123ca:	6878      	ldr	r0, [r7, #4]
 80123cc:	f7ff fa06 	bl	80117dc <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);
 80123d0:	2300      	movs	r3, #0
 80123d2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80123d4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 80123d8:	f043 0310 	orr.w	r3, r3, #16
 80123dc:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
 80123e0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80123e2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80123e4:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NAK;      
 80123e6:	687a      	ldr	r2, [r7, #4]
 80123e8:	683b      	ldr	r3, [r7, #0]
 80123ea:	4413      	add	r3, r2
 80123ec:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 80123f0:	2203      	movs	r2, #3
 80123f2:	701a      	strb	r2, [r3, #0]
 80123f4:	e168      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  }
  
  else if (hcint.b.xacterr)
 80123f6:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 80123fa:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80123fe:	b2db      	uxtb	r3, r3
 8012400:	2b00      	cmp	r3, #0
 8012402:	d03b      	beq.n	801247c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x29a>
  {
    UNMASK_HOST_INT_CHH (num);
 8012404:	687a      	ldr	r2, [r7, #4]
 8012406:	683b      	ldr	r3, [r7, #0]
 8012408:	3322      	adds	r3, #34	; 0x22
 801240a:	009b      	lsls	r3, r3, #2
 801240c:	4413      	add	r3, r2
 801240e:	689b      	ldr	r3, [r3, #8]
 8012410:	68db      	ldr	r3, [r3, #12]
 8012412:	62bb      	str	r3, [r7, #40]	; 0x28
 8012414:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8012418:	f043 0302 	orr.w	r3, r3, #2
 801241c:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
 8012420:	687a      	ldr	r2, [r7, #4]
 8012422:	683b      	ldr	r3, [r7, #0]
 8012424:	3322      	adds	r3, #34	; 0x22
 8012426:	009b      	lsls	r3, r3, #2
 8012428:	4413      	add	r3, r2
 801242a:	689b      	ldr	r3, [r3, #8]
 801242c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801242e:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8012430:	683b      	ldr	r3, [r7, #0]
 8012432:	b2db      	uxtb	r3, r3
 8012434:	4619      	mov	r1, r3
 8012436:	6878      	ldr	r0, [r7, #4]
 8012438:	f7ff f9d0 	bl	80117dc <USB_OTG_HC_Halt>
    pdev->host.ErrCnt[num] ++;
 801243c:	687a      	ldr	r2, [r7, #4]
 801243e:	683b      	ldr	r3, [r7, #0]
 8012440:	3384      	adds	r3, #132	; 0x84
 8012442:	009b      	lsls	r3, r3, #2
 8012444:	4413      	add	r3, r2
 8012446:	685b      	ldr	r3, [r3, #4]
 8012448:	1c5a      	adds	r2, r3, #1
 801244a:	6879      	ldr	r1, [r7, #4]
 801244c:	683b      	ldr	r3, [r7, #0]
 801244e:	3384      	adds	r3, #132	; 0x84
 8012450:	009b      	lsls	r3, r3, #2
 8012452:	440b      	add	r3, r1
 8012454:	605a      	str	r2, [r3, #4]
    pdev->host.HC_Status[num] = HC_XACTERR;
 8012456:	687a      	ldr	r2, [r7, #4]
 8012458:	683b      	ldr	r3, [r7, #0]
 801245a:	4413      	add	r3, r2
 801245c:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012460:	2206      	movs	r2, #6
 8012462:	701a      	strb	r2, [r3, #0]
    CLEAR_HC_INT(hcreg , xacterr);
 8012464:	2300      	movs	r3, #0
 8012466:	627b      	str	r3, [r7, #36]	; 0x24
 8012468:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 801246c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012470:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
 8012474:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012476:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012478:	609a      	str	r2, [r3, #8]
 801247a:	e125      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  }
  else if (hcint.b.nyet)
 801247c:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8012480:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012484:	b2db      	uxtb	r3, r3
 8012486:	2b00      	cmp	r3, #0
 8012488:	d033      	beq.n	80124f2 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x310>
  {
    pdev->host.ErrCnt[num] = 0;
 801248a:	687a      	ldr	r2, [r7, #4]
 801248c:	683b      	ldr	r3, [r7, #0]
 801248e:	3384      	adds	r3, #132	; 0x84
 8012490:	009b      	lsls	r3, r3, #2
 8012492:	4413      	add	r3, r2
 8012494:	2200      	movs	r2, #0
 8012496:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 8012498:	687a      	ldr	r2, [r7, #4]
 801249a:	683b      	ldr	r3, [r7, #0]
 801249c:	3322      	adds	r3, #34	; 0x22
 801249e:	009b      	lsls	r3, r3, #2
 80124a0:	4413      	add	r3, r2
 80124a2:	689b      	ldr	r3, [r3, #8]
 80124a4:	68db      	ldr	r3, [r3, #12]
 80124a6:	623b      	str	r3, [r7, #32]
 80124a8:	f897 3020 	ldrb.w	r3, [r7, #32]
 80124ac:	f043 0302 	orr.w	r3, r3, #2
 80124b0:	f887 3020 	strb.w	r3, [r7, #32]
 80124b4:	687a      	ldr	r2, [r7, #4]
 80124b6:	683b      	ldr	r3, [r7, #0]
 80124b8:	3322      	adds	r3, #34	; 0x22
 80124ba:	009b      	lsls	r3, r3, #2
 80124bc:	4413      	add	r3, r2
 80124be:	689b      	ldr	r3, [r3, #8]
 80124c0:	6a3a      	ldr	r2, [r7, #32]
 80124c2:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80124c4:	683b      	ldr	r3, [r7, #0]
 80124c6:	b2db      	uxtb	r3, r3
 80124c8:	4619      	mov	r1, r3
 80124ca:	6878      	ldr	r0, [r7, #4]
 80124cc:	f7ff f986 	bl	80117dc <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nyet);
 80124d0:	2300      	movs	r3, #0
 80124d2:	61fb      	str	r3, [r7, #28]
 80124d4:	7f3b      	ldrb	r3, [r7, #28]
 80124d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80124da:	773b      	strb	r3, [r7, #28]
 80124dc:	69fa      	ldr	r2, [r7, #28]
 80124de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80124e0:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NYET;    
 80124e2:	687a      	ldr	r2, [r7, #4]
 80124e4:	683b      	ldr	r3, [r7, #0]
 80124e6:	4413      	add	r3, r2
 80124e8:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 80124ec:	2204      	movs	r2, #4
 80124ee:	701a      	strb	r2, [r3, #0]
 80124f0:	e0ea      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  }
  else if (hcint.b.datatglerr)
 80124f2:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 80124f6:	f003 0304 	and.w	r3, r3, #4
 80124fa:	b2db      	uxtb	r3, r3
 80124fc:	2b00      	cmp	r3, #0
 80124fe:	d033      	beq.n	8012568 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x386>
  {
   
    UNMASK_HOST_INT_CHH (num);
 8012500:	687a      	ldr	r2, [r7, #4]
 8012502:	683b      	ldr	r3, [r7, #0]
 8012504:	3322      	adds	r3, #34	; 0x22
 8012506:	009b      	lsls	r3, r3, #2
 8012508:	4413      	add	r3, r2
 801250a:	689b      	ldr	r3, [r3, #8]
 801250c:	68db      	ldr	r3, [r3, #12]
 801250e:	61bb      	str	r3, [r7, #24]
 8012510:	7e3b      	ldrb	r3, [r7, #24]
 8012512:	f043 0302 	orr.w	r3, r3, #2
 8012516:	763b      	strb	r3, [r7, #24]
 8012518:	687a      	ldr	r2, [r7, #4]
 801251a:	683b      	ldr	r3, [r7, #0]
 801251c:	3322      	adds	r3, #34	; 0x22
 801251e:	009b      	lsls	r3, r3, #2
 8012520:	4413      	add	r3, r2
 8012522:	689b      	ldr	r3, [r3, #8]
 8012524:	69ba      	ldr	r2, [r7, #24]
 8012526:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8012528:	683b      	ldr	r3, [r7, #0]
 801252a:	b2db      	uxtb	r3, r3
 801252c:	4619      	mov	r1, r3
 801252e:	6878      	ldr	r0, [r7, #4]
 8012530:	f7ff f954 	bl	80117dc <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);   
 8012534:	2300      	movs	r3, #0
 8012536:	617b      	str	r3, [r7, #20]
 8012538:	7d3b      	ldrb	r3, [r7, #20]
 801253a:	f043 0310 	orr.w	r3, r3, #16
 801253e:	753b      	strb	r3, [r7, #20]
 8012540:	697a      	ldr	r2, [r7, #20]
 8012542:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012544:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_DATATGLERR;
 8012546:	687a      	ldr	r2, [r7, #4]
 8012548:	683b      	ldr	r3, [r7, #0]
 801254a:	4413      	add	r3, r2
 801254c:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012550:	2208      	movs	r2, #8
 8012552:	701a      	strb	r2, [r3, #0]
    
    CLEAR_HC_INT(hcreg , datatglerr);
 8012554:	2300      	movs	r3, #0
 8012556:	613b      	str	r3, [r7, #16]
 8012558:	7c7b      	ldrb	r3, [r7, #17]
 801255a:	f043 0304 	orr.w	r3, r3, #4
 801255e:	747b      	strb	r3, [r7, #17]
 8012560:	693a      	ldr	r2, [r7, #16]
 8012562:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012564:	609a      	str	r2, [r3, #8]
 8012566:	e0af      	b.n	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  }  
  else if (hcint.b.chhltd)
 8012568:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 801256c:	f003 0302 	and.w	r3, r3, #2
 8012570:	b2db      	uxtb	r3, r3
 8012572:	2b00      	cmp	r3, #0
 8012574:	f000 80a8 	beq.w	80126c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4e6>
  {
    MASK_HOST_INT_CHH (num);
 8012578:	687a      	ldr	r2, [r7, #4]
 801257a:	683b      	ldr	r3, [r7, #0]
 801257c:	3322      	adds	r3, #34	; 0x22
 801257e:	009b      	lsls	r3, r3, #2
 8012580:	4413      	add	r3, r2
 8012582:	689b      	ldr	r3, [r3, #8]
 8012584:	68db      	ldr	r3, [r3, #12]
 8012586:	60fb      	str	r3, [r7, #12]
 8012588:	7b3b      	ldrb	r3, [r7, #12]
 801258a:	f36f 0341 	bfc	r3, #1, #1
 801258e:	733b      	strb	r3, [r7, #12]
 8012590:	687a      	ldr	r2, [r7, #4]
 8012592:	683b      	ldr	r3, [r7, #0]
 8012594:	3322      	adds	r3, #34	; 0x22
 8012596:	009b      	lsls	r3, r3, #2
 8012598:	4413      	add	r3, r2
 801259a:	689b      	ldr	r3, [r3, #8]
 801259c:	68fa      	ldr	r2, [r7, #12]
 801259e:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 80125a0:	687a      	ldr	r2, [r7, #4]
 80125a2:	683b      	ldr	r3, [r7, #0]
 80125a4:	4413      	add	r3, r2
 80125a6:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 80125aa:	781b      	ldrb	r3, [r3, #0]
 80125ac:	b2db      	uxtb	r3, r3
 80125ae:	2b01      	cmp	r3, #1
 80125b0:	d120      	bne.n	80125f4 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x412>
    {
      pdev->host.URB_State[num] = URB_DONE;  
 80125b2:	687a      	ldr	r2, [r7, #4]
 80125b4:	683b      	ldr	r3, [r7, #0]
 80125b6:	4413      	add	r3, r2
 80125b8:	f203 239b 	addw	r3, r3, #667	; 0x29b
 80125bc:	2201      	movs	r2, #1
 80125be:	701a      	strb	r2, [r3, #0]
      
      if (hcchar.b.eptype == EP_TYPE_BULK)
 80125c0:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 80125c4:	f003 030c 	and.w	r3, r3, #12
 80125c8:	b2db      	uxtb	r3, r3
 80125ca:	2b08      	cmp	r3, #8
 80125cc:	d173      	bne.n	80126b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d4>
      {
        pdev->host.hc[num].toggle_out ^= 1; 
 80125ce:	687a      	ldr	r2, [r7, #4]
 80125d0:	683b      	ldr	r3, [r7, #0]
 80125d2:	3316      	adds	r3, #22
 80125d4:	015b      	lsls	r3, r3, #5
 80125d6:	4413      	add	r3, r2
 80125d8:	3305      	adds	r3, #5
 80125da:	781b      	ldrb	r3, [r3, #0]
 80125dc:	f083 0301 	eor.w	r3, r3, #1
 80125e0:	b2d9      	uxtb	r1, r3
 80125e2:	687a      	ldr	r2, [r7, #4]
 80125e4:	683b      	ldr	r3, [r7, #0]
 80125e6:	3316      	adds	r3, #22
 80125e8:	015b      	lsls	r3, r3, #5
 80125ea:	4413      	add	r3, r2
 80125ec:	3305      	adds	r3, #5
 80125ee:	460a      	mov	r2, r1
 80125f0:	701a      	strb	r2, [r3, #0]
 80125f2:	e060      	b.n	80126b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d4>
      }
    }
    else if(pdev->host.HC_Status[num] == HC_NAK)
 80125f4:	687a      	ldr	r2, [r7, #4]
 80125f6:	683b      	ldr	r3, [r7, #0]
 80125f8:	4413      	add	r3, r2
 80125fa:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 80125fe:	781b      	ldrb	r3, [r3, #0]
 8012600:	b2db      	uxtb	r3, r3
 8012602:	2b03      	cmp	r3, #3
 8012604:	d107      	bne.n	8012616 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x434>
    {
      pdev->host.URB_State[num] = URB_NOTREADY;      
 8012606:	687a      	ldr	r2, [r7, #4]
 8012608:	683b      	ldr	r3, [r7, #0]
 801260a:	4413      	add	r3, r2
 801260c:	f203 239b 	addw	r3, r3, #667	; 0x29b
 8012610:	2202      	movs	r2, #2
 8012612:	701a      	strb	r2, [r3, #0]
 8012614:	e04f      	b.n	80126b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d4>
    }    
    else if(pdev->host.HC_Status[num] == HC_NYET)
 8012616:	687a      	ldr	r2, [r7, #4]
 8012618:	683b      	ldr	r3, [r7, #0]
 801261a:	4413      	add	r3, r2
 801261c:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012620:	781b      	ldrb	r3, [r3, #0]
 8012622:	b2db      	uxtb	r3, r3
 8012624:	2b04      	cmp	r3, #4
 8012626:	d116      	bne.n	8012656 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x474>
    {
      if(pdev->host.hc[num].do_ping == 1)
 8012628:	687a      	ldr	r2, [r7, #4]
 801262a:	683b      	ldr	r3, [r7, #0]
 801262c:	015b      	lsls	r3, r3, #5
 801262e:	4413      	add	r3, r2
 8012630:	f503 732c 	add.w	r3, r3, #688	; 0x2b0
 8012634:	781b      	ldrb	r3, [r3, #0]
 8012636:	2b01      	cmp	r3, #1
 8012638:	d105      	bne.n	8012646 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x464>
      {
        USB_OTG_HC_DoPing(pdev, num);
 801263a:	683b      	ldr	r3, [r7, #0]
 801263c:	b2db      	uxtb	r3, r3
 801263e:	4619      	mov	r1, r3
 8012640:	6878      	ldr	r0, [r7, #4]
 8012642:	f7ff f8e7 	bl	8011814 <USB_OTG_HC_DoPing>
      }
      pdev->host.URB_State[num] = URB_NOTREADY;      
 8012646:	687a      	ldr	r2, [r7, #4]
 8012648:	683b      	ldr	r3, [r7, #0]
 801264a:	4413      	add	r3, r2
 801264c:	f203 239b 	addw	r3, r3, #667	; 0x29b
 8012650:	2202      	movs	r2, #2
 8012652:	701a      	strb	r2, [r3, #0]
 8012654:	e02f      	b.n	80126b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d4>
    }      
    else if(pdev->host.HC_Status[num] == HC_STALL)
 8012656:	687a      	ldr	r2, [r7, #4]
 8012658:	683b      	ldr	r3, [r7, #0]
 801265a:	4413      	add	r3, r2
 801265c:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012660:	781b      	ldrb	r3, [r3, #0]
 8012662:	b2db      	uxtb	r3, r3
 8012664:	2b05      	cmp	r3, #5
 8012666:	d107      	bne.n	8012678 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x496>
    {
      pdev->host.URB_State[num] = URB_STALL;      
 8012668:	687a      	ldr	r2, [r7, #4]
 801266a:	683b      	ldr	r3, [r7, #0]
 801266c:	4413      	add	r3, r2
 801266e:	f203 239b 	addw	r3, r3, #667	; 0x29b
 8012672:	2204      	movs	r2, #4
 8012674:	701a      	strb	r2, [r3, #0]
 8012676:	e01e      	b.n	80126b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d4>
    }  
    else if(pdev->host.HC_Status[num] == HC_XACTERR)
 8012678:	687a      	ldr	r2, [r7, #4]
 801267a:	683b      	ldr	r3, [r7, #0]
 801267c:	4413      	add	r3, r2
 801267e:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012682:	781b      	ldrb	r3, [r3, #0]
 8012684:	b2db      	uxtb	r3, r3
 8012686:	2b06      	cmp	r3, #6
 8012688:	d115      	bne.n	80126b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d4>
    {
      if (pdev->host.ErrCnt[num] == 3)
 801268a:	687a      	ldr	r2, [r7, #4]
 801268c:	683b      	ldr	r3, [r7, #0]
 801268e:	3384      	adds	r3, #132	; 0x84
 8012690:	009b      	lsls	r3, r3, #2
 8012692:	4413      	add	r3, r2
 8012694:	685b      	ldr	r3, [r3, #4]
 8012696:	2b03      	cmp	r3, #3
 8012698:	d10d      	bne.n	80126b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4d4>
      {
        pdev->host.URB_State[num] = URB_ERROR;  
 801269a:	687a      	ldr	r2, [r7, #4]
 801269c:	683b      	ldr	r3, [r7, #0]
 801269e:	4413      	add	r3, r2
 80126a0:	f203 239b 	addw	r3, r3, #667	; 0x29b
 80126a4:	2203      	movs	r2, #3
 80126a6:	701a      	strb	r2, [r3, #0]
        pdev->host.ErrCnt[num] = 0;
 80126a8:	687a      	ldr	r2, [r7, #4]
 80126aa:	683b      	ldr	r3, [r7, #0]
 80126ac:	3384      	adds	r3, #132	; 0x84
 80126ae:	009b      	lsls	r3, r3, #2
 80126b0:	4413      	add	r3, r2
 80126b2:	2200      	movs	r2, #0
 80126b4:	605a      	str	r2, [r3, #4]
      }
    }
    CLEAR_HC_INT(hcreg , chhltd);    
 80126b6:	2300      	movs	r3, #0
 80126b8:	60bb      	str	r3, [r7, #8]
 80126ba:	7a3b      	ldrb	r3, [r7, #8]
 80126bc:	f043 0302 	orr.w	r3, r3, #2
 80126c0:	723b      	strb	r3, [r7, #8]
 80126c2:	68ba      	ldr	r2, [r7, #8]
 80126c4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80126c6:	609a      	str	r2, [r3, #8]
  }
  

  return 1;
 80126c8:	2301      	movs	r3, #1
}
 80126ca:	4618      	mov	r0, r3
 80126cc:	3760      	adds	r7, #96	; 0x60
 80126ce:	46bd      	mov	sp, r7
 80126d0:	bd80      	pop	{r7, pc}

080126d2 <USB_OTG_USBH_handle_hc_n_In_ISR>:

//--------------------------------------------------------------
uint32_t USB_OTG_USBH_handle_hc_n_In_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 80126d2:	b580      	push	{r7, lr}
 80126d4:	b09c      	sub	sp, #112	; 0x70
 80126d6:	af00      	add	r7, sp, #0
 80126d8:	6078      	str	r0, [r7, #4]
 80126da:	6039      	str	r1, [r7, #0]
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  USB_OTG_HCTSIZn_TypeDef  hctsiz;
  USB_OTG_HC_REGS *hcreg;

  
  hcreg = pdev->regs.HC_REGS[num];
 80126dc:	687a      	ldr	r2, [r7, #4]
 80126de:	683b      	ldr	r3, [r7, #0]
 80126e0:	3322      	adds	r3, #34	; 0x22
 80126e2:	009b      	lsls	r3, r3, #2
 80126e4:	4413      	add	r3, r2
 80126e6:	689b      	ldr	r3, [r3, #8]
 80126e8:	66fb      	str	r3, [r7, #108]	; 0x6c
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 80126ea:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80126ec:	689b      	ldr	r3, [r3, #8]
 80126ee:	66bb      	str	r3, [r7, #104]	; 0x68
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCGINTMSK);
 80126f0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80126f2:	68db      	ldr	r3, [r3, #12]
 80126f4:	667b      	str	r3, [r7, #100]	; 0x64
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 80126f6:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80126f8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80126fa:	4013      	ands	r3, r2
 80126fc:	66bb      	str	r3, [r7, #104]	; 0x68
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 80126fe:	687a      	ldr	r2, [r7, #4]
 8012700:	683b      	ldr	r3, [r7, #0]
 8012702:	3322      	adds	r3, #34	; 0x22
 8012704:	009b      	lsls	r3, r3, #2
 8012706:	4413      	add	r3, r2
 8012708:	689b      	ldr	r3, [r3, #8]
 801270a:	681b      	ldr	r3, [r3, #0]
 801270c:	663b      	str	r3, [r7, #96]	; 0x60
  hcintmsk.d32 = 0;
 801270e:	2300      	movs	r3, #0
 8012710:	667b      	str	r3, [r7, #100]	; 0x64
  
  
  if (hcint.b.ahberr)
 8012712:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8012716:	f003 0304 	and.w	r3, r3, #4
 801271a:	b2db      	uxtb	r3, r3
 801271c:	2b00      	cmp	r3, #0
 801271e:	d021      	beq.n	8012764 <USB_OTG_USBH_handle_hc_n_In_ISR+0x92>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 8012720:	2300      	movs	r3, #0
 8012722:	65bb      	str	r3, [r7, #88]	; 0x58
 8012724:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8012728:	f043 0304 	orr.w	r3, r3, #4
 801272c:	f887 3058 	strb.w	r3, [r7, #88]	; 0x58
 8012730:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8012732:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012734:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8012736:	687a      	ldr	r2, [r7, #4]
 8012738:	683b      	ldr	r3, [r7, #0]
 801273a:	3322      	adds	r3, #34	; 0x22
 801273c:	009b      	lsls	r3, r3, #2
 801273e:	4413      	add	r3, r2
 8012740:	689b      	ldr	r3, [r3, #8]
 8012742:	68db      	ldr	r3, [r3, #12]
 8012744:	657b      	str	r3, [r7, #84]	; 0x54
 8012746:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 801274a:	f043 0302 	orr.w	r3, r3, #2
 801274e:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
 8012752:	687a      	ldr	r2, [r7, #4]
 8012754:	683b      	ldr	r3, [r7, #0]
 8012756:	3322      	adds	r3, #34	; 0x22
 8012758:	009b      	lsls	r3, r3, #2
 801275a:	4413      	add	r3, r2
 801275c:	689b      	ldr	r3, [r3, #8]
 801275e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8012760:	60da      	str	r2, [r3, #12]
 8012762:	e099      	b.n	8012898 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c6>
  }  
  else if (hcint.b.ack)
 8012764:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8012768:	f003 0320 	and.w	r3, r3, #32
 801276c:	b2db      	uxtb	r3, r3
 801276e:	2b00      	cmp	r3, #0
 8012770:	d00b      	beq.n	801278a <USB_OTG_USBH_handle_hc_n_In_ISR+0xb8>
  {
    CLEAR_HC_INT(hcreg ,ack);
 8012772:	2300      	movs	r3, #0
 8012774:	653b      	str	r3, [r7, #80]	; 0x50
 8012776:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 801277a:	f043 0320 	orr.w	r3, r3, #32
 801277e:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
 8012782:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8012784:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012786:	609a      	str	r2, [r3, #8]
 8012788:	e086      	b.n	8012898 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c6>
  }
  
  else if (hcint.b.stall)  
 801278a:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 801278e:	f003 0308 	and.w	r3, r3, #8
 8012792:	b2db      	uxtb	r3, r3
 8012794:	2b00      	cmp	r3, #0
 8012796:	d03f      	beq.n	8012818 <USB_OTG_USBH_handle_hc_n_In_ISR+0x146>
  {
    UNMASK_HOST_INT_CHH (num);
 8012798:	687a      	ldr	r2, [r7, #4]
 801279a:	683b      	ldr	r3, [r7, #0]
 801279c:	3322      	adds	r3, #34	; 0x22
 801279e:	009b      	lsls	r3, r3, #2
 80127a0:	4413      	add	r3, r2
 80127a2:	689b      	ldr	r3, [r3, #8]
 80127a4:	68db      	ldr	r3, [r3, #12]
 80127a6:	64fb      	str	r3, [r7, #76]	; 0x4c
 80127a8:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 80127ac:	f043 0302 	orr.w	r3, r3, #2
 80127b0:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
 80127b4:	687a      	ldr	r2, [r7, #4]
 80127b6:	683b      	ldr	r3, [r7, #0]
 80127b8:	3322      	adds	r3, #34	; 0x22
 80127ba:	009b      	lsls	r3, r3, #2
 80127bc:	4413      	add	r3, r2
 80127be:	689b      	ldr	r3, [r3, #8]
 80127c0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80127c2:	60da      	str	r2, [r3, #12]
    pdev->host.HC_Status[num] = HC_STALL; 
 80127c4:	687a      	ldr	r2, [r7, #4]
 80127c6:	683b      	ldr	r3, [r7, #0]
 80127c8:	4413      	add	r3, r2
 80127ca:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 80127ce:	2205      	movs	r2, #5
 80127d0:	701a      	strb	r2, [r3, #0]
    CLEAR_HC_INT(hcreg , nak);   /* Clear the NAK Condition */
 80127d2:	2300      	movs	r3, #0
 80127d4:	64bb      	str	r3, [r7, #72]	; 0x48
 80127d6:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 80127da:	f043 0310 	orr.w	r3, r3, #16
 80127de:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
 80127e2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80127e4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80127e6:	609a      	str	r2, [r3, #8]
    CLEAR_HC_INT(hcreg , stall); /* Clear the STALL Condition */
 80127e8:	2300      	movs	r3, #0
 80127ea:	647b      	str	r3, [r7, #68]	; 0x44
 80127ec:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 80127f0:	f043 0308 	orr.w	r3, r3, #8
 80127f4:	f887 3044 	strb.w	r3, [r7, #68]	; 0x44
 80127f8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80127fa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80127fc:	609a      	str	r2, [r3, #8]
    hcint.b.nak = 0;           /* NOTE: When there is a 'stall', reset also nak, 
 80127fe:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8012802:	f36f 1304 	bfc	r3, #4, #1
 8012806:	f887 3068 	strb.w	r3, [r7, #104]	; 0x68
                                  else, the pdev->host.HC_Status = HC_STALL
                                  will be overwritten by 'nak' in code below */
    USB_OTG_HC_Halt(pdev, num);    
 801280a:	683b      	ldr	r3, [r7, #0]
 801280c:	b2db      	uxtb	r3, r3
 801280e:	4619      	mov	r1, r3
 8012810:	6878      	ldr	r0, [r7, #4]
 8012812:	f7fe ffe3 	bl	80117dc <USB_OTG_HC_Halt>
 8012816:	e03f      	b.n	8012898 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c6>
  }
  else if (hcint.b.datatglerr)
 8012818:	f897 3069 	ldrb.w	r3, [r7, #105]	; 0x69
 801281c:	f003 0304 	and.w	r3, r3, #4
 8012820:	b2db      	uxtb	r3, r3
 8012822:	2b00      	cmp	r3, #0
 8012824:	d038      	beq.n	8012898 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c6>
  {

      UNMASK_HOST_INT_CHH (num);
 8012826:	687a      	ldr	r2, [r7, #4]
 8012828:	683b      	ldr	r3, [r7, #0]
 801282a:	3322      	adds	r3, #34	; 0x22
 801282c:	009b      	lsls	r3, r3, #2
 801282e:	4413      	add	r3, r2
 8012830:	689b      	ldr	r3, [r3, #8]
 8012832:	68db      	ldr	r3, [r3, #12]
 8012834:	643b      	str	r3, [r7, #64]	; 0x40
 8012836:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 801283a:	f043 0302 	orr.w	r3, r3, #2
 801283e:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
 8012842:	687a      	ldr	r2, [r7, #4]
 8012844:	683b      	ldr	r3, [r7, #0]
 8012846:	3322      	adds	r3, #34	; 0x22
 8012848:	009b      	lsls	r3, r3, #2
 801284a:	4413      	add	r3, r2
 801284c:	689b      	ldr	r3, [r3, #8]
 801284e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012850:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 8012852:	683b      	ldr	r3, [r7, #0]
 8012854:	b2db      	uxtb	r3, r3
 8012856:	4619      	mov	r1, r3
 8012858:	6878      	ldr	r0, [r7, #4]
 801285a:	f7fe ffbf 	bl	80117dc <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak);   
 801285e:	2300      	movs	r3, #0
 8012860:	63fb      	str	r3, [r7, #60]	; 0x3c
 8012862:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 8012866:	f043 0310 	orr.w	r3, r3, #16
 801286a:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
 801286e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012870:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012872:	609a      	str	r2, [r3, #8]
      pdev->host.HC_Status[num] = HC_DATATGLERR; 
 8012874:	687a      	ldr	r2, [r7, #4]
 8012876:	683b      	ldr	r3, [r7, #0]
 8012878:	4413      	add	r3, r2
 801287a:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 801287e:	2208      	movs	r2, #8
 8012880:	701a      	strb	r2, [r3, #0]
    CLEAR_HC_INT(hcreg , datatglerr);
 8012882:	2300      	movs	r3, #0
 8012884:	63bb      	str	r3, [r7, #56]	; 0x38
 8012886:	f897 3039 	ldrb.w	r3, [r7, #57]	; 0x39
 801288a:	f043 0304 	orr.w	r3, r3, #4
 801288e:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
 8012892:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8012894:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012896:	609a      	str	r2, [r3, #8]
  }    
  
  if (hcint.b.frmovrun)
 8012898:	f897 3069 	ldrb.w	r3, [r7, #105]	; 0x69
 801289c:	f003 0302 	and.w	r3, r3, #2
 80128a0:	b2db      	uxtb	r3, r3
 80128a2:	2b00      	cmp	r3, #0
 80128a4:	d027      	beq.n	80128f6 <USB_OTG_USBH_handle_hc_n_In_ISR+0x224>
  {
    UNMASK_HOST_INT_CHH (num);
 80128a6:	687a      	ldr	r2, [r7, #4]
 80128a8:	683b      	ldr	r3, [r7, #0]
 80128aa:	3322      	adds	r3, #34	; 0x22
 80128ac:	009b      	lsls	r3, r3, #2
 80128ae:	4413      	add	r3, r2
 80128b0:	689b      	ldr	r3, [r3, #8]
 80128b2:	68db      	ldr	r3, [r3, #12]
 80128b4:	637b      	str	r3, [r7, #52]	; 0x34
 80128b6:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 80128ba:	f043 0302 	orr.w	r3, r3, #2
 80128be:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
 80128c2:	687a      	ldr	r2, [r7, #4]
 80128c4:	683b      	ldr	r3, [r7, #0]
 80128c6:	3322      	adds	r3, #34	; 0x22
 80128c8:	009b      	lsls	r3, r3, #2
 80128ca:	4413      	add	r3, r2
 80128cc:	689b      	ldr	r3, [r3, #8]
 80128ce:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80128d0:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80128d2:	683b      	ldr	r3, [r7, #0]
 80128d4:	b2db      	uxtb	r3, r3
 80128d6:	4619      	mov	r1, r3
 80128d8:	6878      	ldr	r0, [r7, #4]
 80128da:	f7fe ff7f 	bl	80117dc <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg ,frmovrun);
 80128de:	2300      	movs	r3, #0
 80128e0:	633b      	str	r3, [r7, #48]	; 0x30
 80128e2:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 80128e6:	f043 0302 	orr.w	r3, r3, #2
 80128ea:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
 80128ee:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80128f0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80128f2:	609a      	str	r2, [r3, #8]
 80128f4:	e1bf      	b.n	8012c76 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a4>
  }
  
  else if (hcint.b.xfercompl)
 80128f6:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80128fa:	f003 0301 	and.w	r3, r3, #1
 80128fe:	b2db      	uxtb	r3, r3
 8012900:	2b00      	cmp	r3, #0
 8012902:	f000 809b 	beq.w	8012a3c <USB_OTG_USBH_handle_hc_n_In_ISR+0x36a>
  {
    
    if (pdev->cfg.dma_enable == 1)
 8012906:	687b      	ldr	r3, [r7, #4]
 8012908:	78db      	ldrb	r3, [r3, #3]
 801290a:	2b01      	cmp	r3, #1
 801290c:	d117      	bne.n	801293e <USB_OTG_USBH_handle_hc_n_In_ISR+0x26c>
    {
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCTSIZ);
 801290e:	687a      	ldr	r2, [r7, #4]
 8012910:	683b      	ldr	r3, [r7, #0]
 8012912:	3322      	adds	r3, #34	; 0x22
 8012914:	009b      	lsls	r3, r3, #2
 8012916:	4413      	add	r3, r2
 8012918:	689b      	ldr	r3, [r3, #8]
 801291a:	691b      	ldr	r3, [r3, #16]
 801291c:	65fb      	str	r3, [r7, #92]	; 0x5c
      pdev->host.XferCnt[num] =  pdev->host.hc[num].xfer_len - hctsiz.b.xfersize;
 801291e:	687a      	ldr	r2, [r7, #4]
 8012920:	683b      	ldr	r3, [r7, #0]
 8012922:	015b      	lsls	r3, r3, #5
 8012924:	4413      	add	r3, r2
 8012926:	f503 732f 	add.w	r3, r3, #700	; 0x2bc
 801292a:	681b      	ldr	r3, [r3, #0]
 801292c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801292e:	f3c2 0212 	ubfx	r2, r2, #0, #19
 8012932:	1a99      	subs	r1, r3, r2
 8012934:	687b      	ldr	r3, [r7, #4]
 8012936:	683a      	ldr	r2, [r7, #0]
 8012938:	3294      	adds	r2, #148	; 0x94
 801293a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
 
    pdev->host.HC_Status[num] = HC_XFRC;     
 801293e:	687a      	ldr	r2, [r7, #4]
 8012940:	683b      	ldr	r3, [r7, #0]
 8012942:	4413      	add	r3, r2
 8012944:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012948:	2201      	movs	r2, #1
 801294a:	701a      	strb	r2, [r3, #0]
    pdev->host.ErrCnt [num]= 0;
 801294c:	687a      	ldr	r2, [r7, #4]
 801294e:	683b      	ldr	r3, [r7, #0]
 8012950:	3384      	adds	r3, #132	; 0x84
 8012952:	009b      	lsls	r3, r3, #2
 8012954:	4413      	add	r3, r2
 8012956:	2200      	movs	r2, #0
 8012958:	605a      	str	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , xfercompl);
 801295a:	2300      	movs	r3, #0
 801295c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801295e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8012962:	f043 0301 	orr.w	r3, r3, #1
 8012966:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
 801296a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801296c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801296e:	609a      	str	r2, [r3, #8]
    
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8012970:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8012974:	f003 030c 	and.w	r3, r3, #12
 8012978:	b2db      	uxtb	r3, r3
 801297a:	2b00      	cmp	r3, #0
 801297c:	d006      	beq.n	801298c <USB_OTG_USBH_handle_hc_n_In_ISR+0x2ba>
        (hcchar.b.eptype == EP_TYPE_BULK))
 801297e:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8012982:	f003 030c 	and.w	r3, r3, #12
 8012986:	b2db      	uxtb	r3, r3
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8012988:	2b08      	cmp	r3, #8
 801298a:	d139      	bne.n	8012a00 <USB_OTG_USBH_handle_hc_n_In_ISR+0x32e>
    {
      UNMASK_HOST_INT_CHH (num);
 801298c:	687a      	ldr	r2, [r7, #4]
 801298e:	683b      	ldr	r3, [r7, #0]
 8012990:	3322      	adds	r3, #34	; 0x22
 8012992:	009b      	lsls	r3, r3, #2
 8012994:	4413      	add	r3, r2
 8012996:	689b      	ldr	r3, [r3, #8]
 8012998:	68db      	ldr	r3, [r3, #12]
 801299a:	62bb      	str	r3, [r7, #40]	; 0x28
 801299c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80129a0:	f043 0302 	orr.w	r3, r3, #2
 80129a4:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
 80129a8:	687a      	ldr	r2, [r7, #4]
 80129aa:	683b      	ldr	r3, [r7, #0]
 80129ac:	3322      	adds	r3, #34	; 0x22
 80129ae:	009b      	lsls	r3, r3, #2
 80129b0:	4413      	add	r3, r2
 80129b2:	689b      	ldr	r3, [r3, #8]
 80129b4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80129b6:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 80129b8:	683b      	ldr	r3, [r7, #0]
 80129ba:	b2db      	uxtb	r3, r3
 80129bc:	4619      	mov	r1, r3
 80129be:	6878      	ldr	r0, [r7, #4]
 80129c0:	f7fe ff0c 	bl	80117dc <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak); 
 80129c4:	2300      	movs	r3, #0
 80129c6:	627b      	str	r3, [r7, #36]	; 0x24
 80129c8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 80129cc:	f043 0310 	orr.w	r3, r3, #16
 80129d0:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
 80129d4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80129d6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80129d8:	609a      	str	r2, [r3, #8]
      pdev->host.hc[num].toggle_in ^= 1;
 80129da:	687a      	ldr	r2, [r7, #4]
 80129dc:	683b      	ldr	r3, [r7, #0]
 80129de:	3316      	adds	r3, #22
 80129e0:	015b      	lsls	r3, r3, #5
 80129e2:	4413      	add	r3, r2
 80129e4:	3304      	adds	r3, #4
 80129e6:	781b      	ldrb	r3, [r3, #0]
 80129e8:	f083 0301 	eor.w	r3, r3, #1
 80129ec:	b2d9      	uxtb	r1, r3
 80129ee:	687a      	ldr	r2, [r7, #4]
 80129f0:	683b      	ldr	r3, [r7, #0]
 80129f2:	3316      	adds	r3, #22
 80129f4:	015b      	lsls	r3, r3, #5
 80129f6:	4413      	add	r3, r2
 80129f8:	3304      	adds	r3, #4
 80129fa:	460a      	mov	r2, r1
 80129fc:	701a      	strb	r2, [r3, #0]
 80129fe:	e13a      	b.n	8012c76 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a4>

    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 8012a00:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8012a04:	f003 030c 	and.w	r3, r3, #12
 8012a08:	b2db      	uxtb	r3, r3
 8012a0a:	2b0c      	cmp	r3, #12
 8012a0c:	f040 8133 	bne.w	8012c76 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a4>
    {
      hcchar.b.oddfrm  = 1;
 8012a10:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8012a14:	f043 0320 	orr.w	r3, r3, #32
 8012a18:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 8012a1c:	687a      	ldr	r2, [r7, #4]
 8012a1e:	683b      	ldr	r3, [r7, #0]
 8012a20:	3322      	adds	r3, #34	; 0x22
 8012a22:	009b      	lsls	r3, r3, #2
 8012a24:	4413      	add	r3, r2
 8012a26:	689b      	ldr	r3, [r3, #8]
 8012a28:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8012a2a:	601a      	str	r2, [r3, #0]
      pdev->host.URB_State[num] = URB_DONE;  
 8012a2c:	687a      	ldr	r2, [r7, #4]
 8012a2e:	683b      	ldr	r3, [r7, #0]
 8012a30:	4413      	add	r3, r2
 8012a32:	f203 239b 	addw	r3, r3, #667	; 0x29b
 8012a36:	2201      	movs	r2, #1
 8012a38:	701a      	strb	r2, [r3, #0]
 8012a3a:	e11c      	b.n	8012c76 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a4>
    }
    
  }
  else if (hcint.b.chhltd)
 8012a3c:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8012a40:	f003 0302 	and.w	r3, r3, #2
 8012a44:	b2db      	uxtb	r3, r3
 8012a46:	2b00      	cmp	r3, #0
 8012a48:	d07b      	beq.n	8012b42 <USB_OTG_USBH_handle_hc_n_In_ISR+0x470>
  {
    MASK_HOST_INT_CHH (num);
 8012a4a:	687a      	ldr	r2, [r7, #4]
 8012a4c:	683b      	ldr	r3, [r7, #0]
 8012a4e:	3322      	adds	r3, #34	; 0x22
 8012a50:	009b      	lsls	r3, r3, #2
 8012a52:	4413      	add	r3, r2
 8012a54:	689b      	ldr	r3, [r3, #8]
 8012a56:	68db      	ldr	r3, [r3, #12]
 8012a58:	623b      	str	r3, [r7, #32]
 8012a5a:	f897 3020 	ldrb.w	r3, [r7, #32]
 8012a5e:	f36f 0341 	bfc	r3, #1, #1
 8012a62:	f887 3020 	strb.w	r3, [r7, #32]
 8012a66:	687a      	ldr	r2, [r7, #4]
 8012a68:	683b      	ldr	r3, [r7, #0]
 8012a6a:	3322      	adds	r3, #34	; 0x22
 8012a6c:	009b      	lsls	r3, r3, #2
 8012a6e:	4413      	add	r3, r2
 8012a70:	689b      	ldr	r3, [r3, #8]
 8012a72:	6a3a      	ldr	r2, [r7, #32]
 8012a74:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 8012a76:	687a      	ldr	r2, [r7, #4]
 8012a78:	683b      	ldr	r3, [r7, #0]
 8012a7a:	4413      	add	r3, r2
 8012a7c:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012a80:	781b      	ldrb	r3, [r3, #0]
 8012a82:	b2db      	uxtb	r3, r3
 8012a84:	2b01      	cmp	r3, #1
 8012a86:	d107      	bne.n	8012a98 <USB_OTG_USBH_handle_hc_n_In_ISR+0x3c6>
    {
      pdev->host.URB_State[num] = URB_DONE;      
 8012a88:	687a      	ldr	r2, [r7, #4]
 8012a8a:	683b      	ldr	r3, [r7, #0]
 8012a8c:	4413      	add	r3, r2
 8012a8e:	f203 239b 	addw	r3, r3, #667	; 0x29b
 8012a92:	2201      	movs	r2, #1
 8012a94:	701a      	strb	r2, [r3, #0]
 8012a96:	e04a      	b.n	8012b2e <USB_OTG_USBH_handle_hc_n_In_ISR+0x45c>
    }
    
    else if (pdev->host.HC_Status[num] == HC_STALL) 
 8012a98:	687a      	ldr	r2, [r7, #4]
 8012a9a:	683b      	ldr	r3, [r7, #0]
 8012a9c:	4413      	add	r3, r2
 8012a9e:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012aa2:	781b      	ldrb	r3, [r3, #0]
 8012aa4:	b2db      	uxtb	r3, r3
 8012aa6:	2b05      	cmp	r3, #5
 8012aa8:	d107      	bne.n	8012aba <USB_OTG_USBH_handle_hc_n_In_ISR+0x3e8>
    {
       pdev->host.URB_State[num] = URB_STALL;
 8012aaa:	687a      	ldr	r2, [r7, #4]
 8012aac:	683b      	ldr	r3, [r7, #0]
 8012aae:	4413      	add	r3, r2
 8012ab0:	f203 239b 	addw	r3, r3, #667	; 0x29b
 8012ab4:	2204      	movs	r2, #4
 8012ab6:	701a      	strb	r2, [r3, #0]
 8012ab8:	e039      	b.n	8012b2e <USB_OTG_USBH_handle_hc_n_In_ISR+0x45c>
    }   
    
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 8012aba:	687a      	ldr	r2, [r7, #4]
 8012abc:	683b      	ldr	r3, [r7, #0]
 8012abe:	4413      	add	r3, r2
 8012ac0:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012ac4:	781b      	ldrb	r3, [r3, #0]
 8012ac6:	b2db      	uxtb	r3, r3
 8012ac8:	2b06      	cmp	r3, #6
 8012aca:	d008      	beq.n	8012ade <USB_OTG_USBH_handle_hc_n_In_ISR+0x40c>
            (pdev->host.HC_Status[num] == HC_DATATGLERR))
 8012acc:	687a      	ldr	r2, [r7, #4]
 8012ace:	683b      	ldr	r3, [r7, #0]
 8012ad0:	4413      	add	r3, r2
 8012ad2:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012ad6:	781b      	ldrb	r3, [r3, #0]
 8012ad8:	b2db      	uxtb	r3, r3
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 8012ada:	2b08      	cmp	r3, #8
 8012adc:	d10e      	bne.n	8012afc <USB_OTG_USBH_handle_hc_n_In_ISR+0x42a>
    {
        pdev->host.ErrCnt[num] = 0;
 8012ade:	687a      	ldr	r2, [r7, #4]
 8012ae0:	683b      	ldr	r3, [r7, #0]
 8012ae2:	3384      	adds	r3, #132	; 0x84
 8012ae4:	009b      	lsls	r3, r3, #2
 8012ae6:	4413      	add	r3, r2
 8012ae8:	2200      	movs	r2, #0
 8012aea:	605a      	str	r2, [r3, #4]
        pdev->host.URB_State[num] = URB_ERROR;  
 8012aec:	687a      	ldr	r2, [r7, #4]
 8012aee:	683b      	ldr	r3, [r7, #0]
 8012af0:	4413      	add	r3, r2
 8012af2:	f203 239b 	addw	r3, r3, #667	; 0x29b
 8012af6:	2203      	movs	r2, #3
 8012af8:	701a      	strb	r2, [r3, #0]
 8012afa:	e018      	b.n	8012b2e <USB_OTG_USBH_handle_hc_n_In_ISR+0x45c>

    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 8012afc:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8012b00:	f003 030c 	and.w	r3, r3, #12
 8012b04:	b2db      	uxtb	r3, r3
 8012b06:	2b0c      	cmp	r3, #12
 8012b08:	d111      	bne.n	8012b2e <USB_OTG_USBH_handle_hc_n_In_ISR+0x45c>
    {
      pdev->host.hc[num].toggle_in ^= 1;
 8012b0a:	687a      	ldr	r2, [r7, #4]
 8012b0c:	683b      	ldr	r3, [r7, #0]
 8012b0e:	3316      	adds	r3, #22
 8012b10:	015b      	lsls	r3, r3, #5
 8012b12:	4413      	add	r3, r2
 8012b14:	3304      	adds	r3, #4
 8012b16:	781b      	ldrb	r3, [r3, #0]
 8012b18:	f083 0301 	eor.w	r3, r3, #1
 8012b1c:	b2d9      	uxtb	r1, r3
 8012b1e:	687a      	ldr	r2, [r7, #4]
 8012b20:	683b      	ldr	r3, [r7, #0]
 8012b22:	3316      	adds	r3, #22
 8012b24:	015b      	lsls	r3, r3, #5
 8012b26:	4413      	add	r3, r2
 8012b28:	3304      	adds	r3, #4
 8012b2a:	460a      	mov	r2, r1
 8012b2c:	701a      	strb	r2, [r3, #0]
    }
    
    CLEAR_HC_INT(hcreg , chhltd);    
 8012b2e:	2300      	movs	r3, #0
 8012b30:	61fb      	str	r3, [r7, #28]
 8012b32:	7f3b      	ldrb	r3, [r7, #28]
 8012b34:	f043 0302 	orr.w	r3, r3, #2
 8012b38:	773b      	strb	r3, [r7, #28]
 8012b3a:	69fa      	ldr	r2, [r7, #28]
 8012b3c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012b3e:	609a      	str	r2, [r3, #8]
 8012b40:	e099      	b.n	8012c76 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a4>
    
  }    
  else if (hcint.b.xacterr)
 8012b42:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8012b46:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8012b4a:	b2db      	uxtb	r3, r3
 8012b4c:	2b00      	cmp	r3, #0
 8012b4e:	d037      	beq.n	8012bc0 <USB_OTG_USBH_handle_hc_n_In_ISR+0x4ee>
  {
    UNMASK_HOST_INT_CHH (num);
 8012b50:	687a      	ldr	r2, [r7, #4]
 8012b52:	683b      	ldr	r3, [r7, #0]
 8012b54:	3322      	adds	r3, #34	; 0x22
 8012b56:	009b      	lsls	r3, r3, #2
 8012b58:	4413      	add	r3, r2
 8012b5a:	689b      	ldr	r3, [r3, #8]
 8012b5c:	68db      	ldr	r3, [r3, #12]
 8012b5e:	61bb      	str	r3, [r7, #24]
 8012b60:	7e3b      	ldrb	r3, [r7, #24]
 8012b62:	f043 0302 	orr.w	r3, r3, #2
 8012b66:	763b      	strb	r3, [r7, #24]
 8012b68:	687a      	ldr	r2, [r7, #4]
 8012b6a:	683b      	ldr	r3, [r7, #0]
 8012b6c:	3322      	adds	r3, #34	; 0x22
 8012b6e:	009b      	lsls	r3, r3, #2
 8012b70:	4413      	add	r3, r2
 8012b72:	689b      	ldr	r3, [r3, #8]
 8012b74:	69ba      	ldr	r2, [r7, #24]
 8012b76:	60da      	str	r2, [r3, #12]
    pdev->host.ErrCnt[num] ++;
 8012b78:	687a      	ldr	r2, [r7, #4]
 8012b7a:	683b      	ldr	r3, [r7, #0]
 8012b7c:	3384      	adds	r3, #132	; 0x84
 8012b7e:	009b      	lsls	r3, r3, #2
 8012b80:	4413      	add	r3, r2
 8012b82:	685b      	ldr	r3, [r3, #4]
 8012b84:	1c5a      	adds	r2, r3, #1
 8012b86:	6879      	ldr	r1, [r7, #4]
 8012b88:	683b      	ldr	r3, [r7, #0]
 8012b8a:	3384      	adds	r3, #132	; 0x84
 8012b8c:	009b      	lsls	r3, r3, #2
 8012b8e:	440b      	add	r3, r1
 8012b90:	605a      	str	r2, [r3, #4]
    pdev->host.HC_Status[num] = HC_XACTERR;
 8012b92:	687a      	ldr	r2, [r7, #4]
 8012b94:	683b      	ldr	r3, [r7, #0]
 8012b96:	4413      	add	r3, r2
 8012b98:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012b9c:	2206      	movs	r2, #6
 8012b9e:	701a      	strb	r2, [r3, #0]
    USB_OTG_HC_Halt(pdev, num);
 8012ba0:	683b      	ldr	r3, [r7, #0]
 8012ba2:	b2db      	uxtb	r3, r3
 8012ba4:	4619      	mov	r1, r3
 8012ba6:	6878      	ldr	r0, [r7, #4]
 8012ba8:	f7fe fe18 	bl	80117dc <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xacterr);    
 8012bac:	2300      	movs	r3, #0
 8012bae:	617b      	str	r3, [r7, #20]
 8012bb0:	7d3b      	ldrb	r3, [r7, #20]
 8012bb2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012bb6:	753b      	strb	r3, [r7, #20]
 8012bb8:	697a      	ldr	r2, [r7, #20]
 8012bba:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012bbc:	609a      	str	r2, [r3, #8]
 8012bbe:	e05a      	b.n	8012c76 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a4>
    
  }
  else if (hcint.b.nak)  
 8012bc0:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8012bc4:	f003 0310 	and.w	r3, r3, #16
 8012bc8:	b2db      	uxtb	r3, r3
 8012bca:	2b00      	cmp	r3, #0
 8012bcc:	d053      	beq.n	8012c76 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5a4>
  {  
    if(hcchar.b.eptype == EP_TYPE_INTR)
 8012bce:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8012bd2:	f003 030c 	and.w	r3, r3, #12
 8012bd6:	b2db      	uxtb	r3, r3
 8012bd8:	2b0c      	cmp	r3, #12
 8012bda:	d123      	bne.n	8012c24 <USB_OTG_USBH_handle_hc_n_In_ISR+0x552>
    {
      UNMASK_HOST_INT_CHH (num);
 8012bdc:	687a      	ldr	r2, [r7, #4]
 8012bde:	683b      	ldr	r3, [r7, #0]
 8012be0:	3322      	adds	r3, #34	; 0x22
 8012be2:	009b      	lsls	r3, r3, #2
 8012be4:	4413      	add	r3, r2
 8012be6:	689b      	ldr	r3, [r3, #8]
 8012be8:	68db      	ldr	r3, [r3, #12]
 8012bea:	613b      	str	r3, [r7, #16]
 8012bec:	7c3b      	ldrb	r3, [r7, #16]
 8012bee:	f043 0302 	orr.w	r3, r3, #2
 8012bf2:	743b      	strb	r3, [r7, #16]
 8012bf4:	687a      	ldr	r2, [r7, #4]
 8012bf6:	683b      	ldr	r3, [r7, #0]
 8012bf8:	3322      	adds	r3, #34	; 0x22
 8012bfa:	009b      	lsls	r3, r3, #2
 8012bfc:	4413      	add	r3, r2
 8012bfe:	689b      	ldr	r3, [r3, #8]
 8012c00:	693a      	ldr	r2, [r7, #16]
 8012c02:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 8012c04:	683b      	ldr	r3, [r7, #0]
 8012c06:	b2db      	uxtb	r3, r3
 8012c08:	4619      	mov	r1, r3
 8012c0a:	6878      	ldr	r0, [r7, #4]
 8012c0c:	f7fe fde6 	bl	80117dc <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak);   
 8012c10:	2300      	movs	r3, #0
 8012c12:	60fb      	str	r3, [r7, #12]
 8012c14:	7b3b      	ldrb	r3, [r7, #12]
 8012c16:	f043 0310 	orr.w	r3, r3, #16
 8012c1a:	733b      	strb	r3, [r7, #12]
 8012c1c:	68fa      	ldr	r2, [r7, #12]
 8012c1e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012c20:	609a      	str	r2, [r3, #8]
 8012c22:	e021      	b.n	8012c68 <USB_OTG_USBH_handle_hc_n_In_ISR+0x596>
    }
     else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8012c24:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8012c28:	f003 030c 	and.w	r3, r3, #12
 8012c2c:	b2db      	uxtb	r3, r3
 8012c2e:	2b00      	cmp	r3, #0
 8012c30:	d006      	beq.n	8012c40 <USB_OTG_USBH_handle_hc_n_In_ISR+0x56e>
             (hcchar.b.eptype == EP_TYPE_BULK))
 8012c32:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 8012c36:	f003 030c 	and.w	r3, r3, #12
 8012c3a:	b2db      	uxtb	r3, r3
     else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8012c3c:	2b08      	cmp	r3, #8
 8012c3e:	d113      	bne.n	8012c68 <USB_OTG_USBH_handle_hc_n_In_ISR+0x596>
    {
      /* re-activate the channel  */
      hcchar.b.chen = 1;
 8012c40:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8012c44:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012c48:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
      hcchar.b.chdis = 0;
 8012c4c:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8012c50:	f36f 1386 	bfc	r3, #6, #1
 8012c54:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 8012c58:	687a      	ldr	r2, [r7, #4]
 8012c5a:	683b      	ldr	r3, [r7, #0]
 8012c5c:	3322      	adds	r3, #34	; 0x22
 8012c5e:	009b      	lsls	r3, r3, #2
 8012c60:	4413      	add	r3, r2
 8012c62:	689b      	ldr	r3, [r3, #8]
 8012c64:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8012c66:	601a      	str	r2, [r3, #0]
    }
    pdev->host.HC_Status[num] = HC_NAK;
 8012c68:	687a      	ldr	r2, [r7, #4]
 8012c6a:	683b      	ldr	r3, [r7, #0]
 8012c6c:	4413      	add	r3, r2
 8012c6e:	f503 7323 	add.w	r3, r3, #652	; 0x28c
 8012c72:	2203      	movs	r2, #3
 8012c74:	701a      	strb	r2, [r3, #0]
  }

  
  return 1;
 8012c76:	2301      	movs	r3, #1
  
}
 8012c78:	4618      	mov	r0, r3
 8012c7a:	3770      	adds	r7, #112	; 0x70
 8012c7c:	46bd      	mov	sp, r7
 8012c7e:	bd80      	pop	{r7, pc}

08012c80 <USB_OTG_USBH_handle_rx_qlvl_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_rx_qlvl_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8012c80:	b580      	push	{r7, lr}
 8012c82:	b088      	sub	sp, #32
 8012c84:	af00      	add	r7, sp, #0
 8012c86:	6078      	str	r0, [r7, #4]
  USB_OTG_GRXFSTS_TypeDef       grxsts;
  USB_OTG_GINTMSK_TypeDef       intmsk;
  USB_OTG_HCTSIZn_TypeDef       hctsiz; 
  USB_OTG_HCCHAR_TypeDef        hcchar;
  __IO uint8_t                  channelnum =0;  
 8012c88:	2300      	movs	r3, #0
 8012c8a:	72fb      	strb	r3, [r7, #11]
  uint32_t                      count;    
  
  /* Disable the Rx Status Queue Level interrupt */
  intmsk.d32 = 0;
 8012c8c:	2300      	movs	r3, #0
 8012c8e:	617b      	str	r3, [r7, #20]
  intmsk.b.rxstsqlvl = 1;
 8012c90:	7d3b      	ldrb	r3, [r7, #20]
 8012c92:	f043 0310 	orr.w	r3, r3, #16
 8012c96:	753b      	strb	r3, [r7, #20]
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);
 8012c98:	687b      	ldr	r3, [r7, #4]
 8012c9a:	68db      	ldr	r3, [r3, #12]
 8012c9c:	687a      	ldr	r2, [r7, #4]
 8012c9e:	68d2      	ldr	r2, [r2, #12]
 8012ca0:	6991      	ldr	r1, [r2, #24]
 8012ca2:	697a      	ldr	r2, [r7, #20]
 8012ca4:	43d2      	mvns	r2, r2
 8012ca6:	400a      	ands	r2, r1
 8012ca8:	619a      	str	r2, [r3, #24]
  
  grxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRXSTSP);
 8012caa:	687b      	ldr	r3, [r7, #4]
 8012cac:	68db      	ldr	r3, [r3, #12]
 8012cae:	6a1b      	ldr	r3, [r3, #32]
 8012cb0:	61bb      	str	r3, [r7, #24]
  channelnum = grxsts.b.chnum;  
 8012cb2:	7e3b      	ldrb	r3, [r7, #24]
 8012cb4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8012cb8:	b2db      	uxtb	r3, r3
 8012cba:	72fb      	strb	r3, [r7, #11]
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR);
 8012cbc:	7afb      	ldrb	r3, [r7, #11]
 8012cbe:	b2db      	uxtb	r3, r3
 8012cc0:	687a      	ldr	r2, [r7, #4]
 8012cc2:	3322      	adds	r3, #34	; 0x22
 8012cc4:	009b      	lsls	r3, r3, #2
 8012cc6:	4413      	add	r3, r2
 8012cc8:	689b      	ldr	r3, [r3, #8]
 8012cca:	681b      	ldr	r3, [r3, #0]
 8012ccc:	60fb      	str	r3, [r7, #12]
  
  switch (grxsts.b.pktsts)
 8012cce:	7ebb      	ldrb	r3, [r7, #26]
 8012cd0:	f3c3 0343 	ubfx	r3, r3, #1, #4
 8012cd4:	b2db      	uxtb	r3, r3
 8012cd6:	2b02      	cmp	r3, #2
 8012cd8:	d000      	beq.n	8012cdc <USB_OTG_USBH_handle_rx_qlvl_ISR+0x5c>
    case GRXSTS_PKTSTS_IN_XFER_COMP:
   
    case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
  case GRXSTS_PKTSTS_CH_HALTED:
  default:
    break;
 8012cda:	e08b      	b.n	8012df4 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x174>
    if ((grxsts.b.bcnt > 0) && (pdev->host.hc[channelnum].xfer_buff != (void  *)0))
 8012cdc:	8b3b      	ldrh	r3, [r7, #24]
 8012cde:	f3c3 130a 	ubfx	r3, r3, #4, #11
 8012ce2:	b29b      	uxth	r3, r3
 8012ce4:	2b00      	cmp	r3, #0
 8012ce6:	f340 8084 	ble.w	8012df2 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x172>
 8012cea:	7afb      	ldrb	r3, [r7, #11]
 8012cec:	b2db      	uxtb	r3, r3
 8012cee:	687a      	ldr	r2, [r7, #4]
 8012cf0:	330d      	adds	r3, #13
 8012cf2:	015b      	lsls	r3, r3, #5
 8012cf4:	4413      	add	r3, r2
 8012cf6:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8012cfa:	681b      	ldr	r3, [r3, #0]
 8012cfc:	2b00      	cmp	r3, #0
 8012cfe:	d078      	beq.n	8012df2 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x172>
      USB_OTG_ReadPacket(pdev, pdev->host.hc[channelnum].xfer_buff, grxsts.b.bcnt);
 8012d00:	7afb      	ldrb	r3, [r7, #11]
 8012d02:	b2db      	uxtb	r3, r3
 8012d04:	687a      	ldr	r2, [r7, #4]
 8012d06:	330d      	adds	r3, #13
 8012d08:	015b      	lsls	r3, r3, #5
 8012d0a:	4413      	add	r3, r2
 8012d0c:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8012d10:	6819      	ldr	r1, [r3, #0]
 8012d12:	8b3b      	ldrh	r3, [r7, #24]
 8012d14:	f3c3 130a 	ubfx	r3, r3, #4, #11
 8012d18:	b29b      	uxth	r3, r3
 8012d1a:	461a      	mov	r2, r3
 8012d1c:	6878      	ldr	r0, [r7, #4]
 8012d1e:	f7fd ffcf 	bl	8010cc0 <USB_OTG_ReadPacket>
      pdev->host.hc[grxsts.b.chnum].xfer_buff += grxsts.b.bcnt;           
 8012d22:	7e3b      	ldrb	r3, [r7, #24]
 8012d24:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8012d28:	b2db      	uxtb	r3, r3
 8012d2a:	4618      	mov	r0, r3
 8012d2c:	7e3b      	ldrb	r3, [r7, #24]
 8012d2e:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8012d32:	b2db      	uxtb	r3, r3
 8012d34:	687a      	ldr	r2, [r7, #4]
 8012d36:	330d      	adds	r3, #13
 8012d38:	015b      	lsls	r3, r3, #5
 8012d3a:	4413      	add	r3, r2
 8012d3c:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8012d40:	681b      	ldr	r3, [r3, #0]
 8012d42:	8b3a      	ldrh	r2, [r7, #24]
 8012d44:	f3c2 120a 	ubfx	r2, r2, #4, #11
 8012d48:	b292      	uxth	r2, r2
 8012d4a:	441a      	add	r2, r3
 8012d4c:	6879      	ldr	r1, [r7, #4]
 8012d4e:	f100 030d 	add.w	r3, r0, #13
 8012d52:	015b      	lsls	r3, r3, #5
 8012d54:	440b      	add	r3, r1
 8012d56:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8012d5a:	601a      	str	r2, [r3, #0]
      pdev->host.hc[grxsts.b.chnum].xfer_count  += grxsts.b.bcnt;
 8012d5c:	7e3b      	ldrb	r3, [r7, #24]
 8012d5e:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8012d62:	b2db      	uxtb	r3, r3
 8012d64:	4618      	mov	r0, r3
 8012d66:	7e3b      	ldrb	r3, [r7, #24]
 8012d68:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8012d6c:	b2db      	uxtb	r3, r3
 8012d6e:	687a      	ldr	r2, [r7, #4]
 8012d70:	015b      	lsls	r3, r3, #5
 8012d72:	4413      	add	r3, r2
 8012d74:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8012d78:	681b      	ldr	r3, [r3, #0]
 8012d7a:	8b3a      	ldrh	r2, [r7, #24]
 8012d7c:	f3c2 120a 	ubfx	r2, r2, #4, #11
 8012d80:	b292      	uxth	r2, r2
 8012d82:	441a      	add	r2, r3
 8012d84:	6879      	ldr	r1, [r7, #4]
 8012d86:	0143      	lsls	r3, r0, #5
 8012d88:	440b      	add	r3, r1
 8012d8a:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8012d8e:	601a      	str	r2, [r3, #0]
      count = pdev->host.hc[channelnum].xfer_count;
 8012d90:	7afb      	ldrb	r3, [r7, #11]
 8012d92:	b2db      	uxtb	r3, r3
 8012d94:	687a      	ldr	r2, [r7, #4]
 8012d96:	015b      	lsls	r3, r3, #5
 8012d98:	4413      	add	r3, r2
 8012d9a:	f503 7330 	add.w	r3, r3, #704	; 0x2c0
 8012d9e:	681b      	ldr	r3, [r3, #0]
 8012da0:	61fb      	str	r3, [r7, #28]
      pdev->host.XferCnt[channelnum]  = count;
 8012da2:	7afb      	ldrb	r3, [r7, #11]
 8012da4:	b2db      	uxtb	r3, r3
 8012da6:	461a      	mov	r2, r3
 8012da8:	687b      	ldr	r3, [r7, #4]
 8012daa:	3294      	adds	r2, #148	; 0x94
 8012dac:	69f9      	ldr	r1, [r7, #28]
 8012dae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCTSIZ);
 8012db2:	7afb      	ldrb	r3, [r7, #11]
 8012db4:	b2db      	uxtb	r3, r3
 8012db6:	687a      	ldr	r2, [r7, #4]
 8012db8:	3322      	adds	r3, #34	; 0x22
 8012dba:	009b      	lsls	r3, r3, #2
 8012dbc:	4413      	add	r3, r2
 8012dbe:	689b      	ldr	r3, [r3, #8]
 8012dc0:	691b      	ldr	r3, [r3, #16]
 8012dc2:	613b      	str	r3, [r7, #16]
      if(hctsiz.b.pktcnt > 0)
 8012dc4:	8a7b      	ldrh	r3, [r7, #18]
 8012dc6:	f3c3 03c9 	ubfx	r3, r3, #3, #10
 8012dca:	b29b      	uxth	r3, r3
 8012dcc:	2b00      	cmp	r3, #0
 8012dce:	dd10      	ble.n	8012df2 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x172>
        hcchar.b.chen = 1;
 8012dd0:	7bfb      	ldrb	r3, [r7, #15]
 8012dd2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012dd6:	73fb      	strb	r3, [r7, #15]
        hcchar.b.chdis = 0;
 8012dd8:	7bfb      	ldrb	r3, [r7, #15]
 8012dda:	f36f 1386 	bfc	r3, #6, #1
 8012dde:	73fb      	strb	r3, [r7, #15]
        USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR, hcchar.d32);
 8012de0:	7afb      	ldrb	r3, [r7, #11]
 8012de2:	b2db      	uxtb	r3, r3
 8012de4:	687a      	ldr	r2, [r7, #4]
 8012de6:	3322      	adds	r3, #34	; 0x22
 8012de8:	009b      	lsls	r3, r3, #2
 8012dea:	4413      	add	r3, r2
 8012dec:	689b      	ldr	r3, [r3, #8]
 8012dee:	68fa      	ldr	r2, [r7, #12]
 8012df0:	601a      	str	r2, [r3, #0]
    break;
 8012df2:	bf00      	nop
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  intmsk.b.rxstsqlvl = 1;
 8012df4:	7d3b      	ldrb	r3, [r7, #20]
 8012df6:	f043 0310 	orr.w	r3, r3, #16
 8012dfa:	753b      	strb	r3, [r7, #20]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);
 8012dfc:	687b      	ldr	r3, [r7, #4]
 8012dfe:	68db      	ldr	r3, [r3, #12]
 8012e00:	687a      	ldr	r2, [r7, #4]
 8012e02:	68d2      	ldr	r2, [r2, #12]
 8012e04:	6991      	ldr	r1, [r2, #24]
 8012e06:	697a      	ldr	r2, [r7, #20]
 8012e08:	430a      	orrs	r2, r1
 8012e0a:	619a      	str	r2, [r3, #24]
  return 1;
 8012e0c:	2301      	movs	r3, #1
}
 8012e0e:	4618      	mov	r0, r3
 8012e10:	3720      	adds	r7, #32
 8012e12:	46bd      	mov	sp, r7
 8012e14:	bd80      	pop	{r7, pc}

08012e16 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>:

//--------------------------------------------------------------
static uint32_t USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8012e16:	b480      	push	{r7}
 8012e18:	b085      	sub	sp, #20
 8012e1a:	af00      	add	r7, sp, #0
 8012e1c:	6078      	str	r0, [r7, #4]
    USB_OTG_HCCHAR_TypeDef        hcchar; 
   
    

    
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[0]->HCCHAR);
 8012e1e:	687b      	ldr	r3, [r7, #4]
 8012e20:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012e24:	681b      	ldr	r3, [r3, #0]
 8012e26:	60bb      	str	r3, [r7, #8]
    hcchar.b.chen = 1;
 8012e28:	7afb      	ldrb	r3, [r7, #11]
 8012e2a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012e2e:	72fb      	strb	r3, [r7, #11]
    hcchar.b.chdis = 1;
 8012e30:	7afb      	ldrb	r3, [r7, #11]
 8012e32:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8012e36:	72fb      	strb	r3, [r7, #11]
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[0]->HCCHAR, hcchar.d32);  
 8012e38:	687b      	ldr	r3, [r7, #4]
 8012e3a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012e3e:	68ba      	ldr	r2, [r7, #8]
 8012e40:	601a      	str	r2, [r3, #0]
    
    gintsts.d32 = 0;
 8012e42:	2300      	movs	r3, #0
 8012e44:	60fb      	str	r3, [r7, #12]
    /* Clear interrupt */
    gintsts.b.incomplisoout = 1;
 8012e46:	7bbb      	ldrb	r3, [r7, #14]
 8012e48:	f043 0320 	orr.w	r3, r3, #32
 8012e4c:	73bb      	strb	r3, [r7, #14]
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8012e4e:	687b      	ldr	r3, [r7, #4]
 8012e50:	68db      	ldr	r3, [r3, #12]
 8012e52:	68fa      	ldr	r2, [r7, #12]
 8012e54:	615a      	str	r2, [r3, #20]

    return 1;
 8012e56:	2301      	movs	r3, #1
}
 8012e58:	4618      	mov	r0, r3
 8012e5a:	3714      	adds	r7, #20
 8012e5c:	46bd      	mov	sp, r7
 8012e5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e62:	4770      	bx	lr

08012e64 <USBH_Connect>:

//--------------------------------------------------------------
void USBH_Connect (void *pdev)
{
  USB_OTG_CORE_HANDLE *ppdev = pdev;
  ppdev->host.port_cb->ConnStatus = 1;
 8012e64:	f8d0 34ac 	ldr.w	r3, [r0, #1196]	; 0x4ac
 8012e68:	2101      	movs	r1, #1
  ppdev->host.port_cb->ConnHandled = 0; 
 8012e6a:	2200      	movs	r2, #0
  ppdev->host.port_cb->ConnStatus = 1;
 8012e6c:	7219      	strb	r1, [r3, #8]
  ppdev->host.port_cb->ConnHandled = 0; 
 8012e6e:	729a      	strb	r2, [r3, #10]
 8012e70:	4770      	bx	lr
 8012e72:	bf00      	nop

08012e74 <USBH_Disconnect>:
{
  
  USB_OTG_CORE_HANDLE *ppdev = pdev;
    
  /* Make device Not connected flag true */
  ppdev->host.port_cb->DisconnStatus = 1; 
 8012e74:	f8d0 34ac 	ldr.w	r3, [r0, #1196]	; 0x4ac
 8012e78:	2101      	movs	r1, #1
  ppdev->host.port_cb->DisconnHandled = 0;
 8012e7a:	2200      	movs	r2, #0
  ppdev->host.port_cb->DisconnStatus = 1; 
 8012e7c:	7259      	strb	r1, [r3, #9]
  ppdev->host.port_cb->DisconnHandled = 0;
 8012e7e:	72da      	strb	r2, [r3, #11]
 8012e80:	4770      	bx	lr
 8012e82:	bf00      	nop

08012e84 <USBH_Init>:
void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBH_HOST *phost,               
               USBH_Class_cb_TypeDef *class_cb, 
               USBH_Usr_cb_TypeDef *usr_cb)
{
 8012e84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8012e88:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8012e8c:	4614      	mov	r4, r2
 8012e8e:	4605      	mov	r5, r0
 8012e90:	460f      	mov	r7, r1
 8012e92:	4699      	mov	r9, r3
     
  /* Hardware Init */
  USB_OTG_BSP_Init(pdev);  
 8012e94:	f7fd fe50 	bl	8010b38 <USB_OTG_BSP_Init>
  
  /* configure GPIO pin used for switching VBUS power */
  USB_OTG_BSP_ConfigVBUS(0);  
 8012e98:	2000      	movs	r0, #0
 8012e9a:	f7fd fea7 	bl	8010bec <USB_OTG_BSP_ConfigVBUS>
  phost->RequestState = CMD_SEND;  
  
  phost->Control.state = CTRL_SETUP;
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
  
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8012e9e:	2600      	movs	r6, #0
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 8012ea0:	2340      	movs	r3, #64	; 0x40
  phost->Control.state = CTRL_SETUP;
 8012ea2:	2201      	movs	r2, #1
  phost->gState = HOST_IDLE;
 8012ea4:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 8012ea8:	71a3      	strb	r3, [r4, #6]
  phost->Control.state = CTRL_SETUP;
 8012eaa:	7722      	strb	r2, [r4, #28]
  phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
 8012eac:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
  phost->gState = HOST_IDLE;
 8012eb0:	6021      	str	r1, [r4, #0]
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8012eb2:	f884 6020 	strb.w	r6, [r4, #32]
  
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 8012eb6:	7921      	ldrb	r1, [r4, #4]
 8012eb8:	4628      	mov	r0, r5
 8012eba:	f000 fba3 	bl	8013604 <USBH_Free_Channel>
  USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
 8012ebe:	7961      	ldrb	r1, [r4, #5]
 8012ec0:	4628      	mov	r0, r5
 8012ec2:	f000 fb9f 	bl	8013604 <USBH_Free_Channel>
  pdev->host.port_cb = &USBH_DeviceConnStatus_cb;
 8012ec6:	4a0b      	ldr	r2, [pc, #44]	; (8012ef4 <USBH_Init+0x70>)
  phost->class_cb = class_cb;
 8012ec8:	f8c4 907c 	str.w	r9, [r4, #124]	; 0x7c
  phost->usr_cb = usr_cb;  
 8012ecc:	f8c4 8080 	str.w	r8, [r4, #128]	; 0x80
   HCD_Init(pdev , coreID);
 8012ed0:	4639      	mov	r1, r7
  pdev->host.port_cb = &USBH_DeviceConnStatus_cb;
 8012ed2:	f8c5 24ac 	str.w	r2, [r5, #1196]	; 0x4ac
   HCD_Init(pdev , coreID);
 8012ed6:	4628      	mov	r0, r5
  pdev->host.port_cb->ConnStatus = 0;   
 8012ed8:	7216      	strb	r6, [r2, #8]
  pdev->host.port_cb->DisconnStatus = 0; 
 8012eda:	7256      	strb	r6, [r2, #9]
   HCD_Init(pdev , coreID);
 8012edc:	f7fe fda6 	bl	8011a2c <HCD_Init>
  phost->usr_cb->Init();
 8012ee0:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8012ee4:	681b      	ldr	r3, [r3, #0]
 8012ee6:	4798      	blx	r3
  USB_OTG_BSP_EnableInterrupt(pdev);
 8012ee8:	4628      	mov	r0, r5
}
 8012eea:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  USB_OTG_BSP_EnableInterrupt(pdev);
 8012eee:	f7fd be5f 	b.w	8010bb0 <USB_OTG_BSP_EnableInterrupt>
 8012ef2:	bf00      	nop
 8012ef4:	200000bc 	.word	0x200000bc

08012ef8 <USBH_DeInit>:
{
 8012ef8:	b570      	push	{r4, r5, r6, lr}
 8012efa:	460c      	mov	r4, r1
  phost->Control.state = CTRL_SETUP;
 8012efc:	2301      	movs	r3, #1
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 8012efe:	2240      	movs	r2, #64	; 0x40
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8012f00:	2500      	movs	r5, #0
  phost->gState = HOST_IDLE;
 8012f02:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8012f06:	6021      	str	r1, [r4, #0]
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 8012f08:	71a2      	strb	r2, [r4, #6]
  phost->Control.state = CTRL_SETUP;
 8012f0a:	7723      	strb	r3, [r4, #28]
  phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
 8012f0c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 8012f10:	7921      	ldrb	r1, [r4, #4]
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8012f12:	f884 5020 	strb.w	r5, [r4, #32]
{
 8012f16:	4606      	mov	r6, r0
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 8012f18:	f000 fb74 	bl	8013604 <USBH_Free_Channel>
  USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
 8012f1c:	7961      	ldrb	r1, [r4, #5]
 8012f1e:	4630      	mov	r0, r6
 8012f20:	f000 fb70 	bl	8013604 <USBH_Free_Channel>
  return USBH_OK;
}
 8012f24:	4628      	mov	r0, r5
 8012f26:	bd70      	pop	{r4, r5, r6, pc}

08012f28 <USBH_ErrorHandle>:

//--------------------------------------------------------------
void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
{
  /* Error unrecovered or not supported device speed */
  if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
 8012f28:	1f0b      	subs	r3, r1, #4
 8012f2a:	2b01      	cmp	r3, #1
 8012f2c:	d908      	bls.n	8012f40 <USBH_ErrorHandle+0x18>
  {
    phost->usr_cb->UnrecoveredError(); 
    phost->gState = HOST_ERROR_STATE;   
  }  
  /* USB host restart requested from application layer */
  else if(errType == USBH_APPLY_DEINIT)
 8012f2e:	2906      	cmp	r1, #6
 8012f30:	d000      	beq.n	8012f34 <USBH_ErrorHandle+0xc>
 8012f32:	4770      	bx	lr
  {
    phost->gState = HOST_ERROR_STATE;  
    /* user callback for initalization */
    phost->usr_cb->Init();
 8012f34:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    phost->gState = HOST_ERROR_STATE;  
 8012f38:	220c      	movs	r2, #12
    phost->usr_cb->Init();
 8012f3a:	681b      	ldr	r3, [r3, #0]
    phost->gState = HOST_ERROR_STATE;  
 8012f3c:	7002      	strb	r2, [r0, #0]
    phost->usr_cb->Init();
 8012f3e:	4718      	bx	r3
{
 8012f40:	b510      	push	{r4, lr}
    phost->usr_cb->UnrecoveredError(); 
 8012f42:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8012f46:	4604      	mov	r4, r0
 8012f48:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012f4a:	4798      	blx	r3
    phost->gState = HOST_ERROR_STATE;   
 8012f4c:	230c      	movs	r3, #12
 8012f4e:	7023      	strb	r3, [r4, #0]
 8012f50:	bd10      	pop	{r4, pc}
 8012f52:	bf00      	nop

08012f54 <USBH_HandleControl>:
}


//--------------------------------------------------------------
USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
{
 8012f54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  URB_STATE URB_Status = URB_IDLE;
  
  phost->Control.status = CTRL_START;

  
  switch (phost->Control.state)
 8012f56:	7f0b      	ldrb	r3, [r1, #28]
  phost->Control.status = CTRL_START;
 8012f58:	2200      	movs	r2, #0
  switch (phost->Control.state)
 8012f5a:	3b01      	subs	r3, #1
{
 8012f5c:	460c      	mov	r4, r1
  phost->Control.status = CTRL_START;
 8012f5e:	748a      	strb	r2, [r1, #18]
{
 8012f60:	4605      	mov	r5, r0
  switch (phost->Control.state)
 8012f62:	2b0a      	cmp	r3, #10
 8012f64:	f200 808e 	bhi.w	8013084 <USBH_HandleControl+0x130>
 8012f68:	e8df f003 	tbb	[pc, r3]
 8012f6c:	332a1c14 	.word	0x332a1c14
 8012f70:	8f695c4b 	.word	0x8f695c4b
 8012f74:	8372      	.short	0x8372
 8012f76:	06          	.byte	0x06
 8012f77:	00          	.byte	0x00
    PID; i.e., recovery actions via some other pipe are not required for control
    endpoints. For the Default Control Pipe, a device reset will ultimately be 
    required to clear the halt or error condition if the next Setup PID is not 
    accepted.
    */
    if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8012f78:	7b8b      	ldrb	r3, [r1, #14]
 8012f7a:	3301      	adds	r3, #1
 8012f7c:	b2db      	uxtb	r3, r3
 8012f7e:	2b02      	cmp	r3, #2
 8012f80:	738b      	strb	r3, [r1, #14]
 8012f82:	f240 809e 	bls.w	80130c2 <USBH_HandleControl+0x16e>
      phost->Control.state = CTRL_SETUP; 
    }
    else
    {
      phost->Control.status = CTRL_FAIL;
      phost->gState =   phost->gStateBkp;
 8012f86:	784b      	ldrb	r3, [r1, #1]
 8012f88:	700b      	strb	r3, [r1, #0]
      phost->Control.status = CTRL_FAIL;
 8012f8a:	2208      	movs	r2, #8
 8012f8c:	748a      	strb	r2, [r1, #18]
      
      status = USBH_FAIL;
 8012f8e:	2302      	movs	r3, #2
    
  default:
    break;
  }
  return status;
}
 8012f90:	4618      	mov	r0, r3
 8012f92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USBH_CtlSendSetup     (pdev, 
 8012f94:	794a      	ldrb	r2, [r1, #5]
 8012f96:	3114      	adds	r1, #20
 8012f98:	f000 fb74 	bl	8013684 <USBH_CtlSendSetup>
    phost->Control.state = CTRL_SETUP_WAIT;  
 8012f9c:	2302      	movs	r3, #2
 8012f9e:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 8012fa0:	2300      	movs	r3, #0
    break; 
 8012fa2:	e7f5      	b.n	8012f90 <USBH_HandleControl+0x3c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
 8012fa4:	7949      	ldrb	r1, [r1, #5]
 8012fa6:	f7fe fdcb 	bl	8011b40 <HCD_GetURB_State>
    if(URB_Status == URB_DONE)
 8012faa:	2801      	cmp	r0, #1
 8012fac:	f000 808d 	beq.w	80130ca <USBH_HandleControl+0x176>
    else if(URB_Status == URB_ERROR)
 8012fb0:	2803      	cmp	r0, #3
 8012fb2:	d167      	bne.n	8013084 <USBH_HandleControl+0x130>
      phost->Control.status = CTRL_XACTERR;
 8012fb4:	2305      	movs	r3, #5
      phost->Control.state = CTRL_ERROR;     
 8012fb6:	220b      	movs	r2, #11
      phost->Control.status = CTRL_XACTERR;
 8012fb8:	74a3      	strb	r3, [r4, #18]
      phost->Control.state = CTRL_ERROR;     
 8012fba:	7722      	strb	r2, [r4, #28]
  USBH_Status status = USBH_OK;
 8012fbc:	2300      	movs	r3, #0
 8012fbe:	e7e7      	b.n	8012f90 <USBH_HandleControl+0x3c>
    USBH_CtlReceiveData(pdev,
 8012fc0:	790b      	ldrb	r3, [r1, #4]
 8012fc2:	7b0a      	ldrb	r2, [r1, #12]
 8012fc4:	6889      	ldr	r1, [r1, #8]
 8012fc6:	f000 fb99 	bl	80136fc <USBH_CtlReceiveData>
    phost->Control.state = CTRL_DATA_IN_WAIT;
 8012fca:	2304      	movs	r3, #4
 8012fcc:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 8012fce:	2300      	movs	r3, #0
    break;    
 8012fd0:	e7de      	b.n	8012f90 <USBH_HandleControl+0x3c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 8012fd2:	7909      	ldrb	r1, [r1, #4]
 8012fd4:	f7fe fdb4 	bl	8011b40 <HCD_GetURB_State>
    if  (URB_Status == URB_DONE)
 8012fd8:	2801      	cmp	r0, #1
 8012fda:	f000 8088 	beq.w	80130ee <USBH_HandleControl+0x19a>
    if  (URB_Status == URB_STALL) 
 8012fde:	2804      	cmp	r0, #4
 8012fe0:	d06b      	beq.n	80130ba <USBH_HandleControl+0x166>
    else if (URB_Status == URB_ERROR)
 8012fe2:	2803      	cmp	r0, #3
 8012fe4:	d008      	beq.n	8012ff8 <USBH_HandleControl+0xa4>
    else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
 8012fe6:	4628      	mov	r0, r5
 8012fe8:	f7fe fda6 	bl	8011b38 <HCD_GetCurrentFrame>
 8012fec:	4a4a      	ldr	r2, [pc, #296]	; (8013118 <USBH_HandleControl+0x1c4>)
 8012fee:	8a23      	ldrh	r3, [r4, #16]
 8012ff0:	8812      	ldrh	r2, [r2, #0]
 8012ff2:	1ac0      	subs	r0, r0, r3
 8012ff4:	4290      	cmp	r0, r2
 8012ff6:	d945      	bls.n	8013084 <USBH_HandleControl+0x130>
      phost->Control.state = CTRL_ERROR;    
 8012ff8:	230b      	movs	r3, #11
 8012ffa:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 8012ffc:	2300      	movs	r3, #0
}
 8012ffe:	4618      	mov	r0, r3
 8013000:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
 8013002:	794b      	ldrb	r3, [r1, #5]
    USBH_CtlSendData (pdev,
 8013004:	7b0a      	ldrb	r2, [r1, #12]
 8013006:	6889      	ldr	r1, [r1, #8]
 8013008:	eb00 1743 	add.w	r7, r0, r3, lsl #5
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
 801300c:	f897 62c5 	ldrb.w	r6, [r7, #709]	; 0x2c5
 8013010:	f086 0601 	eor.w	r6, r6, #1
 8013014:	f887 62c5 	strb.w	r6, [r7, #709]	; 0x2c5
    USBH_CtlSendData (pdev,
 8013018:	f000 fb4c 	bl	80136b4 <USBH_CtlSendData>
    phost->Control.state = CTRL_DATA_OUT_WAIT;
 801301c:	2306      	movs	r3, #6
 801301e:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 8013020:	2300      	movs	r3, #0
    break;
 8013022:	e7b5      	b.n	8012f90 <USBH_HandleControl+0x3c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
 8013024:	7949      	ldrb	r1, [r1, #5]
 8013026:	f7fe fd8b 	bl	8011b40 <HCD_GetURB_State>
    if  (URB_Status == URB_DONE)
 801302a:	2801      	cmp	r0, #1
 801302c:	d062      	beq.n	80130f4 <USBH_HandleControl+0x1a0>
    else if  (URB_Status == URB_STALL) 
 801302e:	2804      	cmp	r0, #4
 8013030:	d043      	beq.n	80130ba <USBH_HandleControl+0x166>
    else if  (URB_Status == URB_NOTREADY)
 8013032:	2802      	cmp	r0, #2
 8013034:	d124      	bne.n	8013080 <USBH_HandleControl+0x12c>
      phost->Control.state = CTRL_DATA_OUT;
 8013036:	2305      	movs	r3, #5
 8013038:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 801303a:	2300      	movs	r3, #0
 801303c:	e7a8      	b.n	8012f90 <USBH_HandleControl+0x3c>
    USBH_CtlReceiveData (pdev,
 801303e:	2200      	movs	r2, #0
 8013040:	7923      	ldrb	r3, [r4, #4]
 8013042:	4611      	mov	r1, r2
 8013044:	f000 fb5a 	bl	80136fc <USBH_CtlReceiveData>
    phost->Control.state = CTRL_STATUS_IN_WAIT;
 8013048:	2308      	movs	r3, #8
 801304a:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 801304c:	2300      	movs	r3, #0
    break;
 801304e:	e79f      	b.n	8012f90 <USBH_HandleControl+0x3c>
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
 8013050:	794b      	ldrb	r3, [r1, #5]
 8013052:	eb00 1643 	add.w	r6, r0, r3, lsl #5
    USBH_CtlSendData (pdev,
 8013056:	2200      	movs	r2, #0
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
 8013058:	f896 12c5 	ldrb.w	r1, [r6, #709]	; 0x2c5
 801305c:	f081 0101 	eor.w	r1, r1, #1
 8013060:	f886 12c5 	strb.w	r1, [r6, #709]	; 0x2c5
    USBH_CtlSendData (pdev,
 8013064:	4611      	mov	r1, r2
 8013066:	f000 fb25 	bl	80136b4 <USBH_CtlSendData>
    phost->Control.state = CTRL_STATUS_OUT_WAIT;
 801306a:	230a      	movs	r3, #10
 801306c:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 801306e:	2300      	movs	r3, #0
    break;
 8013070:	e78e      	b.n	8012f90 <USBH_HandleControl+0x3c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
 8013072:	7949      	ldrb	r1, [r1, #5]
 8013074:	f7fe fd64 	bl	8011b40 <HCD_GetURB_State>
    if  (URB_Status == URB_DONE)
 8013078:	2801      	cmp	r0, #1
 801307a:	d01e      	beq.n	80130ba <USBH_HandleControl+0x166>
    else if  (URB_Status == URB_NOTREADY)
 801307c:	2802      	cmp	r0, #2
 801307e:	d03d      	beq.n	80130fc <USBH_HandleControl+0x1a8>
    else if (URB_Status == URB_ERROR)
 8013080:	2803      	cmp	r0, #3
 8013082:	d0b9      	beq.n	8012ff8 <USBH_HandleControl+0xa4>
  USBH_Status status = USBH_OK;
 8013084:	2300      	movs	r3, #0
}
 8013086:	4618      	mov	r0, r3
 8013088:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 801308a:	7909      	ldrb	r1, [r1, #4]
 801308c:	f7fe fd58 	bl	8011b40 <HCD_GetURB_State>
    if  ( URB_Status == URB_DONE)
 8013090:	2801      	cmp	r0, #1
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 8013092:	4606      	mov	r6, r0
    if  ( URB_Status == URB_DONE)
 8013094:	d011      	beq.n	80130ba <USBH_HandleControl+0x166>
    else if (URB_Status == URB_ERROR)
 8013096:	2803      	cmp	r0, #3
 8013098:	d0ae      	beq.n	8012ff8 <USBH_HandleControl+0xa4>
    else if((HCD_GetCurrentFrame(pdev)\
 801309a:	4628      	mov	r0, r5
 801309c:	f7fe fd4c 	bl	8011b38 <HCD_GetCurrentFrame>
      - phost->Control.timer) > timeout)
 80130a0:	4a1d      	ldr	r2, [pc, #116]	; (8013118 <USBH_HandleControl+0x1c4>)
 80130a2:	8a23      	ldrh	r3, [r4, #16]
 80130a4:	8812      	ldrh	r2, [r2, #0]
 80130a6:	1ac0      	subs	r0, r0, r3
    else if((HCD_GetCurrentFrame(pdev)\
 80130a8:	4290      	cmp	r0, r2
 80130aa:	d8a5      	bhi.n	8012ff8 <USBH_HandleControl+0xa4>
     else if(URB_Status == URB_STALL)
 80130ac:	2e04      	cmp	r6, #4
 80130ae:	d1e9      	bne.n	8013084 <USBH_HandleControl+0x130>
      phost->gState =   phost->gStateBkp;
 80130b0:	7863      	ldrb	r3, [r4, #1]
 80130b2:	7023      	strb	r3, [r4, #0]
      phost->Control.status = CTRL_STALL;
 80130b4:	74a6      	strb	r6, [r4, #18]
      status = USBH_NOT_SUPPORTED;
 80130b6:	2303      	movs	r3, #3
 80130b8:	e76a      	b.n	8012f90 <USBH_HandleControl+0x3c>
      phost->gState =   phost->gStateBkp;    
 80130ba:	7863      	ldrb	r3, [r4, #1]
 80130bc:	7023      	strb	r3, [r4, #0]
  USBH_Status status = USBH_OK;
 80130be:	2300      	movs	r3, #0
 80130c0:	e766      	b.n	8012f90 <USBH_HandleControl+0x3c>
      phost->Control.state = CTRL_SETUP; 
 80130c2:	2301      	movs	r3, #1
 80130c4:	770b      	strb	r3, [r1, #28]
  USBH_Status status = USBH_OK;
 80130c6:	2300      	movs	r3, #0
 80130c8:	e762      	b.n	8012f90 <USBH_HandleControl+0x3c>
      if (phost->Control.setup.b.wLength.w != 0 )
 80130ca:	8b63      	ldrh	r3, [r4, #26]
      direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 80130cc:	7d22      	ldrb	r2, [r4, #20]
      if (phost->Control.setup.b.wLength.w != 0 )
 80130ce:	b1cb      	cbz	r3, 8013104 <USBH_HandleControl+0x1b0>
        timeout = DATA_STAGE_TIMEOUT;
 80130d0:	4b11      	ldr	r3, [pc, #68]	; (8013118 <USBH_HandleControl+0x1c4>)
        if (direction == USB_D2H)
 80130d2:	0612      	lsls	r2, r2, #24
        timeout = DATA_STAGE_TIMEOUT;
 80130d4:	f241 3188 	movw	r1, #5000	; 0x1388
 80130d8:	8019      	strh	r1, [r3, #0]
          phost->Control.state = CTRL_DATA_IN;
 80130da:	bf4c      	ite	mi
 80130dc:	2303      	movmi	r3, #3
          phost->Control.state = CTRL_DATA_OUT;
 80130de:	2305      	movpl	r3, #5
 80130e0:	7723      	strb	r3, [r4, #28]
      phost->Control.timer = HCD_GetCurrentFrame(pdev);
 80130e2:	4628      	mov	r0, r5
 80130e4:	f7fe fd28 	bl	8011b38 <HCD_GetCurrentFrame>
  USBH_Status status = USBH_OK;
 80130e8:	2300      	movs	r3, #0
      phost->Control.timer = HCD_GetCurrentFrame(pdev);
 80130ea:	8220      	strh	r0, [r4, #16]
 80130ec:	e750      	b.n	8012f90 <USBH_HandleControl+0x3c>
      phost->Control.state = CTRL_STATUS_OUT;
 80130ee:	2309      	movs	r3, #9
 80130f0:	7723      	strb	r3, [r4, #28]
 80130f2:	e778      	b.n	8012fe6 <USBH_HandleControl+0x92>
      phost->Control.state = CTRL_STATUS_IN;
 80130f4:	2307      	movs	r3, #7
 80130f6:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 80130f8:	2300      	movs	r3, #0
 80130fa:	e749      	b.n	8012f90 <USBH_HandleControl+0x3c>
      phost->Control.state = CTRL_STATUS_OUT;
 80130fc:	2309      	movs	r3, #9
 80130fe:	7723      	strb	r3, [r4, #28]
  USBH_Status status = USBH_OK;
 8013100:	2300      	movs	r3, #0
 8013102:	e745      	b.n	8012f90 <USBH_HandleControl+0x3c>
        timeout = NODATA_STAGE_TIMEOUT;
 8013104:	4b04      	ldr	r3, [pc, #16]	; (8013118 <USBH_HandleControl+0x1c4>)
 8013106:	2132      	movs	r1, #50	; 0x32
 8013108:	8019      	strh	r1, [r3, #0]
        if (direction == USB_D2H)
 801310a:	0613      	lsls	r3, r2, #24
          phost->Control.state = CTRL_STATUS_OUT;
 801310c:	bf4c      	ite	mi
 801310e:	2309      	movmi	r3, #9
          phost->Control.state = CTRL_STATUS_IN;
 8013110:	2307      	movpl	r3, #7
 8013112:	7723      	strb	r3, [r4, #28]
 8013114:	e7e5      	b.n	80130e2 <USBH_HandleControl+0x18e>
 8013116:	bf00      	nop
 8013118:	20008084 	.word	0x20008084

0801311c <USBH_Process>:
{
 801311c:	b570      	push	{r4, r5, r6, lr}
  switch (phost->gState)
 801311e:	780b      	ldrb	r3, [r1, #0]
{
 8013120:	b094      	sub	sp, #80	; 0x50
  volatile USBH_Status status = USBH_FAIL;
 8013122:	2202      	movs	r2, #2
{
 8013124:	460c      	mov	r4, r1
  volatile USBH_Status status = USBH_FAIL;
 8013126:	f88d 200f 	strb.w	r2, [sp, #15]
{
 801312a:	4605      	mov	r5, r0
  switch (phost->gState)
 801312c:	2b0c      	cmp	r3, #12
 801312e:	d821      	bhi.n	8013174 <USBH_Process+0x58>
 8013130:	e8df f013 	tbh	[pc, r3, lsl #1]
 8013134:	006a0060 	.word	0x006a0060
 8013138:	00200070 	.word	0x00200070
 801313c:	00200020 	.word	0x00200020
 8013140:	00cc00b0 	.word	0x00cc00b0
 8013144:	00ed00d7 	.word	0x00ed00d7
 8013148:	00200050 	.word	0x00200050
 801314c:	00f0      	.short	0x00f0
    if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
 801314e:	f891 2032 	ldrb.w	r2, [r1, #50]	; 0x32
 8013152:	2a00      	cmp	r2, #0
 8013154:	f000 81b1 	beq.w	80134ba <USBH_Process+0x39e>
      if ( USBH_Get_StringDesc(pdev, 
 8013158:	21ff      	movs	r1, #255	; 0xff
 801315a:	9100      	str	r1, [sp, #0]
 801315c:	ab04      	add	r3, sp, #16
 801315e:	4621      	mov	r1, r4
 8013160:	f001 f924 	bl	80143ac <USBH_Get_StringDesc>
 8013164:	b930      	cbnz	r0, 8013174 <USBH_Process+0x58>
        phost->usr_cb->SerialNumString(Local_Buffer);
 8013166:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 801316a:	a804      	add	r0, sp, #16
 801316c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801316e:	4798      	blx	r3
        phost->EnumState = ENUM_SET_CONFIGURATION;
 8013170:	2308      	movs	r3, #8
 8013172:	70a3      	strb	r3, [r4, #2]
   if (!(HCD_IsDeviceConnected(pdev)) && 
 8013174:	4628      	mov	r0, r5
 8013176:	f7fe fcdb 	bl	8011b30 <HCD_IsDeviceConnected>
 801317a:	b918      	cbnz	r0, 8013184 <USBH_Process+0x68>
       (pdev->host.port_cb->DisconnHandled == 0))
 801317c:	f8d5 34ac 	ldr.w	r3, [r5, #1196]	; 0x4ac
   if (!(HCD_IsDeviceConnected(pdev)) && 
 8013180:	7ade      	ldrb	r6, [r3, #11]
 8013182:	b10e      	cbz	r6, 8013188 <USBH_Process+0x6c>
}
 8013184:	b014      	add	sp, #80	; 0x50
 8013186:	bd70      	pop	{r4, r5, r6, pc}
    phost->usr_cb->DeviceDisconnected();
 8013188:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 801318c:	691b      	ldr	r3, [r3, #16]
 801318e:	4798      	blx	r3
    pdev->host.port_cb->DisconnHandled = 1; /* Handle to avoid the Re-entry*/
 8013190:	f8d5 24ac 	ldr.w	r2, [r5, #1196]	; 0x4ac
 8013194:	2301      	movs	r3, #1
 8013196:	72d3      	strb	r3, [r2, #11]
  phost->gState = HOST_IDLE;
 8013198:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 801319c:	2240      	movs	r2, #64	; 0x40
 801319e:	71a2      	strb	r2, [r4, #6]
  phost->Control.state = CTRL_SETUP;
 80131a0:	7723      	strb	r3, [r4, #28]
  phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
 80131a2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 80131a6:	7921      	ldrb	r1, [r4, #4]
  phost->gState = HOST_IDLE;
 80131a8:	6020      	str	r0, [r4, #0]
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 80131aa:	f884 6020 	strb.w	r6, [r4, #32]
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 80131ae:	4628      	mov	r0, r5
 80131b0:	f000 fa28 	bl	8013604 <USBH_Free_Channel>
  USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
 80131b4:	7961      	ldrb	r1, [r4, #5]
 80131b6:	4628      	mov	r0, r5
 80131b8:	f000 fa24 	bl	8013604 <USBH_Free_Channel>
    phost->usr_cb->DeInit();
 80131bc:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80131c0:	685b      	ldr	r3, [r3, #4]
 80131c2:	4798      	blx	r3
    phost->class_cb->DeInit(pdev, &phost->device_prop);
 80131c4:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80131c6:	4628      	mov	r0, r5
 80131c8:	685b      	ldr	r3, [r3, #4]
 80131ca:	f104 0120 	add.w	r1, r4, #32
 80131ce:	4798      	blx	r3
}
 80131d0:	b014      	add	sp, #80	; 0x50
 80131d2:	bd70      	pop	{r4, r5, r6, pc}
    if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
 80131d4:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 80131d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80131da:	4798      	blx	r3
 80131dc:	2801      	cmp	r0, #1
 80131de:	d1c9      	bne.n	8013174 <USBH_Process+0x58>
      if((phost->class_cb->Init(pdev, phost))\
 80131e0:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80131e2:	4621      	mov	r1, r4
 80131e4:	681b      	ldr	r3, [r3, #0]
 80131e6:	4628      	mov	r0, r5
 80131e8:	4798      	blx	r3
 80131ea:	2800      	cmp	r0, #0
 80131ec:	d1c2      	bne.n	8013174 <USBH_Process+0x58>
        phost->gState  = HOST_CLASS_REQUEST;     
 80131ee:	2307      	movs	r3, #7
 80131f0:	7023      	strb	r3, [r4, #0]
 80131f2:	e7bf      	b.n	8013174 <USBH_Process+0x58>
    if (HCD_IsDeviceConnected(pdev))  
 80131f4:	f7fe fc9c 	bl	8011b30 <HCD_IsDeviceConnected>
 80131f8:	2800      	cmp	r0, #0
 80131fa:	d0bb      	beq.n	8013174 <USBH_Process+0x58>
      USBH_DeAllocate_AllChannel(pdev);
 80131fc:	4628      	mov	r0, r5
 80131fe:	f000 fa0d 	bl	801361c <USBH_DeAllocate_AllChannel>
      phost->gState = HOST_DEV_ATTACHED;
 8013202:	2302      	movs	r3, #2
 8013204:	7023      	strb	r3, [r4, #0]
 8013206:	e7b5      	b.n	8013174 <USBH_Process+0x58>
    if ( HCD_ResetPort(pdev) == 0)
 8013208:	f7fe fc8c 	bl	8011b24 <HCD_ResetPort>
 801320c:	2800      	cmp	r0, #0
 801320e:	d1b1      	bne.n	8013174 <USBH_Process+0x58>
      phost->gState = HOST_IDLE;
 8013210:	7020      	strb	r0, [r4, #0]
 8013212:	e7af      	b.n	8013174 <USBH_Process+0x58>
    phost->usr_cb->DeviceAttached();
 8013214:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 8013218:	689b      	ldr	r3, [r3, #8]
 801321a:	4798      	blx	r3
    pdev->host.port_cb->DisconnStatus = 0; 
 801321c:	f8d5 34ac 	ldr.w	r3, [r5, #1196]	; 0x4ac
    pdev->host.port_cb->ConnHandled = 1;  
 8013220:	2201      	movs	r2, #1
    pdev->host.port_cb->DisconnStatus = 0; 
 8013222:	2100      	movs	r1, #0
 8013224:	7259      	strb	r1, [r3, #9]
    pdev->host.port_cb->ConnHandled = 1;  
 8013226:	729a      	strb	r2, [r3, #10]
    phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
 8013228:	4628      	mov	r0, r5
 801322a:	f000 f9a7 	bl	801357c <USBH_Alloc_Channel>
    phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
 801322e:	2180      	movs	r1, #128	; 0x80
    phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
 8013230:	7160      	strb	r0, [r4, #5]
    phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
 8013232:	4628      	mov	r0, r5
 8013234:	f000 f9a2 	bl	801357c <USBH_Alloc_Channel>
 8013238:	7120      	strb	r0, [r4, #4]
    if ( HCD_ResetPort(pdev) == 0)
 801323a:	4628      	mov	r0, r5
 801323c:	f7fe fc72 	bl	8011b24 <HCD_ResetPort>
 8013240:	4606      	mov	r6, r0
 8013242:	2800      	cmp	r0, #0
 8013244:	d196      	bne.n	8013174 <USBH_Process+0x58>
      phost->usr_cb->ResetDevice();
 8013246:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 801324a:	68db      	ldr	r3, [r3, #12]
 801324c:	4798      	blx	r3
      phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
 801324e:	4628      	mov	r0, r5
 8013250:	f7fe fc62 	bl	8011b18 <HCD_GetCurrentSpeed>
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
 8013254:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
      phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
 8013258:	b2c0      	uxtb	r0, r0
 801325a:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      phost->gState = HOST_ENUMERATION;
 801325e:	2206      	movs	r2, #6
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
 8013260:	699b      	ldr	r3, [r3, #24]
      phost->gState = HOST_ENUMERATION;
 8013262:	7022      	strb	r2, [r4, #0]
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
 8013264:	4798      	blx	r3
      USBH_Open_Channel (pdev,
 8013266:	79a0      	ldrb	r0, [r4, #6]
 8013268:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 801326c:	f894 2020 	ldrb.w	r2, [r4, #32]
 8013270:	7921      	ldrb	r1, [r4, #4]
 8013272:	9001      	str	r0, [sp, #4]
 8013274:	9600      	str	r6, [sp, #0]
 8013276:	4628      	mov	r0, r5
 8013278:	f000 f93a 	bl	80134f0 <USBH_Open_Channel>
      USBH_Open_Channel (pdev,
 801327c:	79a0      	ldrb	r0, [r4, #6]
 801327e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8013282:	f894 2020 	ldrb.w	r2, [r4, #32]
 8013286:	7961      	ldrb	r1, [r4, #5]
 8013288:	9001      	str	r0, [sp, #4]
 801328a:	9600      	str	r6, [sp, #0]
 801328c:	4628      	mov	r0, r5
 801328e:	f000 f92f 	bl	80134f0 <USBH_Open_Channel>
 8013292:	e76f      	b.n	8013174 <USBH_Process+0x58>
  switch (phost->EnumState)
 8013294:	788b      	ldrb	r3, [r1, #2]
 8013296:	2b09      	cmp	r3, #9
 8013298:	f63f af6c 	bhi.w	8013174 <USBH_Process+0x58>
 801329c:	a201      	add	r2, pc, #4	; (adr r2, 80132a4 <USBH_Process+0x188>)
 801329e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80132a2:	bf00      	nop
 80132a4:	08013423 	.word	0x08013423
 80132a8:	08013405 	.word	0x08013405
 80132ac:	08013467 	.word	0x08013467
 80132b0:	080133a1 	.word	0x080133a1
 80132b4:	080133df 	.word	0x080133df
 80132b8:	080133b3 	.word	0x080133b3
 80132bc:	08013375 	.word	0x08013375
 80132c0:	0801314f 	.word	0x0801314f
 80132c4:	08013361 	.word	0x08013361
 80132c8:	08013353 	.word	0x08013353
    status = phost->class_cb->Requests(pdev, phost);
 80132cc:	6fcb      	ldr	r3, [r1, #124]	; 0x7c
 80132ce:	689b      	ldr	r3, [r3, #8]
 80132d0:	4798      	blx	r3
 80132d2:	f88d 000f 	strb.w	r0, [sp, #15]
     if(status == USBH_OK)
 80132d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80132da:	b93b      	cbnz	r3, 80132ec <USBH_Process+0x1d0>
       phost->gState  = HOST_CLASS;
 80132dc:	2308      	movs	r3, #8
 80132de:	7023      	strb	r3, [r4, #0]
 80132e0:	e748      	b.n	8013174 <USBH_Process+0x58>
    status = phost->class_cb->Machine(pdev, phost);
 80132e2:	6fcb      	ldr	r3, [r1, #124]	; 0x7c
 80132e4:	68db      	ldr	r3, [r3, #12]
 80132e6:	4798      	blx	r3
 80132e8:	f88d 000f 	strb.w	r0, [sp, #15]
    USBH_ErrorHandle(phost, status);
 80132ec:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80132f0:	b2db      	uxtb	r3, r3
  if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
 80132f2:	1f1a      	subs	r2, r3, #4
 80132f4:	2a01      	cmp	r2, #1
 80132f6:	f240 80d9 	bls.w	80134ac <USBH_Process+0x390>
  else if(errType == USBH_APPLY_DEINIT)
 80132fa:	2b06      	cmp	r3, #6
 80132fc:	f47f af3a 	bne.w	8013174 <USBH_Process+0x58>
    phost->usr_cb->Init();
 8013300:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    phost->gState = HOST_ERROR_STATE;  
 8013304:	220c      	movs	r2, #12
    phost->usr_cb->Init();
 8013306:	681b      	ldr	r3, [r3, #0]
    phost->gState = HOST_ERROR_STATE;  
 8013308:	7022      	strb	r2, [r4, #0]
    phost->usr_cb->Init();
 801330a:	4798      	blx	r3
 801330c:	e732      	b.n	8013174 <USBH_Process+0x58>
    USBH_HandleControl(pdev, phost);    
 801330e:	f7ff fe21 	bl	8012f54 <USBH_HandleControl>
    break;
 8013312:	e72f      	b.n	8013174 <USBH_Process+0x58>
  phost->Control.state = CTRL_SETUP;
 8013314:	2301      	movs	r3, #1
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8013316:	2200      	movs	r2, #0
  phost->gState = HOST_IDLE;
 8013318:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 801331c:	2140      	movs	r1, #64	; 0x40
  phost->Control.state = CTRL_SETUP;
 801331e:	7723      	strb	r3, [r4, #28]
  phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
 8013320:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8013324:	f884 2020 	strb.w	r2, [r4, #32]
  phost->gState = HOST_IDLE;
 8013328:	6020      	str	r0, [r4, #0]
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 801332a:	71a1      	strb	r1, [r4, #6]
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 801332c:	4628      	mov	r0, r5
 801332e:	7921      	ldrb	r1, [r4, #4]
 8013330:	f000 f968 	bl	8013604 <USBH_Free_Channel>
  USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
 8013334:	7961      	ldrb	r1, [r4, #5]
 8013336:	4628      	mov	r0, r5
 8013338:	f000 f964 	bl	8013604 <USBH_Free_Channel>
    phost->usr_cb->DeInit();
 801333c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8013340:	685b      	ldr	r3, [r3, #4]
 8013342:	4798      	blx	r3
    phost->class_cb->DeInit(pdev, &phost->device_prop);
 8013344:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8013346:	f104 0120 	add.w	r1, r4, #32
 801334a:	685b      	ldr	r3, [r3, #4]
 801334c:	4628      	mov	r0, r5
 801334e:	4798      	blx	r3
    break;
 8013350:	e710      	b.n	8013174 <USBH_Process+0x58>
      phost->usr_cb->EnumerationDone();
 8013352:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 8013356:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8013358:	4798      	blx	r3
      phost->gState  = HOST_USR_INPUT;    
 801335a:	230a      	movs	r3, #10
 801335c:	7023      	strb	r3, [r4, #0]
 801335e:	e709      	b.n	8013174 <USBH_Process+0x58>
    if (USBH_SetCfg(pdev, 
 8013360:	f891 2039 	ldrb.w	r2, [r1, #57]	; 0x39
 8013364:	f001 f87e 	bl	8014464 <USBH_SetCfg>
 8013368:	2800      	cmp	r0, #0
 801336a:	f47f af03 	bne.w	8013174 <USBH_Process+0x58>
      phost->EnumState = ENUM_DEV_CONFIGURED;
 801336e:	2309      	movs	r3, #9
 8013370:	70a3      	strb	r3, [r4, #2]
 8013372:	e6ff      	b.n	8013174 <USBH_Process+0x58>
    if (phost->device_prop.Dev_Desc.iProduct != 0)
 8013374:	f891 2031 	ldrb.w	r2, [r1, #49]	; 0x31
 8013378:	2a00      	cmp	r2, #0
 801337a:	f000 80ae 	beq.w	80134da <USBH_Process+0x3be>
      if ( USBH_Get_StringDesc(pdev,
 801337e:	21ff      	movs	r1, #255	; 0xff
 8013380:	9100      	str	r1, [sp, #0]
 8013382:	ab04      	add	r3, sp, #16
 8013384:	4621      	mov	r1, r4
 8013386:	f001 f811 	bl	80143ac <USBH_Get_StringDesc>
 801338a:	2800      	cmp	r0, #0
 801338c:	f47f aef2 	bne.w	8013174 <USBH_Process+0x58>
        phost->usr_cb->ProductString(Local_Buffer);
 8013390:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8013394:	a804      	add	r0, sp, #16
 8013396:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013398:	4798      	blx	r3
        phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 801339a:	2307      	movs	r3, #7
 801339c:	70a3      	strb	r3, [r4, #2]
 801339e:	e6e9      	b.n	8013174 <USBH_Process+0x58>
    if ( USBH_Get_CfgDesc(pdev, 
 80133a0:	2209      	movs	r2, #9
 80133a2:	f000 ff6f 	bl	8014284 <USBH_Get_CfgDesc>
 80133a6:	2800      	cmp	r0, #0
 80133a8:	f47f aee4 	bne.w	8013174 <USBH_Process+0x58>
      phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 80133ac:	2304      	movs	r3, #4
 80133ae:	70a3      	strb	r3, [r4, #2]
 80133b0:	e6e0      	b.n	8013174 <USBH_Process+0x58>
    if (phost->device_prop.Dev_Desc.iManufacturer != 0)
 80133b2:	f891 2030 	ldrb.w	r2, [r1, #48]	; 0x30
 80133b6:	2a00      	cmp	r2, #0
 80133b8:	f000 8087 	beq.w	80134ca <USBH_Process+0x3ae>
      if ( USBH_Get_StringDesc(pdev,
 80133bc:	21ff      	movs	r1, #255	; 0xff
 80133be:	9100      	str	r1, [sp, #0]
 80133c0:	ab04      	add	r3, sp, #16
 80133c2:	4621      	mov	r1, r4
 80133c4:	f000 fff2 	bl	80143ac <USBH_Get_StringDesc>
 80133c8:	2800      	cmp	r0, #0
 80133ca:	f47f aed3 	bne.w	8013174 <USBH_Process+0x58>
        phost->usr_cb->ManufacturerString(Local_Buffer);
 80133ce:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80133d2:	a804      	add	r0, sp, #16
 80133d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80133d6:	4798      	blx	r3
        phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 80133d8:	2306      	movs	r3, #6
 80133da:	70a3      	strb	r3, [r4, #2]
 80133dc:	e6ca      	b.n	8013174 <USBH_Process+0x58>
    if (USBH_Get_CfgDesc(pdev, 
 80133de:	8eca      	ldrh	r2, [r1, #54]	; 0x36
 80133e0:	f000 ff50 	bl	8014284 <USBH_Get_CfgDesc>
 80133e4:	2800      	cmp	r0, #0
 80133e6:	f47f aec5 	bne.w	8013174 <USBH_Process+0x58>
      phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
 80133ea:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80133ee:	f104 0250 	add.w	r2, r4, #80	; 0x50
 80133f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80133f4:	f104 013e 	add.w	r1, r4, #62	; 0x3e
 80133f8:	f104 0034 	add.w	r0, r4, #52	; 0x34
 80133fc:	4798      	blx	r3
      phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 80133fe:	2305      	movs	r3, #5
 8013400:	70a3      	strb	r3, [r4, #2]
 8013402:	e6b7      	b.n	8013174 <USBH_Process+0x58>
    if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
 8013404:	2212      	movs	r2, #18
 8013406:	f000 fee1 	bl	80141cc <USBH_Get_DevDesc>
 801340a:	2800      	cmp	r0, #0
 801340c:	f47f aeb2 	bne.w	8013174 <USBH_Process+0x58>
      phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
 8013410:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8013414:	f104 0022 	add.w	r0, r4, #34	; 0x22
 8013418:	69db      	ldr	r3, [r3, #28]
 801341a:	4798      	blx	r3
      phost->EnumState = ENUM_SET_ADDR;
 801341c:	2302      	movs	r3, #2
 801341e:	70a3      	strb	r3, [r4, #2]
 8013420:	e6a8      	b.n	8013174 <USBH_Process+0x58>
    if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
 8013422:	2208      	movs	r2, #8
 8013424:	f000 fed2 	bl	80141cc <USBH_Get_DevDesc>
 8013428:	4606      	mov	r6, r0
 801342a:	2800      	cmp	r0, #0
 801342c:	f47f aea2 	bne.w	8013174 <USBH_Process+0x58>
      phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
 8013430:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 8013434:	71a3      	strb	r3, [r4, #6]
      HCD_ResetPort(pdev);
 8013436:	4628      	mov	r0, r5
 8013438:	f7fe fb74 	bl	8011b24 <HCD_ResetPort>
      USBH_Modify_Channel (pdev,
 801343c:	79a3      	ldrb	r3, [r4, #6]
 801343e:	7961      	ldrb	r1, [r4, #5]
 8013440:	9600      	str	r6, [sp, #0]
      phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 8013442:	2201      	movs	r2, #1
 8013444:	70a2      	strb	r2, [r4, #2]
      USBH_Modify_Channel (pdev,
 8013446:	4628      	mov	r0, r5
 8013448:	9301      	str	r3, [sp, #4]
 801344a:	4632      	mov	r2, r6
 801344c:	4633      	mov	r3, r6
 801344e:	f000 f877 	bl	8013540 <USBH_Modify_Channel>
      USBH_Modify_Channel (pdev,
 8013452:	79a3      	ldrb	r3, [r4, #6]
 8013454:	7921      	ldrb	r1, [r4, #4]
 8013456:	9301      	str	r3, [sp, #4]
 8013458:	9600      	str	r6, [sp, #0]
 801345a:	4633      	mov	r3, r6
 801345c:	4632      	mov	r2, r6
 801345e:	4628      	mov	r0, r5
 8013460:	f000 f86e 	bl	8013540 <USBH_Modify_Channel>
 8013464:	e686      	b.n	8013174 <USBH_Process+0x58>
    if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
 8013466:	2201      	movs	r2, #1
 8013468:	f000 fff0 	bl	801444c <USBH_SetAddress>
 801346c:	4606      	mov	r6, r0
 801346e:	2800      	cmp	r0, #0
 8013470:	f47f ae80 	bne.w	8013174 <USBH_Process+0x58>
      phost->device_prop.address = USBH_DEVICE_ADDRESS;
 8013474:	2201      	movs	r2, #1
      phost->usr_cb->DeviceAddressAssigned();
 8013476:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
      phost->device_prop.address = USBH_DEVICE_ADDRESS;
 801347a:	f884 2020 	strb.w	r2, [r4, #32]
      phost->usr_cb->DeviceAddressAssigned();
 801347e:	6a1b      	ldr	r3, [r3, #32]
 8013480:	4798      	blx	r3
      phost->EnumState = ENUM_GET_CFG_DESC;
 8013482:	2303      	movs	r3, #3
      USBH_Modify_Channel (pdev,
 8013484:	f894 2020 	ldrb.w	r2, [r4, #32]
 8013488:	7921      	ldrb	r1, [r4, #4]
 801348a:	9601      	str	r6, [sp, #4]
 801348c:	9600      	str	r6, [sp, #0]
 801348e:	4628      	mov	r0, r5
      phost->EnumState = ENUM_GET_CFG_DESC;
 8013490:	70a3      	strb	r3, [r4, #2]
      USBH_Modify_Channel (pdev,
 8013492:	4633      	mov	r3, r6
 8013494:	f000 f854 	bl	8013540 <USBH_Modify_Channel>
      USBH_Modify_Channel (pdev,
 8013498:	f894 2020 	ldrb.w	r2, [r4, #32]
 801349c:	7961      	ldrb	r1, [r4, #5]
 801349e:	9601      	str	r6, [sp, #4]
 80134a0:	9600      	str	r6, [sp, #0]
 80134a2:	4633      	mov	r3, r6
 80134a4:	4628      	mov	r0, r5
 80134a6:	f000 f84b 	bl	8013540 <USBH_Modify_Channel>
 80134aa:	e663      	b.n	8013174 <USBH_Process+0x58>
    phost->usr_cb->UnrecoveredError(); 
 80134ac:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80134b0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80134b2:	4798      	blx	r3
    phost->gState = HOST_ERROR_STATE;   
 80134b4:	230c      	movs	r3, #12
 80134b6:	7023      	strb	r3, [r4, #0]
 80134b8:	e65c      	b.n	8013174 <USBH_Process+0x58>
      phost->usr_cb->SerialNumString("N/A");      
 80134ba:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 80134be:	480b      	ldr	r0, [pc, #44]	; (80134ec <USBH_Process+0x3d0>)
 80134c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134c2:	4798      	blx	r3
      phost->EnumState = ENUM_SET_CONFIGURATION;
 80134c4:	2308      	movs	r3, #8
 80134c6:	70a3      	strb	r3, [r4, #2]
 80134c8:	e654      	b.n	8013174 <USBH_Process+0x58>
      phost->usr_cb->ManufacturerString("N/A");      
 80134ca:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 80134ce:	4807      	ldr	r0, [pc, #28]	; (80134ec <USBH_Process+0x3d0>)
 80134d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80134d2:	4798      	blx	r3
      phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 80134d4:	2306      	movs	r3, #6
 80134d6:	70a3      	strb	r3, [r4, #2]
 80134d8:	e64c      	b.n	8013174 <USBH_Process+0x58>
      phost->usr_cb->ProductString("N/A");
 80134da:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 80134de:	4803      	ldr	r0, [pc, #12]	; (80134ec <USBH_Process+0x3d0>)
 80134e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80134e2:	4798      	blx	r3
      phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 80134e4:	2307      	movs	r3, #7
 80134e6:	70a3      	strb	r3, [r4, #2]
 80134e8:	e644      	b.n	8013174 <USBH_Process+0x58>
 80134ea:	bf00      	nop
 80134ec:	08017ac4 	.word	0x08017ac4

080134f0 <USBH_Open_Channel>:
                            uint8_t hc_num,
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps)
{
 80134f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 80134f2:	eb00 0541 	add.w	r5, r0, r1, lsl #1
 80134f6:	eb00 1441 	add.w	r4, r0, r1, lsl #5
 80134fa:	f8b5 548c 	ldrh.w	r5, [r5, #1164]	; 0x48c
{
 80134fe:	f89d 7018 	ldrb.w	r7, [sp, #24]
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
  pdev->host.hc[hc_num].dev_addr = dev_address;  
 8013502:	f884 22ac 	strb.w	r2, [r4, #684]	; 0x2ac
  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 8013506:	f005 067f 	and.w	r6, r5, #127	; 0x7f
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
 801350a:	f3c5 15c0 	ubfx	r5, r5, #7, #1
  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 801350e:	f884 62ad 	strb.w	r6, [r4, #685]	; 0x2ad
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
 8013512:	f884 52ae 	strb.w	r5, [r4, #686]	; 0x2ae
{
 8013516:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  pdev->host.hc[hc_num].ep_type = ep_type;  
  pdev->host.hc[hc_num].max_packet = mps; 
  pdev->host.hc[hc_num].speed = speed; 
 801351a:	f884 32af 	strb.w	r3, [r4, #687]	; 0x2af
  pdev->host.hc[hc_num].toggle_in = 0; 
 801351e:	2500      	movs	r5, #0
  pdev->host.hc[hc_num].ep_type = ep_type;  
 8013520:	f884 72b1 	strb.w	r7, [r4, #689]	; 0x2b1
  pdev->host.hc[hc_num].max_packet = mps; 
 8013524:	f8a4 62b2 	strh.w	r6, [r4, #690]	; 0x2b2
  pdev->host.hc[hc_num].toggle_in = 0; 
 8013528:	f884 52c4 	strb.w	r5, [r4, #708]	; 0x2c4
  pdev->host.hc[hc_num].toggle_out = 0;   
 801352c:	f884 52c5 	strb.w	r5, [r4, #709]	; 0x2c5
  if(speed == HPRT0_PRTSPD_HIGH_SPEED)
 8013530:	b913      	cbnz	r3, 8013538 <USBH_Open_Channel+0x48>
  {
    pdev->host.hc[hc_num].do_ping = 1;
 8013532:	2301      	movs	r3, #1
 8013534:	f884 32b0 	strb.w	r3, [r4, #688]	; 0x2b0
  }
  
  USB_OTG_HC_Init(pdev, hc_num) ;
 8013538:	f7fe f83c 	bl	80115b4 <USB_OTG_HC_Init>
  
  return HC_OK; 

}
 801353c:	2000      	movs	r0, #0
 801353e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08013540 <USBH_Modify_Channel>:
                            uint8_t hc_num,
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps)
{
 8013540:	b570      	push	{r4, r5, r6, lr}
  
  if(dev_address != 0)
  {
    pdev->host.hc[hc_num].dev_addr = dev_address;  
 8013542:	014c      	lsls	r4, r1, #5
{
 8013544:	f8bd 5014 	ldrh.w	r5, [sp, #20]
  if(dev_address != 0)
 8013548:	b112      	cbz	r2, 8013550 <USBH_Modify_Channel+0x10>
    pdev->host.hc[hc_num].dev_addr = dev_address;  
 801354a:	1906      	adds	r6, r0, r4
 801354c:	f886 22ac 	strb.w	r2, [r6, #684]	; 0x2ac
  }
  
  if((pdev->host.hc[hc_num].max_packet != mps) && (mps != 0))
 8013550:	1902      	adds	r2, r0, r4
 8013552:	f8b2 62b2 	ldrh.w	r6, [r2, #690]	; 0x2b2
 8013556:	42ae      	cmp	r6, r5
 8013558:	d000      	beq.n	801355c <USBH_Modify_Channel+0x1c>
 801355a:	b95d      	cbnz	r5, 8013574 <USBH_Modify_Channel+0x34>
  {
    pdev->host.hc[hc_num].max_packet = mps; 
  }
  
  if((pdev->host.hc[hc_num].speed != speed ) && (speed != 0 )) 
 801355c:	4404      	add	r4, r0
 801355e:	f894 22af 	ldrb.w	r2, [r4, #687]	; 0x2af
 8013562:	429a      	cmp	r2, r3
 8013564:	d002      	beq.n	801356c <USBH_Modify_Channel+0x2c>
 8013566:	b10b      	cbz	r3, 801356c <USBH_Modify_Channel+0x2c>
  {
    pdev->host.hc[hc_num].speed = speed; 
 8013568:	f884 32af 	strb.w	r3, [r4, #687]	; 0x2af
  }
  
  USB_OTG_HC_Init(pdev, hc_num);
 801356c:	f7fe f822 	bl	80115b4 <USB_OTG_HC_Init>
  return HC_OK; 

}
 8013570:	2000      	movs	r0, #0
 8013572:	bd70      	pop	{r4, r5, r6, pc}
    pdev->host.hc[hc_num].max_packet = mps; 
 8013574:	f8a2 52b2 	strh.w	r5, [r2, #690]	; 0x2b2
 8013578:	e7f0      	b.n	801355c <USBH_Modify_Channel+0x1c>
 801357a:	bf00      	nop

0801357c <USBH_Alloc_Channel>:
{
  uint8_t idx = 0;
  
  for (idx = 0 ; idx < HC_MAX ; idx++)
  {
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 801357c:	f9b0 248c 	ldrsh.w	r2, [r0, #1164]	; 0x48c
 8013580:	2a00      	cmp	r2, #0
{
 8013582:	4603      	mov	r3, r0
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 8013584:	da1d      	bge.n	80135c2 <USBH_Alloc_Channel+0x46>
 8013586:	f9b0 248e 	ldrsh.w	r2, [r0, #1166]	; 0x48e
 801358a:	2a00      	cmp	r2, #0
 801358c:	da24      	bge.n	80135d8 <USBH_Alloc_Channel+0x5c>
 801358e:	f9b0 2490 	ldrsh.w	r2, [r0, #1168]	; 0x490
 8013592:	2a00      	cmp	r2, #0
 8013594:	da23      	bge.n	80135de <USBH_Alloc_Channel+0x62>
 8013596:	f9b0 2492 	ldrsh.w	r2, [r0, #1170]	; 0x492
 801359a:	2a00      	cmp	r2, #0
 801359c:	da22      	bge.n	80135e4 <USBH_Alloc_Channel+0x68>
 801359e:	f9b0 2494 	ldrsh.w	r2, [r0, #1172]	; 0x494
 80135a2:	2a00      	cmp	r2, #0
 80135a4:	da21      	bge.n	80135ea <USBH_Alloc_Channel+0x6e>
 80135a6:	f9b0 2496 	ldrsh.w	r2, [r0, #1174]	; 0x496
 80135aa:	2a00      	cmp	r2, #0
 80135ac:	da20      	bge.n	80135f0 <USBH_Alloc_Channel+0x74>
 80135ae:	f9b0 2498 	ldrsh.w	r2, [r0, #1176]	; 0x498
 80135b2:	2a00      	cmp	r2, #0
 80135b4:	da1f      	bge.n	80135f6 <USBH_Alloc_Channel+0x7a>
 80135b6:	f9b0 249a 	ldrsh.w	r2, [r0, #1178]	; 0x49a
 80135ba:	2a00      	cmp	r2, #0
 80135bc:	da1e      	bge.n	80135fc <USBH_Alloc_Channel+0x80>
 80135be:	20ff      	movs	r0, #255	; 0xff
}
 80135c0:	4770      	bx	lr
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135c2:	2000      	movs	r0, #0
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135c4:	4602      	mov	r2, r0
	pdev->host.channel[hc_num] = HC_USED | ep_addr;
 80135c6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80135ca:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 80135ce:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 80135d2:	f8a3 148c 	strh.w	r1, [r3, #1164]	; 0x48c
 80135d6:	4770      	bx	lr
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135d8:	2001      	movs	r0, #1
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135da:	4602      	mov	r2, r0
 80135dc:	e7f3      	b.n	80135c6 <USBH_Alloc_Channel+0x4a>
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135de:	2002      	movs	r0, #2
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135e0:	4602      	mov	r2, r0
 80135e2:	e7f0      	b.n	80135c6 <USBH_Alloc_Channel+0x4a>
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135e4:	2003      	movs	r0, #3
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135e6:	4602      	mov	r2, r0
 80135e8:	e7ed      	b.n	80135c6 <USBH_Alloc_Channel+0x4a>
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135ea:	2004      	movs	r0, #4
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135ec:	4602      	mov	r2, r0
 80135ee:	e7ea      	b.n	80135c6 <USBH_Alloc_Channel+0x4a>
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135f0:	2005      	movs	r0, #5
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135f2:	4602      	mov	r2, r0
 80135f4:	e7e7      	b.n	80135c6 <USBH_Alloc_Channel+0x4a>
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135f6:	2006      	movs	r0, #6
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135f8:	4602      	mov	r2, r0
 80135fa:	e7e4      	b.n	80135c6 <USBH_Alloc_Channel+0x4a>
  for (idx = 0 ; idx < HC_MAX ; idx++)
 80135fc:	2007      	movs	r0, #7
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 80135fe:	4602      	mov	r2, r0
 8013600:	e7e1      	b.n	80135c6 <USBH_Alloc_Channel+0x4a>
 8013602:	bf00      	nop

08013604 <USBH_Free_Channel>:
   if(idx < HC_MAX)
 8013604:	2907      	cmp	r1, #7
 8013606:	d807      	bhi.n	8013618 <USBH_Free_Channel+0x14>
 8013608:	eb00 0041 	add.w	r0, r0, r1, lsl #1
	 pdev->host.channel[idx] &= HC_USED_MASK;
 801360c:	f8b0 348c 	ldrh.w	r3, [r0, #1164]	; 0x48c
 8013610:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8013614:	f8a0 348c 	strh.w	r3, [r0, #1164]	; 0x48c
}
 8013618:	2000      	movs	r0, #0
 801361a:	4770      	bx	lr

0801361c <USBH_DeAllocate_AllChannel>:
	 pdev->host.channel[idx] = 0;
 801361c:	f500 6292 	add.w	r2, r0, #1168	; 0x490
 8013620:	2300      	movs	r3, #0
 8013622:	f8c0 3490 	str.w	r3, [r0, #1168]	; 0x490
}
 8013626:	4618      	mov	r0, r3
 8013628:	6053      	str	r3, [r2, #4]
 801362a:	6093      	str	r3, [r2, #8]
 801362c:	4770      	bx	lr
 801362e:	bf00      	nop

08013630 <USBH_CtlReq>:
//--------------------------------------------------------------
USBH_Status USBH_CtlReq     (USB_OTG_CORE_HANDLE *pdev, 
                             USBH_HOST           *phost, 
                             uint8_t             *buff,
                             uint16_t            length)
{
 8013630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013632:	460c      	mov	r4, r1
  USBH_Status status;
  URB_STATE URB_Status = URB_IDLE;
  
  URB_Status = HCD_GetURB_State(pdev, phost->Control.hc_num_out); 
 8013634:	7949      	ldrb	r1, [r1, #5]
{
 8013636:	461d      	mov	r5, r3
 8013638:	4616      	mov	r6, r2
  URB_Status = HCD_GetURB_State(pdev, phost->Control.hc_num_out); 
 801363a:	f7fe fa81 	bl	8011b40 <HCD_GetURB_State>
  
  status = USBH_BUSY;
  
  switch (phost->RequestState)
 801363e:	78e3      	ldrb	r3, [r4, #3]
 8013640:	2b01      	cmp	r3, #1
 8013642:	d00d      	beq.n	8013660 <USBH_CtlReq+0x30>
 8013644:	2b02      	cmp	r3, #2
 8013646:	d109      	bne.n	801365c <USBH_CtlReq+0x2c>
    phost->RequestState = CMD_WAIT;
    status = USBH_BUSY;
    break;
    
  case CMD_WAIT:
    if  (URB_Status == URB_DONE)
 8013648:	2801      	cmp	r0, #1
 801364a:	d018      	beq.n	801367e <USBH_CtlReq+0x4e>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
      status = USBH_OK;
    }
    else if  (URB_Status == URB_ERROR)
 801364c:	2803      	cmp	r0, #3
 801364e:	d012      	beq.n	8013676 <USBH_CtlReq+0x46>
    {
      /* Failure Mode */
      phost->RequestState = CMD_SEND;
      status = USBH_FAIL;
    }   
     else if  (URB_Status == URB_STALL)
 8013650:	2804      	cmp	r0, #4
 8013652:	d103      	bne.n	801365c <USBH_CtlReq+0x2c>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
 8013654:	2301      	movs	r3, #1
 8013656:	70e3      	strb	r3, [r4, #3]
      status = USBH_NOT_SUPPORTED;
 8013658:	2003      	movs	r0, #3
 801365a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  status = USBH_BUSY;
 801365c:	2001      	movs	r0, #1
    
  default:
    break; 
  }
  return status;
}
 801365e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                                           uint8_t* buff, 
                                           uint16_t length)
{
  
  /* Save Global State */
  phost->gStateBkp =   phost->gState; 
 8013660:	7827      	ldrb	r7, [r4, #0]
  
  /* Prepare the Transactions */
  phost->gState = HOST_CTRL_XFER;
  phost->Control.buff = buff; 
 8013662:	60a6      	str	r6, [r4, #8]
  phost->gState = HOST_CTRL_XFER;
 8013664:	2109      	movs	r1, #9
    phost->RequestState = CMD_WAIT;
 8013666:	2202      	movs	r2, #2
  phost->Control.length = length;
 8013668:	81a5      	strh	r5, [r4, #12]
  phost->Control.state = CTRL_SETUP;  
 801366a:	7723      	strb	r3, [r4, #28]
    status = USBH_BUSY;
 801366c:	4618      	mov	r0, r3
  phost->gStateBkp =   phost->gState; 
 801366e:	7067      	strb	r7, [r4, #1]
  phost->gState = HOST_CTRL_XFER;
 8013670:	7021      	strb	r1, [r4, #0]
    phost->RequestState = CMD_WAIT;
 8013672:	70e2      	strb	r2, [r4, #3]
    break;
 8013674:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      phost->RequestState = CMD_SEND;
 8013676:	2201      	movs	r2, #1
      status = USBH_FAIL;
 8013678:	4618      	mov	r0, r3
      phost->RequestState = CMD_SEND;
 801367a:	70e2      	strb	r2, [r4, #3]
 801367c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      phost->RequestState = CMD_SEND;
 801367e:	70e0      	strb	r0, [r4, #3]
      status = USBH_OK;
 8013680:	2000      	movs	r0, #0
 8013682:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08013684 <USBH_CtlSendSetup>:
                                uint8_t hc_num){
 8013684:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
 8013686:	f102 040d 	add.w	r4, r2, #13
 801368a:	eb00 1444 	add.w	r4, r0, r4, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 0;
 801368e:	eb00 1342 	add.w	r3, r0, r2, lsl #5
 8013692:	2700      	movs	r7, #0
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
 8013694:	2603      	movs	r6, #3
  pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
 8013696:	2508      	movs	r5, #8
  pdev->host.hc[hc_num].ep_is_in = 0;
 8013698:	f883 72ae 	strb.w	r7, [r3, #686]	; 0x2ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 801369c:	f8c4 1118 	str.w	r1, [r4, #280]	; 0x118
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
 80136a0:	f884 6114 	strb.w	r6, [r4, #276]	; 0x114
  return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
 80136a4:	4611      	mov	r1, r2
  pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
 80136a6:	f8c3 52bc 	str.w	r5, [r3, #700]	; 0x2bc
  return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
 80136aa:	f7fe fa59 	bl	8011b60 <HCD_SubmitRequest>
}
 80136ae:	b2c0      	uxtb	r0, r0
 80136b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80136b2:	bf00      	nop

080136b4 <USBH_CtlSendData>:
{
 80136b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].xfer_buff = buff;
 80136b6:	f103 040d 	add.w	r4, r3, #13
  pdev->host.hc[hc_num].ep_is_in = 0;
 80136ba:	eb00 1543 	add.w	r5, r0, r3, lsl #5
  pdev->host.hc[hc_num].xfer_buff = buff;
 80136be:	eb00 1644 	add.w	r6, r0, r4, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 0;
 80136c2:	2700      	movs	r7, #0
 80136c4:	f885 72ae 	strb.w	r7, [r5, #686]	; 0x2ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 80136c8:	f8c6 1118 	str.w	r1, [r6, #280]	; 0x118
  pdev->host.hc[hc_num].xfer_len = length;
 80136cc:	f8c5 22bc 	str.w	r2, [r5, #700]	; 0x2bc
  if ( length == 0 )
 80136d0:	b962      	cbnz	r2, 80136ec <USBH_CtlSendData+0x38>
    pdev->host.hc[hc_num].toggle_out = 1;   
 80136d2:	2101      	movs	r1, #1
 80136d4:	f885 12c5 	strb.w	r1, [r5, #709]	; 0x2c5
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
 80136d8:	2202      	movs	r2, #2
 80136da:	eb00 1444 	add.w	r4, r0, r4, lsl #5
  HCD_SubmitRequest (pdev , hc_num);   
 80136de:	4619      	mov	r1, r3
 80136e0:	f884 2114 	strb.w	r2, [r4, #276]	; 0x114
 80136e4:	f7fe fa3c 	bl	8011b60 <HCD_SubmitRequest>
}
 80136e8:	2000      	movs	r0, #0
 80136ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 80136ec:	eb00 1243 	add.w	r2, r0, r3, lsl #5
 80136f0:	f892 22c5 	ldrb.w	r2, [r2, #709]	; 0x2c5
 80136f4:	2a00      	cmp	r2, #0
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
 80136f6:	bf18      	it	ne
 80136f8:	2202      	movne	r2, #2
 80136fa:	e7ee      	b.n	80136da <USBH_CtlSendData+0x26>

080136fc <USBH_CtlReceiveData>:
{
 80136fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 80136fe:	f103 050d 	add.w	r5, r3, #13
 8013702:	eb00 1545 	add.w	r5, r0, r5, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 1;
 8013706:	eb00 1443 	add.w	r4, r0, r3, lsl #5
 801370a:	2701      	movs	r7, #1
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 801370c:	2602      	movs	r6, #2
  pdev->host.hc[hc_num].ep_is_in = 1;
 801370e:	f884 72ae 	strb.w	r7, [r4, #686]	; 0x2ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8013712:	f8c5 1118 	str.w	r1, [r5, #280]	; 0x118
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8013716:	f885 6114 	strb.w	r6, [r5, #276]	; 0x114
  HCD_SubmitRequest (pdev , hc_num);   
 801371a:	4619      	mov	r1, r3
  pdev->host.hc[hc_num].xfer_len = length;  
 801371c:	f8c4 22bc 	str.w	r2, [r4, #700]	; 0x2bc
  HCD_SubmitRequest (pdev , hc_num);   
 8013720:	f7fe fa1e 	bl	8011b60 <HCD_SubmitRequest>
}
 8013724:	2000      	movs	r0, #0
 8013726:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08013728 <USBH_BulkSendData>:
{ 
 8013728:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].xfer_buff = buff;
 801372a:	f103 050d 	add.w	r5, r3, #13
  pdev->host.hc[hc_num].ep_is_in = 0;
 801372e:	eb00 1743 	add.w	r7, r0, r3, lsl #5
  pdev->host.hc[hc_num].xfer_buff = buff;
 8013732:	eb00 1545 	add.w	r5, r0, r5, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 0;
 8013736:	2600      	movs	r6, #0
 8013738:	f887 62ae 	strb.w	r6, [r7, #686]	; 0x2ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 801373c:	f8c5 1118 	str.w	r1, [r5, #280]	; 0x118
  pdev->host.hc[hc_num].xfer_len = length;  
 8013740:	f8c7 22bc 	str.w	r2, [r7, #700]	; 0x2bc
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 8013744:	f897 22c5 	ldrb.w	r2, [r7, #709]	; 0x2c5
 8013748:	42b2      	cmp	r2, r6
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
 801374a:	bf18      	it	ne
 801374c:	2202      	movne	r2, #2
 801374e:	f885 2114 	strb.w	r2, [r5, #276]	; 0x114
  HCD_SubmitRequest (pdev , hc_num);   
 8013752:	4619      	mov	r1, r3
 8013754:	f7fe fa04 	bl	8011b60 <HCD_SubmitRequest>
}
 8013758:	4630      	mov	r0, r6
 801375a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0801375c <USBH_BulkReceiveData>:
{
 801375c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].xfer_buff = buff;
 801375e:	f103 050d 	add.w	r5, r3, #13
  pdev->host.hc[hc_num].ep_is_in = 1;   
 8013762:	eb00 1643 	add.w	r6, r0, r3, lsl #5
  pdev->host.hc[hc_num].xfer_buff = buff;
 8013766:	eb00 1545 	add.w	r5, r0, r5, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 1;   
 801376a:	2701      	movs	r7, #1
 801376c:	f886 72ae 	strb.w	r7, [r6, #686]	; 0x2ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8013770:	f8c5 1118 	str.w	r1, [r5, #280]	; 0x118
  pdev->host.hc[hc_num].xfer_len = length;
 8013774:	f8c6 22bc 	str.w	r2, [r6, #700]	; 0x2bc
  if( pdev->host.hc[hc_num].toggle_in == 0)
 8013778:	f896 22c4 	ldrb.w	r2, [r6, #708]	; 0x2c4
 801377c:	2a00      	cmp	r2, #0
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 801377e:	bf18      	it	ne
 8013780:	2202      	movne	r2, #2
 8013782:	f885 2114 	strb.w	r2, [r5, #276]	; 0x114
  HCD_SubmitRequest (pdev , hc_num);  
 8013786:	4619      	mov	r1, r3
 8013788:	f7fe f9ea 	bl	8011b60 <HCD_SubmitRequest>
}
 801378c:	2000      	movs	r0, #0
 801378e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08013790 <USBH_InterruptReceiveData>:
{
 8013790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].xfer_buff = buff;
 8013792:	f103 050d 	add.w	r5, r3, #13
  pdev->host.hc[hc_num].ep_is_in = 1;  
 8013796:	eb00 1643 	add.w	r6, r0, r3, lsl #5
  pdev->host.hc[hc_num].xfer_buff = buff;
 801379a:	eb00 1545 	add.w	r5, r0, r5, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 1;  
 801379e:	2701      	movs	r7, #1
 80137a0:	f886 72ae 	strb.w	r7, [r6, #686]	; 0x2ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 80137a4:	f8c5 1118 	str.w	r1, [r5, #280]	; 0x118
  pdev->host.hc[hc_num].xfer_len = length;
 80137a8:	f8c6 22bc 	str.w	r2, [r6, #700]	; 0x2bc
  if(pdev->host.hc[hc_num].toggle_in == 0)
 80137ac:	f896 22c4 	ldrb.w	r2, [r6, #708]	; 0x2c4
 80137b0:	2a00      	cmp	r2, #0
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 80137b2:	bf18      	it	ne
 80137b4:	2202      	movne	r2, #2
 80137b6:	f885 2114 	strb.w	r2, [r5, #276]	; 0x114
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 80137ba:	f896 22c4 	ldrb.w	r2, [r6, #708]	; 0x2c4
 80137be:	407a      	eors	r2, r7
  HCD_SubmitRequest (pdev , hc_num);  
 80137c0:	4619      	mov	r1, r3
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 80137c2:	f886 22c4 	strb.w	r2, [r6, #708]	; 0x2c4
  HCD_SubmitRequest (pdev , hc_num);  
 80137c6:	f7fe f9cb 	bl	8011b60 <HCD_SubmitRequest>
}
 80137ca:	2000      	movs	r0, #0
 80137cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80137ce:	bf00      	nop

080137d0 <USBH_InterruptSendData>:
{
 80137d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].xfer_buff = buff;
 80137d2:	f103 050d 	add.w	r5, r3, #13
  pdev->host.hc[hc_num].ep_is_in = 0;  
 80137d6:	eb00 1743 	add.w	r7, r0, r3, lsl #5
  pdev->host.hc[hc_num].xfer_buff = buff;
 80137da:	eb00 1545 	add.w	r5, r0, r5, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 0;  
 80137de:	2600      	movs	r6, #0
 80137e0:	f887 62ae 	strb.w	r6, [r7, #686]	; 0x2ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 80137e4:	f8c5 1118 	str.w	r1, [r5, #280]	; 0x118
  pdev->host.hc[hc_num].xfer_len = length;
 80137e8:	f8c7 22bc 	str.w	r2, [r7, #700]	; 0x2bc
  if(pdev->host.hc[hc_num].toggle_in == 0)
 80137ec:	f897 22c4 	ldrb.w	r2, [r7, #708]	; 0x2c4
 80137f0:	42b2      	cmp	r2, r6
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 80137f2:	bf18      	it	ne
 80137f4:	2202      	movne	r2, #2
 80137f6:	f885 2114 	strb.w	r2, [r5, #276]	; 0x114
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 80137fa:	f897 22c4 	ldrb.w	r2, [r7, #708]	; 0x2c4
 80137fe:	f082 0201 	eor.w	r2, r2, #1
  HCD_SubmitRequest (pdev , hc_num);  
 8013802:	4619      	mov	r1, r3
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8013804:	f887 22c4 	strb.w	r2, [r7, #708]	; 0x2c4
  HCD_SubmitRequest (pdev , hc_num);  
 8013808:	f7fe f9aa 	bl	8011b60 <HCD_SubmitRequest>
}
 801380c:	4630      	mov	r0, r6
 801380e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08013810 <USBH_MSC_Init>:



//--------------------------------------------------------------
void USBH_MSC_Init(USB_OTG_CORE_HANDLE *pdev )
{
 8013810:	b510      	push	{r4, lr}
  if(HCD_IsDeviceConnected(pdev))
 8013812:	f7fe f98d 	bl	8011b30 <HCD_IsDeviceConnected>
 8013816:	b148      	cbz	r0, 801382c <USBH_MSC_Init+0x1c>
  {      
    USBH_MSC_CBWData.field.CBWSignature = USBH_MSC_BOT_CBW_SIGNATURE;
 8013818:	4b07      	ldr	r3, [pc, #28]	; (8013838 <USBH_MSC_Init+0x28>)
 801381a:	4908      	ldr	r1, [pc, #32]	; (801383c <USBH_MSC_Init+0x2c>)
    USBH_MSC_CBWData.field.CBWTag = USBH_MSC_BOT_CBW_TAG;
    USBH_MSC_CBWData.field.CBWLUN = 0;  /*Only one LUN is supported*/
    USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;  
 801381c:	4a08      	ldr	r2, [pc, #32]	; (8013840 <USBH_MSC_Init+0x30>)
    USBH_MSC_CBWData.field.CBWTag = USBH_MSC_BOT_CBW_TAG;
 801381e:	4c09      	ldr	r4, [pc, #36]	; (8013844 <USBH_MSC_Init+0x34>)
    USBH_MSC_CBWData.field.CBWSignature = USBH_MSC_BOT_CBW_SIGNATURE;
 8013820:	6019      	str	r1, [r3, #0]
    USBH_MSC_CBWData.field.CBWLUN = 0;  /*Only one LUN is supported*/
 8013822:	2000      	movs	r0, #0
    USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;  
 8013824:	2101      	movs	r1, #1
    USBH_MSC_CBWData.field.CBWTag = USBH_MSC_BOT_CBW_TAG;
 8013826:	605c      	str	r4, [r3, #4]
    USBH_MSC_CBWData.field.CBWLUN = 0;  /*Only one LUN is supported*/
 8013828:	7358      	strb	r0, [r3, #13]
    USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;  
 801382a:	70d1      	strb	r1, [r2, #3]
  }
  
  BOTStallErrorCount = 0;
  MSCErrorCount = 0;
 801382c:	4a06      	ldr	r2, [pc, #24]	; (8013848 <USBH_MSC_Init+0x38>)
  BOTStallErrorCount = 0;
 801382e:	4907      	ldr	r1, [pc, #28]	; (801384c <USBH_MSC_Init+0x3c>)
 8013830:	2300      	movs	r3, #0
  MSCErrorCount = 0;
 8013832:	7013      	strb	r3, [r2, #0]
  BOTStallErrorCount = 0;
 8013834:	600b      	str	r3, [r1, #0]
  MSCErrorCount = 0;
 8013836:	bd10      	pop	{r4, pc}
 8013838:	2001089c 	.word	0x2001089c
 801383c:	43425355 	.word	0x43425355
 8013840:	2001088c 	.word	0x2001088c
 8013844:	20304050 	.word	0x20304050
 8013848:	20008096 	.word	0x20008096
 801384c:	20008088 	.word	0x20008088

08013850 <USBH_MSC_HandleBOTXfer>:
}

//--------------------------------------------------------------
void USBH_MSC_HandleBOTXfer (USB_OTG_CORE_HANDLE *pdev ,USBH_HOST *phost)
{
 8013850:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013854:	460e      	mov	r6, r1
 8013856:	4605      	mov	r5, r0
  static uint8_t error_direction;
  USBH_Status status;
  
  URB_STATE URB_Status = URB_IDLE;
  
  if(HCD_IsDeviceConnected(pdev))
 8013858:	f7fe f96a 	bl	8011b30 <HCD_IsDeviceConnected>
 801385c:	b1e0      	cbz	r0, 8013898 <USBH_MSC_HandleBOTXfer+0x48>
  {  
    
    switch (USBH_MSC_BOTXferParam.BOTState)
 801385e:	4ca2      	ldr	r4, [pc, #648]	; (8013ae8 <USBH_MSC_HandleBOTXfer+0x298>)
 8013860:	7923      	ldrb	r3, [r4, #4]
 8013862:	3b01      	subs	r3, #1
 8013864:	2b07      	cmp	r3, #7
 8013866:	d817      	bhi.n	8013898 <USBH_MSC_HandleBOTXfer+0x48>
 8013868:	e8df f003 	tbb	[pc, r3]
 801386c:	4e392518 	.word	0x4e392518
 8013870:	04746385 	.word	0x04746385
    
    break;
    
  case USBH_MSC_DIR_OUT :
    /*send ClrFeature on Bulk OUT endpoint */
    status = USBH_ClrFeature(pdev, 
 8013874:	4a9d      	ldr	r2, [pc, #628]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
 8013876:	4631      	mov	r1, r6
 8013878:	7853      	ldrb	r3, [r2, #1]
 801387a:	7892      	ldrb	r2, [r2, #2]
 801387c:	4628      	mov	r0, r5
 801387e:	f000 fdfd 	bl	801447c <USBH_ClrFeature>
    
  default:
    break;
  }
  
  BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
 8013882:	4a9b      	ldr	r2, [pc, #620]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
 8013884:	6813      	ldr	r3, [r2, #0]
 8013886:	3301      	adds	r3, #1
  if (BOTStallErrorCount > MAX_BULK_STALL_COUNT_LIMIT )
 8013888:	2b04      	cmp	r3, #4
  BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
 801388a:	6013      	str	r3, [r2, #0]
  if (BOTStallErrorCount > MAX_BULK_STALL_COUNT_LIMIT )
 801388c:	d86f      	bhi.n	801396e <USBH_MSC_HandleBOTXfer+0x11e>
      if ( status == USBH_OK)
 801388e:	2800      	cmp	r0, #0
 8013890:	f000 80a1 	beq.w	80139d6 <USBH_MSC_HandleBOTXfer+0x186>
      else if (status == USBH_UNRECOVERED_ERROR)
 8013894:	2804      	cmp	r0, #4
 8013896:	d06a      	beq.n	801396e <USBH_MSC_HandleBOTXfer+0x11e>
 8013898:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USBH_BulkSendData (pdev,
 801389c:	4b93      	ldr	r3, [pc, #588]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
 801389e:	4995      	ldr	r1, [pc, #596]	; (8013af4 <USBH_MSC_HandleBOTXfer+0x2a4>)
 80138a0:	785b      	ldrb	r3, [r3, #1]
 80138a2:	221f      	movs	r2, #31
 80138a4:	4628      	mov	r0, r5
 80138a6:	f7ff ff3f 	bl	8013728 <USBH_BulkSendData>
      USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SEND_CBW;
 80138aa:	2201      	movs	r2, #1
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SENT_CBW;
 80138ac:	2302      	movs	r3, #2
      USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SEND_CBW;
 80138ae:	7162      	strb	r2, [r4, #5]
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SENT_CBW;
 80138b0:	7123      	strb	r3, [r4, #4]
      break;
 80138b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_out);
 80138b6:	4b8d      	ldr	r3, [pc, #564]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
 80138b8:	4628      	mov	r0, r5
 80138ba:	7859      	ldrb	r1, [r3, #1]
 80138bc:	f7fe f940 	bl	8011b40 <HCD_GetURB_State>
      if(URB_Status == URB_DONE)
 80138c0:	2801      	cmp	r0, #1
 80138c2:	f000 808c 	beq.w	80139de <USBH_MSC_HandleBOTXfer+0x18e>
      else if(URB_Status == URB_NOTREADY)
 80138c6:	2802      	cmp	r0, #2
 80138c8:	f000 8085 	beq.w	80139d6 <USBH_MSC_HandleBOTXfer+0x186>
      else if(URB_Status == URB_STALL)
 80138cc:	2804      	cmp	r0, #4
 80138ce:	d1e3      	bne.n	8013898 <USBH_MSC_HandleBOTXfer+0x48>
        error_direction = USBH_MSC_DIR_OUT;
 80138d0:	4a87      	ldr	r2, [pc, #540]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
 80138d2:	2101      	movs	r1, #1
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
 80138d4:	2308      	movs	r3, #8
        error_direction = USBH_MSC_DIR_OUT;
 80138d6:	7311      	strb	r1, [r2, #12]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
 80138d8:	7123      	strb	r3, [r4, #4]
 80138da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      URB_Status =   HCD_GetURB_State(pdev , MSC_Machine.hc_num_in);
 80138de:	4f83      	ldr	r7, [pc, #524]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
 80138e0:	4628      	mov	r0, r5
 80138e2:	7839      	ldrb	r1, [r7, #0]
 80138e4:	f7fe f92c 	bl	8011b40 <HCD_GetURB_State>
      if((URB_Status == URB_DONE) ||(USBH_MSC_BOTXferParam.BOTStateBkp != USBH_MSC_BOT_DATAIN_STATE))
 80138e8:	2801      	cmp	r0, #1
 80138ea:	d05e      	beq.n	80139aa <USBH_MSC_HandleBOTXfer+0x15a>
 80138ec:	7963      	ldrb	r3, [r4, #5]
 80138ee:	2b03      	cmp	r3, #3
 80138f0:	d15b      	bne.n	80139aa <USBH_MSC_HandleBOTXfer+0x15a>
      else if(URB_Status == URB_STALL)
 80138f2:	2804      	cmp	r0, #4
 80138f4:	d1d0      	bne.n	8013898 <USBH_MSC_HandleBOTXfer+0x48>
        error_direction = USBH_MSC_DIR_IN;
 80138f6:	497e      	ldr	r1, [pc, #504]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
 80138f8:	2000      	movs	r0, #0
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
 80138fa:	2207      	movs	r2, #7
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 80138fc:	2305      	movs	r3, #5
        error_direction = USBH_MSC_DIR_IN;
 80138fe:	7308      	strb	r0, [r1, #12]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
 8013900:	7122      	strb	r2, [r4, #4]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8013902:	7163      	strb	r3, [r4, #5]
 8013904:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_out);       
 8013908:	4e78      	ldr	r6, [pc, #480]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
 801390a:	4628      	mov	r0, r5
 801390c:	7871      	ldrb	r1, [r6, #1]
 801390e:	f7fe f917 	bl	8011b40 <HCD_GetURB_State>
      if(URB_Status == URB_DONE)
 8013912:	2801      	cmp	r0, #1
 8013914:	d077      	beq.n	8013a06 <USBH_MSC_HandleBOTXfer+0x1b6>
      else if(URB_Status == URB_NOTREADY)
 8013916:	2802      	cmp	r0, #2
 8013918:	f000 80b4 	beq.w	8013a84 <USBH_MSC_HandleBOTXfer+0x234>
      else if(URB_Status == URB_STALL)
 801391c:	2804      	cmp	r0, #4
 801391e:	d1bb      	bne.n	8013898 <USBH_MSC_HandleBOTXfer+0x48>
        error_direction = USBH_MSC_DIR_OUT;
 8013920:	4973      	ldr	r1, [pc, #460]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
 8013922:	2001      	movs	r0, #1
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
 8013924:	2208      	movs	r2, #8
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8013926:	2305      	movs	r3, #5
        error_direction = USBH_MSC_DIR_OUT;
 8013928:	7308      	strb	r0, [r1, #12]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_OUT;
 801392a:	7122      	strb	r2, [r4, #4]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 801392c:	7163      	strb	r3, [r4, #5]
 801392e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      URB_Status = HCD_GetURB_State(pdev , MSC_Machine.hc_num_in);
 8013932:	4e6e      	ldr	r6, [pc, #440]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
 8013934:	4628      	mov	r0, r5
 8013936:	7831      	ldrb	r1, [r6, #0]
 8013938:	f7fe f902 	bl	8011b40 <HCD_GetURB_State>
      if(URB_Status == URB_DONE)
 801393c:	2801      	cmp	r0, #1
 801393e:	f000 8094 	beq.w	8013a6a <USBH_MSC_HandleBOTXfer+0x21a>
      else if(URB_Status == URB_STALL)     
 8013942:	2804      	cmp	r0, #4
 8013944:	d1a8      	bne.n	8013898 <USBH_MSC_HandleBOTXfer+0x48>
        error_direction = USBH_MSC_DIR_IN;
 8013946:	4a6a      	ldr	r2, [pc, #424]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
 8013948:	2100      	movs	r1, #0
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
 801394a:	2307      	movs	r3, #7
        error_direction = USBH_MSC_DIR_IN;
 801394c:	7311      	strb	r1, [r2, #12]
        USBH_MSC_BOTXferParam.BOTState  = USBH_MSC_BOT_ERROR_IN;
 801394e:	7123      	strb	r3, [r4, #4]
 8013950:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    status = USBH_ClrFeature(pdev,
 8013954:	4a65      	ldr	r2, [pc, #404]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
 8013956:	4631      	mov	r1, r6
 8013958:	7813      	ldrb	r3, [r2, #0]
 801395a:	78d2      	ldrb	r2, [r2, #3]
 801395c:	4628      	mov	r0, r5
 801395e:	f000 fd8d 	bl	801447c <USBH_ClrFeature>
  BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
 8013962:	4a63      	ldr	r2, [pc, #396]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
 8013964:	6813      	ldr	r3, [r2, #0]
 8013966:	3301      	adds	r3, #1
  if (BOTStallErrorCount > MAX_BULK_STALL_COUNT_LIMIT )
 8013968:	2b04      	cmp	r3, #4
  BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
 801396a:	6013      	str	r3, [r2, #0]
  if (BOTStallErrorCount > MAX_BULK_STALL_COUNT_LIMIT )
 801396c:	d92d      	bls.n	80139ca <USBH_MSC_HandleBOTXfer+0x17a>
            Di Device intends to send data to the host)
            (13) Ho < Do (Host expects to send data to the device, 
            Device intends to receive data from the host)
            */
            
            status = USBH_MSC_PHASE_ERROR;
 801396e:	2302      	movs	r3, #2
        status = USBH_MSC_PHASE_ERROR;
      }
    } /* CSW Length Check*/
  }
  
  USBH_MSC_BOTXferParam.BOTXferStatus  = status;
 8013970:	73e3      	strb	r3, [r4, #15]
 8013972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
 8013976:	4e60      	ldr	r6, [pc, #384]	; (8013af8 <USBH_MSC_HandleBOTXfer+0x2a8>)
        USBH_BulkReceiveData (pdev,
 8013978:	4b5c      	ldr	r3, [pc, #368]	; (8013aec <USBH_MSC_HandleBOTXfer+0x29c>)
        USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
 801397a:	60a6      	str	r6, [r4, #8]
        USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
 801397c:	273f      	movs	r7, #63	; 0x3f
        USBH_BulkReceiveData (pdev,
 801397e:	4628      	mov	r0, r5
 8013980:	2500      	movs	r5, #0
 8013982:	781b      	ldrb	r3, [r3, #0]
 8013984:	f8c6 5005 	str.w	r5, [r6, #5]
 8013988:	f8c6 5009 	str.w	r5, [r6, #9]
 801398c:	7375      	strb	r5, [r6, #13]
 801398e:	f8c6 5001 	str.w	r5, [r6, #1]
        USBH_MSC_CSWData.CSWArray[0] = 0;
 8013992:	7035      	strb	r5, [r6, #0]
        USBH_BulkReceiveData (pdev,
 8013994:	4631      	mov	r1, r6
 8013996:	463a      	mov	r2, r7
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8013998:	2505      	movs	r5, #5
        USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
 801399a:	81a7      	strh	r7, [r4, #12]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 801399c:	7165      	strb	r5, [r4, #5]
        USBH_BulkReceiveData (pdev,
 801399e:	f7ff fedd 	bl	801375c <USBH_BulkReceiveData>
        USBH_MSC_BOTXferParam.BOTState = USBH_MSC_DECODE_CSW;    
 80139a2:	2306      	movs	r3, #6
 80139a4:	7123      	strb	r3, [r4, #4]
      break;
 80139a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        BOTStallErrorCount = 0;
 80139aa:	4e51      	ldr	r6, [pc, #324]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 80139ac:	6872      	ldr	r2, [r6, #4]
        BOTStallErrorCount = 0;
 80139ae:	f04f 0800 	mov.w	r8, #0
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAIN_STATE;    
 80139b2:	2303      	movs	r3, #3
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 80139b4:	2a40      	cmp	r2, #64	; 0x40
        BOTStallErrorCount = 0;
 80139b6:	f8c6 8000 	str.w	r8, [r6]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAIN_STATE;    
 80139ba:	7163      	strb	r3, [r4, #5]
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 80139bc:	d839      	bhi.n	8013a32 <USBH_MSC_HandleBOTXfer+0x1e2>
        else if ( remainingDataLength == 0)
 80139be:	2a00      	cmp	r2, #0
 80139c0:	d145      	bne.n	8013a4e <USBH_MSC_HandleBOTXfer+0x1fe>
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_RECEIVE_CSW_STATE;
 80139c2:	2305      	movs	r3, #5
 80139c4:	7123      	strb	r3, [r4, #4]
 80139c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (status == USBH_OK)
 80139ca:	2800      	cmp	r0, #0
 80139cc:	f47f af62 	bne.w	8013894 <USBH_MSC_HandleBOTXfer+0x44>
        if (error_direction == USBH_MSC_BOTH_DIR)
 80139d0:	7b13      	ldrb	r3, [r2, #12]
 80139d2:	2b02      	cmp	r3, #2
 80139d4:	d045      	beq.n	8013a62 <USBH_MSC_HandleBOTXfer+0x212>
        USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOTXferParam.BOTStateBkp;        
 80139d6:	7963      	ldrb	r3, [r4, #5]
 80139d8:	7123      	strb	r3, [r4, #4]
 80139da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if ( USBH_MSC_CBWData.field.CBWTransferLength != 0 )
 80139de:	4945      	ldr	r1, [pc, #276]	; (8013af4 <USBH_MSC_HandleBOTXfer+0x2a4>)
        BOTStallErrorCount = 0;
 80139e0:	4b43      	ldr	r3, [pc, #268]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
        if ( USBH_MSC_CBWData.field.CBWTransferLength != 0 )
 80139e2:	688a      	ldr	r2, [r1, #8]
        BOTStallErrorCount = 0;
 80139e4:	2500      	movs	r5, #0
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SENT_CBW; 
 80139e6:	2002      	movs	r0, #2
        BOTStallErrorCount = 0;
 80139e8:	601d      	str	r5, [r3, #0]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_SENT_CBW; 
 80139ea:	7160      	strb	r0, [r4, #5]
        if ( USBH_MSC_CBWData.field.CBWTransferLength != 0 )
 80139ec:	2a00      	cmp	r2, #0
 80139ee:	d0e8      	beq.n	80139c2 <USBH_MSC_HandleBOTXfer+0x172>
        xferDirection = (USBH_MSC_CBWData.field.CBWFlags & USB_REQ_DIR_MASK);
 80139f0:	7b09      	ldrb	r1, [r1, #12]
          datapointer = USBH_MSC_BOTXferParam.pRxTxBuff;
 80139f2:	68a0      	ldr	r0, [r4, #8]
          remainingDataLength = USBH_MSC_CBWData.field.CBWTransferLength ;
 80139f4:	605a      	str	r2, [r3, #4]
          datapointer = USBH_MSC_BOTXferParam.pRxTxBuff;
 80139f6:	6098      	str	r0, [r3, #8]
          if (xferDirection == USB_D2H)
 80139f8:	060b      	lsls	r3, r1, #24
            USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_DATAIN_STATE;
 80139fa:	bf4c      	ite	mi
 80139fc:	2303      	movmi	r3, #3
            USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_DATAOUT_STATE;
 80139fe:	2304      	movpl	r3, #4
 8013a00:	7123      	strb	r3, [r4, #4]
 8013a02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        BOTStallErrorCount = 0;
 8013a06:	4f3a      	ldr	r7, [pc, #232]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 8013a08:	687a      	ldr	r2, [r7, #4]
        BOTStallErrorCount = 0;
 8013a0a:	f04f 0800 	mov.w	r8, #0
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAOUT_STATE;    
 8013a0e:	2304      	movs	r3, #4
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 8013a10:	2a40      	cmp	r2, #64	; 0x40
        BOTStallErrorCount = 0;
 8013a12:	f8c7 8000 	str.w	r8, [r7]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_BOT_DATAOUT_STATE;    
 8013a16:	7163      	strb	r3, [r4, #5]
        if(remainingDataLength > USBH_MSC_MPS_SIZE)
 8013a18:	d83e      	bhi.n	8013a98 <USBH_MSC_HandleBOTXfer+0x248>
        else if ( remainingDataLength == 0)
 8013a1a:	2a00      	cmp	r2, #0
 8013a1c:	d0d1      	beq.n	80139c2 <USBH_MSC_HandleBOTXfer+0x172>
          USBH_BulkSendData (pdev,
 8013a1e:	7873      	ldrb	r3, [r6, #1]
 8013a20:	68b9      	ldr	r1, [r7, #8]
 8013a22:	b292      	uxth	r2, r2
 8013a24:	4628      	mov	r0, r5
 8013a26:	f7ff fe7f 	bl	8013728 <USBH_BulkSendData>
          remainingDataLength = 0; /* Reset this value and keep in same state */   
 8013a2a:	f8c7 8004 	str.w	r8, [r7, #4]
 8013a2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          USBH_BulkReceiveData (pdev,
 8013a32:	783b      	ldrb	r3, [r7, #0]
 8013a34:	68b1      	ldr	r1, [r6, #8]
 8013a36:	2240      	movs	r2, #64	; 0x40
 8013a38:	4628      	mov	r0, r5
 8013a3a:	f7ff fe8f 	bl	801375c <USBH_BulkReceiveData>
          remainingDataLength -= USBH_MSC_MPS_SIZE;
 8013a3e:	6872      	ldr	r2, [r6, #4]
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 8013a40:	68b3      	ldr	r3, [r6, #8]
          remainingDataLength -= USBH_MSC_MPS_SIZE;
 8013a42:	3a40      	subs	r2, #64	; 0x40
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 8013a44:	3340      	adds	r3, #64	; 0x40
          remainingDataLength -= USBH_MSC_MPS_SIZE;
 8013a46:	6072      	str	r2, [r6, #4]
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 8013a48:	60b3      	str	r3, [r6, #8]
 8013a4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          USBH_BulkReceiveData (pdev,
 8013a4e:	783b      	ldrb	r3, [r7, #0]
 8013a50:	68b1      	ldr	r1, [r6, #8]
 8013a52:	b292      	uxth	r2, r2
 8013a54:	4628      	mov	r0, r5
 8013a56:	f7ff fe81 	bl	801375c <USBH_BulkReceiveData>
          remainingDataLength = 0; /* Reset this value and keep in same state */
 8013a5a:	f8c6 8004 	str.w	r8, [r6, #4]
 8013a5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          USBH_MSC_BOTXferParam.BOTState = USBH_MSC_BOT_ERROR_OUT;
 8013a62:	2308      	movs	r3, #8
 8013a64:	7123      	strb	r3, [r4, #4]
 8013a66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateCurrent ;
 8013a6a:	78a3      	ldrb	r3, [r4, #2]
        BOTStallErrorCount = 0;
 8013a6c:	4a20      	ldr	r2, [pc, #128]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateCurrent ;
 8013a6e:	7023      	strb	r3, [r4, #0]
        BOTStallErrorCount = 0;
 8013a70:	2100      	movs	r1, #0
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8013a72:	2305      	movs	r3, #5
  if(HCD_IsDeviceConnected(pdev))
 8013a74:	4628      	mov	r0, r5
        BOTStallErrorCount = 0;
 8013a76:	6011      	str	r1, [r2, #0]
        USBH_MSC_BOTXferParam.BOTStateBkp = USBH_MSC_RECEIVE_CSW_STATE;
 8013a78:	7163      	strb	r3, [r4, #5]
  if(HCD_IsDeviceConnected(pdev))
 8013a7a:	f7fe f859 	bl	8011b30 <HCD_IsDeviceConnected>
 8013a7e:	b9c8      	cbnz	r0, 8013ab4 <USBH_MSC_HandleBOTXfer+0x264>
  status = USBH_MSC_FAIL;
 8013a80:	2301      	movs	r3, #1
 8013a82:	e775      	b.n	8013970 <USBH_MSC_HandleBOTXfer+0x120>
        USBH_BulkSendData (pdev,
 8013a84:	4a1a      	ldr	r2, [pc, #104]	; (8013af0 <USBH_MSC_HandleBOTXfer+0x2a0>)
 8013a86:	7873      	ldrb	r3, [r6, #1]
 8013a88:	6891      	ldr	r1, [r2, #8]
 8013a8a:	4628      	mov	r0, r5
 8013a8c:	3940      	subs	r1, #64	; 0x40
 8013a8e:	2240      	movs	r2, #64	; 0x40
}
 8013a90:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        USBH_BulkSendData (pdev,
 8013a94:	f7ff be48 	b.w	8013728 <USBH_BulkSendData>
          USBH_BulkSendData (pdev,
 8013a98:	7873      	ldrb	r3, [r6, #1]
 8013a9a:	68b9      	ldr	r1, [r7, #8]
 8013a9c:	2240      	movs	r2, #64	; 0x40
 8013a9e:	4628      	mov	r0, r5
 8013aa0:	f7ff fe42 	bl	8013728 <USBH_BulkSendData>
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 8013aa4:	68ba      	ldr	r2, [r7, #8]
          remainingDataLength = remainingDataLength - USBH_MSC_MPS_SIZE;
 8013aa6:	687b      	ldr	r3, [r7, #4]
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 8013aa8:	3240      	adds	r2, #64	; 0x40
          remainingDataLength = remainingDataLength - USBH_MSC_MPS_SIZE;
 8013aaa:	3b40      	subs	r3, #64	; 0x40
          datapointer = datapointer + USBH_MSC_MPS_SIZE;
 8013aac:	60ba      	str	r2, [r7, #8]
          remainingDataLength = remainingDataLength - USBH_MSC_MPS_SIZE;
 8013aae:	607b      	str	r3, [r7, #4]
 8013ab0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    dataXferCount = HCD_GetXferCnt(pdev, MSC_Machine.hc_num_in); 
 8013ab4:	7831      	ldrb	r1, [r6, #0]
 8013ab6:	4628      	mov	r0, r5
 8013ab8:	f7fe f846 	bl	8011b48 <HCD_GetXferCnt>
    if(dataXferCount != USBH_MSC_CSW_LENGTH)
 8013abc:	280d      	cmp	r0, #13
 8013abe:	f47f af56 	bne.w	801396e <USBH_MSC_HandleBOTXfer+0x11e>
      if(USBH_MSC_CSWData.field.CSWSignature == USBH_MSC_BOT_CSW_SIGNATURE)
 8013ac2:	4b0d      	ldr	r3, [pc, #52]	; (8013af8 <USBH_MSC_HandleBOTXfer+0x2a8>)
 8013ac4:	4a0d      	ldr	r2, [pc, #52]	; (8013afc <USBH_MSC_HandleBOTXfer+0x2ac>)
 8013ac6:	6819      	ldr	r1, [r3, #0]
 8013ac8:	4291      	cmp	r1, r2
 8013aca:	f47f af50 	bne.w	801396e <USBH_MSC_HandleBOTXfer+0x11e>
        if(USBH_MSC_CSWData.field.CSWTag == USBH_MSC_CBWData.field.CBWTag)
 8013ace:	4a09      	ldr	r2, [pc, #36]	; (8013af4 <USBH_MSC_HandleBOTXfer+0x2a4>)
 8013ad0:	6859      	ldr	r1, [r3, #4]
 8013ad2:	6852      	ldr	r2, [r2, #4]
 8013ad4:	4291      	cmp	r1, r2
 8013ad6:	d1d3      	bne.n	8013a80 <USBH_MSC_HandleBOTXfer+0x230>
          if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_OK) 
 8013ad8:	7b1b      	ldrb	r3, [r3, #12]
 8013ada:	2b00      	cmp	r3, #0
 8013adc:	f43f af48 	beq.w	8013970 <USBH_MSC_HandleBOTXfer+0x120>
          else if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_PHASE_ERROR)
 8013ae0:	2b02      	cmp	r3, #2
 8013ae2:	d1cd      	bne.n	8013a80 <USBH_MSC_HandleBOTXfer+0x230>
 8013ae4:	e744      	b.n	8013970 <USBH_MSC_HandleBOTXfer+0x120>
 8013ae6:	bf00      	nop
 8013ae8:	2001088c 	.word	0x2001088c
 8013aec:	200108bc 	.word	0x200108bc
 8013af0:	20008088 	.word	0x20008088
 8013af4:	2001089c 	.word	0x2001089c
 8013af8:	2001087c 	.word	0x2001087c
 8013afc:	53425355 	.word	0x53425355

08013b00 <USBH_MSC_BOT_Abort>:
{
 8013b00:	b508      	push	{r3, lr}
  switch (direction)
 8013b02:	b182      	cbz	r2, 8013b26 <USBH_MSC_BOT_Abort+0x26>
 8013b04:	2a01      	cmp	r2, #1
 8013b06:	d008      	beq.n	8013b1a <USBH_MSC_BOT_Abort+0x1a>
  status = USBH_BUSY;
 8013b08:	2001      	movs	r0, #1
  BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
 8013b0a:	4a0a      	ldr	r2, [pc, #40]	; (8013b34 <USBH_MSC_BOT_Abort+0x34>)
 8013b0c:	6813      	ldr	r3, [r2, #0]
 8013b0e:	3301      	adds	r3, #1
    status = USBH_UNRECOVERED_ERROR;
 8013b10:	2b05      	cmp	r3, #5
}
 8013b12:	bf28      	it	cs
 8013b14:	2004      	movcs	r0, #4
  BOTStallErrorCount++; /* Check Continous Number of times, STALL has Occured */ 
 8013b16:	6013      	str	r3, [r2, #0]
}
 8013b18:	bd08      	pop	{r3, pc}
    status = USBH_ClrFeature(pdev, 
 8013b1a:	4a07      	ldr	r2, [pc, #28]	; (8013b38 <USBH_MSC_BOT_Abort+0x38>)
 8013b1c:	7853      	ldrb	r3, [r2, #1]
 8013b1e:	7892      	ldrb	r2, [r2, #2]
 8013b20:	f000 fcac 	bl	801447c <USBH_ClrFeature>
    break;
 8013b24:	e7f1      	b.n	8013b0a <USBH_MSC_BOT_Abort+0xa>
    status = USBH_ClrFeature(pdev,
 8013b26:	4a04      	ldr	r2, [pc, #16]	; (8013b38 <USBH_MSC_BOT_Abort+0x38>)
 8013b28:	7813      	ldrb	r3, [r2, #0]
 8013b2a:	78d2      	ldrb	r2, [r2, #3]
 8013b2c:	f000 fca6 	bl	801447c <USBH_ClrFeature>
    break;
 8013b30:	e7eb      	b.n	8013b0a <USBH_MSC_BOT_Abort+0xa>
 8013b32:	bf00      	nop
 8013b34:	20008088 	.word	0x20008088
 8013b38:	200108bc 	.word	0x200108bc

08013b3c <USBH_MSC_DecodeCSW>:
{
 8013b3c:	b510      	push	{r4, lr}
 8013b3e:	4604      	mov	r4, r0
  if(HCD_IsDeviceConnected(pdev))
 8013b40:	f7fd fff6 	bl	8011b30 <HCD_IsDeviceConnected>
 8013b44:	b920      	cbnz	r0, 8013b50 <USBH_MSC_DecodeCSW+0x14>
  status = USBH_MSC_FAIL;
 8013b46:	2301      	movs	r3, #1
  USBH_MSC_BOTXferParam.BOTXferStatus  = status;
 8013b48:	4a0f      	ldr	r2, [pc, #60]	; (8013b88 <USBH_MSC_DecodeCSW+0x4c>)
 8013b4a:	73d3      	strb	r3, [r2, #15]
  return status;
}
 8013b4c:	4618      	mov	r0, r3
 8013b4e:	bd10      	pop	{r4, pc}
    dataXferCount = HCD_GetXferCnt(pdev, MSC_Machine.hc_num_in); 
 8013b50:	4b0e      	ldr	r3, [pc, #56]	; (8013b8c <USBH_MSC_DecodeCSW+0x50>)
 8013b52:	4620      	mov	r0, r4
 8013b54:	7819      	ldrb	r1, [r3, #0]
 8013b56:	f7fd fff7 	bl	8011b48 <HCD_GetXferCnt>
    if(dataXferCount != USBH_MSC_CSW_LENGTH)
 8013b5a:	280d      	cmp	r0, #13
 8013b5c:	d004      	beq.n	8013b68 <USBH_MSC_DecodeCSW+0x2c>
  USBH_MSC_BOTXferParam.BOTXferStatus  = status;
 8013b5e:	4a0a      	ldr	r2, [pc, #40]	; (8013b88 <USBH_MSC_DecodeCSW+0x4c>)
            status = USBH_MSC_PHASE_ERROR;
 8013b60:	2302      	movs	r3, #2
  USBH_MSC_BOTXferParam.BOTXferStatus  = status;
 8013b62:	73d3      	strb	r3, [r2, #15]
}
 8013b64:	4618      	mov	r0, r3
 8013b66:	bd10      	pop	{r4, pc}
      if(USBH_MSC_CSWData.field.CSWSignature == USBH_MSC_BOT_CSW_SIGNATURE)
 8013b68:	4b09      	ldr	r3, [pc, #36]	; (8013b90 <USBH_MSC_DecodeCSW+0x54>)
 8013b6a:	4a0a      	ldr	r2, [pc, #40]	; (8013b94 <USBH_MSC_DecodeCSW+0x58>)
 8013b6c:	6819      	ldr	r1, [r3, #0]
 8013b6e:	4291      	cmp	r1, r2
 8013b70:	d1f5      	bne.n	8013b5e <USBH_MSC_DecodeCSW+0x22>
        if(USBH_MSC_CSWData.field.CSWTag == USBH_MSC_CBWData.field.CBWTag)
 8013b72:	4a09      	ldr	r2, [pc, #36]	; (8013b98 <USBH_MSC_DecodeCSW+0x5c>)
 8013b74:	6859      	ldr	r1, [r3, #4]
 8013b76:	6852      	ldr	r2, [r2, #4]
 8013b78:	4291      	cmp	r1, r2
 8013b7a:	d1e4      	bne.n	8013b46 <USBH_MSC_DecodeCSW+0xa>
          if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_OK) 
 8013b7c:	7b1b      	ldrb	r3, [r3, #12]
 8013b7e:	2b00      	cmp	r3, #0
 8013b80:	d0e2      	beq.n	8013b48 <USBH_MSC_DecodeCSW+0xc>
          else if(USBH_MSC_CSWData.field.CSWStatus == USBH_MSC_PHASE_ERROR)
 8013b82:	2b02      	cmp	r3, #2
 8013b84:	d1df      	bne.n	8013b46 <USBH_MSC_DecodeCSW+0xa>
 8013b86:	e7df      	b.n	8013b48 <USBH_MSC_DecodeCSW+0xc>
 8013b88:	2001088c 	.word	0x2001088c
 8013b8c:	200108bc 	.word	0x200108bc
 8013b90:	2001087c 	.word	0x2001087c
 8013b94:	53425355 	.word	0x53425355
 8013b98:	2001089c 	.word	0x2001089c

08013b9c <USBH_MSC_ClassRequest>:
static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
                                        void *phost)
{   
  
  USBH_Status status = USBH_OK ;
  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_INIT_STATE;
 8013b9c:	4b01      	ldr	r3, [pc, #4]	; (8013ba4 <USBH_MSC_ClassRequest+0x8>)
 8013b9e:	2000      	movs	r0, #0
 8013ba0:	7018      	strb	r0, [r3, #0]
  
  return status; 
}
 8013ba2:	4770      	bx	lr
 8013ba4:	2001088c 	.word	0x2001088c

08013ba8 <USBH_MSC_InterfaceDeInit>:
{	
 8013ba8:	b538      	push	{r3, r4, r5, lr}
  if ( MSC_Machine.hc_num_out)
 8013baa:	4c0c      	ldr	r4, [pc, #48]	; (8013bdc <USBH_MSC_InterfaceDeInit+0x34>)
 8013bac:	7861      	ldrb	r1, [r4, #1]
{	
 8013bae:	4605      	mov	r5, r0
  if ( MSC_Machine.hc_num_out)
 8013bb0:	b959      	cbnz	r1, 8013bca <USBH_MSC_InterfaceDeInit+0x22>
  if ( MSC_Machine.hc_num_in)
 8013bb2:	7821      	ldrb	r1, [r4, #0]
 8013bb4:	b141      	cbz	r1, 8013bc8 <USBH_MSC_InterfaceDeInit+0x20>
    USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_in);
 8013bb6:	4628      	mov	r0, r5
 8013bb8:	f7fd fe10 	bl	80117dc <USB_OTG_HC_Halt>
    USBH_Free_Channel  (pdev, MSC_Machine.hc_num_in);
 8013bbc:	4628      	mov	r0, r5
 8013bbe:	7821      	ldrb	r1, [r4, #0]
 8013bc0:	f7ff fd20 	bl	8013604 <USBH_Free_Channel>
    MSC_Machine.hc_num_in = 0;     /* Reset the Channel as Free */
 8013bc4:	2300      	movs	r3, #0
 8013bc6:	7023      	strb	r3, [r4, #0]
 8013bc8:	bd38      	pop	{r3, r4, r5, pc}
    USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_out);
 8013bca:	f7fd fe07 	bl	80117dc <USB_OTG_HC_Halt>
    USBH_Free_Channel  (pdev, MSC_Machine.hc_num_out);
 8013bce:	7861      	ldrb	r1, [r4, #1]
 8013bd0:	4628      	mov	r0, r5
 8013bd2:	f7ff fd17 	bl	8013604 <USBH_Free_Channel>
    MSC_Machine.hc_num_out = 0;     /* Reset the Channel as Free */
 8013bd6:	2300      	movs	r3, #0
 8013bd8:	7063      	strb	r3, [r4, #1]
 8013bda:	e7ea      	b.n	8013bb2 <USBH_MSC_InterfaceDeInit+0xa>
 8013bdc:	200108bc 	.word	0x200108bc

08013be0 <USBH_MSC_InterfaceInit>:
{	 
 8013be0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
 8013be2:	f891 3043 	ldrb.w	r3, [r1, #67]	; 0x43
 8013be6:	2b08      	cmp	r3, #8
{	 
 8013be8:	b083      	sub	sp, #12
 8013bea:	460c      	mov	r4, r1
  if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
 8013bec:	d006      	beq.n	8013bfc <USBH_MSC_InterfaceInit+0x1c>
    pphost->usr_cb->USBH_USR_DeviceNotSupported(); 
 8013bee:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8013bf2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013bf4:	4798      	blx	r3
}
 8013bf6:	2000      	movs	r0, #0
 8013bf8:	b003      	add	sp, #12
 8013bfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
 8013bfc:	f891 3045 	ldrb.w	r3, [r1, #69]	; 0x45
 8013c00:	2b50      	cmp	r3, #80	; 0x50
 8013c02:	d1f4      	bne.n	8013bee <USBH_MSC_InterfaceInit+0xe>
    if(pphost->device_prop.Ep_Desc[0][0].bEndpointAddress & 0x80)
 8013c04:	f891 3052 	ldrb.w	r3, [r1, #82]	; 0x52
      MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][0].wMaxPacketSize;
 8013c08:	f8b1 2054 	ldrh.w	r2, [r1, #84]	; 0x54
      MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
 8013c0c:	4d1b      	ldr	r5, [pc, #108]	; (8013c7c <USBH_MSC_InterfaceInit+0x9c>)
    if(pphost->device_prop.Ep_Desc[0][0].bEndpointAddress & 0x80)
 8013c0e:	0619      	lsls	r1, r3, #24
    if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
 8013c10:	f894 105a 	ldrb.w	r1, [r4, #90]	; 0x5a
      MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
 8013c14:	bf4b      	itete	mi
 8013c16:	70eb      	strbmi	r3, [r5, #3]
      MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
 8013c18:	70ab      	strbpl	r3, [r5, #2]
      MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][0].wMaxPacketSize;
 8013c1a:	80aa      	strhmi	r2, [r5, #4]
      MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0] [0].wMaxPacketSize;      
 8013c1c:	80ea      	strhpl	r2, [r5, #6]
    if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
 8013c1e:	060a      	lsls	r2, r1, #24
 8013c20:	4606      	mov	r6, r0
      MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
 8013c22:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
 8013c26:	d425      	bmi.n	8013c74 <USBH_MSC_InterfaceInit+0x94>
      MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
 8013c28:	70a9      	strb	r1, [r5, #2]
      MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
 8013c2a:	80eb      	strh	r3, [r5, #6]
    MSC_Machine.hc_num_out = USBH_Alloc_Channel(pdev, 
 8013c2c:	4630      	mov	r0, r6
 8013c2e:	f7ff fca5 	bl	801357c <USBH_Alloc_Channel>
    MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
 8013c32:	78e9      	ldrb	r1, [r5, #3]
    MSC_Machine.hc_num_out = USBH_Alloc_Channel(pdev, 
 8013c34:	7068      	strb	r0, [r5, #1]
    MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
 8013c36:	4630      	mov	r0, r6
 8013c38:	f7ff fca0 	bl	801357c <USBH_Alloc_Channel>
    USBH_Open_Channel  (pdev,
 8013c3c:	f8b5 e006 	ldrh.w	lr, [r5, #6]
 8013c40:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8013c44:	f894 2020 	ldrb.w	r2, [r4, #32]
 8013c48:	7869      	ldrb	r1, [r5, #1]
    MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
 8013c4a:	7028      	strb	r0, [r5, #0]
    USBH_Open_Channel  (pdev,
 8013c4c:	2702      	movs	r7, #2
 8013c4e:	e88d 4080 	stmia.w	sp, {r7, lr}
 8013c52:	4630      	mov	r0, r6
 8013c54:	f7ff fc4c 	bl	80134f0 <USBH_Open_Channel>
    USBH_Open_Channel  (pdev,
 8013c58:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8013c5c:	f894 2020 	ldrb.w	r2, [r4, #32]
 8013c60:	88ac      	ldrh	r4, [r5, #4]
 8013c62:	7829      	ldrb	r1, [r5, #0]
 8013c64:	9700      	str	r7, [sp, #0]
 8013c66:	4630      	mov	r0, r6
 8013c68:	9401      	str	r4, [sp, #4]
 8013c6a:	f7ff fc41 	bl	80134f0 <USBH_Open_Channel>
}
 8013c6e:	2000      	movs	r0, #0
 8013c70:	b003      	add	sp, #12
 8013c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
      MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
 8013c74:	70e9      	strb	r1, [r5, #3]
      MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
 8013c76:	80ab      	strh	r3, [r5, #4]
 8013c78:	78a9      	ldrb	r1, [r5, #2]
 8013c7a:	e7d7      	b.n	8013c2c <USBH_MSC_InterfaceInit+0x4c>
 8013c7c:	200108bc 	.word	0x200108bc

08013c80 <USBH_MSC_Handle>:


//--------------------------------------------------------------
static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev , 
                                   void   *phost)
{
 8013c80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013c82:	b083      	sub	sp, #12
 8013c84:	460d      	mov	r5, r1
 8013c86:	4606      	mov	r6, r0
  uint8_t appliStatus = 0;
  
  static uint8_t maxLunExceed = FALSE;
  
    
  if(HCD_IsDeviceConnected(pdev))
 8013c88:	f7fd ff52 	bl	8011b30 <HCD_IsDeviceConnected>
 8013c8c:	b1b0      	cbz	r0, 8013cbc <USBH_MSC_Handle+0x3c>
  {   
    switch(USBH_MSC_BOTXferParam.MSCState)
 8013c8e:	4c5c      	ldr	r4, [pc, #368]	; (8013e00 <USBH_MSC_Handle+0x180>)
 8013c90:	7823      	ldrb	r3, [r4, #0]
 8013c92:	2b0a      	cmp	r3, #10
 8013c94:	d812      	bhi.n	8013cbc <USBH_MSC_Handle+0x3c>
 8013c96:	e8df f003 	tbb	[pc, r3]
 8013c9a:	1c16      	.short	0x1c16
 8013c9c:	594f0632 	.word	0x594f0632
 8013ca0:	7b716b63 	.word	0x7b716b63
 8013ca4:	14          	.byte	0x14
 8013ca5:	00          	.byte	0x00
      }
      break;  
      
    case USBH_MSC_TEST_UNIT_READY:
      /* Issue SCSI command TestUnitReady */ 
      mscStatus = USBH_MSC_TestUnitReady(pdev);
 8013ca6:	4630      	mov	r0, r6
 8013ca8:	f000 f8cc 	bl	8013e44 <USBH_MSC_TestUnitReady>
      
      if(mscStatus == USBH_MSC_OK )
 8013cac:	2800      	cmp	r0, #0
 8013cae:	f000 808e 	beq.w	8013dce <USBH_MSC_Handle+0x14e>
}

//--------------------------------------------------------------
void USBH_MSC_ErrorHandle(uint8_t status)
{  
    if(status == USBH_MSC_FAIL)
 8013cb2:	2801      	cmp	r0, #1
 8013cb4:	f000 8090 	beq.w	8013dd8 <USBH_MSC_Handle+0x158>
      {
        /* Error trials exceeded the limit, go to unrecovered state */
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
      }
    } 
    else if(status == USBH_MSC_PHASE_ERROR)
 8013cb8:	2802      	cmp	r0, #2
 8013cba:	d077      	beq.n	8013dac <USBH_MSC_Handle+0x12c>
  USBH_Status status = USBH_BUSY;
 8013cbc:	2001      	movs	r0, #1
}
 8013cbe:	b003      	add	sp, #12
 8013cc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      status = USBH_UNRECOVERED_ERROR;
 8013cc2:	2004      	movs	r0, #4
 8013cc4:	e7fb      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      USBH_MSC_Init(pdev);
 8013cc6:	4630      	mov	r0, r6
 8013cc8:	f7ff fda2 	bl	8013810 <USBH_MSC_Init>
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_RESET;  
 8013ccc:	2001      	movs	r0, #1
 8013cce:	7020      	strb	r0, [r4, #0]
 8013cd0:	e7f5      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
  phost->Control.setup.b.wValue.w = 0;
 8013cd2:	2300      	movs	r3, #0
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
 8013cd4:	2121      	movs	r1, #33	; 0x21
  phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
 8013cd6:	22ff      	movs	r2, #255	; 0xff
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
 8013cd8:	7529      	strb	r1, [r5, #20]
  phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
 8013cda:	756a      	strb	r2, [r5, #21]
  return USBH_CtlReq(pdev, phost, 0 , 0 ); 
 8013cdc:	4630      	mov	r0, r6
  phost->Control.setup.b.wValue.w = 0;
 8013cde:	82eb      	strh	r3, [r5, #22]
  phost->Control.setup.b.wIndex.w = 0;
 8013ce0:	832b      	strh	r3, [r5, #24]
  phost->Control.setup.b.wLength.w = 0;           
 8013ce2:	836b      	strh	r3, [r5, #26]
  return USBH_CtlReq(pdev, phost, 0 , 0 ); 
 8013ce4:	4629      	mov	r1, r5
 8013ce6:	461a      	mov	r2, r3
 8013ce8:	f7ff fca2 	bl	8013630 <USBH_CtlReq>
      if(status == USBH_OK )
 8013cec:	2800      	cmp	r0, #0
 8013cee:	d067      	beq.n	8013dc0 <USBH_MSC_Handle+0x140>
      if(status == USBH_NOT_SUPPORTED )
 8013cf0:	2803      	cmp	r0, #3
 8013cf2:	d1e4      	bne.n	8013cbe <USBH_MSC_Handle+0x3e>
        USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_GET_MAX_LUN; 
 8013cf4:	2202      	movs	r2, #2
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
 8013cf6:	2309      	movs	r3, #9
        USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_GET_MAX_LUN; 
 8013cf8:	7062      	strb	r2, [r4, #1]
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
 8013cfa:	7023      	strb	r3, [r4, #0]
 8013cfc:	e7df      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
  phost->Control.setup.b.wValue.w = 0;
 8013cfe:	2300      	movs	r3, #0
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
 8013d00:	21a1      	movs	r1, #161	; 0xa1
  phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
 8013d02:	22fe      	movs	r2, #254	; 0xfe
  phost->Control.setup.b.wLength.w = 1;           
 8013d04:	2701      	movs	r7, #1
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
 8013d06:	7529      	strb	r1, [r5, #20]
  phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
 8013d08:	756a      	strb	r2, [r5, #21]
  phost->Control.setup.b.wValue.w = 0;
 8013d0a:	82eb      	strh	r3, [r5, #22]
  phost->Control.setup.b.wIndex.w = 0;
 8013d0c:	832b      	strh	r3, [r5, #24]
  return USBH_CtlReq(pdev, phost, MSC_Machine.buff , 1 ); 
 8013d0e:	4630      	mov	r0, r6
  phost->Control.setup.b.wLength.w = 1;           
 8013d10:	836f      	strh	r7, [r5, #26]
  return USBH_CtlReq(pdev, phost, MSC_Machine.buff , 1 ); 
 8013d12:	463b      	mov	r3, r7
 8013d14:	4a3b      	ldr	r2, [pc, #236]	; (8013e04 <USBH_MSC_Handle+0x184>)
 8013d16:	4629      	mov	r1, r5
 8013d18:	f7ff fc8a 	bl	8013630 <USBH_CtlReq>
      if(status == USBH_OK )
 8013d1c:	2800      	cmp	r0, #0
 8013d1e:	d149      	bne.n	8013db4 <USBH_MSC_Handle+0x134>
        MSC_Machine.maxLun = *(MSC_Machine.buff) ;
 8013d20:	4a39      	ldr	r2, [pc, #228]	; (8013e08 <USBH_MSC_Handle+0x188>)
 8013d22:	7a13      	ldrb	r3, [r2, #8]
 8013d24:	f882 3048 	strb.w	r3, [r2, #72]	; 0x48
        if((MSC_Machine.maxLun > 0) && (maxLunExceed == FALSE))
 8013d28:	b11b      	cbz	r3, 8013d32 <USBH_MSC_Handle+0xb2>
 8013d2a:	4b38      	ldr	r3, [pc, #224]	; (8013e0c <USBH_MSC_Handle+0x18c>)
 8013d2c:	781a      	ldrb	r2, [r3, #0]
 8013d2e:	2a00      	cmp	r2, #0
 8013d30:	d05e      	beq.n	8013df0 <USBH_MSC_Handle+0x170>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_TEST_UNIT_READY;
 8013d32:	2303      	movs	r3, #3
 8013d34:	7023      	strb	r3, [r4, #0]
 8013d36:	e7c2      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      mscStatus = USBH_MSC_ReadCapacity10(pdev);
 8013d38:	4630      	mov	r0, r6
 8013d3a:	f000 f8b9 	bl	8013eb0 <USBH_MSC_ReadCapacity10>
      if(mscStatus == USBH_MSC_OK )
 8013d3e:	2800      	cmp	r0, #0
 8013d40:	d1b7      	bne.n	8013cb2 <USBH_MSC_Handle+0x32>
        MSCErrorCount = 0;
 8013d42:	4a32      	ldr	r2, [pc, #200]	; (8013e0c <USBH_MSC_Handle+0x18c>)
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_MODE_SENSE6;
 8013d44:	2305      	movs	r3, #5
        MSCErrorCount = 0;
 8013d46:	7050      	strb	r0, [r2, #1]
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_MODE_SENSE6;
 8013d48:	7023      	strb	r3, [r4, #0]
 8013d4a:	e7b8      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      mscStatus = USBH_MSC_ModeSense6(pdev);
 8013d4c:	4630      	mov	r0, r6
 8013d4e:	f000 f8fd 	bl	8013f4c <USBH_MSC_ModeSense6>
      if(mscStatus == USBH_MSC_OK )
 8013d52:	2800      	cmp	r0, #0
 8013d54:	d1ad      	bne.n	8013cb2 <USBH_MSC_Handle+0x32>
        MSCErrorCount = 0;
 8013d56:	4a2d      	ldr	r2, [pc, #180]	; (8013e0c <USBH_MSC_Handle+0x18c>)
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
 8013d58:	2308      	movs	r3, #8
        MSCErrorCount = 0;
 8013d5a:	7050      	strb	r0, [r2, #1]
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
 8013d5c:	7023      	strb	r3, [r4, #0]
 8013d5e:	e7ae      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      mscStatus = USBH_MSC_RequestSense(pdev);
 8013d60:	4630      	mov	r0, r6
 8013d62:	f000 f937 	bl	8013fd4 <USBH_MSC_RequestSense>
      if(mscStatus == USBH_MSC_OK )
 8013d66:	2800      	cmp	r0, #0
 8013d68:	d1a3      	bne.n	8013cb2 <USBH_MSC_Handle+0x32>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;
 8013d6a:	7863      	ldrb	r3, [r4, #1]
 8013d6c:	7023      	strb	r3, [r4, #0]
 8013d6e:	e7a6      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      USBH_MSC_HandleBOTXfer(pdev , phost);
 8013d70:	4630      	mov	r0, r6
 8013d72:	4629      	mov	r1, r5
 8013d74:	f7ff fd6c 	bl	8013850 <USBH_MSC_HandleBOTXfer>
  USBH_Status status = USBH_BUSY;
 8013d78:	2001      	movs	r0, #1
 8013d7a:	e7a0      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      appliStatus = pphost->usr_cb->USBH_USR_MSC_Application();
 8013d7c:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
 8013d80:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013d82:	4798      	blx	r3
 8013d84:	b2c0      	uxtb	r0, r0
      if(appliStatus == 0)
 8013d86:	b1f0      	cbz	r0, 8013dc6 <USBH_MSC_Handle+0x146>
      else if (appliStatus == 1) 
 8013d88:	2801      	cmp	r0, #1
 8013d8a:	d197      	bne.n	8013cbc <USBH_MSC_Handle+0x3c>
        status =  USBH_APPLY_DEINIT;
 8013d8c:	2006      	movs	r0, #6
 8013d8e:	e796      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      status = USBH_ClrFeature(pdev,
 8013d90:	4630      	mov	r0, r6
 8013d92:	796b      	ldrb	r3, [r5, #5]
 8013d94:	4629      	mov	r1, r5
 8013d96:	2200      	movs	r2, #0
 8013d98:	f000 fb70 	bl	801447c <USBH_ClrFeature>
      if(status == USBH_OK )
 8013d9c:	2800      	cmp	r0, #0
 8013d9e:	d18e      	bne.n	8013cbe <USBH_MSC_Handle+0x3e>
        MSC_Machine.maxLun = 0;  
 8013da0:	4a19      	ldr	r2, [pc, #100]	; (8013e08 <USBH_MSC_Handle+0x188>)
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
 8013da2:	7863      	ldrb	r3, [r4, #1]
        MSC_Machine.maxLun = 0;  
 8013da4:	f882 0048 	strb.w	r0, [r2, #72]	; 0x48
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
 8013da8:	7023      	strb	r3, [r4, #0]
 8013daa:	e788      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
 8013dac:	230a      	movs	r3, #10
 8013dae:	7023      	strb	r3, [r4, #0]
  USBH_Status status = USBH_BUSY;
 8013db0:	2001      	movs	r0, #1
 8013db2:	e784      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      if(status == USBH_NOT_SUPPORTED )
 8013db4:	2803      	cmp	r0, #3
 8013db6:	d182      	bne.n	8013cbe <USBH_MSC_Handle+0x3e>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
 8013db8:	2309      	movs	r3, #9
        USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_TEST_UNIT_READY; 
 8013dba:	7060      	strb	r0, [r4, #1]
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
 8013dbc:	7023      	strb	r3, [r4, #0]
 8013dbe:	e77e      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_GET_MAX_LUN;
 8013dc0:	2302      	movs	r3, #2
 8013dc2:	7023      	strb	r3, [r4, #0]
 8013dc4:	e77b      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
 8013dc6:	2308      	movs	r3, #8
 8013dc8:	7023      	strb	r3, [r4, #0]
  USBH_Status status = USBH_BUSY;
 8013dca:	2001      	movs	r0, #1
 8013dcc:	e777      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
        MSCErrorCount = 0;
 8013dce:	4a0f      	ldr	r2, [pc, #60]	; (8013e0c <USBH_MSC_Handle+0x18c>)
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_READ_CAPACITY10;
 8013dd0:	2304      	movs	r3, #4
        MSCErrorCount = 0;
 8013dd2:	7050      	strb	r0, [r2, #1]
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_READ_CAPACITY10;
 8013dd4:	7023      	strb	r3, [r4, #0]
 8013dd6:	e772      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
      MSCErrorCount++;
 8013dd8:	4a0c      	ldr	r2, [pc, #48]	; (8013e0c <USBH_MSC_Handle+0x18c>)
 8013dda:	7853      	ldrb	r3, [r2, #1]
 8013ddc:	3301      	adds	r3, #1
 8013dde:	b2db      	uxtb	r3, r3
      if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
 8013de0:	2b09      	cmp	r3, #9
      MSCErrorCount++;
 8013de2:	7053      	strb	r3, [r2, #1]
      if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
 8013de4:	d8e2      	bhi.n	8013dac <USBH_MSC_Handle+0x12c>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
 8013de6:	2306      	movs	r3, #6
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013de8:	2001      	movs	r0, #1
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
 8013dea:	7023      	strb	r3, [r4, #0]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013dec:	70e0      	strb	r0, [r4, #3]
 8013dee:	e766      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
          pphost->usr_cb->USBH_USR_DeviceNotSupported();
 8013df0:	f8d5 2080 	ldr.w	r2, [r5, #128]	; 0x80
          maxLunExceed = TRUE;
 8013df4:	701f      	strb	r7, [r3, #0]
          pphost->usr_cb->USBH_USR_DeviceNotSupported();
 8013df6:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8013df8:	9001      	str	r0, [sp, #4]
 8013dfa:	4798      	blx	r3
 8013dfc:	9801      	ldr	r0, [sp, #4]
 8013dfe:	e75e      	b.n	8013cbe <USBH_MSC_Handle+0x3e>
 8013e00:	2001088c 	.word	0x2001088c
 8013e04:	200108c4 	.word	0x200108c4
 8013e08:	200108bc 	.word	0x200108bc
 8013e0c:	20008095 	.word	0x20008095

08013e10 <USBH_MSC_ErrorHandle>:
    if(status == USBH_MSC_FAIL)
 8013e10:	2801      	cmp	r0, #1
 8013e12:	d002      	beq.n	8013e1a <USBH_MSC_ErrorHandle+0xa>
    else if(status == USBH_MSC_PHASE_ERROR)
 8013e14:	2802      	cmp	r0, #2
 8013e16:	d007      	beq.n	8013e28 <USBH_MSC_ErrorHandle+0x18>
 8013e18:	4770      	bx	lr
      MSCErrorCount++;
 8013e1a:	4a08      	ldr	r2, [pc, #32]	; (8013e3c <USBH_MSC_ErrorHandle+0x2c>)
 8013e1c:	7853      	ldrb	r3, [r2, #1]
 8013e1e:	3301      	adds	r3, #1
 8013e20:	b2db      	uxtb	r3, r3
      if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
 8013e22:	2b09      	cmp	r3, #9
      MSCErrorCount++;
 8013e24:	7053      	strb	r3, [r2, #1]
      if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
 8013e26:	d903      	bls.n	8013e30 <USBH_MSC_ErrorHandle+0x20>
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
 8013e28:	4b05      	ldr	r3, [pc, #20]	; (8013e40 <USBH_MSC_ErrorHandle+0x30>)
 8013e2a:	220a      	movs	r2, #10
 8013e2c:	701a      	strb	r2, [r3, #0]
 8013e2e:	4770      	bx	lr
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
 8013e30:	4b03      	ldr	r3, [pc, #12]	; (8013e40 <USBH_MSC_ErrorHandle+0x30>)
 8013e32:	2206      	movs	r2, #6
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013e34:	70d8      	strb	r0, [r3, #3]
        USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
 8013e36:	701a      	strb	r2, [r3, #0]
 8013e38:	4770      	bx	lr
 8013e3a:	bf00      	nop
 8013e3c:	20008095 	.word	0x20008095
 8013e40:	2001088c 	.word	0x2001088c

08013e44 <USBH_MSC_TestUnitReady>:



//--------------------------------------------------------------
uint8_t USBH_MSC_TestUnitReady (USB_OTG_CORE_HANDLE *pdev)
{
 8013e44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
  
  if(HCD_IsDeviceConnected(pdev))
 8013e46:	f7fd fe73 	bl	8011b30 <HCD_IsDeviceConnected>
 8013e4a:	b908      	cbnz	r0, 8013e50 <USBH_MSC_TestUnitReady+0xc>
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8013e4c:	2003      	movs	r0, #3
    default:
      break;
    }
  }
  return status;
}
 8013e4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8013e50:	4b14      	ldr	r3, [pc, #80]	; (8013ea4 <USBH_MSC_TestUnitReady+0x60>)
 8013e52:	78da      	ldrb	r2, [r3, #3]
 8013e54:	2a01      	cmp	r2, #1
 8013e56:	d00a      	beq.n	8013e6e <USBH_MSC_TestUnitReady+0x2a>
 8013e58:	2a02      	cmp	r2, #2
 8013e5a:	d1f7      	bne.n	8013e4c <USBH_MSC_TestUnitReady+0x8>
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 8013e5c:	7bd8      	ldrb	r0, [r3, #15]
 8013e5e:	b118      	cbz	r0, 8013e68 <USBH_MSC_TestUnitReady+0x24>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8013e60:	2801      	cmp	r0, #1
 8013e62:	d01c      	beq.n	8013e9e <USBH_MSC_TestUnitReady+0x5a>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8013e64:	2802      	cmp	r0, #2
 8013e66:	d1f1      	bne.n	8013e4c <USBH_MSC_TestUnitReady+0x8>
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013e68:	2201      	movs	r2, #1
 8013e6a:	70da      	strb	r2, [r3, #3]
 8013e6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBH_MSC_CBWData.field.CBWTransferLength = 0;       /* No Data Transfer */
 8013e6e:	490e      	ldr	r1, [pc, #56]	; (8013ea8 <USBH_MSC_TestUnitReady+0x64>)
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8013e70:	711a      	strb	r2, [r3, #4]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH_TEST_UNIT_READY;
 8013e72:	2506      	movs	r5, #6
      USBH_MSC_CBWData.field.CBWTransferLength = 0;       /* No Data Transfer */
 8013e74:	2200      	movs	r2, #0
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_TEST_UNIT_READY;
 8013e76:	2003      	movs	r0, #3
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH_TEST_UNIT_READY;
 8013e78:	738d      	strb	r5, [r1, #14]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8013e7a:	2402      	movs	r4, #2
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8013e7c:	2507      	movs	r5, #7
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
 8013e7e:	4f0b      	ldr	r7, [pc, #44]	; (8013eac <USBH_MSC_TestUnitReady+0x68>)
 8013e80:	614a      	str	r2, [r1, #20]
      USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
 8013e82:	263f      	movs	r6, #63	; 0x3f
 8013e84:	618a      	str	r2, [r1, #24]
 8013e86:	61ca      	str	r2, [r1, #28]
      USBH_MSC_CBWData.field.CBWTransferLength = 0;       /* No Data Transfer */
 8013e88:	608a      	str	r2, [r1, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
 8013e8a:	730a      	strb	r2, [r1, #12]
 8013e8c:	610a      	str	r2, [r1, #16]
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_TEST_UNIT_READY; 
 8013e8e:	73ca      	strb	r2, [r1, #15]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_TEST_UNIT_READY;
 8013e90:	7098      	strb	r0, [r3, #2]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8013e92:	73d8      	strb	r0, [r3, #15]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8013e94:	701d      	strb	r5, [r3, #0]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8013e96:	70dc      	strb	r4, [r3, #3]
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
 8013e98:	609f      	str	r7, [r3, #8]
      USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
 8013e9a:	819e      	strh	r6, [r3, #12]
      break;
 8013e9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013e9e:	70d8      	strb	r0, [r3, #3]
 8013ea0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013ea2:	bf00      	nop
 8013ea4:	2001088c 	.word	0x2001088c
 8013ea8:	2001089c 	.word	0x2001089c
 8013eac:	2001087c 	.word	0x2001087c

08013eb0 <USBH_MSC_ReadCapacity10>:


//--------------------------------------------------------------
uint8_t USBH_MSC_ReadCapacity10(USB_OTG_CORE_HANDLE *pdev)
{
 8013eb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
  
  if(HCD_IsDeviceConnected(pdev))
 8013eb2:	f7fd fe3d 	bl	8011b30 <HCD_IsDeviceConnected>
 8013eb6:	b908      	cbnz	r0, 8013ebc <USBH_MSC_ReadCapacity10+0xc>
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8013eb8:	2003      	movs	r0, #3
    default:
      break;
    }
  }
  return status;
}
 8013eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8013ebc:	4b1f      	ldr	r3, [pc, #124]	; (8013f3c <USBH_MSC_ReadCapacity10+0x8c>)
 8013ebe:	78da      	ldrb	r2, [r3, #3]
 8013ec0:	2a01      	cmp	r2, #1
 8013ec2:	d00a      	beq.n	8013eda <USBH_MSC_ReadCapacity10+0x2a>
 8013ec4:	2a02      	cmp	r2, #2
 8013ec6:	d1f7      	bne.n	8013eb8 <USBH_MSC_ReadCapacity10+0x8>
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 8013ec8:	7bd8      	ldrb	r0, [r3, #15]
 8013eca:	b310      	cbz	r0, 8013f12 <USBH_MSC_ReadCapacity10+0x62>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8013ecc:	2801      	cmp	r0, #1
 8013ece:	d033      	beq.n	8013f38 <USBH_MSC_ReadCapacity10+0x88>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8013ed0:	2802      	cmp	r0, #2
 8013ed2:	d1f1      	bne.n	8013eb8 <USBH_MSC_ReadCapacity10+0x8>
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013ed4:	2201      	movs	r2, #1
 8013ed6:	70da      	strb	r2, [r3, #3]
 8013ed8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_READ_CAPACITY10;
 8013eda:	4919      	ldr	r1, [pc, #100]	; (8013f40 <USBH_MSC_ReadCapacity10+0x90>)
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8013edc:	711a      	strb	r2, [r3, #4]
      USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_READ_CAPACITY10;
 8013ede:	2208      	movs	r2, #8
 8013ee0:	f101 0410 	add.w	r4, r1, #16
 8013ee4:	608a      	str	r2, [r1, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8013ee6:	2680      	movs	r6, #128	; 0x80
 8013ee8:	2200      	movs	r2, #0
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8013eea:	250a      	movs	r5, #10
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_READ_CAPACITY10; 
 8013eec:	2025      	movs	r0, #37	; 0x25
 8013eee:	73c8      	strb	r0, [r1, #15]
 8013ef0:	610a      	str	r2, [r1, #16]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8013ef2:	730e      	strb	r6, [r1, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8013ef4:	738d      	strb	r5, [r1, #14]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_READ_CAPACITY10;
 8013ef6:	2604      	movs	r6, #4
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8013ef8:	2507      	movs	r5, #7
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8013efa:	2003      	movs	r0, #3
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8013efc:	2102      	movs	r1, #2
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8013efe:	4f11      	ldr	r7, [pc, #68]	; (8013f44 <USBH_MSC_ReadCapacity10+0x94>)
 8013f00:	6062      	str	r2, [r4, #4]
 8013f02:	60a2      	str	r2, [r4, #8]
 8013f04:	60e2      	str	r2, [r4, #12]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_READ_CAPACITY10;
 8013f06:	709e      	strb	r6, [r3, #2]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8013f08:	701d      	strb	r5, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8013f0a:	73d8      	strb	r0, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8013f0c:	70d9      	strb	r1, [r3, #3]
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8013f0e:	609f      	str	r7, [r3, #8]
      break;
 8013f10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[3]) = USBH_DataInBuffer[0];
 8013f12:	490c      	ldr	r1, [pc, #48]	; (8013f44 <USBH_MSC_ReadCapacity10+0x94>)
 8013f14:	4a0c      	ldr	r2, [pc, #48]	; (8013f48 <USBH_MSC_ReadCapacity10+0x98>)
 8013f16:	780c      	ldrb	r4, [r1, #0]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[2]) = USBH_DataInBuffer[1];
 8013f18:	f891 e001 	ldrb.w	lr, [r1, #1]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[1]) = USBH_DataInBuffer[2];
 8013f1c:	788f      	ldrb	r7, [r1, #2]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[0]) = USBH_DataInBuffer[3];
 8013f1e:	78ce      	ldrb	r6, [r1, #3]
        (((uint8_t*)&USBH_MSC_Param.MSPageLength )[1]) = USBH_DataInBuffer[6];
 8013f20:	798d      	ldrb	r5, [r1, #6]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[3]) = USBH_DataInBuffer[0];
 8013f22:	70d4      	strb	r4, [r2, #3]
        (((uint8_t*)&USBH_MSC_Param.MSPageLength )[0]) = USBH_DataInBuffer[7];
 8013f24:	79cc      	ldrb	r4, [r1, #7]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[2]) = USBH_DataInBuffer[1];
 8013f26:	f882 e002 	strb.w	lr, [r2, #2]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013f2a:	2101      	movs	r1, #1
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[1]) = USBH_DataInBuffer[2];
 8013f2c:	7057      	strb	r7, [r2, #1]
        (((uint8_t*)&USBH_MSC_Param.MSCapacity )[0]) = USBH_DataInBuffer[3];
 8013f2e:	7016      	strb	r6, [r2, #0]
        (((uint8_t*)&USBH_MSC_Param.MSPageLength )[1]) = USBH_DataInBuffer[6];
 8013f30:	7255      	strb	r5, [r2, #9]
        (((uint8_t*)&USBH_MSC_Param.MSPageLength )[0]) = USBH_DataInBuffer[7];
 8013f32:	7214      	strb	r4, [r2, #8]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013f34:	70d9      	strb	r1, [r3, #3]
 8013f36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013f38:	70d8      	strb	r0, [r3, #3]
 8013f3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013f3c:	2001088c 	.word	0x2001088c
 8013f40:	2001089c 	.word	0x2001089c
 8013f44:	20010910 	.word	0x20010910
 8013f48:	20010b10 	.word	0x20010b10

08013f4c <USBH_MSC_ModeSense6>:


//--------------------------------------------------------------
uint8_t USBH_MSC_ModeSense6(USB_OTG_CORE_HANDLE *pdev)
{
 8013f4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
  
  if(HCD_IsDeviceConnected(pdev))
 8013f4e:	f7fd fdef 	bl	8011b30 <HCD_IsDeviceConnected>
 8013f52:	b908      	cbnz	r0, 8013f58 <USBH_MSC_ModeSense6+0xc>
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8013f54:	2003      	movs	r0, #3
    default:
      break;
    }
  }
  return status;
}
 8013f56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8013f58:	4b1a      	ldr	r3, [pc, #104]	; (8013fc4 <USBH_MSC_ModeSense6+0x78>)
 8013f5a:	78da      	ldrb	r2, [r3, #3]
 8013f5c:	2a01      	cmp	r2, #1
 8013f5e:	d00b      	beq.n	8013f78 <USBH_MSC_ModeSense6+0x2c>
 8013f60:	2a02      	cmp	r2, #2
 8013f62:	d1f7      	bne.n	8013f54 <USBH_MSC_ModeSense6+0x8>
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 8013f64:	7bd8      	ldrb	r0, [r3, #15]
 8013f66:	bb18      	cbnz	r0, 8013fb0 <USBH_MSC_ModeSense6+0x64>
        if ( USBH_DataInBuffer[2] & MASK_MODE_SENSE_WRITE_PROTECT)
 8013f68:	4a17      	ldr	r2, [pc, #92]	; (8013fc8 <USBH_MSC_ModeSense6+0x7c>)
 8013f6a:	4c18      	ldr	r4, [pc, #96]	; (8013fcc <USBH_MSC_ModeSense6+0x80>)
 8013f6c:	7892      	ldrb	r2, [r2, #2]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013f6e:	2101      	movs	r1, #1
        if ( USBH_DataInBuffer[2] & MASK_MODE_SENSE_WRITE_PROTECT)
 8013f70:	09d2      	lsrs	r2, r2, #7
 8013f72:	7322      	strb	r2, [r4, #12]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013f74:	70d9      	strb	r1, [r3, #3]
 8013f76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_MODE_SENSE6;
 8013f78:	4915      	ldr	r1, [pc, #84]	; (8013fd0 <USBH_MSC_ModeSense6+0x84>)
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8013f7a:	711a      	strb	r2, [r3, #4]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8013f7c:	2480      	movs	r4, #128	; 0x80
 8013f7e:	2200      	movs	r2, #0
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8013f80:	260a      	movs	r6, #10
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_MODE_SENSE6; 
 8013f82:	251a      	movs	r5, #26
 8013f84:	610a      	str	r2, [r1, #16]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8013f86:	730c      	strb	r4, [r1, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8013f88:	738e      	strb	r6, [r1, #14]
      USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_MODE_SENSE6;
 8013f8a:	243f      	movs	r4, #63	; 0x3f
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_MODE_SENSE6;
 8013f8c:	2605      	movs	r6, #5
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_MODE_SENSE6; 
 8013f8e:	73cd      	strb	r5, [r1, #15]
 8013f90:	614a      	str	r2, [r1, #20]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8013f92:	2507      	movs	r5, #7
 8013f94:	618a      	str	r2, [r1, #24]
 8013f96:	61ca      	str	r2, [r1, #28]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8013f98:	2003      	movs	r0, #3
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8013f9a:	2202      	movs	r2, #2
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8013f9c:	4f0a      	ldr	r7, [pc, #40]	; (8013fc8 <USBH_MSC_ModeSense6+0x7c>)
      USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_MODE_SENSE6;
 8013f9e:	608c      	str	r4, [r1, #8]
      USBH_MSC_CBWData.field.CBWCB[2]  = MODE_SENSE_PAGE_CONTROL_FIELD | \
 8013fa0:	744c      	strb	r4, [r1, #17]
      USBH_MSC_CBWData.field.CBWCB[4]  = XFER_LEN_MODE_SENSE6;
 8013fa2:	74cc      	strb	r4, [r1, #19]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_MODE_SENSE6;
 8013fa4:	709e      	strb	r6, [r3, #2]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8013fa6:	701d      	strb	r5, [r3, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8013fa8:	73d8      	strb	r0, [r3, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8013faa:	70da      	strb	r2, [r3, #3]
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8013fac:	609f      	str	r7, [r3, #8]
      break;
 8013fae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8013fb0:	2801      	cmp	r0, #1
 8013fb2:	d004      	beq.n	8013fbe <USBH_MSC_ModeSense6+0x72>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8013fb4:	2802      	cmp	r0, #2
 8013fb6:	d1cd      	bne.n	8013f54 <USBH_MSC_ModeSense6+0x8>
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013fb8:	2201      	movs	r2, #1
 8013fba:	70da      	strb	r2, [r3, #3]
 8013fbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013fbe:	70d8      	strb	r0, [r3, #3]
 8013fc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013fc2:	bf00      	nop
 8013fc4:	2001088c 	.word	0x2001088c
 8013fc8:	20010910 	.word	0x20010910
 8013fcc:	20010b10 	.word	0x20010b10
 8013fd0:	2001089c 	.word	0x2001089c

08013fd4 <USBH_MSC_RequestSense>:

//--------------------------------------------------------------
uint8_t USBH_MSC_RequestSense(USB_OTG_CORE_HANDLE *pdev)
{
 8013fd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
  
  uint8_t index;
  
  
  if(HCD_IsDeviceConnected(pdev))
 8013fd6:	f7fd fdab 	bl	8011b30 <HCD_IsDeviceConnected>
 8013fda:	b908      	cbnz	r0, 8013fe0 <USBH_MSC_RequestSense+0xc>
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 8013fdc:	2003      	movs	r0, #3
    default:
      break;
    }
  }
  return status;
}
 8013fde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8013fe0:	4b1e      	ldr	r3, [pc, #120]	; (801405c <USBH_MSC_RequestSense+0x88>)
 8013fe2:	78da      	ldrb	r2, [r3, #3]
 8013fe4:	2a01      	cmp	r2, #1
 8013fe6:	d00a      	beq.n	8013ffe <USBH_MSC_RequestSense+0x2a>
 8013fe8:	2a02      	cmp	r2, #2
 8013fea:	d1f7      	bne.n	8013fdc <USBH_MSC_RequestSense+0x8>
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 8013fec:	7bd8      	ldrb	r0, [r3, #15]
 8013fee:	b328      	cbz	r0, 801403c <USBH_MSC_RequestSense+0x68>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8013ff0:	2801      	cmp	r0, #1
 8013ff2:	d030      	beq.n	8014056 <USBH_MSC_RequestSense+0x82>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8013ff4:	2802      	cmp	r0, #2
 8013ff6:	d1f1      	bne.n	8013fdc <USBH_MSC_RequestSense+0x8>
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8013ff8:	2201      	movs	r2, #1
 8013ffa:	70da      	strb	r2, [r3, #3]
 8013ffc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBH_MSC_CBWData.field.CBWTransferLength = \
 8013ffe:	4918      	ldr	r1, [pc, #96]	; (8014060 <USBH_MSC_RequestSense+0x8c>)
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 8014000:	711a      	strb	r2, [r3, #4]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8014002:	2580      	movs	r5, #128	; 0x80
 8014004:	2200      	movs	r2, #0
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8014006:	200a      	movs	r0, #10
 8014008:	610a      	str	r2, [r1, #16]
      USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_BOTXferParam.MSCStateCurrent;
 801400a:	789f      	ldrb	r7, [r3, #2]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 801400c:	730d      	strb	r5, [r1, #12]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 801400e:	7388      	strb	r0, [r1, #14]
      USBH_MSC_CBWData.field.CBWTransferLength = \
 8014010:	253f      	movs	r5, #63	; 0x3f
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_REQUEST_SENSE; 
 8014012:	2003      	movs	r0, #3
 8014014:	614a      	str	r2, [r1, #20]
 8014016:	618a      	str	r2, [r1, #24]
 8014018:	61ca      	str	r2, [r1, #28]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_REQUEST_SENSE;
 801401a:	2606      	movs	r6, #6
      USBH_MSC_CBWData.field.CBWCB[1]  = DESC_REQUEST_SENSE;
 801401c:	740a      	strb	r2, [r1, #16]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 801401e:	2407      	movs	r4, #7
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8014020:	2202      	movs	r2, #2
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8014022:	f8df e040 	ldr.w	lr, [pc, #64]	; 8014064 <USBH_MSC_RequestSense+0x90>
      USBH_MSC_CBWData.field.CBWTransferLength = \
 8014026:	608d      	str	r5, [r1, #8]
      USBH_MSC_CBWData.field.CBWCB[4]  = ALLOCATION_LENGTH_REQUEST_SENSE;
 8014028:	74cd      	strb	r5, [r1, #19]
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_REQUEST_SENSE; 
 801402a:	73c8      	strb	r0, [r1, #15]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 801402c:	73d8      	strb	r0, [r3, #15]
      USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_BOTXferParam.MSCStateCurrent;
 801402e:	705f      	strb	r7, [r3, #1]
      USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_REQUEST_SENSE;
 8014030:	709e      	strb	r6, [r3, #2]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8014032:	701c      	strb	r4, [r3, #0]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8014034:	70da      	strb	r2, [r3, #3]
      USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
 8014036:	f8c3 e008 	str.w	lr, [r3, #8]
      break;
 801403a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[3]) = USBH_DataInBuffer[0];
 801403c:	4909      	ldr	r1, [pc, #36]	; (8014064 <USBH_MSC_RequestSense+0x90>)
 801403e:	4a0a      	ldr	r2, [pc, #40]	; (8014068 <USBH_MSC_RequestSense+0x94>)
 8014040:	780f      	ldrb	r7, [r1, #0]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[2]) = USBH_DataInBuffer[1];
 8014042:	784e      	ldrb	r6, [r1, #1]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[1]) = USBH_DataInBuffer[2];
 8014044:	788d      	ldrb	r5, [r1, #2]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[0]) = USBH_DataInBuffer[3];
 8014046:	78cc      	ldrb	r4, [r1, #3]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[3]) = USBH_DataInBuffer[0];
 8014048:	71d7      	strb	r7, [r2, #7]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 801404a:	2101      	movs	r1, #1
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[2]) = USBH_DataInBuffer[1];
 801404c:	7196      	strb	r6, [r2, #6]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[1]) = USBH_DataInBuffer[2];
 801404e:	7155      	strb	r5, [r2, #5]
        (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[0]) = USBH_DataInBuffer[3];
 8014050:	7114      	strb	r4, [r2, #4]
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8014052:	70d9      	strb	r1, [r3, #3]
 8014054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8014056:	70d8      	strb	r0, [r3, #3]
 8014058:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801405a:	bf00      	nop
 801405c:	2001088c 	.word	0x2001088c
 8014060:	2001089c 	.word	0x2001089c
 8014064:	20010910 	.word	0x20010910
 8014068:	20010b10 	.word	0x20010b10

0801406c <USBH_MSC_Write10>:
//--------------------------------------------------------------
uint8_t USBH_MSC_Write10(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dataBuffer,
                         uint32_t address,
                         uint32_t nbOfbytes)
{
 801406c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801406e:	b085      	sub	sp, #20
 8014070:	460d      	mov	r5, r1
 8014072:	9201      	str	r2, [sp, #4]
 8014074:	461c      	mov	r4, r3
  uint8_t index;
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
  uint16_t nbOfPages;
  
  if(HCD_IsDeviceConnected(pdev))
 8014076:	f7fd fd5b 	bl	8011b30 <HCD_IsDeviceConnected>
 801407a:	b910      	cbnz	r0, 8014082 <USBH_MSC_Write10+0x16>
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 801407c:	2003      	movs	r0, #3
    default:
      break;
    }
  }
  return status;
}
 801407e:	b005      	add	sp, #20
 8014080:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 8014082:	4a1d      	ldr	r2, [pc, #116]	; (80140f8 <USBH_MSC_Write10+0x8c>)
 8014084:	78d1      	ldrb	r1, [r2, #3]
 8014086:	2901      	cmp	r1, #1
 8014088:	d00a      	beq.n	80140a0 <USBH_MSC_Write10+0x34>
 801408a:	2902      	cmp	r1, #2
 801408c:	d1f6      	bne.n	801407c <USBH_MSC_Write10+0x10>
      if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
 801408e:	7bd0      	ldrb	r0, [r2, #15]
 8014090:	b118      	cbz	r0, 801409a <USBH_MSC_Write10+0x2e>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
 8014092:	2801      	cmp	r0, #1
 8014094:	d02c      	beq.n	80140f0 <USBH_MSC_Write10+0x84>
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8014096:	2802      	cmp	r0, #2
 8014098:	d1f0      	bne.n	801407c <USBH_MSC_Write10+0x10>
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 801409a:	2301      	movs	r3, #1
 801409c:	70d3      	strb	r3, [r2, #3]
 801409e:	e7ee      	b.n	801407e <USBH_MSC_Write10+0x12>
      USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
 80140a0:	4b16      	ldr	r3, [pc, #88]	; (80140fc <USBH_MSC_Write10+0x90>)
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 80140a2:	7111      	strb	r1, [r2, #4]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 80140a4:	210a      	movs	r1, #10
 80140a6:	7399      	strb	r1, [r3, #14]
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_WRITE10; 
 80140a8:	212a      	movs	r1, #42	; 0x2a
      USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
 80140aa:	f89d 6006 	ldrb.w	r6, [sp, #6]
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_WRITE10; 
 80140ae:	73d9      	strb	r1, [r3, #15]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
 80140b0:	2100      	movs	r1, #0
 80140b2:	6119      	str	r1, [r3, #16]
      USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]) ;
 80140b4:	f89d 7007 	ldrb.w	r7, [sp, #7]
      USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
 80140b8:	f89d e005 	ldrb.w	lr, [sp, #5]
      USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
 80140bc:	6095      	str	r5, [r2, #8]
      USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
 80140be:	749e      	strb	r6, [r3, #18]
      nbOfPages = nbOfbytes/ USBH_MSC_PAGE_LENGTH; 
 80140c0:	0a65      	lsrs	r5, r4, #9
      USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
 80140c2:	f89d 6004 	ldrb.w	r6, [sp, #4]
 80140c6:	6159      	str	r1, [r3, #20]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 80140c8:	2003      	movs	r0, #3
      USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
 80140ca:	609c      	str	r4, [r3, #8]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
 80140cc:	7319      	strb	r1, [r3, #12]
      USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]) ;
 80140ce:	745f      	strb	r7, [r3, #17]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 80140d0:	2407      	movs	r4, #7
      USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
 80140d2:	f3c5 2707 	ubfx	r7, r5, #8, #8
 80140d6:	6199      	str	r1, [r3, #24]
 80140d8:	61d9      	str	r1, [r3, #28]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 80140da:	2102      	movs	r1, #2
      USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
 80140dc:	f883 e013 	strb.w	lr, [r3, #19]
      USBH_MSC_CBWData.field.CBWCB[8]  = (((uint8_t *)&nbOfPages)[0]) ; 
 80140e0:	75dd      	strb	r5, [r3, #23]
      USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
 80140e2:	759f      	strb	r7, [r3, #22]
      USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
 80140e4:	751e      	strb	r6, [r3, #20]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 80140e6:	7014      	strb	r4, [r2, #0]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 80140e8:	73d0      	strb	r0, [r2, #15]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 80140ea:	70d1      	strb	r1, [r2, #3]
}
 80140ec:	b005      	add	sp, #20
 80140ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 80140f0:	70d0      	strb	r0, [r2, #3]
  USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
 80140f2:	2003      	movs	r0, #3
 80140f4:	e7c3      	b.n	801407e <USBH_MSC_Write10+0x12>
 80140f6:	bf00      	nop
 80140f8:	2001088c 	.word	0x2001088c
 80140fc:	2001089c 	.word	0x2001089c

08014100 <USBH_MSC_Read10>:
//--------------------------------------------------------------
uint8_t USBH_MSC_Read10(USB_OTG_CORE_HANDLE *pdev,
                        uint8_t *dataBuffer,
                        uint32_t address,
                        uint32_t nbOfbytes)
{
 8014100:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t index;
  static USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
  uint16_t nbOfPages;
  status = USBH_MSC_BUSY;
 8014104:	4e2e      	ldr	r6, [pc, #184]	; (80141c0 <USBH_MSC_Read10+0xc0>)
{
 8014106:	b085      	sub	sp, #20
  status = USBH_MSC_BUSY;
 8014108:	2403      	movs	r4, #3
{
 801410a:	9201      	str	r2, [sp, #4]
 801410c:	4689      	mov	r9, r1
 801410e:	4698      	mov	r8, r3
  status = USBH_MSC_BUSY;
 8014110:	7034      	strb	r4, [r6, #0]
{
 8014112:	4605      	mov	r5, r0
  
  if(HCD_IsDeviceConnected(pdev))
 8014114:	f7fd fd0c 	bl	8011b30 <HCD_IsDeviceConnected>
 8014118:	b190      	cbz	r0, 8014140 <USBH_MSC_Read10+0x40>
  {
    switch(USBH_MSC_BOTXferParam.CmdStateMachine)
 801411a:	4f2a      	ldr	r7, [pc, #168]	; (80141c4 <USBH_MSC_Read10+0xc4>)
 801411c:	78fb      	ldrb	r3, [r7, #3]
 801411e:	2b01      	cmp	r3, #1
 8014120:	d012      	beq.n	8014148 <USBH_MSC_Read10+0x48>
 8014122:	2b02      	cmp	r3, #2
 8014124:	d10c      	bne.n	8014140 <USBH_MSC_Read10+0x40>
      
      break;
      
    case CMD_WAIT_STATUS:
      
      if((USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK) && \
 8014126:	7bfc      	ldrb	r4, [r7, #15]
 8014128:	2c00      	cmp	r4, #0
 801412a:	d03b      	beq.n	80141a4 <USBH_MSC_Read10+0xa4>
      { 
        /* Commands successfully sent and Response Received  */       
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
        status = USBH_MSC_OK;      
      }
      else if (( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL ) && \
 801412c:	2c01      	cmp	r4, #1
 801412e:	d040      	beq.n	80141b2 <USBH_MSC_Read10+0xb2>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
      }
      
      else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
 8014130:	2c02      	cmp	r4, #2
 8014132:	d105      	bne.n	8014140 <USBH_MSC_Read10+0x40>
      {
        /* Failure Mode */
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 8014134:	2301      	movs	r3, #1
        status = USBH_MSC_PHASE_ERROR;    
 8014136:	7034      	strb	r4, [r6, #0]
 8014138:	4620      	mov	r0, r4
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 801413a:	70fb      	strb	r3, [r7, #3]
 801413c:	e001      	b.n	8014142 <USBH_MSC_Read10+0x42>
        USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
 801413e:	70fc      	strb	r4, [r7, #3]
 8014140:	7830      	ldrb	r0, [r6, #0]
    default:
      break;
    }
  }
  return status;
}
 8014142:	b005      	add	sp, #20
 8014144:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
 8014148:	4a1f      	ldr	r2, [pc, #124]	; (80141c8 <USBH_MSC_Read10+0xc8>)
      status = USBH_MSC_BUSY;
 801414a:	7034      	strb	r4, [r6, #0]
      break;
 801414c:	4620      	mov	r0, r4
      USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
 801414e:	713b      	strb	r3, [r7, #4]
      USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
 8014150:	73fc      	strb	r4, [r7, #15]
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8014152:	230a      	movs	r3, #10
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_READ10; 
 8014154:	2428      	movs	r4, #40	; 0x28
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 8014156:	2680      	movs	r6, #128	; 0x80
      USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
 8014158:	7393      	strb	r3, [r2, #14]
      USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_READ10; 
 801415a:	73d4      	strb	r4, [r2, #15]
 801415c:	2300      	movs	r3, #0
      USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
 801415e:	f89d 4005 	ldrb.w	r4, [sp, #5]
 8014162:	6113      	str	r3, [r2, #16]
      nbOfPages = nbOfbytes/ USBH_MSC_PAGE_LENGTH;  
 8014164:	ea4f 2558 	mov.w	r5, r8, lsr #9
      USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]);
 8014168:	f89d e007 	ldrb.w	lr, [sp, #7]
      USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
 801416c:	7316      	strb	r6, [r2, #12]
      USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
 801416e:	74d4      	strb	r4, [r2, #19]
      USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
 8014170:	f89d 6006 	ldrb.w	r6, [sp, #6]
      USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
 8014174:	f89d 4004 	ldrb.w	r4, [sp, #4]
 8014178:	6153      	str	r3, [r2, #20]
      USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
 801417a:	7496      	strb	r6, [r2, #18]
 801417c:	6193      	str	r3, [r2, #24]
      USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
 801417e:	f3c5 2607 	ubfx	r6, r5, #8, #8
 8014182:	61d3      	str	r3, [r2, #28]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 8014184:	2107      	movs	r1, #7
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 8014186:	2302      	movs	r3, #2
      USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
 8014188:	f8c7 9008 	str.w	r9, [r7, #8]
      USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
 801418c:	f8c2 8008 	str.w	r8, [r2, #8]
      USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]);
 8014190:	f882 e011 	strb.w	lr, [r2, #17]
      USBH_MSC_CBWData.field.CBWCB[8]  = (((uint8_t *)&nbOfPages)[0]) ; 
 8014194:	75d5      	strb	r5, [r2, #23]
      USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
 8014196:	7596      	strb	r6, [r2, #22]
      USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
 8014198:	7514      	strb	r4, [r2, #20]
      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
 801419a:	7039      	strb	r1, [r7, #0]
      USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
 801419c:	70fb      	strb	r3, [r7, #3]
}
 801419e:	b005      	add	sp, #20
 80141a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        (HCD_IsDeviceConnected(pdev)))
 80141a4:	4628      	mov	r0, r5
 80141a6:	f7fd fcc3 	bl	8011b30 <HCD_IsDeviceConnected>
      if((USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK) && \
 80141aa:	2800      	cmp	r0, #0
 80141ac:	d1c2      	bne.n	8014134 <USBH_MSC_Read10+0x34>
 80141ae:	7bfc      	ldrb	r4, [r7, #15]
 80141b0:	e7bc      	b.n	801412c <USBH_MSC_Read10+0x2c>
        (HCD_IsDeviceConnected(pdev)))
 80141b2:	4628      	mov	r0, r5
 80141b4:	f7fd fcbc 	bl	8011b30 <HCD_IsDeviceConnected>
      else if (( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL ) && \
 80141b8:	2800      	cmp	r0, #0
 80141ba:	d1c0      	bne.n	801413e <USBH_MSC_Read10+0x3e>
 80141bc:	7bfc      	ldrb	r4, [r7, #15]
 80141be:	e7b7      	b.n	8014130 <USBH_MSC_Read10+0x30>
 80141c0:	200000d8 	.word	0x200000d8
 80141c4:	2001088c 	.word	0x2001088c
 80141c8:	2001089c 	.word	0x2001089c

080141cc <USBH_Get_DevDesc>:

//--------------------------------------------------------------
USBH_Status USBH_Get_DevDesc(USB_OTG_CORE_HANDLE *pdev,
                             USBH_HOST *phost,
                             uint8_t length)
{
 80141cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  USBH_Status status;
  
  if((status = USBH_GetDescriptor(pdev, 
 80141ce:	4616      	mov	r6, r2
                               uint8_t  req_type,
                               uint16_t value_idx, 
                               uint8_t* buff, 
                               uint16_t length )
{ 
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 80141d0:	2580      	movs	r5, #128	; 0x80
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
  phost->Control.setup.b.wValue.w = value_idx;
 80141d2:	f44f 7280 	mov.w	r2, #256	; 0x100
  {
    phost->Control.setup.b.wIndex.w = 0x0409;
  }
  else
  {
    phost->Control.setup.b.wIndex.w = 0;
 80141d6:	2300      	movs	r3, #0
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 80141d8:	2706      	movs	r7, #6
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 80141da:	750d      	strb	r5, [r1, #20]
  phost->Control.setup.b.wValue.w = value_idx;
 80141dc:	82ca      	strh	r2, [r1, #22]
    phost->Control.setup.b.wIndex.w = 0;
 80141de:	830b      	strh	r3, [r1, #24]
  }
  phost->Control.setup.b.wLength.w = length;           
 80141e0:	834e      	strh	r6, [r1, #26]
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 80141e2:	754f      	strb	r7, [r1, #21]
  return USBH_CtlReq(pdev, phost, buff , length );     
 80141e4:	4633      	mov	r3, r6
 80141e6:	f500 7288 	add.w	r2, r0, #272	; 0x110
{
 80141ea:	460c      	mov	r4, r1
 80141ec:	4605      	mov	r5, r0
  return USBH_CtlReq(pdev, phost, buff , length );     
 80141ee:	f7ff fa1f 	bl	8013630 <USBH_CtlReq>
  if((status = USBH_GetDescriptor(pdev, 
 80141f2:	b100      	cbz	r0, 80141f6 <USBH_Get_DevDesc+0x2a>
}
 80141f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
//--------------------------------------------------------------
static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
                                uint8_t *buf, 
                                uint16_t length)
{
  dev_desc->bLength            = *(uint8_t  *) (buf +  0);
 80141f6:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
 80141fa:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
 80141fe:	f895 3111 	ldrb.w	r3, [r5, #273]	; 0x111
 8014202:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
  dev_desc->bcdUSB             = LE16 (buf +  2);
 8014206:	f895 2113 	ldrb.w	r2, [r5, #275]	; 0x113
 801420a:	f895 3112 	ldrb.w	r3, [r5, #274]	; 0x112
 801420e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8014212:	84a3      	strh	r3, [r4, #36]	; 0x24
  dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
 8014214:	f895 3114 	ldrb.w	r3, [r5, #276]	; 0x114
 8014218:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
  dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
 801421c:	f895 3115 	ldrb.w	r3, [r5, #277]	; 0x115
 8014220:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
  dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
 8014224:	f895 3116 	ldrb.w	r3, [r5, #278]	; 0x116
 8014228:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
 801422c:	f895 3117 	ldrb.w	r3, [r5, #279]	; 0x117
 8014230:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
  
  if (length > 8)
 8014234:	2e08      	cmp	r6, #8
 8014236:	d9dd      	bls.n	80141f4 <USBH_Get_DevDesc+0x28>
  { /* For 1st time after device connection, Host may issue only 8 bytes for 
    Device Descriptor Length  */
    dev_desc->idVendor           = LE16 (buf +  8);
 8014238:	f895 2119 	ldrb.w	r2, [r5, #281]	; 0x119
 801423c:	f895 3118 	ldrb.w	r3, [r5, #280]	; 0x118
 8014240:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8014244:	8563      	strh	r3, [r4, #42]	; 0x2a
    dev_desc->idProduct          = LE16 (buf + 10);
 8014246:	f895 211b 	ldrb.w	r2, [r5, #283]	; 0x11b
 801424a:	f895 311a 	ldrb.w	r3, [r5, #282]	; 0x11a
 801424e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8014252:	85a3      	strh	r3, [r4, #44]	; 0x2c
    dev_desc->bcdDevice          = LE16 (buf + 12);
 8014254:	f895 211d 	ldrb.w	r2, [r5, #285]	; 0x11d
 8014258:	f895 311c 	ldrb.w	r3, [r5, #284]	; 0x11c
 801425c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8014260:	85e3      	strh	r3, [r4, #46]	; 0x2e
    dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
 8014262:	f895 311e 	ldrb.w	r3, [r5, #286]	; 0x11e
 8014266:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
 801426a:	f895 311f 	ldrb.w	r3, [r5, #287]	; 0x11f
 801426e:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
    dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
 8014272:	f895 3120 	ldrb.w	r3, [r5, #288]	; 0x120
 8014276:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
    dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
 801427a:	f895 3121 	ldrb.w	r3, [r5, #289]	; 0x121
 801427e:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
}
 8014282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08014284 <USBH_Get_CfgDesc>:
{
 8014284:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 8014288:	2306      	movs	r3, #6
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 801428a:	2680      	movs	r6, #128	; 0x80
{
 801428c:	4617      	mov	r7, r2
                                  pdev->host.Rx_Buffer,
 801428e:	f500 7888 	add.w	r8, r0, #272	; 0x110
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8014292:	750e      	strb	r6, [r1, #20]
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 8014294:	754b      	strb	r3, [r1, #21]
  phost->Control.setup.b.wValue.w = value_idx;
 8014296:	f44f 7600 	mov.w	r6, #512	; 0x200
    phost->Control.setup.b.wIndex.w = 0;
 801429a:	2300      	movs	r3, #0
 801429c:	830b      	strh	r3, [r1, #24]
  return USBH_CtlReq(pdev, phost, buff , length );     
 801429e:	4642      	mov	r2, r8
  phost->Control.setup.b.wLength.w = length;           
 80142a0:	834f      	strh	r7, [r1, #26]
  phost->Control.setup.b.wValue.w = value_idx;
 80142a2:	82ce      	strh	r6, [r1, #22]
  return USBH_CtlReq(pdev, phost, buff , length );     
 80142a4:	463b      	mov	r3, r7
{
 80142a6:	4605      	mov	r5, r0
 80142a8:	460c      	mov	r4, r1
  return USBH_CtlReq(pdev, phost, buff , length );     
 80142aa:	f7ff f9c1 	bl	8013630 <USBH_CtlReq>
  if((status = USBH_GetDescriptor(pdev,
 80142ae:	b108      	cbz	r0, 80142b4 <USBH_Get_CfgDesc+0x30>
}
 80142b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  int8_t                        ep_ix;  
  
  pdesc   = (USBH_DescHeader_t *)buf;
  
  /* Parse configuration descriptor */
  cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
 80142b4:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
 80142b8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
 80142bc:	f895 3111 	ldrb.w	r3, [r5, #273]	; 0x111
 80142c0:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  cfg_desc->wTotalLength        = LE16 (buf + 2);
 80142c4:	f895 2113 	ldrb.w	r2, [r5, #275]	; 0x113
 80142c8:	f895 3112 	ldrb.w	r3, [r5, #274]	; 0x112
 80142cc:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80142d0:	86e3      	strh	r3, [r4, #54]	; 0x36
  cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
 80142d2:	f895 6114 	ldrb.w	r6, [r5, #276]	; 0x114
 80142d6:	f884 6038 	strb.w	r6, [r4, #56]	; 0x38
  cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
 80142da:	f895 3115 	ldrb.w	r3, [r5, #277]	; 0x115
 80142de:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
 80142e2:	f895 3116 	ldrb.w	r3, [r5, #278]	; 0x116
 80142e6:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
 80142ea:	f895 3117 	ldrb.w	r3, [r5, #279]	; 0x117
 80142ee:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
  cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
 80142f2:	f895 3118 	ldrb.w	r3, [r5, #280]	; 0x118
 80142f6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  
  
  if (length > USB_CONFIGURATION_DESC_SIZE)
 80142fa:	2f09      	cmp	r7, #9
 80142fc:	d9d8      	bls.n	80142b0 <USBH_Get_CfgDesc+0x2c>
  {
    ptr = USB_LEN_CFG_DESC;
    
    if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
 80142fe:	2e02      	cmp	r6, #2
 8014300:	d8d6      	bhi.n	80142b0 <USBH_Get_CfgDesc+0x2c>
                       phost->device_prop.Itf_Desc,
 8014302:	f104 073e 	add.w	r7, r4, #62	; 0x3e
    if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
 8014306:	4642      	mov	r2, r8
 8014308:	4605      	mov	r5, r0
                       phost->device_prop.Ep_Desc[0], 
 801430a:	3450      	adds	r4, #80	; 0x50
 801430c:	b26b      	sxtb	r3, r5
 801430e:	42b3      	cmp	r3, r6
 8014310:	dace      	bge.n	80142b0 <USBH_Get_CfgDesc+0x2c>
{
  USBH_DescHeader_t  *pnext;
 
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
  pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
         ((USBH_DescHeader_t *)pbuf)->bLength);
 8014312:	7811      	ldrb	r1, [r2, #0]
  pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
 8014314:	440a      	add	r2, r1
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
 8014316:	7851      	ldrb	r1, [r2, #1]
 8014318:	2904      	cmp	r1, #4
 801431a:	d1fa      	bne.n	8014312 <USBH_Get_CfgDesc+0x8e>
            pif               = &itf_desc[if_ix];
 801431c:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
  if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
 8014320:	7811      	ldrb	r1, [r2, #0]
 8014322:	54f9      	strb	r1, [r7, r3]
            pif               = &itf_desc[if_ix];
 8014324:	443b      	add	r3, r7
  if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
 8014326:	7851      	ldrb	r1, [r2, #1]
 8014328:	7059      	strb	r1, [r3, #1]
  if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
 801432a:	7891      	ldrb	r1, [r2, #2]
 801432c:	7099      	strb	r1, [r3, #2]
  if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
 801432e:	78d1      	ldrb	r1, [r2, #3]
 8014330:	70d9      	strb	r1, [r3, #3]
  if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
 8014332:	f892 e004 	ldrb.w	lr, [r2, #4]
 8014336:	f883 e004 	strb.w	lr, [r3, #4]
  if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
 801433a:	7951      	ldrb	r1, [r2, #5]
 801433c:	7159      	strb	r1, [r3, #5]
  if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
 801433e:	7991      	ldrb	r1, [r2, #6]
 8014340:	7199      	strb	r1, [r3, #6]
  if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
 8014342:	79d1      	ldrb	r1, [r2, #7]
 8014344:	71d9      	strb	r1, [r3, #7]
  if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
 8014346:	7a11      	ldrb	r1, [r2, #8]
 8014348:	7219      	strb	r1, [r3, #8]
            if(pif->bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
 801434a:	f1be 0f02 	cmp.w	lr, #2
 801434e:	d82a      	bhi.n	80143a6 <USBH_Get_CfgDesc+0x122>
 8014350:	2100      	movs	r1, #0
              while (ep_ix < pif->bNumEndpoints) 
 8014352:	4571      	cmp	r1, lr
 8014354:	da27      	bge.n	80143a6 <USBH_Get_CfgDesc+0x122>
         ((USBH_DescHeader_t *)pbuf)->bLength);
 8014356:	7813      	ldrb	r3, [r2, #0]
  pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
 8014358:	441a      	add	r2, r3
                if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
 801435a:	7853      	ldrb	r3, [r2, #1]
 801435c:	2b05      	cmp	r3, #5
 801435e:	d1f8      	bne.n	8014352 <USBH_Get_CfgDesc+0xce>
                  pep               = &ep_desc[ep_ix];
 8014360:	b20b      	sxth	r3, r1
  ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
 8014362:	f892 c000 	ldrb.w	ip, [r2]
 8014366:	f804 c033 	strb.w	ip, [r4, r3, lsl #3]
                  pep               = &ep_desc[ep_ix];
 801436a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
  ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
 801436e:	f892 c001 	ldrb.w	ip, [r2, #1]
 8014372:	f883 c001 	strb.w	ip, [r3, #1]
  ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
 8014376:	f892 c002 	ldrb.w	ip, [r2, #2]
 801437a:	f883 c002 	strb.w	ip, [r3, #2]
  ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
 801437e:	f892 c003 	ldrb.w	ip, [r2, #3]
 8014382:	f883 c003 	strb.w	ip, [r3, #3]
  ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
 8014386:	f892 8005 	ldrb.w	r8, [r2, #5]
 801438a:	f892 c004 	ldrb.w	ip, [r2, #4]
                  ep_ix++;
 801438e:	3101      	adds	r1, #1
  ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
 8014390:	eb0c 2c08 	add.w	ip, ip, r8, lsl #8
 8014394:	f8a3 c004 	strh.w	ip, [r3, #4]
                  ep_ix++;
 8014398:	b249      	sxtb	r1, r1
  ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
 801439a:	f892 c006 	ldrb.w	ip, [r2, #6]
 801439e:	f883 c006 	strb.w	ip, [r3, #6]
              while (ep_ix < pif->bNumEndpoints) 
 80143a2:	4571      	cmp	r1, lr
 80143a4:	dbd7      	blt.n	8014356 <USBH_Get_CfgDesc+0xd2>
 80143a6:	3501      	adds	r5, #1
 80143a8:	e7b0      	b.n	801430c <USBH_Get_CfgDesc+0x88>
 80143aa:	bf00      	nop

080143ac <USBH_Get_StringDesc>:
{
 80143ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 80143b0:	2680      	movs	r6, #128	; 0x80
{
 80143b2:	f8bd 7018 	ldrh.w	r7, [sp, #24]
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 80143b6:	750e      	strb	r6, [r1, #20]
  if((status = USBH_GetDescriptor(pdev,
 80143b8:	f442 7240 	orr.w	r2, r2, #768	; 0x300
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 80143bc:	f04f 0e06 	mov.w	lr, #6
{
 80143c0:	461d      	mov	r5, r3
                                  pdev->host.Rx_Buffer,
 80143c2:	f500 7688 	add.w	r6, r0, #272	; 0x110
    phost->Control.setup.b.wIndex.w = 0x0409;
 80143c6:	f240 4309 	movw	r3, #1033	; 0x409
  phost->Control.setup.b.wValue.w = value_idx;
 80143ca:	82ca      	strh	r2, [r1, #22]
    phost->Control.setup.b.wIndex.w = 0x0409;
 80143cc:	830b      	strh	r3, [r1, #24]
  phost->Control.setup.b.wLength.w = length;           
 80143ce:	834f      	strh	r7, [r1, #26]
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 80143d0:	f881 e015 	strb.w	lr, [r1, #21]
  return USBH_CtlReq(pdev, phost, buff , length );     
 80143d4:	4632      	mov	r2, r6
 80143d6:	463b      	mov	r3, r7
{
 80143d8:	4680      	mov	r8, r0
  return USBH_CtlReq(pdev, phost, buff , length );     
 80143da:	f7ff f929 	bl	8013630 <USBH_CtlReq>
  if((status = USBH_GetDescriptor(pdev,
 80143de:	b918      	cbnz	r0, 80143e8 <USBH_Get_StringDesc+0x3c>
  if ( psrc[1] == USB_DESC_TYPE_STRING)
 80143e0:	f898 3111 	ldrb.w	r3, [r8, #273]	; 0x111
 80143e4:	2b03      	cmp	r3, #3
 80143e6:	d001      	beq.n	80143ec <USBH_Get_StringDesc+0x40>
}
 80143e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
 80143ec:	f898 3110 	ldrb.w	r3, [r8, #272]	; 0x110
 80143f0:	3b02      	subs	r3, #2
 80143f2:	42bb      	cmp	r3, r7
 80143f4:	bfa8      	it	ge
 80143f6:	463b      	movge	r3, r7
 80143f8:	b29b      	uxth	r3, r3
    for (idx = 0; idx < strlength; idx+=2 )
 80143fa:	b143      	cbz	r3, 801440e <USBH_Get_StringDesc+0x62>
 80143fc:	4602      	mov	r2, r0
      *pdest =  psrc[idx];
 80143fe:	18b1      	adds	r1, r6, r2
    for (idx = 0; idx < strlength; idx+=2 )
 8014400:	3202      	adds	r2, #2
 8014402:	b292      	uxth	r2, r2
      *pdest =  psrc[idx];
 8014404:	7889      	ldrb	r1, [r1, #2]
 8014406:	f805 1b01 	strb.w	r1, [r5], #1
    for (idx = 0; idx < strlength; idx+=2 )
 801440a:	4293      	cmp	r3, r2
 801440c:	d8f7      	bhi.n	80143fe <USBH_Get_StringDesc+0x52>
    *pdest = 0; /* mark end of string */  
 801440e:	2300      	movs	r3, #0
 8014410:	702b      	strb	r3, [r5, #0]
}
 8014412:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014416:	bf00      	nop

08014418 <USBH_GetDescriptor>:
{ 
 8014418:	b4f0      	push	{r4, r5, r6, r7}
 801441a:	461f      	mov	r7, r3
  if ((value_idx & 0xff00) == USB_DESC_STRING)
 801441c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8014420:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
{ 
 8014424:	9e04      	ldr	r6, [sp, #16]
 8014426:	f8bd 3014 	ldrh.w	r3, [sp, #20]
  phost->Control.setup.b.wValue.w = value_idx;
 801442a:	82cf      	strh	r7, [r1, #22]
    phost->Control.setup.b.wIndex.w = 0;
 801442c:	f240 4509 	movw	r5, #1033	; 0x409
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8014430:	f062 027f 	orn	r2, r2, #127	; 0x7f
    phost->Control.setup.b.wIndex.w = 0;
 8014434:	bf18      	it	ne
 8014436:	2500      	movne	r5, #0
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 8014438:	2706      	movs	r7, #6
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 801443a:	750a      	strb	r2, [r1, #20]
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 801443c:	754f      	strb	r7, [r1, #21]
 801443e:	830d      	strh	r5, [r1, #24]
  return USBH_CtlReq(pdev, phost, buff , length );     
 8014440:	4632      	mov	r2, r6
  phost->Control.setup.b.wLength.w = length;           
 8014442:	834b      	strh	r3, [r1, #26]
}
 8014444:	bcf0      	pop	{r4, r5, r6, r7}
  return USBH_CtlReq(pdev, phost, buff , length );     
 8014446:	f7ff b8f3 	b.w	8013630 <USBH_CtlReq>
 801444a:	bf00      	nop

0801444c <USBH_SetAddress>:
{
 801444c:	b430      	push	{r4, r5}
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 801444e:	2300      	movs	r3, #0
  phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
 8014450:	2505      	movs	r5, #5
  phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 8014452:	82ca      	strh	r2, [r1, #22]
  phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
 8014454:	754d      	strb	r5, [r1, #21]
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8014456:	750b      	strb	r3, [r1, #20]
  phost->Control.setup.b.wIndex.w = 0;
 8014458:	830b      	strh	r3, [r1, #24]
  phost->Control.setup.b.wLength.w = 0;
 801445a:	834b      	strh	r3, [r1, #26]
  return USBH_CtlReq(pdev, phost, 0 , 0 );
 801445c:	461a      	mov	r2, r3
}
 801445e:	bc30      	pop	{r4, r5}
  return USBH_CtlReq(pdev, phost, 0 , 0 );
 8014460:	f7ff b8e6 	b.w	8013630 <USBH_CtlReq>

08014464 <USBH_SetCfg>:
{
 8014464:	b430      	push	{r4, r5}
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
 8014466:	2300      	movs	r3, #0
  phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
 8014468:	2509      	movs	r5, #9
  phost->Control.setup.b.wValue.w = cfg_idx;
 801446a:	82ca      	strh	r2, [r1, #22]
  phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
 801446c:	754d      	strb	r5, [r1, #21]
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
 801446e:	750b      	strb	r3, [r1, #20]
  phost->Control.setup.b.wIndex.w = 0;
 8014470:	830b      	strh	r3, [r1, #24]
  phost->Control.setup.b.wLength.w = 0;           
 8014472:	834b      	strh	r3, [r1, #26]
  return USBH_CtlReq(pdev, phost, 0 , 0 );      
 8014474:	461a      	mov	r2, r3
}
 8014476:	bc30      	pop	{r4, r5}
  return USBH_CtlReq(pdev, phost, 0 , 0 );      
 8014478:	f7ff b8da 	b.w	8013630 <USBH_CtlReq>

0801447c <USBH_ClrFeature>:
{
 801447c:	b470      	push	{r4, r5, r6}
    pdev->host.hc[hc_num].toggle_in = 0; 
 801447e:	3316      	adds	r3, #22
 8014480:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
 8014484:	2400      	movs	r4, #0
  phost->Control.setup.b.wIndex.w = ep_num;
 8014486:	830a      	strh	r2, [r1, #24]
  phost->Control.setup.b.bmRequestType = USB_H2D | 
 8014488:	2602      	movs	r6, #2
  if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
 801448a:	0612      	lsls	r2, r2, #24
  phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
 801448c:	f04f 0501 	mov.w	r5, #1
  phost->Control.setup.b.bmRequestType = USB_H2D | 
 8014490:	750e      	strb	r6, [r1, #20]
  phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
 8014492:	754d      	strb	r5, [r1, #21]
  phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
 8014494:	82cc      	strh	r4, [r1, #22]
  phost->Control.setup.b.wLength.w = 0;           
 8014496:	834c      	strh	r4, [r1, #26]
    pdev->host.hc[hc_num].toggle_in = 0; 
 8014498:	bf4c      	ite	mi
 801449a:	711c      	strbmi	r4, [r3, #4]
    pdev->host.hc[hc_num].toggle_out = 0; 
 801449c:	715c      	strbpl	r4, [r3, #5]
  return USBH_CtlReq(pdev, phost, 0 , 0 );   
 801449e:	2300      	movs	r3, #0
 80144a0:	461a      	mov	r2, r3
}
 80144a2:	bc70      	pop	{r4, r5, r6}
  return USBH_CtlReq(pdev, phost, 0 , 0 );   
 80144a4:	f7ff b8c4 	b.w	8013630 <USBH_CtlReq>

080144a8 <USBH_USR_DeviceDisconnected>:
//--------------------------------------------------------------
// wird beim ziehen vom Device aufgerufen
//--------------------------------------------------------------
void USBH_USR_DeviceDisconnected (void)
{
  USB_MSC_HOST_STATUS=USB_MSC_DEV_DETACHED;
 80144a8:	4b01      	ldr	r3, [pc, #4]	; (80144b0 <USBH_USR_DeviceDisconnected+0x8>)
 80144aa:	2201      	movs	r2, #1
 80144ac:	701a      	strb	r2, [r3, #0]
 80144ae:	4770      	bx	lr
 80144b0:	20008098 	.word	0x20008098

080144b4 <USBH_USR_DeviceSpeedDetected>:
// nach dem stecken vom Device
// (auslesen von Daten)
//--------------------------------------------------------------
void USBH_USR_DeviceSpeedDetected(uint8_t DeviceSpeed)
{
  if ((DeviceSpeed != HPRT0_PRTSPD_FULL_SPEED)&&(DeviceSpeed != HPRT0_PRTSPD_LOW_SPEED))
 80144b4:	3801      	subs	r0, #1
 80144b6:	2801      	cmp	r0, #1
 80144b8:	d902      	bls.n	80144c0 <USBH_USR_DeviceSpeedDetected+0xc>
  {
    USB_MSC_HOST_STATUS=USB_MSC_SPEED_ERROR;
 80144ba:	4b02      	ldr	r3, [pc, #8]	; (80144c4 <USBH_USR_DeviceSpeedDetected+0x10>)
 80144bc:	2202      	movs	r2, #2
 80144be:	701a      	strb	r2, [r3, #0]
 80144c0:	4770      	bx	lr
 80144c2:	bf00      	nop
 80144c4:	20008098 	.word	0x20008098

080144c8 <USBH_USR_Configuration_DescAvailable>:
// (auslesen von Daten)
//--------------------------------------------------------------
void USBH_USR_Configuration_DescAvailable(USBH_CfgDesc_TypeDef * cfgDesc,
    USBH_InterfaceDesc_TypeDef *itfDesc,
    USBH_EpDesc_TypeDef *epDesc)
{
 80144c8:	4770      	bx	lr
 80144ca:	bf00      	nop

080144cc <USBH_USR_SerialNum_String>:
// wird vom USB-Handler aufgerufen
// nach dem stecken vom Device
// (auslesen von Daten)
//--------------------------------------------------------------
void USBH_USR_SerialNum_String(void *SerialNumString)
{
 80144cc:	4770      	bx	lr
 80144ce:	bf00      	nop

080144d0 <USBH_USR_EnumerationDone>:
//--------------------------------------------------------------
// wird vom USB-Handler aufgerufen
// nach dem stecken vom Device
//--------------------------------------------------------------
void USBH_USR_EnumerationDone(void)
{
 80144d0:	4770      	bx	lr
 80144d2:	bf00      	nop

080144d4 <USBH_USR_DeviceNotSupported>:
// wird vom USB-Handler aufgerufen
// wenn das Device nicht untresttzt wird
//--------------------------------------------------------------
void USBH_USR_DeviceNotSupported(void)
{
  USB_MSC_HOST_STATUS=USB_MSC_DEV_NOT_SUPPORTED;
 80144d4:	4b01      	ldr	r3, [pc, #4]	; (80144dc <USBH_USR_DeviceNotSupported+0x8>)
 80144d6:	2203      	movs	r2, #3
 80144d8:	701a      	strb	r2, [r3, #0]
 80144da:	4770      	bx	lr
 80144dc:	20008098 	.word	0x20008098

080144e0 <USBH_USR_UserInput>:
// wird vom USB-Handler aufgerufen
//--------------------------------------------------------------
USBH_USR_Status USBH_USR_UserInput(void)
{
  return USBH_USR_RESP_OK;
}
 80144e0:	2001      	movs	r0, #1
 80144e2:	4770      	bx	lr

080144e4 <USBH_USR_OverCurrentDetected>:
// wird vom USB-Handler aufgerufen
// wenn die berstrom berwachung angeschlagen hat
//--------------------------------------------------------------
void USBH_USR_OverCurrentDetected (void)
{
  USB_MSC_HOST_STATUS=USB_MSC_OVER_CURRENT;
 80144e4:	4b01      	ldr	r3, [pc, #4]	; (80144ec <USBH_USR_OverCurrentDetected+0x8>)
 80144e6:	2205      	movs	r2, #5
 80144e8:	701a      	strb	r2, [r3, #0]
 80144ea:	4770      	bx	lr
 80144ec:	20008098 	.word	0x20008098

080144f0 <USBH_USR_DeInit>:
//--------------------------------------------------------------
// wird beim ziehen vom Device aufgerufen
//--------------------------------------------------------------
void USBH_USR_DeInit(void)
{
  USBH_USR_ApplicationState = USH_USR_FS_INIT;
 80144f0:	4b01      	ldr	r3, [pc, #4]	; (80144f8 <USBH_USR_DeInit+0x8>)
 80144f2:	2200      	movs	r2, #0
 80144f4:	701a      	strb	r2, [r3, #0]
 80144f6:	4770      	bx	lr
 80144f8:	20008097 	.word	0x20008097

080144fc <USBH_USR_MSC_Application>:
  switch (USBH_USR_ApplicationState) {
 80144fc:	4b08      	ldr	r3, [pc, #32]	; (8014520 <USBH_USR_MSC_Application+0x24>)
 80144fe:	781a      	ldrb	r2, [r3, #0]
 8014500:	b962      	cbnz	r2, 801451c <USBH_USR_MSC_Application+0x20>
      if (USBH_MSC_Param.MSWriteProtect == DISK_WRITE_PROTECTED) {
 8014502:	4908      	ldr	r1, [pc, #32]	; (8014524 <USBH_USR_MSC_Application+0x28>)
      USB_MSC_HOST_STATUS=USB_MSC_DEV_CONNECTED;
 8014504:	4a08      	ldr	r2, [pc, #32]	; (8014528 <USBH_USR_MSC_Application+0x2c>)
      if (USBH_MSC_Param.MSWriteProtect == DISK_WRITE_PROTECTED) {
 8014506:	7b09      	ldrb	r1, [r1, #12]
 8014508:	2901      	cmp	r1, #1
      USB_MSC_HOST_STATUS=USB_MSC_DEV_CONNECTED;
 801450a:	f04f 0006 	mov.w	r0, #6
    	USB_MSC_HOST_STATUS=USB_MSC_DEV_WRITE_PROTECT;
 801450e:	bf08      	it	eq
 8014510:	2104      	moveq	r1, #4
      USB_MSC_HOST_STATUS=USB_MSC_DEV_CONNECTED;
 8014512:	7010      	strb	r0, [r2, #0]
    	USB_MSC_HOST_STATUS=USB_MSC_DEV_WRITE_PROTECT;
 8014514:	bf08      	it	eq
 8014516:	7011      	strbeq	r1, [r2, #0]
      USBH_USR_ApplicationState = USH_USR_FS_LOOP;
 8014518:	2201      	movs	r2, #1
 801451a:	701a      	strb	r2, [r3, #0]
}
 801451c:	2000      	movs	r0, #0
 801451e:	4770      	bx	lr
 8014520:	20008097 	.word	0x20008097
 8014524:	20010b10 	.word	0x20010b10
 8014528:	20008098 	.word	0x20008098

0801452c <USBH_USR_Manufacturer_String>:
 801452c:	4770      	bx	lr
 801452e:	bf00      	nop

08014530 <USBH_USR_Product_String>:
 8014530:	4770      	bx	lr
 8014532:	bf00      	nop

08014534 <USBH_USR_Device_DescAvailable>:
 8014534:	4770      	bx	lr
 8014536:	bf00      	nop

08014538 <USBH_USR_ResetDevice>:
 8014538:	4770      	bx	lr
 801453a:	bf00      	nop

0801453c <USBH_USR_DeviceAddressAssigned>:
 801453c:	4770      	bx	lr
 801453e:	bf00      	nop

08014540 <USBH_USR_Init>:
 8014540:	4770      	bx	lr
 8014542:	bf00      	nop

08014544 <USBH_USR_DeviceAttached>:
 8014544:	4b01      	ldr	r3, [pc, #4]	; (801454c <USBH_USR_DeviceAttached+0x8>)
 8014546:	2201      	movs	r2, #1
 8014548:	701a      	strb	r2, [r3, #0]
 801454a:	4770      	bx	lr
 801454c:	20008098 	.word	0x20008098

08014550 <USBH_USR_UnrecoveredError>:
 8014550:	4b01      	ldr	r3, [pc, #4]	; (8014558 <USBH_USR_UnrecoveredError+0x8>)
 8014552:	2201      	movs	r2, #1
 8014554:	701a      	strb	r2, [r3, #0]
 8014556:	4770      	bx	lr
 8014558:	20008098 	.word	0x20008098

0801455c <strcmp>:
 801455c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8014560:	f811 3b01 	ldrb.w	r3, [r1], #1
 8014564:	2a01      	cmp	r2, #1
 8014566:	bf28      	it	cs
 8014568:	429a      	cmpcs	r2, r3
 801456a:	d0f7      	beq.n	801455c <strcmp>
 801456c:	1ad0      	subs	r0, r2, r3
 801456e:	4770      	bx	lr

08014570 <main>:
#include "stm32_ub_mp3Player.h"


//--------------------------------------------------------------
int main(void)
{
 8014570:	b508      	push	{r3, lr}
  uint32_t akt_mode=0;

  SystemInit(); // Quarz Einstellungen aktivieren
 8014572:	f7eb fe2f 	bl	80001d4 <SystemInit>

  // Init vom USB-MSC-Host
  UB_USB_MSC_HOST_Init();
 8014576:	f7fc fab3 	bl	8010ae0 <UB_USB_MSC_HOST_Init>

  // Init vom MP3-Player
  UB_MP3Player_Init();
 801457a:	f7fc f9bb 	bl	80108f4 <UB_MP3Player_Init>

  while(1)
  {
    // Test ob USB-Stick angeschlossen ist
    if(UB_USB_MSC_HOST_Do()==USB_MSC_DEV_CONNECTED) {
 801457e:	f7fc fac9 	bl	8010b14 <UB_USB_MSC_HOST_Do>
 8014582:	2806      	cmp	r0, #6
 8014584:	d1fb      	bne.n	801457e <main+0xe>
      if(akt_mode==0) {
        akt_mode=1;
        UB_MP3Player_Start(); // Start vom MP3-Player
 8014586:	f7fc fa35 	bl	80109f4 <UB_MP3Player_Start>
    if(UB_USB_MSC_HOST_Do()==USB_MSC_DEV_CONNECTED) {
 801458a:	f7fc fac3 	bl	8010b14 <UB_USB_MSC_HOST_Do>
 801458e:	2806      	cmp	r0, #6
 8014590:	d002      	beq.n	8014598 <main+0x28>
      }
    }
    else {
      if(akt_mode==1) {
        akt_mode=0;
        UB_MP3Player_Stop(); // Stop vom MP3-Player
 8014592:	f7fc f9bb 	bl	801090c <UB_MP3Player_Stop>
 8014596:	e7f2      	b.n	801457e <main+0xe>
        UB_MP3Player_Do(); // MP3 abspielen
 8014598:	f7fc fa3e 	bl	8010a18 <UB_MP3Player_Do>
    if(UB_USB_MSC_HOST_Do()==USB_MSC_DEV_CONNECTED) {
 801459c:	f7fc faba 	bl	8010b14 <UB_USB_MSC_HOST_Do>
 80145a0:	2806      	cmp	r0, #6
 80145a2:	d1f6      	bne.n	8014592 <main+0x22>
        UB_MP3Player_Do(); // MP3 abspielen
 80145a4:	f7fc fa38 	bl	8010a18 <UB_MP3Player_Do>
    if(UB_USB_MSC_HOST_Do()==USB_MSC_DEV_CONNECTED) {
 80145a8:	f7fc fab4 	bl	8010b14 <UB_USB_MSC_HOST_Do>
 80145ac:	2806      	cmp	r0, #6
 80145ae:	d1f0      	bne.n	8014592 <main+0x22>
 80145b0:	e7f2      	b.n	8014598 <main+0x28>
 80145b2:	bf00      	nop

080145b4 <memcpy>:
 80145b4:	b510      	push	{r4, lr}
 80145b6:	1e43      	subs	r3, r0, #1
 80145b8:	440a      	add	r2, r1
 80145ba:	4291      	cmp	r1, r2
 80145bc:	d100      	bne.n	80145c0 <memcpy+0xc>
 80145be:	bd10      	pop	{r4, pc}
 80145c0:	f811 4b01 	ldrb.w	r4, [r1], #1
 80145c4:	f803 4f01 	strb.w	r4, [r3, #1]!
 80145c8:	e7f7      	b.n	80145ba <memcpy+0x6>

080145ca <memmove>:
 80145ca:	4288      	cmp	r0, r1
 80145cc:	b510      	push	{r4, lr}
 80145ce:	eb01 0302 	add.w	r3, r1, r2
 80145d2:	d803      	bhi.n	80145dc <memmove+0x12>
 80145d4:	1e42      	subs	r2, r0, #1
 80145d6:	4299      	cmp	r1, r3
 80145d8:	d10c      	bne.n	80145f4 <memmove+0x2a>
 80145da:	bd10      	pop	{r4, pc}
 80145dc:	4298      	cmp	r0, r3
 80145de:	d2f9      	bcs.n	80145d4 <memmove+0xa>
 80145e0:	1881      	adds	r1, r0, r2
 80145e2:	1ad2      	subs	r2, r2, r3
 80145e4:	42d3      	cmn	r3, r2
 80145e6:	d100      	bne.n	80145ea <memmove+0x20>
 80145e8:	bd10      	pop	{r4, pc}
 80145ea:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80145ee:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80145f2:	e7f7      	b.n	80145e4 <memmove+0x1a>
 80145f4:	f811 4b01 	ldrb.w	r4, [r1], #1
 80145f8:	f802 4f01 	strb.w	r4, [r2, #1]!
 80145fc:	e7eb      	b.n	80145d6 <memmove+0xc>

080145fe <memset>:
 80145fe:	4402      	add	r2, r0
 8014600:	4603      	mov	r3, r0
 8014602:	4293      	cmp	r3, r2
 8014604:	d100      	bne.n	8014608 <memset+0xa>
 8014606:	4770      	bx	lr
 8014608:	f803 1b01 	strb.w	r1, [r3], #1
 801460c:	e7f9      	b.n	8014602 <memset+0x4>

0801460e <strrchr>:
 801460e:	b538      	push	{r3, r4, r5, lr}
 8014610:	4603      	mov	r3, r0
 8014612:	460d      	mov	r5, r1
 8014614:	b151      	cbz	r1, 801462c <strrchr+0x1e>
 8014616:	2400      	movs	r4, #0
 8014618:	4629      	mov	r1, r5
 801461a:	4618      	mov	r0, r3
 801461c:	f000 f80a 	bl	8014634 <strchr>
 8014620:	b908      	cbnz	r0, 8014626 <strrchr+0x18>
 8014622:	4620      	mov	r0, r4
 8014624:	bd38      	pop	{r3, r4, r5, pc}
 8014626:	1c43      	adds	r3, r0, #1
 8014628:	4604      	mov	r4, r0
 801462a:	e7f5      	b.n	8014618 <strrchr+0xa>
 801462c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8014630:	f000 b800 	b.w	8014634 <strchr>

08014634 <strchr>:
 8014634:	b2c9      	uxtb	r1, r1
 8014636:	4603      	mov	r3, r0
 8014638:	f810 2b01 	ldrb.w	r2, [r0], #1
 801463c:	b11a      	cbz	r2, 8014646 <strchr+0x12>
 801463e:	4291      	cmp	r1, r2
 8014640:	d1f9      	bne.n	8014636 <strchr+0x2>
 8014642:	4618      	mov	r0, r3
 8014644:	4770      	bx	lr
 8014646:	2900      	cmp	r1, #0
 8014648:	bf0c      	ite	eq
 801464a:	4618      	moveq	r0, r3
 801464c:	2000      	movne	r0, #0
 801464e:	4770      	bx	lr
